
<!-- saved from url=(0051)http://www.lydsy.com/JudgeOnline/export_ac_code.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<link rel="stylesheet" href="./Export All AC Source_files/hoj.css" type="text/css">
</head>
<body>
<center>
<div style="width:90%; text-align:left">
<img src="./Export All AC Source_files/logo.png">
</div>
<table width="96%"> 
	<tbody><tr align="center" class="hd" valign="top">
				<th><a href="http://www.lydsy.com/JudgeOnline/faqs.php">F.A.Qs</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/">Home</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/bbs.php">Discuss</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/problemset.php">ProblemSet</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/status.php">Status</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/ranklist.php">Ranklist</a></th>
        <th><a href="http://www.lydsy.com/JudgeOnline/contest.php">1<font color="red">&nbsp;Contest</font></a></th>
        <th><a href="http://begin.lydsy.com/JudgeOnline">入门OJ</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/modifypage.php"><b>ModifyUser</b></a>&nbsp;&nbsp;<a href="http://www.lydsy.com/JudgeOnline/userinfo.php?user=SmallMartin">
				<font color="red">SmallMartin</font></a></th><th><a href="http://www.lydsy.com/JudgeOnline/logout.php">Logout</a></th>		<th><a href="http://www.lydsy.com/JudgeOnline/donation.php"><font color="red">捐赠本站</font></a></th>
	</tr>
</tbody></table>
</center>
<center>
<div class="notice">
	<div>
		<b>Notice:</b>此次系统维护时间过长，给大家带来不便，还望谅解。	</div>
</div>
</center>

<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int main(){
    int a,b;
    sf("%d%d",&amp;a,&amp;b);
    pf("%d\n",a+b);
    return 0;
}<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace spfa{
	int vcnt,dis[2000010];
	struct data{data(int a,int b):d(a),u(b){}int d,u;};
	bool operator&lt;(const data&amp;a,const data&amp;b){return a.d&gt;b.d;}
	vector&lt;int&gt;to[2000010],we[2000010];
	void add(int u,int v,int w){to[u].pb(v);we[u].pb(w);to[v].pb(u);we[v].pb(w);}
	int solve(){
		lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;dis[1]=0;
		priority_queue&lt;data&gt;qu;qu.push(data(0,1));
		while(!qu.empty()){
			int u=qu.top().u,d=qu.top().d;qu.pop();
			if(d!=dis[u])continue;
			vp(i,to[u]){
				int v=to[u][i],w=we[u][i];
				if(dis[u]+w&lt;dis[v]){
					dis[v]=dis[u]+w;
					qu.push(data(dis[v],v));
				}
			}
		}
		return dis[vcnt];
	}
}

int n,m,st,et,up[1010][1010],dw[1010][1010],nw;
int main(){
	sf("%d%d",&amp;n,&amp;m);
	if(n==1){
		int ans=~0u&gt;&gt;1;
		lp(i,1,m-1){
			int t;sf("%d",&amp;t);
			ans=min(ans,t);
		}
		pf("%d\n",ans);
	}else if(m==1){
		int ans=~0u&gt;&gt;1;
		lp(i,1,n-1){
			int t;sf("%d",&amp;t);
			ans=min(ans,t);
		}
		pf("%d\n",ans);
	}else{
		st=++nw;
		lp(i,1,n-1)lp(j,1,m-1)up[i][j]=++nw,dw[i][j]=++nw;
		et=++nw;spfa::vcnt=nw;
		lp(i,1,n)lp(j,1,m-1){
			int t;sf("%d",&amp;t);
			if(i==1)spfa::add(st,up[i][j],t);
			else if(i==n)spfa::add(dw[i-1][j],et,t);
			else spfa::add(dw[i-1][j],up[i][j],t);
		}
		lp(i,1,n-1)lp(j,1,m){
			int t;sf("%d",&amp;t);
			if(j==1)spfa::add(dw[i][j],et,t);
			else if(j==m)spfa::add(st,up[i][j-1],t);
			else spfa::add(up[i][j-1],dw[i][j],t);
		}
		lp(i,1,n-1)lp(j,1,m-1){
			int t;sf("%d",&amp;t);
			spfa::add(up[i][j],dw[i][j],t);
		}
		pf("%d\n",spfa::solve());
	}
    return 0;
}<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace spfa{
	int vcnt,dis[2000010];
	struct data{data(int a,int b):d(a),u(b){}int d,u;};
	bool operator&lt;(const data&amp;a,const data&amp;b){return a.d&gt;b.d;}
	vector&lt;int&gt;to[2000010],we[2000010];
	void add(int u,int v,int w){to[u].pb(v);we[u].pb(w);to[v].pb(u);we[v].pb(w);}
	int solve(){
		lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;dis[1]=0;
		priority_queue&lt;data&gt;qu;qu.push(data(0,1));
		while(!qu.empty()){
			int u=qu.top().u,d=qu.top().d;qu.pop();
			if(d!=dis[u])continue;
			vp(i,to[u]){
				int v=to[u][i],w=we[u][i];
				if(dis[u]+w&lt;dis[v]){
					dis[v]=dis[u]+w;
					qu.push(data(dis[v],v));
				}
			}
		}
		return dis[vcnt];
	}
}

int n,m,st,et,up[1010][1010],dw[1010][1010],nw;
int main(){
	sf("%d%d",&amp;n,&amp;m);
	if(n==1){
		int ans=~0u&gt;&gt;1;
		lp(i,1,m-1){
			int t;sf("%d",&amp;t);
			ans=min(ans,t);
		}
		pf("%d\n",ans);
	}else if(m==1){
		int ans=~0u&gt;&gt;1;
		lp(i,1,n-1){
			int t;sf("%d",&amp;t);
			ans=min(ans,t);
		}
		pf("%d\n",ans);
	}else{
		st=++nw;
		lp(i,1,n-1)lp(j,1,m-1)up[i][j]=++nw,dw[i][j]=++nw;
		et=++nw;spfa::vcnt=nw;
		lp(i,1,n)lp(j,1,m-1){
			int t;sf("%d",&amp;t);
			if(i==1)spfa::add(st,up[i][j],t);
			else if(i==n)spfa::add(dw[i-1][j],et,t);
			else spfa::add(dw[i-1][j],up[i][j],t);
		}
		lp(i,1,n-1)lp(j,1,m){
			int t;sf("%d",&amp;t);
			if(j==1)spfa::add(dw[i][j],et,t);
			else if(j==m)spfa::add(st,up[i][j-1],t);
			//else spfa::add(up[i][j-1],dw[i][j],t);
		}
		lp(i,1,n-1)lp(j,1,m-1){
			int t;sf("%d",&amp;t);
			spfa::add(up[i][j],dw[i][j],t);
		}
		pf("%d\n",spfa::solve());
	}
    return 0;
}<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace spfa{
    int vcnt,dis[2000010];
    struct data{data(int a,int b):d(a),u(b){}int d,u;};
    bool operator&lt;(const data&amp;a,const data&amp;b){return a.d&gt;b.d;}
    vector&lt;int&gt;to[2000010],we[2000010];
    void add(int u,int v,int w){to[u].pb(v);we[u].pb(w);to[v].pb(u);we[v].pb(w);}
    int solve(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;dis[1]=0;
        priority_queue&lt;data&gt;qu;qu.push(data(0,1));
        while(dis[vcnt]==~0u&gt;&gt;1){
            int u=qu.top().u,d=qu.top().d;qu.pop();
            if(d!=dis[u])continue;
            vp(i,to[u]){
                int v=to[u][i],w=we[u][i];
                if(dis[u]+w&lt;dis[v]){
                    dis[v]=dis[u]+w;
                    qu.push(data(dis[v],v));
                }
            }
        }
        return dis[vcnt];
    }
}
 
int n,m,st,et,up[1010][1010],dw[1010][1010],nw;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    if(n==1){
        int ans=~0u&gt;&gt;1;
        lp(i,1,m-1){
            int t;sf("%d",&amp;t);
            ans=min(ans,t);
        }
        pf("%d\n",ans);
    }else if(m==1){
        int ans=~0u&gt;&gt;1;
        lp(i,1,n-1){
            int t;sf("%d",&amp;t);
            ans=min(ans,t);
        }
        pf("%d\n",ans);
    }else{
        st=++nw;
        lp(i,1,n-1)lp(j,1,m-1)up[i][j]=++nw,dw[i][j]=++nw;
        et=++nw;spfa::vcnt=nw;
        lp(i,1,n)lp(j,1,m-1){
            int t;sf("%d",&amp;t);
            if(i==1)spfa::add(st,up[i][j],t);
            else if(i==n)spfa::add(dw[i-1][j],et,t);
            else spfa::add(dw[i-1][j],up[i][j],t);
        }
        lp(i,1,n-1)lp(j,1,m){
            int t;sf("%d",&amp;t);
            if(j==1)spfa::add(dw[i][j],et,t);
            else if(j==m)spfa::add(st,up[i][j-1],t);
            //else spfa::add(up[i][j-1],dw[i][j],t);
        }
        lp(i,1,n-1)lp(j,1,m-1){
            int t;sf("%d",&amp;t);
            spfa::add(up[i][j],dw[i][j],t);
        }
        pf("%d\n",spfa::solve());
    }
    return 0;
}<pre><h2>Problem1002</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace gas{
    long double fbs(double a){
        return a&gt;0?a:-a;
    }
    long double mt[110][110];int n;
    long double solve(){
        lp(i,1,n){
            int j=i;while(j&lt;=n&amp;&amp;fbs(mt[j][i])&lt;1e-8)++j;
            lp(k,1,n)swap(mt[i][k],mt[j][k]);
            lp(k,i+1,n){
                if(fbs(mt[k][i])&gt;1e-8){
                    long double t=mt[k][i];
                    lp(l,1,n)mt[k][l]-=mt[i][l]/mt[i][i]*t;
                }
            }
        }
        long double ans=1;
        lp(i,1,n)ans*=mt[i][i];
        return ans;
    }
}
struct num{
    int dat[310],len;
};
num mul4(num a){
    lp(i,1,a.len)a.dat[i]*=4;
    lp(i,1,a.len-1){
        a.dat[i+1]+=a.dat[i]/10;
        a.dat[i]%=10; 
    }
    while(a.dat[a.len]&gt;=10){
        a.dat[a.len+1]=a.dat[a.len]/10;
        a.dat[a.len]%=10;
        ++a.len;
    }
    return a;
} 
num plu(num a,num b){
    num c;c.len=max(a.len,b.len);
    lp(i,1,c.len)c.dat[i]=0;
    lp(i,1,a.len)c.dat[i]+=a.dat[i];
    lp(i,1,b.len)c.dat[i]+=b.dat[i];
    lp(i,1,c.len-1){
        c.dat[i+1]+=c.dat[i]/10;
        c.dat[i]%=10; 
    }
    while(c.dat[c.len]&gt;=10){
        c.dat[c.len+1]=c.dat[c.len]/10;
        c.dat[c.len]%=10;
        ++c.len;
    }
    return c;
}
void prit(num a){
    rp(i,a.len,1)pf("%d",a.dat[i]);
} 
num mins(num a,num b){
    while(b.len&lt;a.len)++b.len,b.dat[b.len]=0;
    lp(i,1,b.len)b.dat[i]=9-b.dat[i];
    num c=plu(a,b);num d;d.len=1;d.dat[1]=1;
    c=plu(c,d);
    c.len=a.len;
    while(c.dat[c.len]==0&amp;&amp;c.len!=1)--c.len;
    return c;
}

num f[110];
int main(){
    f[1].len=1;f[1].dat[1]=1;
    f[2].len=1;f[2].dat[1]=5;
    f[3].len=2;f[3].dat[1]=6;f[3].dat[2]=1;
    lp(i,4,100){
        f[i]=plu(mul4(mins(f[i-1],f[i-2])),f[i-3]);
    }
    int n;sf("%d",&amp;n);
    prit(f[n]);
    pf("\n"); 
    //ps; 
    return 0;
} 
<pre><h2>Problem1003</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,m,k,e,busy[21],dis[21];
vector&lt;int&gt; to[21],wei[21],bbg[21],eed[21];
int bellman(int bg,int ed){
	lp(i,1,m)busy[i]=0;
	lp(i,1,m)lp(j,0,int(bbg[i].size()-1)){
		int l=bbg[i][j],r=eed[i][j];
		if(!(r&lt;bg||l&gt;ed)){
			busy[i]=1;break;
		}
	}
	dis[1]=0;lp(i,2,m)dis[i]=~0u&gt;&gt;2;
	lp(cnt,1,m){
		lp(i,1,m){
			if(busy[i])continue;
			lp(j,0,int(to[i].size()-1)){
				int u=i,v=to[i][j],w=wei[i][j];
				if(busy[v])continue;
				if(dis[u]+w&lt;dis[v])dis[v]=dis[u]+w;
			}
		}
	}
	return dis[m];
}
int f[110];
int main(){
	//fr("data.in","r",stdin);
	//fr("hehe.out","w",stdout);
	sf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;e);
	lp(i,1,e){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		to[u].push_back(v);wei[u].push_back(w);
		to[v].push_back(u);wei[v].push_back(w);
	}
	int d;sf("%d",&amp;d);
	lp(i,1,d){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		bbg[u].push_back(v);
		eed[u].push_back(w);
	}
	lp(i,1,n){
		f[i]=~0u&gt;&gt;2;
		lp(j,1,i){
			int t=bellman(j,i);
			if(t!=~0u&gt;&gt;2)
				f[i]=min(f[i],f[j-1]+(i-j+1)*t+k);
		}
		
	}
	pf("%d\n",f[n]-k);
    return 0;
} <pre><h2>Problem1004</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int sr,sb,sg,m,n,p,ans;
int inv(int x){
    int r=1;
    for(int i=p-2;i;i&gt;&gt;=1){
        if(i&amp;1)r=r*x%p;
        x=x*x%p;
    }
    return r;
}
int tr[70],vis[70];
int dp[70][30][30][30];
int calc(){
    lp(i,1,n)sf("%d",&amp;tr[i]);
    lp(i,1,n)vis[i]=0;
    vector&lt;int&gt;tmp;
    lp(i,1,n){
        if(!vis[i]){
            int j=i,c=0;
            do{
                vis[j]=1;
                j=tr[j];
                ++c;
            }while(j!=i);
            tmp.pb(c);
        }
    }
    lp(i,1,tmp.size())lp(j,0,sr)lp(k,0,sb)lp(l,0,sg)dp[i][j][k][l]=0;
    dp[0][0][0][0]=1;
    lp(i,1,tmp.size())
        lp(j,0,sr)lp(k,0,sb)lp(l,0,sg){
            int t=tmp[i-1];
            if(t&lt;=j)dp[i][j][k][l]+=dp[i-1][j-t][k][l];
            if(t&lt;=k)dp[i][j][k][l]+=dp[i-1][j][k-t][l];
            if(t&lt;=l)dp[i][j][k][l]+=dp[i-1][j][k][l-t];
            dp[i][j][k][l]%=p;
        }
    return dp[tmp.size()][sr][sb][sg];
}
int calc2(){
    lp(i,1,n)tr[i]=i;
    lp(i,1,n)vis[i]=0;
    vector&lt;int&gt;tmp;
    lp(i,1,n){
        if(!vis[i]){
            int j=i,c=0;
            do{
                vis[j]=1;
                j=tr[j];
                ++c;
            }while(j!=i);
            tmp.pb(c);
        }
    }
    lp(i,1,tmp.size())lp(j,0,sr)lp(k,0,sb)lp(l,0,sg)dp[i][j][k][l]=0;
    dp[0][0][0][0]=1;
    lp(i,1,tmp.size())
        lp(j,0,sr)lp(k,0,sb)lp(l,0,sg){
            int t=tmp[i-1];
            if(t&lt;=j)dp[i][j][k][l]+=dp[i-1][j-t][k][l];
            if(t&lt;=k)dp[i][j][k][l]+=dp[i-1][j][k-t][l];
            if(t&lt;=l)dp[i][j][k][l]+=dp[i-1][j][k][l-t];
            dp[i][j][k][l]%=p;
            //pf("[%d,%d,%d,%d,%d,%d]\n",dp[i][j][k][l],t,i,j,k,l);
        }
    return dp[tmp.size()][sr][sb][sg];
}
int main(){
    sf("%d%d%d%d%d",&amp;sr,&amp;sb,&amp;sg,&amp;m,&amp;p);n=sr+sb+sg;
    lp(i,1,m)ans=(ans+calc())%p;
    ans=(ans+calc2())%p;
    ans=ans*inv(m+1)%p;
    pf("%d\n",ans);
    return 0;
}<pre><h2>Problem1005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
 bigint()
 bigint(long long)
 bigint(bigint)
 bigint(char*)
 bigint(string)
 +, +=, ++
 -, -=, --
 *, *=
 /, /=
 &lt;&lt;, &lt;&lt;=
 ==, !=
 &lt;, &lt;=
 &gt;, &gt;=
 -
 !
 abs(bigint), bigint.abs()
 pow(bigint, unsigned), bigint.pow(unsigned)
 root(bigint, unsigned), bigint.root(unsigned)
 sqrt(bigint), bigint.sqrt()
 bigint.read(default = stdin)
 bigint.write(default = stdout)
 istream&gt;&gt;bigint
 ostream&lt;&lt;bigint
 enoughMemory() : optimize division and modulo
*/
#include &lt;iostream&gt;
 
#ifndef BIGINT
#define BIGINT 1
 
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;
 
static const unsigned base = 10000, length = 4;
static bool __enoughMemory = false;
 
typedef vector&lt;int&gt; vi;
typedef vector&lt;int&gt;::iterator viit;
typedef vector&lt;int&gt;::const_iterator vicit;
typedef vector&lt;int&gt;::reverse_iterator virit;
typedef vector&lt;int&gt;::const_reverse_iterator vicrit;
typedef complex&lt;double&gt; comp;
typedef vector&lt;comp&gt; vc;
typedef vector&lt;comp&gt;::iterator vcit;
 
class Bigint {
public :
    Bigint();
    template&lt;typename _Tp&gt; Bigint(_Tp);
    Bigint(const Bigint&amp;);
    Bigint(const char*);
    Bigint(const string&amp;);
     
    bool&amp; neg();
    const bool&amp; neg() const;
    vi&amp; num();
    const vi&amp; num() const;
     
    bool operator==(const Bigint&amp;) const;
    bool operator!=(const Bigint&amp;) const;
    bool operator&lt;(const Bigint&amp;) const;
    bool operator&lt;=(const Bigint&amp;) const;
    bool operator&gt;(const Bigint&amp;) const;
    bool operator&gt;=(const Bigint&amp;) const;
     
    Bigint&amp; operator+=(const Bigint&amp;);
    Bigint&amp; operator-=(const Bigint&amp;);
    Bigint&amp; operator*=(const Bigint&amp;);
    Bigint&amp; operator/=(const Bigint&amp;);
    Bigint&amp; operator%=(const Bigint&amp;);
    Bigint&amp; operator&lt;&lt;=(const unsigned&amp;);
    Bigint&amp; operator&gt;&gt;=(const unsigned&amp;);
     
    Bigint&amp; operator++();
    Bigint&amp; operator--();
    Bigint operator-() const;
    bool operator!() const;
     
    int compare(const Bigint&amp;) const;
    bool equal(const Bigint&amp;) const;
    bool less(const Bigint&amp;) const;
    bool lessOrEqual(const Bigint&amp;) const;
    bool greater(const Bigint&amp;) const;
    bool greaterOrEqual(const Bigint&amp;) const;
     
    Bigint&amp; abs();
    Bigint&amp; pow(unsigned);
    Bigint&amp; root(const unsigned&amp;);
    Bigint&amp; sqrt();
    void multiply10(const unsigned&amp;);
    void divide2();
     
    void add(const Bigint&amp;);
    void subtract(const Bigint&amp;);
    void multiply(const Bigint&amp;);
    void multiplySlow(const Bigint&amp;);
    void multiplyFast(const Bigint&amp;, const int&amp;, const int&amp;);
    pair&lt;vi, vi&gt; divide(const Bigint&amp;);
     
    Bigint&amp; read(FILE*);
    const Bigint&amp; write(FILE*) const;
     
private :
    bool _m_neg;
    vi _m_num;
     
    void adjust();
    comp exp(const double&amp;);
    void bitrev(const vcit&amp;, const int&amp;, const int&amp;, const int&amp;, const int&amp;);
    void fft(vc&amp;, const int&amp;, const int&amp;, const bool&amp;);
     
    void divideByZero();
    void imaginaryNumberUnsupported();
    void error(const string&amp;);
};
 
//pre-declaration
Bigint abs(const Bigint&amp;);
Bigint pow(const Bigint&amp;, const unsigned&amp;);
Bigint root(const Bigint&amp;, const unsigned&amp;);
Bigint sqrt(const Bigint&amp;);
istream&amp; operator&gt;&gt;(istream&amp;, Bigint&amp;);
ostream&amp; operator&lt;&lt;(ostream&amp;, const Bigint&amp;);
void enoughMemory();
 
//operator
inline Bigint operator+(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) += __y;
}
inline Bigint operator-(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) -= __y;
}
inline Bigint operator*(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) *= __y;
}
inline Bigint operator/(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) /= __y;
}
inline Bigint operator%(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) %= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&lt;&lt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &lt;&lt;= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&gt;&gt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &gt;&gt;= __y;
}
 
//public
 
//constructor
inline Bigint::Bigint() {
    neg() = false;
    num().clear();
    num().push_back(0);
}
template&lt;typename _Tp&gt; inline Bigint::Bigint(_Tp __t) {
    if (__t &lt; 0) neg() = true, __t = -__t;
    else neg() = false;
    num().clear();
    while (__t &gt;= base) {
        num().push_back(__t % base);
        __t /= base;
    }
    num().push_back(__t);
}
inline Bigint::Bigint(const Bigint&amp; __t) {
    *this = __t;
}
inline Bigint::Bigint(const char* __c) {
    while (*__c) {
        if (*__c == '-' || *__c == '+' || '0' &lt;= *__c &amp;&amp; *__c &lt;= '9')
            break;
        ++__c;
    }
    if (*__c == '-') ++__c, neg() = true;
    else {
        neg() = false;
        if (*__c == '+') ++__c;
    }
    int __n = strlen(__c);
    num().clear();
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    const char* __t = __c + __n;
    while (__c + 1 != __t &amp;&amp; *__c == '0') ++__c;
    int __x = 0, __y = 1, __z = 0;
    while (__t-- != __c) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*__t - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
inline Bigint::Bigint(const string&amp; __s) {
    string::const_iterator i = __s.begin();
    string::const_iterator j = __s.end();
    while (i != j) {
        if (*i == '-' || *i == '+' || '0' &lt;= *i &amp;&amp; *i &lt;= '9')
            break;
        ++i;
    }
    if (i != j) {
        if (*i == '-') ++i, neg() = true;
        else {
            neg() = false;
            if (*i == '+') ++i;
        }
    }
    int __n = j - i;
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    while (i + 1 != j &amp;&amp; *i == '0') ++i;
    int __x = 0, __y = 1, __z = 0;
    while (j-- != i) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*j - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
 
inline bool&amp; Bigint::neg() {
    return _m_neg;
}
inline const bool&amp; Bigint::neg() const {
    return _m_neg;
}
inline vi&amp; Bigint::num() {
    return _m_num;
}
inline const vi&amp; Bigint::num() const {
    return _m_num;
}
 
//logical operator
inline bool Bigint::operator==(const Bigint&amp; __t) const {
    return neg() == __t.neg() &amp;&amp; equal(__t);
}
inline bool Bigint::operator!=(const Bigint&amp; __t) const {
    return neg() != __t.neg() || !equal(__t);
}
inline bool Bigint::operator&lt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greater(__t);
    return less(__t);
}
inline bool Bigint::operator&lt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greaterOrEqual(__t);
    return lessOrEqual(__t);
}
inline bool Bigint::operator&gt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return less(__t);
    return greater(__t);
}
inline bool Bigint::operator&gt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return lessOrEqual(__t);
    return greaterOrEqual(__t);
}
 
//arithmetic operators
inline Bigint&amp; Bigint::operator+=(const Bigint&amp; __t) {
    if (neg() == __t.neg()) add(__t);
    else {
        int __x = compare(__t);
        if (__x == 0) *this = Bigint();
        else if (__x == -1) {
            Bigint __y = *this;
            *this = __t;
            subtract(__y);
        }
        else subtract(__t);
    }
    return *this;
}
inline Bigint&amp; Bigint::operator-=(const Bigint&amp; __t) {
    return *this += (-__t);
}
inline Bigint&amp; Bigint::operator*=(const Bigint&amp; __t) {
    if (*this != 0 &amp;&amp; __t != 0) {
        neg() = neg() != __t.neg();
        multiply(__t);
    }
    else *this = Bigint();
    return *this;
}
inline Bigint&amp; Bigint::operator/=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    if (less(__t)) *this = Bigint();
    else {
        neg() = neg() != __t.neg();
        num() = divide(__t).first;
        adjust();
    }
    return *this;
}
inline Bigint&amp; Bigint::operator%=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    num() = divide(__t).second;
    adjust();
    if (num().size() == 1 &amp;&amp; !*num().rbegin()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::operator&lt;&lt;=(const unsigned&amp; __y) {
    return *this *= Bigint(2).pow(__y);
}
inline Bigint&amp; Bigint::operator&gt;&gt;=(const unsigned&amp; __y) {
    for (unsigned i = 0 ; i &lt; __y ; ++i) divide2();
    return *this;
}
 
//self operator
inline Bigint&amp; Bigint::operator++() {
    return *this += 1;
}
inline Bigint&amp; Bigint::operator--() {
    return *this -= 1;
}
inline Bigint Bigint::operator-() const {
    Bigint __t = *this;
    if (__t != 0) __t.neg() ^= true;
    return __t;
}
inline bool Bigint::operator!() const {
    return *this == 0;
}
 
//comparator
inline int Bigint::compare(const Bigint&amp; __t) const {
    if (num().size() &lt; __t.num().size()) return -1;
    else if (num().size() &gt; __t.num().size()) return 1;
    vicrit i = num().rbegin();
    vicrit j = __t.num().rbegin();
    while (i != num().rend()) {
        if (*i &lt; *j) return -1;
        else if (*i &gt; *j) return 1;
        ++i, ++j;
    }
    return 0;
}
inline bool Bigint::equal(const Bigint&amp; __t) const {
    return compare(__t) == 0;
}
inline bool Bigint::less(const Bigint&amp; __t) const {
    return compare(__t) == -1;
}
inline bool Bigint::lessOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == -1 || __r == 0;
}
inline bool Bigint::greater(const Bigint&amp; __t) const {
    return compare(__t) == 1;
}
inline bool Bigint::greaterOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == 1 || __r == 0;
}
 
//math
inline Bigint&amp; Bigint::abs() {
    if (neg()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::pow(unsigned __y) {
    Bigint __x = *this;
    *this = 1;
    while (__y) {
        if (__y &amp; 1) *this *= __x;
        __x *= __x;
        __y &gt;&gt;= 1;
    }
    return *this;
}
inline Bigint&amp; Bigint::root(const unsigned&amp; __y = 2) {
    if (!__y) divideByZero();
    if (*this == 0 || __y == 1) return *this;
    bool __n = neg();
    if (__n)
        if (__y &amp; 1) neg() = false;
        else imaginaryNumberUnsupported();
    const double log2_10 = 3.3219280948873623478703194294893901758648313930245806;
    size_t __s = num().size();
    if (double(__s &lt;&lt; 2) * log2_10 &lt; __y) return *this = 1;
    __s = __s / __y + (__s % __y ? 1 : 0);
    int __l, __r, __m;
    Bigint __a = *this, __b, __c;
    num().clear();
    for (int i = __s - 1 ; i &gt;= 0 ; --i) {
        __l = 1, __r = base - 1;
        while (__l &lt;= __r) {
            __m = __l + __r &gt;&gt; 1;
            __b = *this;
            __b.num().insert(__b.num().begin(), __m);
            __b.pow(__y);
            __b.multiply10(i * __y &lt;&lt; 2);
            if (__b &lt;= __a) __l = __m + 1;
            else __r = __m - 1;
        }
        num().insert(num().begin(), __r);
    }
    neg() = __n;
    return *this;
}
inline Bigint&amp; Bigint::sqrt() {
    root();
    return *this;
}
inline void Bigint::multiply10(const unsigned&amp; __t) {
    if (!__t) return ;
    size_t __s = num().size();
    size_t __r = (__t &gt;&gt; 2) + (__t &amp; 3 ? 1 : 0);
    int __x = 0, __y, __z, __a, __b;
    if ((__t &amp; 3) == 0) __a = 1, __b = 10000;
    else if ((__t &amp; 3) == 1) __a = 1000, __b = 10;
    else if ((__t &amp; 3) == 2) __a = 100, __b = 100;
    else if ((__t &amp; 3) == 3) __a = 10, __b = 1000;
    num().resize(__s + __r);
    virit i = num().rbegin();
    virit j = i + __r;
    while (i != num().rbegin() + __s) {
        __y = *j++;
        __z = __y / __a;
        __x += __z;
        *i++ = __x;
        __x = (__y - __z * __a) * __b;
    }
    *i++ = __x;
    fill(i, num().rend(), 0);
    adjust();
}
inline void Bigint::divide2() {
    int __t = 0;
    for (virit i = num().rbegin() ; i != num().rend() ; ++i) {
        __t = (__t &amp; 1 ? base : 0) + *i;
        *i = __t &gt;&gt; 1;
    }
    adjust();
}
 
//+, -, *, /
inline void Bigint::add(const Bigint&amp; __t) {
    if (num().size() &lt; __t.num().size())
        num().resize(__t.num().size());
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (i != num().end() &amp;&amp; j != __t.num().end())
        *i++ += *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &gt;= base) {
            *i -= base;
            ++*(i + 1);
        }
    if (*i &gt;= base) {
        *i -= base;
        num().push_back(1);
    }
}
inline void Bigint::subtract(const Bigint&amp; __t) {
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (j != __t.num().end())
        *i++ -= *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &lt; 0) {
            *i += base;
            --*(i + 1);
        }
    adjust();
}
inline void Bigint::multiply(const Bigint&amp; __t) {
    int __n = max(num().size(), __t.num().size());
    int __l = 0;
    while ((1 &lt;&lt; __l) &lt; __n) ++__l;
    __n = 1 &lt;&lt; ++__l;
    if ((long long)num().size() * __t.num().size() &lt;= (long long)__n * __l * 20)
        multiplySlow(__t);
    else
        multiplyFast(__t, __n, __l);
    adjust();
}
inline void Bigint::multiplySlow(const Bigint&amp; __t) {
    int __n = num().size() + __t.num().size(), i, j, k;
    vi __x, __y;
    if (__t.num().size() * 4 &lt; num().size())
        __x = __t.num(), __y = num();
    else
        __x = num(), __y = __t.num();
    num().clear();
    num().resize(__n);
    for (i = 0 ; i &lt; __x.size() ; ++i) {
        k = __x[i];
        for (j = 0 ; j &lt; __y.size() ; ++j)
            num()[i + j] += k * __y[j];
        k = i + 1 + __y.size();
        for (j = 0 ; j &lt; k ; ++j) {
            num()[j + 1] += num()[j] / base;
            num()[j] %= base;
        }
    }
}
inline void Bigint::multiplyFast(const Bigint&amp; __t, const int&amp; __n, const int&amp; __l) {
    vc a, b;
    a.reserve(__n);
    b.reserve(__n);
    for (viit i = num().begin() ; i != num().end() ; ++i)
        a.push_back(comp(*i, 0));
    for (vicit i = __t.num().begin() ; i != __t.num().end() ; ++i)
        b.push_back(comp(*i, 0));
    a.resize(__n);
    b.resize(__n);
    fft(a, __l, __n, true);
    fft(b, __l, __n, true);
    vcit i = a.begin(), j = b.begin();
    while (i != a.end()) *i++ *= *j++;
    fft(a, __l, __n, false);
    long long __x = 0;
    num().resize(__n);
    i = a.begin();
    viit k = num().begin();
    while (i != a.end()) {
        __x = (long long)(i++ -&gt;real() / __n + 0.5) + __x / base;
        *k++ = __x % base;
    }
}
inline pair&lt;vi, vi&gt; Bigint::divide(const Bigint&amp; __t) {
    int __l, __r, __m, __n = num().size() - __t.num().size() + 1;
    Bigint __x = *this, __y = __t, __z;
    vi __v;
    __v.resize(__n);
    if (__enoughMemory) {
        Bigint __p[10];
        for (__m = 0 ; __m &lt; 10 ; ++__m) __p[__m] = __m * __y;
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            int k = 0;
            for (int j = 3 + (i &lt;&lt; 2) ; j &gt;= (i &lt;&lt; 2) ; --j) {
                __l = 1, __r = 9;
                while (__l &lt;= __r) {
                    __m = __l + __r &gt;&gt; 1;
                    __z = __p[__m];
                    __z.multiply10(j);
                    if (__z.greater(__x)) __r = __m - 1;
                    else __l = __m + 1;
                }
                k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + __r;
                __z = __p[__r];
                __z.multiply10(j);
                __x.subtract(__z);
            }
            __v[i] = k;
        }
    }
    else {
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            __l = 1, __r = base - 1;
            while (__l &lt;= __r) {
                __m = __l + __r &gt;&gt; 1;
                __z = __m * __y;
                __z.multiply10(i &lt;&lt; 2);
                if (__z.greater(__x)) __r = __m - 1;
                else __l = __m + 1;
            }
            __v[i] = __r;
            __z = __r * __y;
            __z.multiply10(i &lt;&lt; 2);
            __x.subtract(__z);
        }
    }
    return make_pair(__v, __x.num());
}
 
//io
inline Bigint&amp; Bigint::read(FILE *in = stdin) {
    string __s = "";
    char __c = fgetc(in);
    while (true) {
        if (__c == '-' || __c == '+' || '0' &lt;= __c &amp;&amp; __c &lt;= '9' || __c == EOF)
            break;
        __c = fgetc(in);
    }
    while (true) {
        __s += __c;
        __c = fgetc(in);
        if (__c &lt; '0' || __c &gt; '9') break;
    }
    return *this = Bigint(__s.c_str());
}
inline const Bigint&amp; Bigint::write(FILE *out = stdout) const {
    vicrit i = num().rbegin();
    if (neg()) fprintf(out, "-");
    fprintf(out, "%d", *i++);
    while (i != num().rend()) fprintf(out, "%04d", *i++);
    return *this;
}
 
//private
 
//other
inline void Bigint::adjust() {
    virit i = num().rbegin();
    while (i + 1 != num().rend()) {
        if (*i) break;
        ++i;
    }
    num().erase(i.base(), num().end());
}
inline comp Bigint::exp(const double&amp; u) {
    return comp(cos(u), sin(u));
}
inline void Bigint::bitrev(const vcit&amp; i, const int&amp; __l, const int&amp; __p, const int&amp; __x, const int&amp; __y) {
    if (__p == 0) {
        if (__x &lt; __y) swap(*(i + __x), *(i + __y));
        return ;
    }
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1, __y);
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1 | 1, __y | (1 &lt;&lt; __l - __p));
}
inline void Bigint::fft(vc&amp; __a, const int&amp; __l, const int&amp; __n, const bool&amp; __r) {
    const double __p = 3.141592653589793238462643383279;
    bitrev(__a.begin(), __l, __l, 0, 0);
    for (int i = 1 ; i &lt;= __l ; ++i) {
        int __m = 1 &lt;&lt; i;
        comp wm = exp((__r ? -2 : 2) * __p / __m);
        for (int k = 0 ; k &lt; __n ; k += __m) {
            comp w = 1;
            for (int j = 0 ; j &lt; __m / 2 ; ++j) {
                comp t = w * __a[k + j + __m / 2];
                comp u = __a[k + j];
                __a[k + j] = u + t;
                __a[k + j + __m / 2] = u - t;
                w *= wm;
            }
        }
    }
}
 
//error
inline void Bigint::divideByZero() {
    error("divide by zero");
}
inline void Bigint::imaginaryNumberUnsupported() {
    error("imaginary number unsupported");
}
inline void Bigint::error(const string&amp; __s) {
    fprintf(stderr, "%s\n", __s.c_str());
    cerr &lt;&lt; __s &lt;&lt; endl;
    abort();
}
 
//math
inline Bigint abs(const Bigint&amp; __x) {
    return Bigint(__x).abs();
}
inline Bigint pow(const Bigint&amp; __x, const unsigned&amp; __y) {
    return Bigint(__x).pow(__y);
}
inline Bigint root(const Bigint&amp; __x, const unsigned&amp; __y = 2) {
    return Bigint(__x).root(__y);
}
inline Bigint sqrt(const Bigint&amp; __x) {
    return Bigint(__x).sqrt();
}
 
//io
inline istream&amp; operator&gt;&gt;(istream&amp; __s, Bigint&amp; __t) {
    string __r;
    __s &gt;&gt; __r;
    __t = Bigint(__r);
    return __s;
}
inline ostream&amp; operator&lt;&lt;(ostream&amp; __s, const Bigint&amp; __t) {
    if (__t.neg()) __s &lt;&lt; '-';
    vicrit i = __t.num().rbegin();
    __s &lt;&lt; *i;
    while (++i != __t.num().rend()) {
        __s.width(length);
        __s.fill('0');
        __s &lt;&lt; *i;
    }
    return __s;
}
 
//optimization
inline void enoughMemory() {
    __enoughMemory = true;
}
 
#endif
int d[1010];
Bigint fac(int x){
	Bigint r=1;
	lp(i,1,x)r*=i;
	return r;
}
int main(){
	enoughMemory();
	int tot=0,n,w=0;
	sf("%d",&amp;n);
	lp(i,1,n){sf("%d",&amp;d[i]);if(d[i]!=-1)tot+=d[i]-1,++w;}
	Bigint t1=1;lp(i,n-2-tot+1,n-2)t1*=i;
	Bigint t2=1;
	lp(i,1,n)if(d[i]!=-1)t2*=fac(d[i]-1);
	t1*=pow(Bigint(n-w),n-2-tot);
	cout&lt;&lt;t1/t2&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[10010];int n,m,eng[10010],cod[10010],doc[10010],nw;//coddoc互为反函数 
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int a,b;
        sf("%d%d",&amp;a,&amp;b);
        to[a].push_back(b);
        to[b].push_back(a);
    }
    priority_queue&lt;pair&lt;int,int&gt; &gt;qu;//max heap 
    lp(i,1,n)qu.push(make_pair(0,i));nw=n;
    while(!qu.empty()){
        int u=qu.top().second;qu.pop();
        if(cod[u])continue;//不会出现eng[u]!=e的情况，eng总是在增大 
        cod[u]=nw;doc[nw]=u;--nw;
        lp(i,0,int(to[u].size()-1))
            if(!cod[to[u][i]])
                qu.push(make_pair(++eng[to[u][i]],to[u][i]));
    }
    int ans=0;
    lp(i,1,n){
        int u=doc[i],t=1;
        lp(j,0,int(to[u].size()-1))
            t+=(cod[to[u][j]]&gt;cod[u]);
        ans=max(ans,t);
    } 
    //lp(i,1,n)pf("[%d]",doc[i]);
    pf("%d\n",ans);//ps;
    return 0;
}
/*
4 5
1 2
2 4
4 3
3 1
1 4
*/
<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
#define pb push_back
struct line{
    line(int c,int d,int e):
        a(c),b(d),id(e){}
    int a,b,id;
};
bool operator&lt;(line a,line b){
    return a.a==b.a?a.b&gt;b.b:a.a&lt;b.a;
}
int main(){
    vector&lt;line&gt;ls;
    int n;sf("%d",&amp;n);
    lp(i,1,n){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        ls.pb(line(a,b,i));
    }
    sort(ls.begin(),ls.end());
    vector&lt;line&gt;stk;
    lp(i,0,n-1){
        while(stk.size()&gt;1){
            int a1=ls[i].a,b1=ls[i].b;
            int a2=stk[stk.size()-1].a,b2=stk[stk.size()-1].b;
            int a3=stk[stk.size()-2].a,b3=stk[stk.size()-2].b;
            double x=double(b3-b2)/(a2-a3);
            double y=a2*x+b2;
            double yy=a1*x+b1;
            if(y-yy&lt;1e-8)stk.pop_back();
            else break;
        }
        if(stk.empty()||stk.back().a!=ls[i].a)
            stk.push_back(ls[i]);
    }
    vector&lt;int&gt;ans;
    lp(i,0,int(stk.size()-1)){
        ans.push_back(stk[i].id);
    }
    sort(ans.begin(),ans.end());
    lp(i,0,int(ans.size()-1)){
        pf("%d ",ans[i]);
    }pf("\n");
    //ps;
    return 0;
}
<pre><h2>Problem1008</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll pmod(ll a,ll b){
	ll r=1;
	while(b){
		if(b&amp;1)r=r*a%100003;
		a=a*a%100003;
		b&gt;&gt;=1;
	}
	return r;
}
int main(){
	//fr("data.in","r",stdin);
	//fr("hehe.out","w",stdout);
	ll m,n;sf("%lld%lld",&amp;m,&amp;n);
	pf("%lld\n",((pmod(m,n)-m*pmod(m-1,n-1))%100003+100003)%100003);
    return 0;
} <pre><h2>Problem1009</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,m,kk,fail[31],ch[31][10],nw=1;
char str[31];
struct mat{
    int d[31][31],l;
};
void printmat(mat a){
    lp(i,1,a.l){lp(j,1,a.l){
        pf("%d ",a.d[i][j]);
    }pf("\n");}pf("\n");
}
mat operator*(mat a,mat b){
    mat c;c.l=a.l;
    lp(i,1,c.l)lp(j,1,c.l)c.d[i][j]=0;
    lp(i,1,c.l)
        lp(j,1,c.l)
            lp(k,1,c.l){
                c.d[i][j]+=a.d[i][k]*b.d[k][j];
                c.d[i][j]%=kk;
            }
    return c;
}
mat pw(mat t,int b){
    mat r;r.l=t.l;lp(i,1,r.l)lp(j,1,r.l)r.d[i][j]=(i==j);
    while(b){
        if(b&amp;1)r=r*t;
        t=t*t;
       // printmat(t);
        b&gt;&gt;=1;
    }
    return r;
}
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;kk);
    sf("%s",str+1);
    lp(i,1,m){++nw;ch[nw-1][str[i]-'0']=nw;}
    lp(i,0,9)if(!ch[1][i])ch[1][i]=1;else fail[ch[1][i]]=1;
    lp(i,2,nw){
        lp(j,0,9)if(!ch[i][j])ch[i][j]=ch[fail[i]][j];
            else fail[ch[i][j]]=ch[fail[i]][j];
    }
    mat t;t.l=nw;lp(i,1,nw)lp(j,1,nw)t.d[i][j]=0;
    lp(i,1,nw)lp(j,0,9)if(ch[i][j]!=m+1)++t.d[i][ch[i][j]];
    t=pw(t,n);
    int ans=0;lp(i,1,nw)ans=(ans+t.d[1][i])%kk;
    pf("%d\n",ans);
    //ps;
    return 0;
}

<pre><h2>Problem1010</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll n,l,s[50010],t[50010],x[50010],y[50010],f[50010];
double k(int a,int b){
	return double(y[a]-y[b])/(x[a]-x[b]);
}
int main(){
	//fr("data.in","r",stdin);
	//fr("hehe.out","w",stdout);
  	sf("%lld%lld",&amp;n,&amp;l);
    lp(i,1,n)sf("%lld",&amp;s[i]),s[i]+=s[i-1];
    x[0]=0;y[0]=0;deque&lt;int&gt; qu;qu.push_back(0);
    lp(i,1,n){
    	t[i]=s[i]+i-1-l;
        while(qu.size()&gt;1&amp;&amp;k(qu[0],qu[1])&lt;t[i])qu.pop_front();
        f[i]=f[qu[0]]+(t[i]-s[qu[0]]-qu[0])*(t[i]-s[qu[0]]-qu[0]);
        x[i]=2*(s[i]+i);y[i]=f[i]+(s[i]+i)*(s[i]+i);
        while(qu.size()&gt;1&amp;&amp;k(qu[qu.size()-1],qu[qu.size()-2])&gt;k(qu[qu.size()-2],i))qu.pop_back();
        qu.push_back(i);
    }
    pf("%lld\n",f[n]);
    return 0;
} <pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int L[200010],R[200010],S[200010],M[200010],V[200010],NW,RT;
void init(){
    M[0]=-(~0u&gt;&gt;1);
}
int mak(int v){
    ++NW;
    S[NW]=1;M[NW]=V[NW]=v;
    return NW;
}
void up(int x){
    S[x]=S[L[x]]+S[R[x]]+1;
    M[x]=max(max(M[L[x]],M[R[x]]),V[x]);
}
void rot_l(int &amp;x){
    int t=L[x];
    L[x]=R[t];
    R[t]=x;
    up(x);
    up(t);
    x=t;
}
void rot_r(int &amp;x){
    int t=R[x];
    R[x]=L[t];
    L[t]=x;
    up(x);
    up(t);
    x=t;
}
void spl(int &amp;x,int k){
    if(k&lt;S[L[x]]+1)spl(L[x],k),rot_l(x);
    else if(k&gt;S[L[x]]+1)spl(R[x],k-S[L[x]]-1),rot_r(x);
}
void ins(int &amp;x,int y){
    if(x==0)x=y;
    else{
        ins(R[x],y);
        up(x);
    }
}
int main(){
    int m,d,last=0,t;sf("%d%d",&amp;m,&amp;d);char op;
    lp(i,1,m){
        op=getchar();while(op=='\n'||op==' ')op=getchar();
        sf("%d",&amp;t);
        if(op=='A'){
            ins(RT,mak((last+t)%d));
        }else{
            if(t==S[RT])last=M[RT];
            else{
                spl(RT,S[RT]-t);
                last=M[R[RT]];
            }
            pf("%d\n",last);
        }
    }
    //ps;
    return 0;
}
<pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int L[200010],R[200010],S[200010],M[200010],V[200010],W[200010],NW,RT;
void init(){
    M[0]=-(~0u&gt;&gt;1);
}
int mak(int v){
    ++NW;
    S[NW]=1;M[NW]=V[NW]=v;
    W[NW]=rand()*rand();
    return NW;
}
void up(int x){
    S[x]=S[L[x]]+S[R[x]]+1;
    M[x]=max(max(M[L[x]],M[R[x]]),V[x]);
}
void rot_l(int &amp;x){
    int t=L[x];
    L[x]=R[t];
    R[t]=x;
    up(x);
    up(t);
    x=t;
}
void rot_r(int &amp;x){
    int t=R[x];
    R[x]=L[t];
    L[t]=x;
    up(x);
    up(t);
    x=t;
}
void spl(int &amp;x,int k){
    if(k&lt;S[L[x]]+1)spl(L[x],k),rot_l(x);
    else if(k&gt;S[L[x]]+1)spl(R[x],k-S[L[x]]-1),rot_r(x);
}
void ins(int &amp;x,int y){
    if(x==0)x=y;
    else{
        ins(R[x],y);
        up(x);
        if(W[R[x]]&lt;W[x])rot_r(x);
    }
}
int main(){
    int m,d,last=0,t;sf("%d%d",&amp;m,&amp;d);char op;
    lp(i,1,m){
        op=getchar();while(op=='\n'||op==' ')op=getchar();
        sf("%d",&amp;t);
        if(op=='A'){
            ins(RT,mak((last+t)%d));
        }else{
            if(t==S[RT])last=M[RT];
            else{
                spl(RT,S[RT]-t);
                last=M[R[RT]];
            }
            pf("%d\n",last);
        }
    }
    //ps;
    return 0;
}
<pre><h2>Problem1013</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define pb push_back
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
double a[110][110];int n;
double mab(double t){
    return t&lt;0?-t:t;
}
double ans[110];
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        double t;sf("%lf",&amp;t);
        lp(j,1,n)a[j][i]=2*t,a[j][0]+=t*t;
    } 
    lp(i,1,n){
        lp(j,1,n){
            double t;sf("%lf",&amp;t);
            a[i][j]-=2*t;
            a[i][0]-=t*t;
        }
    }
    lp(i,1,n){
        int j=1;while(mab(a[i][j])&lt;1e-8)++j;
        double t=a[i][j];
        lp(k,0,n)a[i][k]/=t;
        lp(k,1,n)if(k!=i&amp;&amp;mab(a[k][j])&gt;1e-8){
            double t2=a[k][j];
            lp(l,0,n)a[k][l]-=a[i][l]*t2;
        }
    }
    lp(i,1,n){
        int j=1;while(mab(a[i][j])&lt;1e-8)++j;
        ans[j]=a[i][0];
    }
    lp(i,1,n)pf("%.3lf%c",ans[i],i==n?'\n':' ');
    //ps;
    return 0;
}
<pre><h2>Problem1014</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll p=1000000007,q=26;
ll pw[100010];
namespace treap{
    struct node{
        node(){}
        node(char c){siz=1;ch[0]=ch[1]=0;val=c;hs=c-'a';fix=rand();}
        node*ch[2];char val;ll hs;int siz,fix;
    };
    node buff[100010],*bfs=buff;
    node*newnode(char v){
        *bfs=node(v);
        return bfs++;
    }
    inline void update(node*x){
        x-&gt;siz=1;
        if(x-&gt;ch[0])x-&gt;siz+=x-&gt;ch[0]-&gt;siz;
        if(x-&gt;ch[1])x-&gt;siz+=x-&gt;ch[1]-&gt;siz;
        x-&gt;hs=x-&gt;val-'a';
        if(x-&gt;ch[0])x-&gt;hs=(x-&gt;hs+x-&gt;ch[0]-&gt;hs*q)%p;
        if(x-&gt;ch[1])x-&gt;hs=(x-&gt;hs*pw[x-&gt;ch[1]-&gt;siz]+x-&gt;ch[1]-&gt;hs)%p;
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        y-&gt;siz=x-&gt;siz;y-&gt;hs=x-&gt;hs;
        update(x);
        x=y;
    }
    inline void insert(node*&amp;x,int k,char v){
        if(!x)x=newnode(v);
        else{
            int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
            if(k&lt;=t){
                insert(x-&gt;ch[0],k,v);
                update(x);
                if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;fix)rotate(x,0);
            }else {
                insert(x-&gt;ch[1],k-(t+1),v);
                update(x);
                if(x-&gt;ch[1]-&gt;fix&lt;x-&gt;fix)rotate(x,1);
            }
        }
    }
    inline void modify(node*x,int k,char v){
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(k&lt;=t)modify(x-&gt;ch[0],k,v);
        else if(k&gt;t+1)modify(x-&gt;ch[1],k-(t+1),v);
        else x-&gt;val=v;
        update(x);
    }
    inline ll query(node*x,int l,int r){
    	if(l==1&amp;&amp;r==x-&gt;siz)return x-&gt;hs;
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(r&lt;=t)return query(x-&gt;ch[0],l,r);
        else if(l&gt;t+1)return query(x-&gt;ch[1],l-(t+1),r-(t+1));
        else if(l==t+1&amp;&amp;r==t+1)return x-&gt;val-'a';
        else if(l==t+1)return ((x-&gt;val-'a')*pw[r-(t+1)]+query(x-&gt;ch[1],1,r-(t+1)))%p;
        else if(r==t+1)return (query(x-&gt;ch[0],l,t)*q+(x-&gt;val-'a'))%p;
        else{
            ll t1=query(x-&gt;ch[0],l,t);
            t1=(t1*q+x-&gt;val-'a')%p;
            r=r-(t+1);
            t1=(t1*pw[r]+query(x-&gt;ch[1],1,r))%p;
            return t1;
        }
    }
    int lcp(node*x,int a,int b){
        int len=x-&gt;siz;
        int lft=0,rht=min(len-a,len-b);
        if(query(x,a,a)!=query(x,b,b))return 0;
        if(query(x,a,a+rht)==query(x,b,b+rht))return rht+1;
        while(lft+1&lt;rht){
            int mid=(lft+rht)/2;
            if(query(x,a,a+mid)==query(x,b,b+mid))
                lft=mid;
            else
                rht=mid;
        }
        return lft+1;
    }
    void print(node*x,int d){
    	if(x){
    		print(x-&gt;ch[0],d+1);
    		lp(i,1,d*4)pf(" ");pf("[%lld,%d]\n",x-&gt;hs,x-&gt;siz);
    		print(x-&gt;ch[1],d+1);
    	}
    }
}
int main(){
    pw[0]=1;lp(i,1,100005)pw[i]=pw[i-1]*q%p;
    static char str[100010];
    sf("%s",str+1);treap::node*rt=0;int len=strlen(str+1);
    lp(i,1,len)treap::insert(rt,i-1,str[i]);
    int m;sf("%d",&amp;m);
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int x,y;sf("%d%d",&amp;x,&amp;y);
            pf("%d\n",treap::lcp(rt,x,y));
        }else if(op[0]=='R'){
            int x;char v[11];sf("%d%s",&amp;x,v);
            treap::modify(rt,x,v[0]);
        }else{
            int x;char v[11];sf("%d%s",&amp;x,v);
            treap::insert(rt,x,v[0]);
        }
    }
    return 0;
}<pre><h2>Problem1014</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll p=1000000007,q=26;
ll pw[100010];
namespace treap{
    struct node{
        node(){}
        node(char c){siz=1;ch[0]=ch[1]=0;val=c;hs=c-'a';fix=rand();}
        node*ch[2];char val;ll hs;int siz,fix;
    };
    node buff[100010],*bfs=buff;
    node*newnode(char v){
        *bfs=node(v);
        return bfs++;
    }
    inline void update(node*x){
        x-&gt;siz=1;
        if(x-&gt;ch[0])x-&gt;siz+=x-&gt;ch[0]-&gt;siz;
        if(x-&gt;ch[1])x-&gt;siz+=x-&gt;ch[1]-&gt;siz;
        x-&gt;hs=x-&gt;val-'a';
        if(x-&gt;ch[0])x-&gt;hs=(x-&gt;hs+x-&gt;ch[0]-&gt;hs*q)%p;
        if(x-&gt;ch[1])x-&gt;hs=(x-&gt;hs*pw[x-&gt;ch[1]-&gt;siz]+x-&gt;ch[1]-&gt;hs)%p;
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        y-&gt;siz=x-&gt;siz;y-&gt;hs=x-&gt;hs;
        update(x);
        x=y;
    }
    inline void insert(node*&amp;x,int k,char v){
        if(!x)x=new node(v);
        else{
            int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
            if(k&lt;=t){
                insert(x-&gt;ch[0],k,v);
                update(x);
                if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;fix)rotate(x,0);
            }else {
                insert(x-&gt;ch[1],k-(t+1),v);
                update(x);
                if(x-&gt;ch[1]-&gt;fix&lt;x-&gt;fix)rotate(x,1);
            }
        }
    }
    inline void modify(node*x,int k,char v){
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(k&lt;=t)modify(x-&gt;ch[0],k,v);
        else if(k&gt;t+1)modify(x-&gt;ch[1],k-(t+1),v);
        else x-&gt;val=v;
        update(x);
    }
    inline ll query(node*x,int l,int r){
    	if(l==1&amp;&amp;r==x-&gt;siz)return x-&gt;hs;
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(r&lt;=t)return query(x-&gt;ch[0],l,r);
        else if(l&gt;t+1)return query(x-&gt;ch[1],l-(t+1),r-(t+1));
        else if(l==t+1&amp;&amp;r==t+1)return x-&gt;val-'a';
        else if(l==t+1)return ((x-&gt;val-'a')*pw[r-(t+1)]+query(x-&gt;ch[1],1,r-(t+1)))%p;
        else if(r==t+1)return (query(x-&gt;ch[0],l,t)*q+(x-&gt;val-'a'))%p;
        else{
            ll t1=query(x-&gt;ch[0],l,t);
            t1=(t1*q+x-&gt;val-'a')%p;
            r=r-(t+1);
            t1=(t1*pw[r]+query(x-&gt;ch[1],1,r))%p;
            return t1;
        }
    }
    int lcp(node*x,int a,int b){
        int len=x-&gt;siz;
        int lft=0,rht=min(len-a,len-b);
        if(query(x,a,a)!=query(x,b,b))return 0;
        if(query(x,a,a+rht)==query(x,b,b+rht))return rht+1;
        while(lft+1&lt;rht){
            int mid=(lft+rht)/2;
            if(query(x,a,a+mid)==query(x,b,b+mid))
                lft=mid;
            else
                rht=mid;
        }
        return lft+1;
    }
    void print(node*x,int d){
    	if(x){
    		print(x-&gt;ch[0],d+1);
    		lp(i,1,d*4)pf(" ");pf("[%lld,%d]\n",x-&gt;hs,x-&gt;siz);
    		print(x-&gt;ch[1],d+1);
    	}
    }
}
int main(){
    pw[0]=1;lp(i,1,100005)pw[i]=pw[i-1]*q%p;
    static char str[100010];
    sf("%s",str+1);treap::node*rt=0;int len=strlen(str+1);
    lp(i,1,len)treap::insert(rt,i-1,str[i]);
    int m;sf("%d",&amp;m);
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int x,y;sf("%d%d",&amp;x,&amp;y);
            pf("%d\n",treap::lcp(rt,x,y));
        }else if(op[0]=='R'){
            int x;char v[11];sf("%d%s",&amp;x,v);
            treap::modify(rt,x,v[0]);
        }else{
            int x;char v[11];sf("%d%s",&amp;x,v);
            treap::insert(rt,x,v[0]);
        }
    }
    return 0;
}<pre><h2>Problem1015</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int pr[400010],n,m,q,dl[400010];
vector&lt;int&gt;to[400010],qs;
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u+1].push_back(v+1);
        to[v+1].push_back(u+1); 
    }
    sf("%d",&amp;q);
    lp(i,1,n)pr[i]=i;
    lp(i,1,q){
        int u;sf("%d",&amp;u);
        qs.push_back(u+1);
        dl[u+1]=1;
    }
    int ans=0;
    lp(i,1,n)if(!dl[i]){
        lp(j,0,int(to[i].size()-1)){
            if(!dl[to[i][j]]){
                int u=i,v=to[i][j];
                if(fd(u)!=fd(v)){
                    pr[fd(u)]=v;
                }
            }
        }
    }
    vector&lt;int&gt;aas;
    lp(i,1,n)if(!dl[i]&amp;&amp;pr[i]==i)++ans;
    rp(i,int(qs.size()-1),0){
        aas.push_back(ans);
        ++ans;
        int u=qs[i];dl[u]=0;
        lp(j,0,int(to[u].size()-1)){
            int v=to[u][j];
            if(!dl[v]){
                if(fd(u)!=fd(v)){
                    pr[fd(u)]=v;
                    --ans;
                }
            }
        }
    }
    aas.push_back(ans);
    rp(i,int(aas.size()-1),0)
        pf("%d\n",aas[i]);
    //ps;
    return 0; 
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m;
struct edge{
    edge(){sf("%d%d%d",&amp;u,&amp;v,&amp;w);}
    int u,v,w;
};
bool operator&lt;(edge a,edge b){
    return a.w&lt;b.w;
}
vector&lt;edge&gt;eg;
int pr[110];
int fd(int x){return pr[x]==x?x:pr[x]=fd(pr[x]);}
int ans=1;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m)eg.push_back(edge());
    sort(eg.begin(),eg.end());
    for(int i=0,j=0;i&lt;eg.size();i=j+1,j=i){
        while(j+1&lt;eg.size()&amp;&amp;eg[j+1].w==eg[j].w)++j;
        vector&lt;edge&gt;tmp;
        lp(k,i,j)tmp.push_back(eg[k]);
        int cnt=0,exc=0;
        lp(l,1,n)pr[l]=l;
        lp(l,0,int(tmp.size()-1)){
            int u=tmp[l].u,v=tmp[l].v;
            if(fd(u)!=fd(v))
                pr[fd(u)]=v;
        }
        lp(l,1,n)exc+=(pr[l]==l);
        lp(k,0,(1&lt;&lt;tmp.size())-1){
            int fail=0;
            lp(l,1,n)pr[l]=l;
            for(int l=0;l&lt;tmp.size();++l)
                if((k&gt;&gt;l)&amp;1){
                    int u=tmp[l].u,v=tmp[l].v;
                    if(fd(u)==fd(v)){fail=1;break;}
                    else pr[fd(u)]=v;
                }
            int tc=0;
            lp(l,1,n)tc+=(pr[l]==l);
            if(!fail&amp;&amp;tc==exc)++cnt;
        }
        ans=ans*cnt%31011;
        lp(l,1,n)pr[l]=l;
        lp(l,0,int(tmp.size()-1)){
            int u=tmp[l].u,v=tmp[l].v;
            if(fd(u)!=fd(v))
                pr[fd(u)]=v;
        }
        static int tag[110];int nw=0;
        lp(l,1,n)if(pr[l]==l)tag[l]=++nw;
        n=nw;
        lp(l,0,int(eg.size()-1))
            eg[l].u=tag[fd(eg[l].u)],
            eg[l].v=tag[fd(eg[l].v)];
    }
    pf("%d\n",ans*(n==1));
    //ps;
    return 0;
}
<pre><h2>Problem1018</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int way[3][100010][5];//1up2down3left4right
struct node{
    node(int a,int b){l=a,r=b;lc=rc=0;lp(i,1,6)go[i]=0;}
    node*lc,*rc;int go[7],l,r;
};
node*build(int l,int r){
    node*x=new node(l,r);
    if(l!=r){
        int m=(l+r)/2;
        x-&gt;lc=build(l,m);
        x-&gt;rc=build(m+1,r);
    }else{
        x-&gt;go[3]=x-&gt;go[4]=1;
    }
    return x;
}
#define hehe(a,b) (x-&gt;lc-&gt;go[a]&amp;&amp;x-&gt;rc-&gt;go[b])
void upda(node*x){
    int m=x-&gt;lc-&gt;r;
    x-&gt;go[1]=((hehe(1,4)&amp;&amp;way[2][m][4])||(hehe(3,1)&amp;&amp;way[1][m][4]));
    x-&gt;go[2]=((hehe(4,2)&amp;&amp;way[2][m][4])||(hehe(2,3)&amp;&amp;way[1][m][4]));
    x-&gt;go[3]=((hehe(1,2)&amp;&amp;way[2][m][4])||(hehe(3,3)&amp;&amp;way[1][m][4]));
    x-&gt;go[4]=((hehe(4,4)&amp;&amp;way[2][m][4])||(hehe(2,1)&amp;&amp;way[1][m][4]));
    x-&gt;go[5]=(x-&gt;lc-&gt;go[5]||(x-&gt;rc-&gt;go[5]&amp;&amp;x-&gt;lc-&gt;go[3]&amp;&amp;x-&gt;lc-&gt;go[4]&amp;&amp;way[2][m][4]&amp;&amp;way[1][m][4]));
    x-&gt;go[6]=(x-&gt;rc-&gt;go[6]||(x-&gt;lc-&gt;go[6]&amp;&amp;x-&gt;rc-&gt;go[3]&amp;&amp;x-&gt;rc-&gt;go[4]&amp;&amp;way[2][m][4]&amp;&amp;way[1][m][4]));
}
void update(node*x,int p){
    if(x-&gt;l==x-&gt;r){
        x-&gt;go[1]=x-&gt;go[2]=x-&gt;go[5]=x-&gt;go[6]=way[1][x-&gt;l][2];
        x-&gt;go[3]=x-&gt;go[4]=1;
    }else{
        if(p&lt;=x-&gt;lc-&gt;r)update(x-&gt;lc,p);
        else update(x-&gt;rc,p);
        upda(x);
    }
}
node*rt;
vector&lt;node*&gt;ans;
void query(node*x,int l,int r){
    //pf("[%d,%d]",l,r);
    if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)ans.push_back(x);
    else{
        int m=(x-&gt;l+x-&gt;r)/2;
        if(l&lt;=m)query(x-&gt;lc,l,r);
        if(r&gt;m)query(x-&gt;rc,l,r);
    }
}
node*get(int l,int r){
    ans.clear();
    query(rt,l,r);
    while(ans.size()&gt;1){
        node*t=new node(0,0);
        t-&gt;lc=ans[ans.size()-2];t-&gt;rc=ans[ans.size()-1];
        t-&gt;l=t-&gt;lc-&gt;l;t-&gt;r=t-&gt;rc-&gt;r;
        upda(t);
        ans.pop_back();ans.pop_back();
        ans.push_back(t);
    }
    return ans.front();
}
void pnode(node*x){
    pf("[%d,%d:%d%d%d%d%d%d]\n",x-&gt;l,x-&gt;r,x-&gt;go[1],
            x-&gt;go[2],x-&gt;go[3],x-&gt;go[4],x-&gt;go[5],x-&gt;go[6]);
} 
void print(node*x){
    if(x){
        pf("[%d,%d:%d%d%d%d%d%d]\n",x-&gt;l,x-&gt;r,x-&gt;go[1],
            x-&gt;go[2],x-&gt;go[3],x-&gt;go[4],x-&gt;go[5],x-&gt;go[6]);
        print(x-&gt;lc);
        print(x-&gt;rc);
        if(x==rt)pf("\n");
    }
}
int main(){
    int n;sf("%d",&amp;n);
    rt=build(1,n);
    while(true){
        char op[11];int u,v,w,x;
        sf("%s%d%d%d%d",op,&amp;u,&amp;v,&amp;w,&amp;x);
        if(op[0]=='O'){
            if(u==w){
                if(v&gt;x)swap(v,x);
                way[u][v][4]=1;
                way[w][x][3]=1;
            }else{
                if(u&gt;w)swap(u,w);
                way[u][v][2]=1;
                way[w][x][1]=1;
            }
            update(rt,v);
            update(rt,x);
        }else if(op[0]=='A'){
            int orz=0;
            int r1=u,c1=v,r2=w,c2=x;
            if(c1&gt;c2)swap(c1,c2),swap(r1,r2);
            node*l=(c1-1)?get(1,c1-1):0,*m=get(c1,c2),*r=(c2==n)?0:get(c2+1,n);
            //pnode(l);pnode(m);pnode(r);
            if(r1==1&amp;&amp;r2==1){
                if(m-&gt;go[3])orz=1;
                if(l&amp;&amp;r&amp;&amp;way[1][c1][3]&amp;&amp;way[1][c2][4]&amp;&amp;l-&gt;go[6]&amp;&amp;r-&gt;go[5]&amp;&amp;
                    way[2][c1][3]&amp;&amp;way[2][c2][4]&amp;&amp;m-&gt;go[4])
                    orz=1;
                if(l&amp;&amp;way[1][c1][3]&amp;&amp;l-&gt;go[6]&amp;&amp;way[2][c1][3]&amp;&amp;m-&gt;go[2])
                    orz=1;
                if(r&amp;&amp;way[1][c2][4]&amp;&amp;r-&gt;go[5]&amp;&amp;way[2][c2][4]&amp;&amp;m-&gt;go[1])
                    orz=1;
            }else if(r1==2&amp;&amp;r2==2){
                if(m-&gt;go[4])orz=1;
                //pf("[%d]\n",orz);
                if(l&amp;&amp;r&amp;&amp;way[1][c1][3]&amp;&amp;way[1][c2][4]&amp;&amp;l-&gt;go[6]&amp;&amp;r-&gt;go[5]&amp;&amp;
                    way[2][c1][3]&amp;&amp;way[2][c2][4]&amp;&amp;m-&gt;go[3])
                    orz=1;
                //pf("[%d]\n",orz);
                if(l&amp;&amp;way[1][c1][3]&amp;&amp;l-&gt;go[6]&amp;&amp;way[2][c1][3]&amp;&amp;m-&gt;go[1])
                    orz=1;
                //pf("[%d]\n",orz);
                if(r&amp;&amp;way[1][c2][4]&amp;&amp;r-&gt;go[5]&amp;&amp;way[2][c2][4]&amp;&amp;m-&gt;go[2])
                    orz=1;
                //pf("[%d]\n",orz);
            }else if(r1==1&amp;&amp;r2==2){
                if(m-&gt;go[1])orz=1;
                if(l&amp;&amp;way[1][c1][3]&amp;&amp;way[2][c1][3]&amp;&amp;l-&gt;go[6]&amp;&amp;m-&gt;go[4])
                    orz=1;
                if(r&amp;&amp;way[1][c2][4]&amp;&amp;way[2][c2][4]&amp;&amp;r-&gt;go[5]&amp;&amp;m-&gt;go[3])
                    orz=1;
            }else{//r1=2,r2=1
                if(m-&gt;go[2])orz=1;
                if(l&amp;&amp;way[1][c1][3]&amp;&amp;way[2][c1][3]&amp;&amp;l-&gt;go[6]&amp;&amp;m-&gt;go[3])
                    orz=1;
                if(r&amp;&amp;way[1][c2][4]&amp;&amp;way[2][c2][4]&amp;&amp;r-&gt;go[5]&amp;&amp;m-&gt;go[4])
                    orz=1;
            }
            pf("%s\n",orz?"Y":"N");
        }else if(op[0]=='C'){
            if(u==w){
                if(v&gt;x)swap(v,x);
                way[u][v][4]=0;
                way[w][x][3]=0;
            }else{
                if(u&gt;w)swap(u,w);
                way[u][v][2]=0;
                way[w][x][1]=0;
            }
            update(rt,v);
            update(rt,x);
        }else break;
        //print(rt);
    }//ps;
    return 0;
}

<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int main(){
    int test;sf("%d",&amp;test);
    lp(kase,1,test){
        int n,s=0,f=1;sf("%d",&amp;n);
        lp(i,1,n){int t;sf("%d",&amp;t);s^=t;if(t!=1)f=0;}
        if((s==0&amp;&amp;f==1)||(s!=0&amp;&amp;f==0))pf("John\n");
        else pf("Brother\n");
    } 
    //ps;
    return 0;
}
<pre><h2>Problem1023</h2><pre>    #include &lt;cstdio&gt;  
    #include &lt;cstdlib&gt;  
    #include &lt;cstring&gt;  
    #include &lt;map&gt;  
    #include &lt;set&gt;  
    #include &lt;queue&gt;  
    #include &lt;algorithm&gt;  
    using namespace std;  
    #define FOR(i, j, k) for (i = (j); i &lt;= (k); ++ i)  
    #define ROF(i, j, k) for (i = (j); i &gt;= (k); -- i)  
    #define FER(i, j, k) for (i = j[k]; i; i = i-&gt;n)  
    #define maxn 50005  
      
    struct da{int t; da * n;};  
    da das[maxn * 4], * adj = das + 1, * edge[maxn];  
    int n, m, dfnn, tot, ans, i, j, k;  
    int dfn[maxn], low[maxn], dis[maxn];  
    da * sta[maxn * 2], ** top = sta;  
    int a[maxn * 2], q[maxn * 2], h, t;  
      
    void up(int &amp; i, int j) {if (j &gt; i) i = j;}  
    void down(int &amp; i, int j) {if (j &lt; i) i = j;}  
      
    void solve(int k)  
    {  
        int i; q[h = t = 1] = 1;  
        FOR (i, 2, tot)  
            {  
                while (i - q[h] &gt; k) ++ h;  
                up(ans, dis[a[q[h]]] - q[h] + dis[a[i]] + i);  
                while (h &lt;= t &amp;&amp; dis[a[i]] - i &gt; dis[a[q[t]]] - q[t]) -- t;  
                q[++ t] = i;  
            }  
    }  
      
    void dfs(int u, int fa)  
    {  
        da * e; int l = 0;  
        dfn[u] = low[u] = ++ dfnn;  
        FER (e, edge, u) if (e-&gt;t != fa)  
            if (dfn[e-&gt;t]) down(low[u], dfn[e-&gt;t]);  
            else  
                {  
                    * (++ top) = e, dfs(e-&gt;t, u), down(low[u], low[e-&gt;t]);  
                    if (low[e-&gt;t] &gt; dfn[u])  
                        {  
                            -- top;  
                            if (dis[e-&gt;t] + 1 &gt; dis[u])  
                                l = dis[u], dis[u] = dis[e-&gt;t] + 1;  
                            else if (dis[e-&gt;t] + 1 &gt; l)  
                                l = dis[e-&gt;t] + 1;  
                        }  
                    else if (low[e-&gt;t] == dfn[u])  
                        {  
                            tot = j = 0;  
                            do a[++ tot] = (* top)-&gt;t; while (* (top --) != e);  
                            FOR (i, 1, tot)  
                                {  
                                    up(j, dis[a[i]] + min(i, tot + 1 - i));  
                                    a[i + tot + 1] = a[i];  
                                }  
                            a[++ tot] = u, k = tot &gt;&gt; 1, tot = (tot &lt;&lt; 1) - 1;  
                            solve(k);  
                            if (j &gt; dis[u]) l = dis[u], dis[u] = j;  
                            else if (j &gt; l) l = j;  
                        }  
                }  
        up(ans, l + dis[u]);  
    }  
      
    void link(int i, int j)  
    {  
        * (++ adj) = (da) {j, edge[i]}, edge[i] = adj;  
        * (++ adj) = (da) {i, edge[j]}, edge[j] = adj;  
    }  
      
    int main()  
    {  
      
        int u, v;  
        scanf("%d%d", &amp; n, &amp; m);  
        FOR (i, 1, m)  
            {  
                scanf("%d%d", &amp; k, &amp; u);  
                FOR (j, 2, k) scanf("%d", &amp; v), link(u, v), u = v;  
            }  
        dfs(1, 0);  
        printf("%d\n", ans);  
        //for(;;); 
        return 0;  
    }  
<pre><h2>Problem1023</h2><pre># include&lt;cstdio&gt;
# include&lt;cstring&gt;
# include&lt;cstdlib&gt;
# include&lt;iostream&gt;
# include&lt;cmath&gt;
using namespace std;
const int maxn=100008,maxm=4000008,maxx=20000008;
int a1[2000008],next1[2000008],start1[50008],tot,n;
int low[maxn],dfn[maxn],belong[maxn],stack[maxn],len,r[maxn],d[maxn],v[maxn],tmp[maxn&lt;&lt;1];
int p,ans,h[maxn&lt;&lt;1],s[maxn],ll;
int a[maxm],next[maxm],start[maxn],T,fa[maxn],tot1,dis[maxm];
bool flag[maxn],t[maxm];
char Input[maxx+5],*ipos;
#define read() (strtol(ipos,&amp;ipos,10))
void Add1(int x,int y)
{
     a1[++tot]=y;next1[tot]=start1[x];start1[x]=tot;
     a1[++tot]=x;next1[tot]=start1[y];start1[y]=tot;
}
void Add(int x,int y,int z)
{
     a[++tot]=y;next[tot]=start[x];start[x]=tot;dis[tot]=z;
     a[++tot]=x;next[tot]=start[y];start[y]=tot;dis[tot]=z;
}
void Init()
{
     int m,k,x,y;tot=1;
     n=read();m=read();
     while (m--)
     {
           k=read();x=read();k--;
           while (k--)  
           {
                 y=read();
                 Add1(x,y);x=y;     
           }
     }
}
void Dfs(int u)
{
     dfn[u]=++tot1;
     for (int i=start1[u];i;i=next1[i])
     {
         int v=a1[i];if (v==a1[fa[u]]) continue;
         if (dfn[v]&amp;&amp;dfn[v]&lt;dfn[u])
         {
            ++p;
            for (int j=u;j!=a1[fa[v]];j=a1[fa[j]])
            {
                if (flag[j]) {s[++ll]=++T;Add(j,T,0);}
                else {s[++ll]=j;flag[j]=1;}
                if (j!=v) t[fa[j]^1]=1;
            }
            t[i]=t[i^1]=1;
            r[p]=ll;s[r[p]+1]=s[r[p-1]+1];
            for (int j=r[p-1]+1;j&lt;=r[p];j++) {Add(s[j],s[j+1],1);belong[s[j]]=p;}
         }
         else if (!dfn[v]) {fa[v]=(i^1);Dfs(v);}
     }
     for (int i=start1[u];i;i=next1[i])
      if (i!=fa[u]&amp;&amp;!t[i]) Add(u,a1[i],1);
     if (!flag[u])
     {
        r[++p]=++ll;s[ll]=u;belong[u]=p;
     }
}
void Treedp(int u,int fa)
{
     int p=belong[u];
     for (int i=r[p-1]+1;i&lt;=r[p];i++)
     {
         int x=0,y=0;
         for (int j=start[s[i]];j;j=next[j])
           if (belong[a[j]]!=p&amp;&amp;a[j]!=fa)
           {
              Treedp(a[j],s[i]);
              d[a[j]]+=dis[j];
              if (d[a[j]]&gt;d[x]) x=a[j];
           }
         if (x) {ans=max(ans,d[x]);v[s[i]]=d[x];}
         for (int j=start[s[i]];j;j=next[j])
           if (belong[a[j]]!=p&amp;&amp;a[j]!=fa&amp;&amp;a[j]!=x)
              if (d[a[j]]&gt;d[y]) y=a[j];
         if (x&amp;&amp;y) ans=max(ans,d[x]+d[y]);
     }
     len=0;int pos=0;
     for (int i=r[p-1]+1;i&lt;=r[p];i++) {tmp[++len]=s[i];if (s[i]==u) pos=len;}
     for (int i=1;i&lt;=len;i++) tmp[len+i]=tmp[i];
     int ll=1,rr=0;d[u]=v[u];
     for (int i=1;i&lt;=len+(len&gt;&gt;1);i++)
     {
         while (ll&lt;=rr&amp;&amp;(i-h[ll])&gt;(len&gt;&gt;1)) ll++;
         if (ll&lt;=rr) ans=max(v[tmp[h[ll]]]+i-h[ll]+v[tmp[i]],ans);
         while (rr&gt;=ll&amp;&amp;v[tmp[i]]-i&gt;=v[tmp[h[rr]]]-h[rr]) rr--;
         h[++rr]=i;
     }
     for (int i=1;i&lt;=len;i++)
      if (i!=pos) d[u]=max(d[u],min(abs(pos-i),len-abs(pos-i))+v[tmp[i]]);
}
void Work()
{
     T=n;tot=0;Dfs(1);
     Treedp(1,0);
     printf("%d\n",ans);
}
int main()
{
    fread(Input,maxx,1,stdin);ipos=Input;
    Init();
    Work();
    return 0;   
}
<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;deque&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
int n;vector&lt;int&gt;to[50010];
void init(){
    int m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int k,u,v;sf("%d%d",&amp;k,&amp;u);
        lp(j,2,k){
            sf("%d",&amp;v);
            to[u].pb(v);
            to[v].pb(u);
            u=v;
        }
    } 
}
int df[50010],lw[50010],pr[50010],dp[50010],nw,ans;stack&lt;int&gt;stk;
void treedp(int u){
    df[u]=lw[u]=++nw;stk.push(u);
    vp(i,to[u]){
        int v=to[u][i];
        if(v==pr[u])continue; 
        else if(df[v])lw[u]=min(lw[u],df[v]);
        else{
            pr[v]=u;treedp(v);lw[u]=min(lw[u],lw[v]);
            if(lw[v]&gt;df[u]){
                ans=max(ans,dp[v]+1+dp[u]);
                dp[u]=max(dp[u],dp[v]+1);
                stk.pop();
            }else if(lw[v]==df[u]){
                vector&lt;int&gt;cir,dcir;
                for(;stk.top()!=v;stk.pop())cir.pb(stk.top());stk.pop();cir.pb(v);cir.pb(u);
                dcir=cir;
                vp(j,cir)dcir.pb(cir[j]);
                deque&lt;int&gt;qu;qu.push_back(0);
                lp(j,1,int(dcir.size()-2)){
                    while(j-qu[0]&gt;cir.size()/2)qu.pop_front();
                    ans=max(ans,dp[dcir[qu[0]]]+dp[dcir[j]]+j-qu[0]);
                    while(!qu.empty()&amp;&amp;dp[dcir[qu.back()]]-qu.back()&lt;=dp[dcir[j]]-j)
                        qu.pop_back();
                    qu.push_back(j);
                }
                lp(j,0,int(cir.size()-2))
                    dp[u]=max(dp[u],dp[cir[j]]+min(j+1,int(cir.size())-(j+1)));
            }
        }
    }
}
int main(){
    init();
    treedp(1);
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1026</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;string&gt;
#include&lt;sstream&gt;
ll f[10][21];
int myabs(int a){return a&gt;0?a:-a;}
ll calc(ll tn){
	stringstream ss;ss&lt;&lt;tn;string n;ss&gt;&gt;n;ll ret=0;
	vp(i,n)n[i]-='0';
	lp(i,1,n[0]-1)ret+=f[i][n.size()];
	for(int i=1;i&lt;n.size();++i)
		lp(j,1,9)ret+=f[j][n.size()-i];
	++ret;
	for(int i=1;i&lt;n.size();++i){
		lp(j,0,i-2)if(myabs(n[j]-n[j+1])&lt;=1)return ret;
		lp(j,0,n[i]-1)if(myabs(n[i-1]-j)&gt;1)ret+=f[j][n.size()-i];
	}
	return ret;
}
ll bf(ll n){
	ll ret=0;
	lp(i,0,n-1){
		stringstream ss;ss&lt;&lt;i;string tmp;ss&gt;&gt;tmp;
		int flg=1;
		lp(j,0,int(tmp.size()-2))
			if(myabs(tmp[j]-tmp[j+1])&lt;=1)
				flg=0;
		ret+=flg;
	}
	return ret;
}
int main(){
	lp(i,0,9)f[i][1]=1;
	lp(i,2,20){
		lp(j,0,9){
			lp(k,0,9){
				if(myabs(j-k)&gt;1){
					f[j][i]+=f[k][i-1];
				}
			}
		}
	}
	//pf("[%lld,%lld]\n",calc(102),calc(103));
	//lp(i,1,200)pf("[%d,%lld,%lld,%lld]\n",i,calc(i),bf(i),calc(i)-bf(i));
	ll a,b;sf("%lld%lld",&amp;a,&amp;b);
	pf("%lld\n",calc(b+1)-calc(a));
	return 0;
}<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct task{
    int dur,dle;
}tasks[150010];int n;
struct cmp1{bool operator()(task a,task b){return a.dle&lt;b.dle;}};
struct cmp2{bool operator()(task a,task b){return a.dur&lt;b.dur;}};
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;tasks[i].dur,&amp;tasks[i].dle);
    sort(tasks+1,tasks+n+1,cmp1());
    priority_queue&lt;task,vector&lt;task&gt;,cmp2&gt;qu;int now=0;
    lp(i,1,n){
        if(now+tasks[i].dur&lt;=tasks[i].dle)now+=tasks[i].dur,qu.push(tasks[i]);
        else if(!qu.empty()&amp;&amp;qu.top().dur&gt;tasks[i].dur)now+=-qu.top().dur+tasks[i].dur,qu.pop(),qu.push(tasks[i]);
    }
    pf("%d\n",qu.size());//ps;
    return 0;
}
<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct task{
    int dur,dle;
}tasks[150010];int n;
struct cmp1{bool operator()(task a,task b){return a.dle&lt;b.dle;}};
struct cmp2{bool operator()(task a,task b){return a.dur&lt;b.dur;}};
vector&lt;vector&lt;int&gt;*&gt;tmp;
int main(){
    lp(i,0,10000)tmp.push_back(new vector&lt;int&gt;(100)); 
    lp(i,0,tmp.size()-1)delete tmp[i];
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;tasks[i].dur,&amp;tasks[i].dle);
    sort(tasks+1,tasks+n+1,cmp1());
    priority_queue&lt;task,vector&lt;task&gt;,cmp2&gt;qu;int now=0;
    lp(i,1,n){
        if(now+tasks[i].dur&lt;=tasks[i].dle)now+=tasks[i].dur,qu.push(tasks[i]);
        else if(!qu.empty()&amp;&amp;qu.top().dur&gt;tasks[i].dur)now+=-qu.top().dur+tasks[i].dur,qu.pop(),qu.push(tasks[i]);
    }
    pf("%d\n",qu.size());//ps;
    return 0;
}
<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct task{
    int dur,dle;
}tasks[150010];int n;
struct cmp1{bool operator()(task a,task b){return a.dle&lt;b.dle;}};
struct cmp2{bool operator()(task a,task b){return a.dur&lt;b.dur;}};
vector&lt;vector&lt;int&gt;*&gt;tmp;
int main(){
    lp(i,0,30000)tmp.push_back(new vector&lt;int&gt;(400)); 
    lp(i,0,tmp.size()-1)delete tmp[i];
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;tasks[i].dur,&amp;tasks[i].dle);
    sort(tasks+1,tasks+n+1,cmp1());
    priority_queue&lt;task,vector&lt;task&gt;,cmp2&gt;qu;int now=0;
    lp(i,1,n){
        if(now+tasks[i].dur&lt;=tasks[i].dle)now+=tasks[i].dur,qu.push(tasks[i]);
        else if(!qu.empty()&amp;&amp;qu.top().dur&gt;tasks[i].dur)now+=-qu.top().dur+tasks[i].dur,qu.pop(),qu.push(tasks[i]);
    }
    pf("%d\n",qu.size());//ps;
    return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
char str[500010];int len;
unsigned pw[500010],hs[500010],p=29;
unsigned get(int l,int r){return hs[r]-hs[l-1]*pw[r-l+1];}
bool cmp(int a,int b){
    int d=min(len*2-a,len*2-b);
    if(get(a,a+d)==get(b,b+d))return a&gt;b;
    if(str[a]!=str[b])return str[a]&lt;str[b];
    int l=0,r=d;
    while(l+1&lt;r){
        int m=((l+r)&gt;&gt;1);
        if(get(a,a+m)==get(b,b+m))
            l=m;
        else r=m;
        //pf("[%d,%d]",l,r);
    }
    return str[a+r]&lt;str[b+r];
}
int tmp[500010];
int main(){
    sf("%s",str+1);len=strlen(str+1);
    lp(i,len+1,len+len)str[i]=str[i-len];
    pw[0]=1;lp(i,1,len+len)pw[i]=pw[i-1]*p;
    lp(i,1,len+len)hs[i]=hs[i-1]*p+unsigned(str[i]);
    lp(i,1,len+len)tmp[i]=i;
    //pf("[%d]",cmp(4,1));ps;
    sort(tmp+1,tmp+len+len+1,cmp);
    lp(i,1,len+len){
        if(tmp[i]&lt;=len){
            //pf("[%d]",tmp[i]);
            pf("%c",str[tmp[i]+len-1]);
        }
    }
    pf("\n");
    //ps;
    return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; to[30010];int wei[30010],n;
int dep[30010],siz[30010],pr[30010],len[30010],tp[30010],ch[30010];
int sum[30010],mxx[30010];
void dfs(int x,int p){
    pr[x]=p;dep[x]=dep[p]+1;siz[x]=1;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=p){
            dfs(y,x),siz[x]+=siz[y];
            if(siz[y]&gt;siz[ch[x]])ch[x]=y;
        }
    } 
}
void build(int x,int t){
    if(x==t)mxx[t]=-(~0u&gt;&gt;2);
    tp[x]=t,++len[t];sum[t]+=wei[x];mxx[t]=max(mxx[t],wei[x]);
    if(len[t]&lt;200&amp;&amp;ch[x])build(ch[x],t);
    else ch[x]=0;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=pr[x]&amp;&amp;y!=ch[x])build(y,y);
    }
}
void modify(int x,int w){
    sum[tp[x]]+=-wei[x]+w;wei[x]=w;
    mxx[tp[x]]=-(~0u&gt;&gt;2); 
    for(int y=tp[x];y;y=ch[y])mxx[tp[x]]=max(mxx[tp[x]],wei[y]);
}
int qmax(int x,int y){
    int r=-(~0u&gt;&gt;2);
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r=max(r,mxx[tp[y]]);
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r=max(r,wei[z]);
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r=max(r,wei[z]);
    return r; 
}
int qsum(int x,int y){
    int r=0;
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r+=sum[tp[y]];
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r+=wei[z];
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r+=wei[z];
    return r; 
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);to[v].push_back(u);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
    dfs(1,0);build(1,1);
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[20];int u,v;
        sf("%s",op);sf("%d%d",&amp;u,&amp;v);
        if(op[1]=='H')modify(u,v);
        else if(op[1]=='M')pf("%d\n",qmax(u,v));
        else pf("%d\n",qsum(u,v));
    }//ps;
    return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; to[30010];int wei[30010],n;
int dep[30010],siz[30010],pr[30010],len[30010],tp[30010],ch[30010];
int sum[30010],mxx[30010];
void dfs(int x,int p){
    pr[x]=p;dep[x]=dep[p]+1;siz[x]=1;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=p){
            dfs(y,x),siz[x]+=siz[y];
            if(siz[y]&gt;siz[ch[x]])ch[x]=y;
        }
    } 
}
void build(int x,int t){
    if(x==t)mxx[t]=-(~0u&gt;&gt;2);
    tp[x]=t,++len[t];sum[t]+=wei[x];mxx[t]=max(mxx[t],wei[x]);
    if(len[t]&lt;100&amp;&amp;ch[x])build(ch[x],t);
    else ch[x]=0;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=pr[x]&amp;&amp;y!=ch[x])build(y,y);
    }
}
void modify(int x,int w){
    sum[tp[x]]+=-wei[x]+w;wei[x]=w;
    mxx[tp[x]]=-(~0u&gt;&gt;2); 
    for(int y=tp[x];y;y=ch[y])mxx[tp[x]]=max(mxx[tp[x]],wei[y]);
}
int qmax(int x,int y){
    int r=-(~0u&gt;&gt;2);
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r=max(r,mxx[tp[y]]);
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r=max(r,wei[z]);
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r=max(r,wei[z]);
    return r; 
}
int qsum(int x,int y){
    int r=0;
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r+=sum[tp[y]];
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r+=wei[z];
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r+=wei[z];
    return r; 
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);to[v].push_back(u);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
    dfs(1,0);build(1,1);
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[20];int u,v;
        sf("%s",op);sf("%d%d",&amp;u,&amp;v);
        if(op[1]=='H')modify(u,v);
        else if(op[1]=='M')pf("%d\n",qmax(u,v));
        else pf("%d\n",qsum(u,v));
    }//ps;
    return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; to[30010];int wei[30010],n;
int dep[30010],siz[30010],pr[30010],len[30010],tp[30010],ch[30010];
int sum[30010],mxx[30010];
void dfs(int x,int p){
    pr[x]=p;dep[x]=dep[p]+1;siz[x]=1;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=p){
            dfs(y,x),siz[x]+=siz[y];
            if(siz[y]&gt;siz[ch[x]])ch[x]=y;
        }
    } 
}
void build(int x,int t){
    if(x==t)mxx[t]=-(~0u&gt;&gt;2);
    tp[x]=t,++len[t];sum[t]+=wei[x];mxx[t]=max(mxx[t],wei[x]);
    if(len[t]&lt;200&amp;&amp;ch[x])build(ch[x],t);
    else ch[x]=0;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=pr[x]&amp;&amp;y!=ch[x])build(y,y);
    }
}
void modify(int x,int w){
    sum[tp[x]]+=-wei[x]+w;int t=wei[x];wei[x]=w;
    if(mxx[tp[x]]==t){
        if(w&gt;t)mxx[tp[x]]=w;
        else{
            mxx[tp[x]]=-(~0u&gt;&gt;2); 
            for(int y=tp[x];y;y=ch[y])mxx[tp[x]]=max(mxx[tp[x]],wei[y]);
        }
    }else if(w&gt;mxx[tp[x]])mxx[tp[x]]=w;
}
int qmax(int x,int y){
    int r=-(~0u&gt;&gt;2);
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r=max(r,mxx[tp[y]]);
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r=max(r,wei[z]);
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r=max(r,wei[z]);
    return r; 
}
int qsum(int x,int y){
    int r=0;
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r+=sum[tp[y]];
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r+=wei[z];
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r+=wei[z];
    return r; 
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);to[v].push_back(u);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
    dfs(1,0);build(1,1);
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[20];int u,v;
        sf("%s",op);sf("%d%d",&amp;u,&amp;v);
        if(op[1]=='H')modify(u,v);
        else if(op[1]=='M')pf("%d\n",qmax(u,v));
        else pf("%d\n",qsum(u,v));
    }//ps;
    return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; to[30010];int wei[30010],n;
int dep[30010],siz[30010],pr[30010],len[30010],tp[30010],ch[30010];
int sum[30010],mxx[30010];
void dfs(int x,int p){
    pr[x]=p;dep[x]=dep[p]+1;siz[x]=1;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=p){
            dfs(y,x),siz[x]+=siz[y];
            if(siz[y]&gt;siz[ch[x]])ch[x]=y;
        }
    } 
}
void build(int x,int t){
    if(x==t)mxx[t]=-(~0u&gt;&gt;2);
    tp[x]=t,++len[t];sum[t]+=wei[x];mxx[t]=max(mxx[t],wei[x]);
    if(len[t]&lt;300&amp;&amp;ch[x])build(ch[x],t);
    else ch[x]=0;
    lp(i,0,int(to[x].size()-1)){ 
        int y=to[x][i]; 
        if(y!=pr[x]&amp;&amp;y!=ch[x])build(y,y);
    }
}
void modify(int x,int w){
    sum[tp[x]]+=-wei[x]+w;int t=wei[x];wei[x]=w;
    if(mxx[tp[x]]==t){
        if(w&gt;t)mxx[tp[x]]=w;
        else{
            mxx[tp[x]]=-(~0u&gt;&gt;2); 
            for(int y=tp[x];y;y=ch[y])mxx[tp[x]]=max(mxx[tp[x]],wei[y]);
        }
    }else if(w&gt;mxx[tp[x]])mxx[tp[x]]=w;
}
int qmax(int x,int y){
    int r=-(~0u&gt;&gt;2);
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r=max(r,mxx[tp[y]]);
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r=max(r,wei[z]);
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r=max(r,wei[z]);
    return r; 
}
int qsum(int x,int y){
    int r=0;
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]&gt;dep[tp[y]])swap(x,y);
        if(ch[y]==0)r+=sum[tp[y]];
        else for(int z=y;z!=pr[tp[y]];z=pr[z])r+=wei[z];
        y=pr[tp[y]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    for(int z=x;z!=ch[y];z=ch[z])r+=wei[z];
    return r; 
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);to[v].push_back(u);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
    dfs(1,0);build(1,1);
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[20];int u,v;
        sf("%s",op);sf("%d%d",&amp;u,&amp;v);
        if(op[1]=='H')modify(u,v);
        else if(op[1]=='M')pf("%d\n",qmax(u,v));
        else pf("%d\n",qsum(u,v));
    }//ps;
    return 0;
}
<pre><h2>Problem1040</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int w[1000010],h[1000010],v[1000010],n;
vector&lt;int&gt;b[1000010];
long long dp[1000010][2];
int qu1[1000010],qu2[1000010],qu3[1000010],qu3f,qu3b;
void tree(int x){
    qu2[0]=0;
    qu3f=1,qu3b=2;qu3[1]=x;
    while(qu3f!=qu3b){
        int u=qu3[qu3f++];if(qu3f&gt;1000005)qu3f=1;
        qu2[++qu2[0]]=u;
        lp(i,0,int(b[u].size()-1)){
            if(v[b[u][i]])continue;
            qu3[qu3b++]=b[u][i];
            if(qu3b&gt;1000005)qu3b=1;
        }
    }
    for(int i=qu2[0];i;--i){
        int u=qu2[i];
        dp[u][0]=0;dp[u][1]=w[u];
        lp(j,0,int(b[u].size()-1)){
            if(v[b[u][j]])continue;
            dp[u][0]+=max(dp[b[u][j]][0],dp[b[u][j]][1]);
            dp[u][1]+=dp[b[u][j]][0];
        }
    }
    lp(i,1,qu2[0])v[qu2[i]]=1;
} 
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        sf("%d%d",&amp;w[i],&amp;h[i]);
        b[h[i]].push_back(i);
    }
    long long ans=0;
    lp(i,1,n)if(!v[i]){
        int t=i;v[t]=1;
        while(!v[h[t]])v[h[t]]=1,t=h[t];t=h[t];
        for(int j=i;j!=t;j=h[j])v[j]=0;
        qu1[0]=0;qu1[++qu1[0]]=t;
        for(int j=h[t];j!=t;j=h[j])qu1[++qu1[0]]=j;
        lp(j,1,qu1[0])tree(qu1[j]);
        long long f0=0,f1=0,tc=0;
        for(int j=2;j&lt;=qu1[0];++j){
            long long g0=max(f0,f1)+dp[qu1[j]][0],g1=f0+dp[qu1[j]][1];
            f0=g0;f1=g1;
        }
        tc=max(f0,f1)+dp[qu1[1]][0];
        f0=0,f1=0;
        for(int j=1;j&lt;=qu1[0]-1;++j){
            long long g0=max(f0,f1)+dp[qu1[j]][0],g1=f0+dp[qu1[j]][1];
            f0=g0;f1=g1;
        }
        tc=max(tc,max(f0,f1)+dp[qu1[qu1[0]]][0]);
        ans+=tc;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1041</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
ll check(ll n){
    ll r=0;
    for(ll i=1;i*i&lt;n;++i){
        ll j=n-i*i;
        ll k=sqrt(double(j));
        if(k*k&gt;j)--k;
        if(k*k&lt;j)++k;
        if(k*k==j){
            if(gcd(i,k)==1&amp;&amp;(i+k)%2==1){
                ++r;
            }
        }
    }
    return r;
}
int main(){
    ll n,a=0;
    sf("%lld",&amp;n);
    for(ll i=1;i*i&lt;=n;++i){
        if(n%i==0){
            a+=check(n/i);
            if(i*i!=n)a+=check(i);
        }
    }
    pf("%lld\n",a*4+4);
    //ps;
    return 0;
} 
<pre><h2>Problem1041</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
ll check(ll n){
    ll r=0;
    for(ll i=1;i*i&lt;n;++i){
        ll j=n-i*i;
        ll k=sqrt(double(j));
        if(k*k&gt;j)--k;
        if(k*k&lt;j)++k;
        if(k*k==j){
            if(gcd(i,k)==1&amp;&amp;(i+k)%2==1&amp;&amp;i&gt;k){
                ++r;
            }
        }
    }
    return r;
}
int main(){
    ll n,a=0;
    sf("%lld",&amp;n);
    for(ll i=1;i*i&lt;=n;++i){
        if(n%i==0){
            a+=check(n/i);
            if(i*i!=n)a+=check(i);
        }
    }
    pf("%lld\n",a*8+4);
    //ps;
    return 0;
} 
<pre><h2>Problem1045</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;ll a[1000010],b[1000010],s[1000010];
int main(){
	sf("%d",&amp;n);ll tsum=0;
	lp(i,1,n)sf("%lld",a+i),tsum+=a[i];
	lp(i,1,n)b[i]=tsum/n;
	lp(i,2,n)s[i]=s[i-1]+a[i-1]-b[i-1];
	sort(s+1,s+n+1);
	ll t=s[(n+1)/2];
	ll ans=0;
	lp(i,1,n)if(s[i]&gt;t)ans+=s[i]-t;else ans+=t-s[i];
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1047</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;deque&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,a,b;
int val[1010][1010],minx[1010][1010],maxx[1010][1010];
int miny[1010][1010],maxy[1010][1010]; 
int main(){
    sf("%d%d%d",&amp;a,&amp;b,&amp;n);
    lp(i,1,a)lp(j,1,b)sf("%d",&amp;val[i][j]);
    lp(i,1,a){
        deque&lt;int&gt;qu1,qu2;
        lp(j,1,b){
            while(!qu1.empty()&amp;&amp;val[i][qu1.back()]&gt;=val[i][j])
                qu1.pop_back();
            qu1.push_back(j);
            while(qu1.front()&lt;j-n+1)qu1.pop_front();
            minx[i][j]=val[i][qu1.front()];
            while(!qu2.empty()&amp;&amp;val[i][qu2.back()]&lt;=val[i][j])
                qu2.pop_back();
            qu2.push_back(j);
            while(qu2.front()&lt;j-n+1)qu2.pop_front();
            maxx[i][j]=val[i][qu2.front()];
        }
    }
    /*lp(i,1,a){
        lp(j,1,b)pf("[%d,%d]",minx[i][j],maxx[i][j]);
        pf("\n");
    }*/
    lp(j,1,b){
        deque&lt;int&gt;qu1,qu2;
        lp(i,1,a){
            while(!qu1.empty()&amp;&amp;minx[qu1.back()][j]&gt;=minx[i][j])
                 qu1.pop_back();
            qu1.push_back(i);
            while(qu1.front()&lt;i-n+1)qu1.pop_front();
            miny[i][j]=minx[qu1.front()][j];
            while(!qu2.empty()&amp;&amp;maxx[qu2.back()][j]&lt;=maxx[i][j])
                 qu2.pop_back();
            qu2.push_back(i);
            while(qu2.front()&lt;i-n+1)qu2.pop_front();
            maxy[i][j]=maxx[qu2.front()][j];
        } 
    }
    /*lp(i,1,a){
        lp(j,1,b)pf("[%d,%d]",miny[i][j],maxy[i][j]);
        pf("\n");
    }*/
    int ans=~0u&gt;&gt;1;
    lp(i,n,a)
        lp(j,n,b)
            ans=min(ans,maxy[i][j]-miny[i][j]);
    pf("%d\n",ans); 
    //ps;
    return 0;
}
<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;stack&gt;
vector&lt;int&gt;to[10010];int n,m;
namespace tarjan{
	int tim,df[10010],lw[10010],in[10010];stack&lt;int&gt;stk;
	int nw,bel[10010],siz[10010];
	void dfs(int u){
		df[u]=lw[u]=++tim;in[u]=1;stk.push(u);
		vp(i,to[u]){
			int v=to[u][i];
			if(!df[v])dfs(v),lw[u]=min(lw[u],lw[v]);
			else if(in[v])lw[u]=min(lw[u],df[v]);
		}
		if(df[u]==lw[u]){
			++nw;int t;
			do{
				t=stk.top();
				stk.pop();
				bel[t]=nw;
				in[t]=0;
				++siz[nw];
			}while(t!=u);
		}
	}
	void run(){
		dfs(1);
	}
}
int outd[10010];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		to[u].pb(v);
	}
	tarjan::run();
	//pf("[%d]",tarjan::nw);
	lp(u,1,n)vp(i,to[u]){
		int v=to[u][i];
		if(tarjan::bel[u]!=tarjan::bel[v])
			++outd[tarjan::bel[u]];
	}
	int o0=0;
	lp(i,1,tarjan::nw)if(outd[i]==0)++o0;
	if(o0==1){
		lp(i,1,tarjan::nw)if(outd[i]==0)pf("%d\n",tarjan::siz[i]);
	}else pf("0\n");
    return 0;
}<pre><h2>Problem1053</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll pr[9]={2,3,5,7,11,13,17,19,23},n,tcnt,tans;
void dfs(ll lev,ll cnt,ll ans,ll pre){
	if(lev==9){
		if(cnt&gt;tcnt||(cnt==tcnt&amp;&amp;ans&lt;tans))
			tcnt=cnt,tans=ans;
	}else{
		for(ll i=0;i&lt;=pre&amp;&amp;ans&lt;=n;++i){
			dfs(lev+1,cnt*(i+1),ans,i);
			ans*=pr[lev];
		}
	}
}
int main(){
	sf("%lld",&amp;n);
	dfs(0,1,1,~0u&gt;&gt;1);
	pf("%lld\n",tans);
	//ps;
	return 0;
}<pre><h2>Problem1058</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int val[500010*2],nxt[500010*2];
int top[500010];int n,m,nw;
struct node{
    node(int a,int b,int c):
        df(a),x(b),nx(c){}
    int df,x,nx;
};
int mb(int x){return x&gt;0?x:-x;}
bool operator&lt;(node a,node b){
    return a.df&gt;b.df;
}
priority_queue&lt;node&gt;pq;
set&lt;int&gt;st;int mst=~0u&gt;&gt;1;
void ins(int x){
    set&lt;int&gt;::iterator it=st.lower_bound(x);
    if(it!=st.end())mst=min(mst,mb(*it-x));
    if(it!=st.begin()&amp;&amp;st.size()!=0)mst=min(mst,mb(*(--it)-x));
    st.insert(x);
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;val[i]);
        if(i!=n)nxt[i]=i+1;
        top[i]=i;
        ins(val[i]);
    }nw=n;
    lp(i,1,n-1)pq.push(node(mb(val[i]-val[i+1]),i,i+1));
    lp(i,1,m){
        char op[110];sf("%s",op);
        if(op[0]=='I'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            ins(v);
            val[++nw]=v;
            nxt[top[u]]=nw;
            nxt[nw]=(u==n?0:u+1);
            pq.push(node(mb(val[top[u]]-val[nxt[top[u]]]),top[u],nxt[top[u]]));
            if(nxt[nw])pq.push(node(mb(val[nw]-val[u+1]),nw,u+1));
            top[u]=nw;
        }else if(op[4]=='S'){
            pf("%d\n",mst);
        }else{
            while(nxt[pq.top().x]!=pq.top().nx)pq.pop();
            pf("%d\n",pq.top().df);
        }
    }
    //ps;
    return 0;
}
<pre><h2>Problem1059</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int cx,cy,eg[310][310],in[310],lk[310];
int dfs(int x){
    lp(y,1,cy){
        if(eg[x][y]&amp;&amp;!in[y]){
            in[y]=1;
            if(!lk[y]||dfs(lk[y])){
                lk[y]=x;
                return 1;
            }
        }
    }
    return 0;
}
int mch(){
    int r=0;
    lp(i,1,cx){
        lp(j,1,cy)in[j]=0;
        r+=dfs(i);
    }
    return r;
}
int main(){
    int test;sf("%d",&amp;test);
    lp(kase,1,test){
        int n;sf("%d",&amp;n);
        cx=cy=n;
        lp(i,1,cx)lp(j,1,cy)eg[i][j]=0;
        lp(i,1,cy)lk[i]=0;
        lp(i,1,n)lp(j,1,n){
            int t;sf("%d",&amp;t);
            if(t)eg[j][i]=1;
        }
        if(mch()==n)pf("Yes\n");
        else pf("No\n");
    }
    //ps;
    return 0;
}
/*
3
2
0 0
0 0
2
1 0
1 0
4
0 0 0 1
0 1 0 0
0 0 1 0
1 0 0 0
*/
<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace sim{
    double a[10010][1010];int n,m;
    double fbs(double x){return x&gt;0?x:-x;}
    void pivot(int l,int e){
        double t=-a[l][e];a[l][e]=-1;
        vector&lt;int&gt;qu;
        lp(i,0,m)if(fbs(a[l][i]/=t)&gt;1e-8)qu.push_back(i);
        lp(i,0,n){
            if(i!=l&amp;&amp;fbs(a[i][e])&gt;1e-8){
                double t2=a[i][e];a[i][e]=0;
                lp(j,0,int(qu.size()-1))
                    a[i][qu[j]]+=a[l][qu[j]]*t2;
            }
        }
    }
    void solve(){
        while(true){
            int e=-1;
            lp(i,1,m)if(a[0][i]&gt;1e-8){e=i;break;}
            if(e==-1)break;
            int l=-1;double t=1e100;
            lp(i,1,n)if(a[i][e]&lt;-1e-8&amp;&amp;a[i][0]/-a[i][e]&lt;t){
                t=a[i][0]/-a[i][e];
                l=i; 
            } 
            pivot(l,e);
        }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        sim::a[0][i]=t;
    }
    lp(i,1,m){
        int s,t,c;sf("%d%d%d",&amp;s,&amp;t,&amp;c);
        lp(j,s,t)sim::a[i][j]=-1;
        sim::a[i][0]=c;
    }
    sim::n=m;sim::m=n;
    sim::solve();
    pf("%d\n",int(sim::a[0][0]+0.5));
    //ps;
    return 0;
}
<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace sim{
    double a[10010][1010];int n,m;
    double fbs(double x){return x&gt;0?x:-x;}
    void pivot(int l,int e){
        double t=-a[l][e];a[l][e]=-1;
        vector&lt;int&gt;qu;
        lp(i,0,m)if(fbs(a[l][i]/=t)&gt;1e-8)qu.push_back(i);
        lp(i,0,n){
            if(i!=l&amp;&amp;fbs(a[i][e])&gt;1e-8){
                double t2=a[i][e];a[i][e]=0;
                lp(j,0,m)
                    a[i][j]+=a[l][j]*t2;
            }
        }
    }
    void solve(){
        while(true){
            int e=-1;
            lp(i,1,m)if(a[0][i]&gt;1e-8){e=i;break;}
            if(e==-1)break;
            int l=-1;double t=1e100;
            lp(i,1,n)if(a[i][e]&lt;-1e-8&amp;&amp;a[i][0]/-a[i][e]&lt;t){
                t=a[i][0]/-a[i][e];
                l=i; 
            } 
            pivot(l,e);
        }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        sim::a[0][i]=t;
    }
    lp(i,1,m){
        int s,t,c;sf("%d%d%d",&amp;s,&amp;t,&amp;c);
        lp(j,s,t)sim::a[i][j]=-1;
        sim::a[i][0]=c;
    }
    sim::n=m;sim::m=n;
    sim::solve();
    pf("%d\n",int(sim::a[0][0]+0.5));
    //ps;
    return 0;
}
<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace sim{
    double a[10010][1010];int n,m;
    double fbs(double x){return x&gt;0?x:-x;}
    void pivot(int l,int e){
        double t=-a[l][e];a[l][e]=-1;
        vector&lt;int&gt;qu;
        lp(i,0,m)if(fbs(a[l][i]/=t)&gt;1e-8)qu.push_back(i);
        lp(i,0,n){
            if(i!=l){
                double t2=a[i][e];a[i][e]=0;
                lp(j,0,m)
                    a[i][j]+=a[l][j]*t2;
            }
        }
    }
    void solve(){
        while(true){
            int e=-1;
            lp(i,1,m)if(a[0][i]&gt;1e-8){e=i;break;}
            if(e==-1)break;
            int l=-1;double t=1e100;
            lp(i,1,n)if(a[i][e]&lt;-1e-8&amp;&amp;a[i][0]/-a[i][e]&lt;t){
                t=a[i][0]/-a[i][e];
                l=i; 
            } 
            pivot(l,e);
        }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        sim::a[0][i]=t;
    }
    lp(i,1,m){
        int s,t,c;sf("%d%d%d",&amp;s,&amp;t,&amp;c);
        lp(j,s,t)sim::a[i][j]=-1;
        sim::a[i][0]=c;
    }
    sim::n=m;sim::m=n;
    sim::solve();
    pf("%d\n",int(sim::a[0][0]+0.5));
    //ps;
    return 0;
}
<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace sim{
    double a[10010][1010];int n,m;
    double fbs(double x){return x&gt;0?x:-x;}
    void pivot(int l,int e){
        double t=-a[l][e];a[l][e]=-1;
        vector&lt;int&gt;qu;
        lp(i,0,m)if(fbs(a[l][i]/=t)&gt;1e-8)qu.push_back(i);
        lp(i,0,n){
            if(i!=l){
                double t2=a[i][e];a[i][e]=0;
                lp(j,0,int(qu.size()-1))
                    a[i][qu[j]]+=a[l][qu[j]]*t2;
            }
        }
    }
    void solve(){
        while(true){
            int e=-1;
            lp(i,1,m)if(a[0][i]&gt;1e-8){e=i;break;}
            if(e==-1)break;
            int l=-1;double t=1e100;
            lp(i,1,n)if(a[i][e]&lt;-1e-8&amp;&amp;a[i][0]/-a[i][e]&lt;t){
                t=a[i][0]/-a[i][e];
                l=i;
            }
            pivot(l,e);
        }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        sim::a[0][i]=t;
    }
    lp(i,1,m){
        int s,t,c;sf("%d%d%d",&amp;s,&amp;t,&amp;c);
        lp(j,s,t)sim::a[i][j]=-1;
        sim::a[i][0]=c;
    }
    sim::n=m;sim::m=n;
    sim::solve();
    pf("%d\n",int(sim::a[0][0]+0.5));
    //ps;
    return 0;
}
<pre><h2>Problem1070</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c,w;}edges[200010];int nw=1;
vector&lt;int&gt;to[1010];int vcnt;
void add(int u,int v,int c,int w){
    edge&amp;e=edges[++nw];
    e.v=v,e.c=c,e.w=w;
    to[u].push_back(nw);
}
int tim[110][11],n,m;
int dis[1010],in[1010],cst;
int spfa(){
    dis[1]=0;lp(i,2,vcnt)dis[i]=~0u&gt;&gt;2;
    in[1]=1;lp(i,2,vcnt)in[i]=0;
    queue&lt;int&gt;qu;qu.push(1);
    while(!qu.empty()){
        int u=qu.front();qu.pop();in[u]=0;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=edges[to[u][i]];
            if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                dis[e.v]=dis[u]+e.w;
                if(!in[e.v]){
                    in[e.v]=1;
                    qu.push(e.v);
                }
            }
        }
    }
    return dis[vcnt]!=~0u&gt;&gt;2;
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    in[u]=1;
    int g=f;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=edges[to[u][i]];
        if(e.c&amp;&amp;!in[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t,edges[to[u][i]^1].c+=t,g-=t;
            cst+=t*e.w;
            if(!g)return f;
        }
    }
    return f-g;
}
void mcmf(){
    while(spfa()){do{lp(i,1,vcnt)in[i]=0;}while(dfs(1,~0u&gt;&gt;2));}
}
int main(){
    sf("%d%d",&amp;m,&amp;n);
    lp(i,1,n)lp(j,1,m)sf("%d",&amp;tim[i][j]);
    lp(i,1,n)lp(j,1,m)lp(k,1,n)
        add(i+1,n+1+(j-1)*n+k,1,k*tim[i][j]),
        add(n+1+(j-1)*n+k,i+1,0,-k*tim[i][j]);
    lp(i,1,n)add(1,i+1,1,0),add(i+1,1,0,0);
    lp(i,1,m)lp(j,1,n)add(n+1+(i-1)*n+j,n*m+n+2,1,0),add(n*m+n+2,n+1+(i-1)*n+j,0,0);
    vcnt=n*m+n+2;
    mcmf();
    pf("%.2lf\n",double(cst)/n);
    //ps;
    return 0;
}<pre><h2>Problem1078</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,ch[110][2],pr[110],rt=1;
int main(){
	//fr("heap.in","r",stdin);
	//fr("heap.out","w",stdout);
	sf("%d",&amp;n);
	lp(i,2,n+1){
		int d;sf("%d",&amp;d);
		if(d&lt;100){
			pr[i]=d+1;
			ch[d+1][0]=i;
		}else{
			pr[i]=d-100+1;
			ch[d-100+1][1]=i;
		}
	}
	vector&lt;int&gt;ans;
	lp(i,1,n+1){
		int u=rt;while(ch[u][1])u=ch[u][0];
		if(ch[u][0]&amp;&amp;!ch[ch[u][0]][0])u=ch[u][0];
		ans.pb(u);
		pr[ch[u][0]]=pr[u];if(pr[u]==0)rt=ch[u][0];
		ch[pr[u]][0]=ch[u][0];
		for(int j=pr[u];j;j=pr[j])swap(ch[j][0],ch[j][1]);
	}
	wp(i,ans)pf("%d ",ans[i]-1);
	return 0;
}<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll dp[11][410][1010],n,m;
bool check(int s1,int s2){
	vector&lt;int&gt;t1,t2;
	lp(i,0,n-1)t1.pb((s1&gt;&gt;i)&amp;1);
	lp(i,0,n-1)t2.pb((s2&gt;&gt;i)&amp;1);
	lp(i,0,n-1)if(t1[i]==1&amp;&amp;t2[i]==1)return false;
	lp(i,1,n-1)if(t1[i]+t2[i-1]==2)return false;
	lp(i,1,n-1)if(t2[i]+t1[i-1]==2)return false;
	return true;
}
vector&lt;int&gt;state;
bool check(int s1){
	vector&lt;int&gt;t1;
	lp(i,0,n-1)t1.pb((s1&gt;&gt;i)&amp;1);
	for(int i=1;i&lt;t1.size();++i)
		if(t1[i-1]+t1[i]==2)return false;
	return true;
}
int count(int x){
	int ret=0;
	lp(i,0,n-1)if((x&gt;&gt;i)&amp;1)++ret;
	return ret;
}
int main(){
	dp[0][0][0]=1;
	sf("%lld%lld",&amp;n,&amp;m);
	lp(i,0,(1&lt;&lt;n)-1)if(check(i))state.pb(i);
	lp(i,0,n-1)lp(j,0,m)vp(k,state)vp(l,state)
		if(check(state[k],state[l]))dp[i+1][j+count(state[l])][state[l]]+=dp[i][j][state[k]];
	ll ans=0;
	lp(s1,0,(1&lt;&lt;n)-1)ans+=dp[n][m][s1];
	pf("%lld\n",ans);
	return 0;
}
<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll dp[11][410][1010],n,m;
bool check(int s1,int s2){
	vector&lt;int&gt;t1,t2;
	lp(i,0,n-1)t1.pb((s1&gt;&gt;i)&amp;1);
	lp(i,0,n-1)t2.pb((s2&gt;&gt;i)&amp;1);
	lp(i,0,n-1)if(t1[i]==1&amp;&amp;t2[i]==1)return false;
	lp(i,1,n-1)if(t1[i]+t2[i-1]==2)return false;
	lp(i,1,n-1)if(t2[i]+t1[i-1]==2)return false;
	return true;
}
vector&lt;int&gt;state;
bool check(int s1){
	vector&lt;int&gt;t1;
	lp(i,0,n-1)t1.pb((s1&gt;&gt;i)&amp;1);
	for(int i=1;i&lt;t1.size();++i)
		if(t1[i-1]+t1[i]==2)return false;
	return true;
}
int count(int x){
	int ret=0;
	lp(i,0,n-1)if((x&gt;&gt;i)&amp;1)++ret;
	return ret;
}
bool checktable[1010][1010];
int counttable[1010];
int main(){
	dp[0][0][0]=1;
	sf("%lld%lld",&amp;n,&amp;m);
	lp(i,0,(1&lt;&lt;n)-1)if(check(i))state.pb(i);
	vp(i,state)vp(j,state)checktable[i][j]=check(state[i],state[j]);
	vp(i,state)counttable[i]=count(state[i]);
	lp(i,0,n-1)lp(j,0,m)vp(k,state)vp(l,state)
		if(checktable[k][l])dp[i+1][j+counttable[l]][state[l]]+=dp[i][j][state[k]];
	ll ans=0;
	lp(s1,0,(1&lt;&lt;n)-1)ans+=dp[n][m][s1];
	pf("%lld\n",ans);
	return 0;
}
<pre><h2>Problem1089</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
 bigint()
 bigint(long long)
 bigint(bigint)
 bigint(char*)
 bigint(string)
 +, +=, ++
 -, -=, --
 *, *=
 /, /=
 &lt;&lt;, &lt;&lt;=
 ==, !=
 &lt;, &lt;=
 &gt;, &gt;=
 -
 !
 abs(bigint), bigint.abs()
 pow(bigint, unsigned), bigint.pow(unsigned)
 root(bigint, unsigned), bigint.root(unsigned)
 sqrt(bigint), bigint.sqrt()
 bigint.read(default = stdin)
 bigint.write(default = stdout)
 istream&gt;&gt;bigint
 ostream&lt;&lt;bigint
 enoughMemory() : optimize division and modulo
*/
#include &lt;iostream&gt;
  
#ifndef BIGINT
#define BIGINT 1
  
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;
  
static const unsigned base = 10000, length = 4;
static bool __enoughMemory = false;
  
typedef vector&lt;int&gt; vi;
typedef vector&lt;int&gt;::iterator viit;
typedef vector&lt;int&gt;::const_iterator vicit;
typedef vector&lt;int&gt;::reverse_iterator virit;
typedef vector&lt;int&gt;::const_reverse_iterator vicrit;
typedef complex&lt;double&gt; comp;
typedef vector&lt;comp&gt; vc;
typedef vector&lt;comp&gt;::iterator vcit;
  
class Bigint {
public :
    Bigint();
    template&lt;typename _Tp&gt; Bigint(_Tp);
    Bigint(const Bigint&amp;);
    Bigint(const char*);
    Bigint(const string&amp;);
      
    bool&amp; neg();
    const bool&amp; neg() const;
    vi&amp; num();
    const vi&amp; num() const;
      
    bool operator==(const Bigint&amp;) const;
    bool operator!=(const Bigint&amp;) const;
    bool operator&lt;(const Bigint&amp;) const;
    bool operator&lt;=(const Bigint&amp;) const;
    bool operator&gt;(const Bigint&amp;) const;
    bool operator&gt;=(const Bigint&amp;) const;
      
    Bigint&amp; operator+=(const Bigint&amp;);
    Bigint&amp; operator-=(const Bigint&amp;);
    Bigint&amp; operator*=(const Bigint&amp;);
    Bigint&amp; operator/=(const Bigint&amp;);
    Bigint&amp; operator%=(const Bigint&amp;);
    Bigint&amp; operator&lt;&lt;=(const unsigned&amp;);
    Bigint&amp; operator&gt;&gt;=(const unsigned&amp;);
      
    Bigint&amp; operator++();
    Bigint&amp; operator--();
    Bigint operator-() const;
    bool operator!() const;
      
    int compare(const Bigint&amp;) const;
    bool equal(const Bigint&amp;) const;
    bool less(const Bigint&amp;) const;
    bool lessOrEqual(const Bigint&amp;) const;
    bool greater(const Bigint&amp;) const;
    bool greaterOrEqual(const Bigint&amp;) const;
      
    Bigint&amp; abs();
    Bigint&amp; pow(unsigned);
    Bigint&amp; root(const unsigned&amp;);
    Bigint&amp; sqrt();
    void multiply10(const unsigned&amp;);
    void divide2();
      
    void add(const Bigint&amp;);
    void subtract(const Bigint&amp;);
    void multiply(const Bigint&amp;);
    void multiplySlow(const Bigint&amp;);
    void multiplyFast(const Bigint&amp;, const int&amp;, const int&amp;);
    pair&lt;vi, vi&gt; divide(const Bigint&amp;);
      
    Bigint&amp; read(FILE*);
    const Bigint&amp; write(FILE*) const;
      
private :
    bool _m_neg;
    vi _m_num;
      
    void adjust();
    comp exp(const double&amp;);
    void bitrev(const vcit&amp;, const int&amp;, const int&amp;, const int&amp;, const int&amp;);
    void fft(vc&amp;, const int&amp;, const int&amp;, const bool&amp;);
      
    void divideByZero();
    void imaginaryNumberUnsupported();
    void error(const string&amp;);
};
  
//pre-declaration
Bigint abs(const Bigint&amp;);
Bigint pow(const Bigint&amp;, const unsigned&amp;);
Bigint root(const Bigint&amp;, const unsigned&amp;);
Bigint sqrt(const Bigint&amp;);
istream&amp; operator&gt;&gt;(istream&amp;, Bigint&amp;);
ostream&amp; operator&lt;&lt;(ostream&amp;, const Bigint&amp;);
void enoughMemory();
  
//operator
inline Bigint operator+(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) += __y;
}
inline Bigint operator-(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) -= __y;
}
inline Bigint operator*(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) *= __y;
}
inline Bigint operator/(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) /= __y;
}
inline Bigint operator%(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) %= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&lt;&lt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &lt;&lt;= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&gt;&gt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &gt;&gt;= __y;
}
  
//public
  
//constructor
inline Bigint::Bigint() {
    neg() = false;
    num().clear();
    num().push_back(0);
}
template&lt;typename _Tp&gt; inline Bigint::Bigint(_Tp __t) {
    if (__t &lt; 0) neg() = true, __t = -__t;
    else neg() = false;
    num().clear();
    while (__t &gt;= base) {
        num().push_back(__t % base);
        __t /= base;
    }
    num().push_back(__t);
}
inline Bigint::Bigint(const Bigint&amp; __t) {
    *this = __t;
}
inline Bigint::Bigint(const char* __c) {
    while (*__c) {
        if (*__c == '-' || *__c == '+' || '0' &lt;= *__c &amp;&amp; *__c &lt;= '9')
            break;
        ++__c;
    }
    if (*__c == '-') ++__c, neg() = true;
    else {
        neg() = false;
        if (*__c == '+') ++__c;
    }
    int __n = strlen(__c);
    num().clear();
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    const char* __t = __c + __n;
    while (__c + 1 != __t &amp;&amp; *__c == '0') ++__c;
    int __x = 0, __y = 1, __z = 0;
    while (__t-- != __c) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*__t - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
inline Bigint::Bigint(const string&amp; __s) {
    string::const_iterator i = __s.begin();
    string::const_iterator j = __s.end();
    while (i != j) {
        if (*i == '-' || *i == '+' || '0' &lt;= *i &amp;&amp; *i &lt;= '9')
            break;
        ++i;
    }
    if (i != j) {
        if (*i == '-') ++i, neg() = true;
        else {
            neg() = false;
            if (*i == '+') ++i;
        }
    }
    int __n = j - i;
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    while (i + 1 != j &amp;&amp; *i == '0') ++i;
    int __x = 0, __y = 1, __z = 0;
    while (j-- != i) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*j - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
  
inline bool&amp; Bigint::neg() {
    return _m_neg;
}
inline const bool&amp; Bigint::neg() const {
    return _m_neg;
}
inline vi&amp; Bigint::num() {
    return _m_num;
}
inline const vi&amp; Bigint::num() const {
    return _m_num;
}
  
//logical operator
inline bool Bigint::operator==(const Bigint&amp; __t) const {
    return neg() == __t.neg() &amp;&amp; equal(__t);
}
inline bool Bigint::operator!=(const Bigint&amp; __t) const {
    return neg() != __t.neg() || !equal(__t);
}
inline bool Bigint::operator&lt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greater(__t);
    return less(__t);
}
inline bool Bigint::operator&lt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greaterOrEqual(__t);
    return lessOrEqual(__t);
}
inline bool Bigint::operator&gt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return less(__t);
    return greater(__t);
}
inline bool Bigint::operator&gt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return lessOrEqual(__t);
    return greaterOrEqual(__t);
}
  
//arithmetic operators
inline Bigint&amp; Bigint::operator+=(const Bigint&amp; __t) {
    if (neg() == __t.neg()) add(__t);
    else {
        int __x = compare(__t);
        if (__x == 0) *this = Bigint();
        else if (__x == -1) {
            Bigint __y = *this;
            *this = __t;
            subtract(__y);
        }
        else subtract(__t);
    }
    return *this;
}
inline Bigint&amp; Bigint::operator-=(const Bigint&amp; __t) {
    return *this += (-__t);
}
inline Bigint&amp; Bigint::operator*=(const Bigint&amp; __t) {
    if (*this != 0 &amp;&amp; __t != 0) {
        neg() = neg() != __t.neg();
        multiply(__t);
    }
    else *this = Bigint();
    return *this;
}
inline Bigint&amp; Bigint::operator/=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    if (less(__t)) *this = Bigint();
    else {
        neg() = neg() != __t.neg();
        num() = divide(__t).first;
        adjust();
    }
    return *this;
}
inline Bigint&amp; Bigint::operator%=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    num() = divide(__t).second;
    adjust();
    if (num().size() == 1 &amp;&amp; !*num().rbegin()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::operator&lt;&lt;=(const unsigned&amp; __y) {
    return *this *= Bigint(2).pow(__y);
}
inline Bigint&amp; Bigint::operator&gt;&gt;=(const unsigned&amp; __y) {
    for (unsigned i = 0 ; i &lt; __y ; ++i) divide2();
    return *this;
}
  
//self operator
inline Bigint&amp; Bigint::operator++() {
    return *this += 1;
}
inline Bigint&amp; Bigint::operator--() {
    return *this -= 1;
}
inline Bigint Bigint::operator-() const {
    Bigint __t = *this;
    if (__t != 0) __t.neg() ^= true;
    return __t;
}
inline bool Bigint::operator!() const {
    return *this == 0;
}
  
//comparator
inline int Bigint::compare(const Bigint&amp; __t) const {
    if (num().size() &lt; __t.num().size()) return -1;
    else if (num().size() &gt; __t.num().size()) return 1;
    vicrit i = num().rbegin();
    vicrit j = __t.num().rbegin();
    while (i != num().rend()) {
        if (*i &lt; *j) return -1;
        else if (*i &gt; *j) return 1;
        ++i, ++j;
    }
    return 0;
}
inline bool Bigint::equal(const Bigint&amp; __t) const {
    return compare(__t) == 0;
}
inline bool Bigint::less(const Bigint&amp; __t) const {
    return compare(__t) == -1;
}
inline bool Bigint::lessOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == -1 || __r == 0;
}
inline bool Bigint::greater(const Bigint&amp; __t) const {
    return compare(__t) == 1;
}
inline bool Bigint::greaterOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == 1 || __r == 0;
}
  
//math
inline Bigint&amp; Bigint::abs() {
    if (neg()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::pow(unsigned __y) {
    Bigint __x = *this;
    *this = 1;
    while (__y) {
        if (__y &amp; 1) *this *= __x;
        __x *= __x;
        __y &gt;&gt;= 1;
    }
    return *this;
}
inline Bigint&amp; Bigint::root(const unsigned&amp; __y = 2) {
    if (!__y) divideByZero();
    if (*this == 0 || __y == 1) return *this;
    bool __n = neg();
    if (__n)
        if (__y &amp; 1) neg() = false;
        else imaginaryNumberUnsupported();
    const double log2_10 = 3.3219280948873623478703194294893901758648313930245806;
    size_t __s = num().size();
    if (double(__s &lt;&lt; 2) * log2_10 &lt; __y) return *this = 1;
    __s = __s / __y + (__s % __y ? 1 : 0);
    int __l, __r, __m;
    Bigint __a = *this, __b, __c;
    num().clear();
    for (int i = __s - 1 ; i &gt;= 0 ; --i) {
        __l = 1, __r = base - 1;
        while (__l &lt;= __r) {
            __m = __l + __r &gt;&gt; 1;
            __b = *this;
            __b.num().insert(__b.num().begin(), __m);
            __b.pow(__y);
            __b.multiply10(i * __y &lt;&lt; 2);
            if (__b &lt;= __a) __l = __m + 1;
            else __r = __m - 1;
        }
        num().insert(num().begin(), __r);
    }
    neg() = __n;
    return *this;
}
inline Bigint&amp; Bigint::sqrt() {
    root();
    return *this;
}
inline void Bigint::multiply10(const unsigned&amp; __t) {
    if (!__t) return ;
    size_t __s = num().size();
    size_t __r = (__t &gt;&gt; 2) + (__t &amp; 3 ? 1 : 0);
    int __x = 0, __y, __z, __a, __b;
    if ((__t &amp; 3) == 0) __a = 1, __b = 10000;
    else if ((__t &amp; 3) == 1) __a = 1000, __b = 10;
    else if ((__t &amp; 3) == 2) __a = 100, __b = 100;
    else if ((__t &amp; 3) == 3) __a = 10, __b = 1000;
    num().resize(__s + __r);
    virit i = num().rbegin();
    virit j = i + __r;
    while (i != num().rbegin() + __s) {
        __y = *j++;
        __z = __y / __a;
        __x += __z;
        *i++ = __x;
        __x = (__y - __z * __a) * __b;
    }
    *i++ = __x;
    fill(i, num().rend(), 0);
    adjust();
}
inline void Bigint::divide2() {
    int __t = 0;
    for (virit i = num().rbegin() ; i != num().rend() ; ++i) {
        __t = (__t &amp; 1 ? base : 0) + *i;
        *i = __t &gt;&gt; 1;
    }
    adjust();
}
  
//+, -, *, /
inline void Bigint::add(const Bigint&amp; __t) {
    if (num().size() &lt; __t.num().size())
        num().resize(__t.num().size());
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (i != num().end() &amp;&amp; j != __t.num().end())
        *i++ += *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &gt;= base) {
            *i -= base;
            ++*(i + 1);
        }
    if (*i &gt;= base) {
        *i -= base;
        num().push_back(1);
    }
}
inline void Bigint::subtract(const Bigint&amp; __t) {
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (j != __t.num().end())
        *i++ -= *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &lt; 0) {
            *i += base;
            --*(i + 1);
        }
    adjust();
}
inline void Bigint::multiply(const Bigint&amp; __t) {
    int __n = max(num().size(), __t.num().size());
    int __l = 0;
    while ((1 &lt;&lt; __l) &lt; __n) ++__l;
    __n = 1 &lt;&lt; ++__l;
    if ((long long)num().size() * __t.num().size() &lt;= (long long)__n * __l * 20)
        multiplySlow(__t);
    else
        multiplyFast(__t, __n, __l);
    adjust();
}
inline void Bigint::multiplySlow(const Bigint&amp; __t) {
    int __n = num().size() + __t.num().size(), i, j, k;
    vi __x, __y;
    if (__t.num().size() * 4 &lt; num().size())
        __x = __t.num(), __y = num();
    else
        __x = num(), __y = __t.num();
    num().clear();
    num().resize(__n);
    for (i = 0 ; i &lt; __x.size() ; ++i) {
        k = __x[i];
        for (j = 0 ; j &lt; __y.size() ; ++j)
            num()[i + j] += k * __y[j];
        k = i + 1 + __y.size();
        for (j = 0 ; j &lt; k ; ++j) {
            num()[j + 1] += num()[j] / base;
            num()[j] %= base;
        }
    }
}
inline void Bigint::multiplyFast(const Bigint&amp; __t, const int&amp; __n, const int&amp; __l) {
    vc a, b;
    a.reserve(__n);
    b.reserve(__n);
    for (viit i = num().begin() ; i != num().end() ; ++i)
        a.push_back(comp(*i, 0));
    for (vicit i = __t.num().begin() ; i != __t.num().end() ; ++i)
        b.push_back(comp(*i, 0));
    a.resize(__n);
    b.resize(__n);
    fft(a, __l, __n, true);
    fft(b, __l, __n, true);
    vcit i = a.begin(), j = b.begin();
    while (i != a.end()) *i++ *= *j++;
    fft(a, __l, __n, false);
    long long __x = 0;
    num().resize(__n);
    i = a.begin();
    viit k = num().begin();
    while (i != a.end()) {
        __x = (long long)(i++ -&gt;real() / __n + 0.5) + __x / base;
        *k++ = __x % base;
    }
}
inline pair&lt;vi, vi&gt; Bigint::divide(const Bigint&amp; __t) {
    int __l, __r, __m, __n = num().size() - __t.num().size() + 1;
    Bigint __x = *this, __y = __t, __z;
    vi __v;
    __v.resize(__n);
    if (__enoughMemory) {
        Bigint __p[10];
        for (__m = 0 ; __m &lt; 10 ; ++__m) __p[__m] = __m * __y;
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            int k = 0;
            for (int j = 3 + (i &lt;&lt; 2) ; j &gt;= (i &lt;&lt; 2) ; --j) {
                __l = 1, __r = 9;
                while (__l &lt;= __r) {
                    __m = __l + __r &gt;&gt; 1;
                    __z = __p[__m];
                    __z.multiply10(j);
                    if (__z.greater(__x)) __r = __m - 1;
                    else __l = __m + 1;
                }
                k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + __r;
                __z = __p[__r];
                __z.multiply10(j);
                __x.subtract(__z);
            }
            __v[i] = k;
        }
    }
    else {
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            __l = 1, __r = base - 1;
            while (__l &lt;= __r) {
                __m = __l + __r &gt;&gt; 1;
                __z = __m * __y;
                __z.multiply10(i &lt;&lt; 2);
                if (__z.greater(__x)) __r = __m - 1;
                else __l = __m + 1;
            }
            __v[i] = __r;
            __z = __r * __y;
            __z.multiply10(i &lt;&lt; 2);
            __x.subtract(__z);
        }
    }
    return make_pair(__v, __x.num());
}
  
//io
inline Bigint&amp; Bigint::read(FILE *in = stdin) {
    string __s = "";
    char __c = fgetc(in);
    while (true) {
        if (__c == '-' || __c == '+' || '0' &lt;= __c &amp;&amp; __c &lt;= '9' || __c == EOF)
            break;
        __c = fgetc(in);
    }
    while (true) {
        __s += __c;
        __c = fgetc(in);
        if (__c &lt; '0' || __c &gt; '9') break;
    }
    return *this = Bigint(__s.c_str());
}
inline const Bigint&amp; Bigint::write(FILE *out = stdout) const {
    vicrit i = num().rbegin();
    if (neg()) fprintf(out, "-");
    fprintf(out, "%d", *i++);
    while (i != num().rend()) fprintf(out, "%04d", *i++);
    return *this;
}
  
//private
  
//other
inline void Bigint::adjust() {
    virit i = num().rbegin();
    while (i + 1 != num().rend()) {
        if (*i) break;
        ++i;
    }
    num().erase(i.base(), num().end());
}
inline comp Bigint::exp(const double&amp; u) {
    return comp(cos(u), sin(u));
}
inline void Bigint::bitrev(const vcit&amp; i, const int&amp; __l, const int&amp; __p, const int&amp; __x, const int&amp; __y) {
    if (__p == 0) {
        if (__x &lt; __y) swap(*(i + __x), *(i + __y));
        return ;
    }
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1, __y);
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1 | 1, __y | (1 &lt;&lt; __l - __p));
}
inline void Bigint::fft(vc&amp; __a, const int&amp; __l, const int&amp; __n, const bool&amp; __r) {
    const double __p = 3.141592653589793238462643383279;
    bitrev(__a.begin(), __l, __l, 0, 0);
    for (int i = 1 ; i &lt;= __l ; ++i) {
        int __m = 1 &lt;&lt; i;
        comp wm = exp((__r ? -2 : 2) * __p / __m);
        for (int k = 0 ; k &lt; __n ; k += __m) {
            comp w = 1;
            for (int j = 0 ; j &lt; __m / 2 ; ++j) {
                comp t = w * __a[k + j + __m / 2];
                comp u = __a[k + j];
                __a[k + j] = u + t;
                __a[k + j + __m / 2] = u - t;
                w *= wm;
            }
        }
    }
}
  
//error
inline void Bigint::divideByZero() {
    error("divide by zero");
}
inline void Bigint::imaginaryNumberUnsupported() {
    error("imaginary number unsupported");
}
inline void Bigint::error(const string&amp; __s) {
    fprintf(stderr, "%s\n", __s.c_str());
    cerr &lt;&lt; __s &lt;&lt; endl;
    abort();
}
  
//math
inline Bigint abs(const Bigint&amp; __x) {
    return Bigint(__x).abs();
}
inline Bigint pow(const Bigint&amp; __x, const unsigned&amp; __y) {
    return Bigint(__x).pow(__y);
}
inline Bigint root(const Bigint&amp; __x, const unsigned&amp; __y = 2) {
    return Bigint(__x).root(__y);
}
inline Bigint sqrt(const Bigint&amp; __x) {
    return Bigint(__x).sqrt();
}
  
//io
inline istream&amp; operator&gt;&gt;(istream&amp; __s, Bigint&amp; __t) {
    string __r;
    __s &gt;&gt; __r;
    __t = Bigint(__r);
    return __s;
}
inline ostream&amp; operator&lt;&lt;(ostream&amp; __s, const Bigint&amp; __t) {
    if (__t.neg()) __s &lt;&lt; '-';
    vicrit i = __t.num().rbegin();
    __s &lt;&lt; *i;
    while (++i != __t.num().rend()) {
        __s.width(length);
        __s.fill('0');
        __s &lt;&lt; *i;
    }
    return __s;
}
//optimization
inline void enoughMemory() {
    __enoughMemory = true;
}

#endif
Bigint f[21];
int main(){
	int n,d;sf("%d%d",&amp;n,&amp;d);
	f[0]=1;
	lp(i,1,d)f[i]=pow(f[i-1],n)+1;
	cout&lt;&lt;f[d]-(d==0?0:f[d-1])&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1093</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;set&gt;
int n,m,p;vector&lt;int&gt;to[100010];
vector&lt;int&gt;bg[100010];
int cnt[100010];
namespace tarjan{
	int ti,df[100010],lw[100010],bl[100010],in[100010],nw;
	vector&lt;int&gt;stk;
	void dfs(int u){
		df[u]=lw[u]=++ti;
		stk.pb(u);in[u]=1;
		vp(i,to[u]){
			int v=to[u][i];
			if(!df[v])dfs(v),lw[u]=min(lw[u],lw[v]);
			else if(in[v])lw[u]=min(lw[u],df[v]);
		}
		if(df[u]==lw[u]){
			++nw;int t;
			do{
				t=stk.back();stk.pop_back();
				in[t]=0;
				bl[t]=nw;
				++cnt[nw];
			}while(t!=u);
		}
	}
	void solve(){
		lp(i,1,n)if(!df[i])dfs(i);
		set&lt;pair&lt;int,int&gt; &gt;eg;
		lp(i,1,n)vp(j,to[i])if(bl[i]!=bl[to[i][j]])eg.insert(mp(bl[i],bl[to[i][j]]));
		for(set&lt;pair&lt;int,int&gt; &gt;::iterator it=eg.begin();it!=eg.end();++it){
			bg[it-&gt;first].pb(it-&gt;second);
		}
		n=nw;
		//lp(i,1,n)vp(j,bg[i])pf("[%d-&gt;%d]\n",i,bg[i][j]);
		//lp(i,1,n)pf("[%d]",cnt[i]);pf("\n");
	}
}
int f[100010],g[100010],vis[100010];
void dp(int u){
	if(vis[u])return;
	vis[u]=1;
	if(bg[u].size()==0){f[u]=cnt[u],g[u]=1;return;}
	vp(i,bg[u]){
		int v=bg[u][i];
		dp(v);
		f[u]=max(f[u],f[v]);
	}
	vp(i,bg[u]){
		int v=bg[u][i];
		if(f[v]==f[u])g[u]=(g[v]+g[u])%p;
	}
	f[u]+=cnt[u];
}
int main(){
	sf("%d%d%d",&amp;n,&amp;m,&amp;p);
	lp(i,1,m){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		to[u].pb(v);
	}
	tarjan::solve();
	lp(i,1,n)bg[0].pb(i);
	dp(0);
	pf("%d\n%d\n",f[0],g[0]);
	return 0;
}<pre><h2>Problem1096</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;deque&gt;
int n;ll T[1000010],C[1000010],S[1000010],D[1000010];
ll X[1000010],Y[1000010],F[1000010];
double slope(int u,int v){
	if(X[u]==X[v])return Y[u]&gt;Y[v]?-1e100:1e100;
	return double(Y[u]-Y[v])/(X[u]-X[v]);
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%lld%lld%lld",&amp;D[i],&amp;S[i],&amp;C[i]);
	rp(i,n,2)D[i]-=D[i-1];
	lp(i,1,n)D[i]=D[i+1];
	rp(i,n-1,0){
		D[i]+=D[i+1];
		T[i]=T[i+1]+S[i]*D[i];
		S[i]+=S[i+1];
	}
	deque&lt;int&gt;qu;qu.push_back(n);F[n]=Y[n]=C[n];
	rp(i,n-1,0){
		while(qu.size()&gt;1){
			int u=qu[0],v=qu[1];
			if(slope(u,v)&lt;S[i+1]+1e-8)qu.pop_front();
			else break;
		}
		F[i]=F[qu[0]]+T[i+1]-T[qu[0]]-(S[i+1]-S[qu[0]])*D[qu[0]]+C[i];
		X[i]=D[i];Y[i]=F[i]-T[i]+D[i]*S[i];
		while(qu.size()&gt;1){
			int u=qu[qu.size()-2],v=qu[qu.size()-1];
			if(slope(u,v)&gt;slope(v,i)-1e-8)qu.pop_back();
			else break;
		}
		qu.push_back(i);
	}
	pf("%lld\n",F[0]);
	return 0;
}<pre><h2>Problem1101</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll sum[50010],mui[50010],pri[50010],isp[50010];
ll solve(ll a,ll b){
    ll r=0;
    for(ll i=1;i&lt;=min(a,b);++i){
        ll t1=(a/i),t2=(b/i);
        ll j=min(a/t1,b/t2);
        r+=(sum[j]-sum[i-1])*t1*t2;
        i=j;
    }
    return r;
}
int main(){
    mui[1]=1;
    lp(i,2,50005){
        if(!isp[i]){
            pri[++pri[0]]=i;
            mui[i]=-1;
        }
        for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=50005;++j){
            if(i%pri[j]==0){
                isp[i*pri[j]]=1;
                mui[i*pri[j]]=0;
            }else{
                isp[i*pri[j]]=1;
                mui[i*pri[j]]=-mui[i];
            }
        }
    }
    lp(i,1,50005)sum[i]=sum[i-1]+mui[i];
    int n;sf("%d",&amp;n);
    lp(i,1,n){
        ll a,b,d;
        sf("%lld%lld%lld",&amp;a,&amp;b,&amp;d);
        pf("%lld\n",solve(a/d,b/d));
    }
    //ps;
    return 0;
}
<pre><h2>Problem1112</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace seg{
    int cnt[1000010*4];
    ll sum[1000010*4];
    void add(int x,int l,int r,int p,int d){
        cnt[x]+=d;
        sum[x]+=d*p;
        if(l==r)return;
        int m=(l+r)/2;
        if(p&lt;=m)add(x*2,l,m,p,d);
        else add(x*2+1,m+1,r,p,d);
    }
    int ask(int x,int l,int r,int k){
        if(l==r)return l;
        int m=(l+r)/2;
        if(cnt[x*2]&gt;=k)return ask(x*2,l,m,k);
        else return ask(x*2+1,m+1,r,k-cnt[x*2]);
    }
    ll gsum(int x,int l,int r,int k){
        if(l==r)return sum[x];
        int m=(l+r)/2;
        if(cnt[x*2]&gt;=k)return gsum(x*2,l,m,k);
        else return sum[x*2]+gsum(x*2+1,m+1,r,k-cnt[x*2]);
    }
    int gcnt(int x,int l,int r,int k){
        if(l==r)return cnt[x];
        int m=(l+r)/2;
        if(cnt[x*2]&gt;=k)return gcnt(x*2,l,m,k);
        else return cnt[x*2]+gcnt(x*2+1,m+1,r,k-cnt[x*2]);
    }
}
int n,k,a[100010];
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,n)sf("%d",a+i);
    ll sum=0,ans;
    lp(i,1,k){
        sum+=a[i];
        seg::add(1,0,1000000,a[i],1);
    }
    int mid=seg::ask(1,0,1000000,(k+1)/2);
    ll lesseqsum=seg::gsum(1,0,1000000,(k+1)/2);
    int rk=seg::gcnt(1,0,1000000,(k+1)/2);
    ll tmp=ll(mid)*rk-lesseqsum+(sum-lesseqsum)-ll(mid)*(k-rk);
    ans=tmp;
    for(int i=2;i+k-1&lt;=n;++i){
        seg::add(1,0,1000000,a[i-1],-1);sum-=a[i-1];
        seg::add(1,0,1000000,a[i+k-1],1);sum+=a[i+k-1];
        mid=seg::ask(1,0,1000000,(k+1)/2);
        ll lesseqsum=seg::gsum(1,0,1000000,(k+1)/2);rk=seg::gcnt(1,0,1000000,(k+1)/2);
        ll tmp=ll(mid)*rk-lesseqsum+(sum-lesseqsum)-ll(mid)*(k-rk);
        ans=min(ans,tmp);
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}    <pre><h2>Problem1119</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
int n,a[1000010],b[1000010],v[1000010],p[1000010];
ll w[1000010],t=~0u&gt;&gt;2,ans;
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lld",&amp;w[i]),t=min(w[i],t),ans+=w[i];
    lp(i,1,n)sf("%d",&amp;a[i]),p[a[i]]=i;
    lp(i,1,n)sf("%d",&amp;b[i]);
    lp(i,1,n){
        if(!v[i]){
            ll m=~0u&gt;&gt;2;int j=i,len=0;
            do{
                ++len;
                v[j]=1;
                m=min(m,w[j]);
                j=b[p[j]];
            }while(j!=i);
            ans+=min((len-2)*m,(len+1)*t+m);
        }
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}<pre><h2>Problem1121</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int main(){
	int n;sf("%d",&amp;n);
	pf("%d\n",n/2);
	return 0;
}<pre><h2>Problem1135</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;\
typedef long long ll;
int n,m;ll k,d;
struct node{
    node*ch[2];
    int l,r;ll lmx,rmx,mmx,sum;
}*rt;
node*build(int l,int r){
    node*t=new node;t-&gt;l=l;t-&gt;r=r;
    t-&gt;lmx=t-&gt;rmx=t-&gt;mmx=-k;t-&gt;sum=-k*(r-l+1);
    if(l!=r){
        int m=(l+r)/2;
        t-&gt;ch[0]=build(l,m);
        t-&gt;ch[1]=build(m+1,r);
    }
    return t;
}
void modify(node*x,int p,ll d){
    if(x-&gt;l==x-&gt;r){
        x-&gt;lmx+=d;
        x-&gt;rmx+=d;
        x-&gt;mmx+=d;
        x-&gt;sum+=d;
    }else{
        if(p&lt;=x-&gt;ch[0]-&gt;r)modify(x-&gt;ch[0],p,d);
        else modify(x-&gt;ch[1],p,d);
        x-&gt;lmx=max(x-&gt;ch[0]-&gt;lmx,x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;lmx);
        x-&gt;rmx=max(x-&gt;ch[1]-&gt;rmx,x-&gt;ch[1]-&gt;sum+x-&gt;ch[0]-&gt;rmx);
        x-&gt;sum=x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;sum;
        x-&gt;mmx=max(x-&gt;ch[0]-&gt;mmx,x-&gt;ch[1]-&gt;mmx);
        x-&gt;mmx=max(x-&gt;mmx,x-&gt;ch[0]-&gt;rmx+x-&gt;ch[1]-&gt;lmx);
    }
}
int main(){
    sf("%d%d%lld%lld",&amp;n,&amp;m,&amp;k,&amp;d);
    rt=build(1,n);
    lp(i,1,m){
        int a,b;
        sf("%d%d",&amp;a,&amp;b);
        modify(rt,a,b);
        pf("%s\n",rt-&gt;mmx&lt;=k*d?"TAK":"NIE");
    }
    //ps;
    return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace hug{
	int cx,cy;vector&lt;int&gt;to[210];int lk[210],vi[210];
	int dfs(int u){
		vp(i,to[u]){
			int v=to[u][i];
			if(!vi[v]){
				vi[v]=1;
				if(!lk[v]||dfs(lk[v])){
					lk[v]=u;
					return 1;
				}
			}
		}
		return 0;
	}
	int solve(){
		int r=0;
		lp(i,1,cx){
			fill(vi+1,vi+cy+1,0);
			r+=dfs(i);
		}
		return r;
	}
}
int fld[210][210],n,m;
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		fld[a][b]=1;
	}
	lp(k,1,n)lp(i,1,n)lp(j,1,n)if(fld[i][k]&amp;&amp;fld[k][j])fld[i][j]=1;
	hug::cx=hug::cy=n;
	lp(i,1,n)lp(j,1,n)if(fld[i][j])hug::to[i].pb(j);
	pf("%d\n",n-hug::solve());
	return 0;
}<pre><h2>Problem1146</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n;
vector&lt;int&gt;to[80010];
int bg[80010],ed[80010],tim;
void dfs_tree(int u,int p){
    bg[u]=++tim;
    lp(i,0,int(to[u].size()-1))
        if(to[u][i]!=p)dfs_tree(to[u][i],u);
    ed[u]=tim;
}
void init_tree(){
    lp(i,1,n-1){
        int u,v;
        sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);
        to[v].push_back(u);
    }
}
struct query{
    int tp;//1:add 2:del 3:ask
    int u,a;
    int v,k,now,whe;
}qs[240010];int qz;
int ans[80010],as;
void init(){
    static int val[80010];
    int q;sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n){
        sf("%d",&amp;val[i]);
        ++qz;qs[qz].tp=1;
        qs[qz].u=i;qs[qz].a=val[i];
    }
    init_tree();
    lp(i,1,q){
        int k,u,v;sf("%d%d%d",&amp;k,&amp;u,&amp;v);
        if(k==0){
            ++qz;qs[qz].tp=2;qs[qz].u=u;qs[qz].a=val[u];
            ++qz;qs[qz].tp=1;qs[qz].u=u;qs[qz].a=v;
            val[u]=v;
        }else{
            ++qz;qs[qz].tp=3;
            qs[qz].u=u,qs[qz].v=v,qs[qz].k=k;
            qs[qz].now=0,qs[qz].whe=++as;
        }
    }
}
int up[80010][19],dp[80010];
void build_lca(int u,int p){
    up[u][0]=p;dp[u]=dp[p]+1;
    lp(i,1,18)up[u][i]=up[up[u][i-1]][i-1];
    lp(i,0,int(to[u].size()-1))
        if(to[u][i]!=p)build_lca(to[u][i],u);
}
int lca(int x,int y){
    if(dp[x]&lt;dp[y])swap(x,y);
    lp(i,0,18)if(((dp[x]-dp[y])&gt;&gt;i)&amp;1)x=up[x][i];
    if(x==y)return x;
    for(int i=18;i&gt;=0;--i){
        if(up[x][i]!=up[y][i])
            x=up[x][i],y=up[y][i];
    }
    return up[x][0];
}
int dis(int x,int y){
    int z=lca(x,y);
    int t=dp[x]+dp[y]-dp[z];
    if(z!=1)t-=dp[up[z][0]];
    return t;
}
void print(){
    lp(i,1,as){
        if(ans[i]!=-1)
            pf("%d\n",ans[i]);
        else
            pf("invalid request!\n");
    }
}
int db[80010];
void bit_add(int i,int d){
    for(;i&lt;=n;i+=i&amp;-i)db[i]+=d;
}
int bit_ask(int i){
    int r=0;
    for(;i;i-=i&amp;-i)r+=db[i];
    return r;
}
void add(int u,int d){
    bit_add(bg[u],d);
    bit_add(ed[u]+1,-d);
}
int ask(int u,int v){
    int w=lca(u,v);
    int r=bit_ask(bg[u])+bit_ask(bg[v])-bit_ask(bg[w]);
    if(w!=1)r-=bit_ask(bg[up[w][0]]);
    return r;
}
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==3){
            if(dis(qs[i].u,qs[i].v)&gt;=qs[i].k)
                ans[qs[i].whe]=vl;
            else
                ans[qs[i].whe]=-1;
        }
    }else{
        int vm=vl+(vr-vl)/2;
        static int delt[240010];
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].a&gt;vm){
                add(qs[i].u,1);
            }else if(qs[i].tp==2&amp;&amp;qs[i].a&gt;vm){
                add(qs[i].u,-1);
            }else if(qs[i].tp==3)delt[i]=ask(qs[i].u,qs[i].v);
        }
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].a&gt;vm){
                add(qs[i].u,-1);
            }else if(qs[i].tp==2&amp;&amp;qs[i].a&gt;vm){
                add(qs[i].u,1);
            }
        }
        static query lq[240010],rq[240010];int lqs=0,rqs=0;
        lp(i,ql,qr){
            if(qs[i].tp==3){
                if(qs[i].now+delt[i]&lt;=qs[i].k-1){
                    qs[i].now+=delt[i];
                    lq[++lqs]=qs[i];
                }else rq[++rqs]=qs[i];
            }else{
                if(qs[i].a&lt;=vm)
                    lq[++lqs]=qs[i];
                else
                    rq[++rqs]=qs[i];
            }
        }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    dfs_tree(1,0);
    build_lca(1,0);
    solve(1,qz,0,100000010);
    print();
    //ps;
    return 0;
}
<pre><h2>Problem1167</h2><pre>int main(){}<pre><h2>Problem1176</h2><pre>#include&lt;iostream&gt;

#include&lt;cstdio&gt;



#include&lt;algorithm&gt;
using namespace std;
const int N=2000000;
struct BIT{
    int n,a[N+1];
    BIT(int _n):
        n(_n){
        fill(a+1,a+n+1,0);
    }
    void add(int i,int d){
        for(;i&lt;=n;i+=i&amp;-i)
            a[i]+=d;
    }
    int ask(int i){
        int r=0;
        for(;i;i-=i&amp;-i)
            r+=a[i];
        return r;
    }
};
struct data{
    char typ;

    int x,y,delta;
        int id,t;

};
bool operator&lt;(data a,data b){
    return a.x&lt;b.x;
}

int n;
data ds[200000*4+10];
int dss;
int ans[200000+10];
int qid;
BIT*bit;
void work(int dsl,int dsr){
    if(dsl==dsr){
        return;
    }else{
        int dsm=(dsl+dsr)/2;
        work(dsl,dsm);
        work(dsm+1,dsr);
        static data op[200000*4+10];
        int ops=0;
        static data qu[200000*4+10];
        int qus=0;
        for(int i=dsl;i&lt;=dsm;++i)
            if(ds[i].typ=='A')
                op[++ops]=ds[i];
        for(int i=dsm+1;i&lt;=dsr;++i)
            if(ds[i].typ=='Q')
                qu[++qus]=ds[i];
        sort(op+1,op+ops+1);
        sort(qu+1,qu+qus+1);
        int ptr=1;
        for(int i=1;i&lt;=qus;++i){
            while(ptr&lt;=ops&amp;&amp;op[ptr].x&lt;=qu[i].x){
                bit-&gt;add(op[ptr].y,op[ptr].delta);
                ++ptr;
            }
            ans[qu[i].id]+=qu[i].t*bit-&gt;ask(qu[i].y);
        }
        ptr=1;
        for(int i=1;i&lt;=qus;++i){
            while(ptr&lt;=ops&amp;&amp;op[ptr].x&lt;=qu[i].x){
                bit-&gt;add(op[ptr].y,-op[ptr].delta);
                ++ptr;
            }
        }
    }
}

int main(){
    int s;
    scanf("%d%d",&amp;s,&amp;n);
    bit=new BIT(n);
    for(int i=1;;++i){
        int t;scanf("%d",&amp;t);
        data tmp;
        if(t==1){
            int x,y,d;
            scanf("%d%d%d",&amp;x,&amp;y,&amp;d);
            tmp.typ='A';
            tmp.x=x;
            tmp.y=y;
            tmp.delta=d;
            ds[++dss]=tmp;
        }else if(t==2){
            ++qid;
            int x1,y1,x2,y2;
            scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            tmp.typ='Q';
            tmp.x=x2;
            tmp.y=y2;
            tmp.t=1;
            tmp.id=qid;
             ds[++dss]=tmp;

             if(x1!=1){
                 tmp.typ='Q';
                 tmp.x=x1-1;
                 tmp.y=y2;
                 tmp.t=-1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
             if(y1!=1){
                 tmp.typ='Q';
                 tmp.x=x2;
                 tmp.y=y1-1;
                 tmp.t=-1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
             if(x1!=1&amp;&amp;y1!=1){
                 tmp.typ='Q';
                 tmp.x=x1-1;
                 tmp.y=y1-1;
                 tmp.t=1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
        }else{
            break;
        }
    }
    work(1,dss);
    for(int i=1;i&lt;=qid;++i)
        printf("%d\n",ans[i]+s);
    return 0;
}
/*

16
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
*/
<pre><h2>Problem1180</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct node{
	node(){ch[0]=ch[1]=pr=0;rev=0;}
	node*ch[2],*pr;int val,sum,rev;
}ns[30010];
int direct(node*x){
	if(!x-&gt;pr)return 2;
	else if(x==x-&gt;pr-&gt;ch[0])return 0;
	else if(x==x-&gt;pr-&gt;ch[1])return 1;
	else return 2;
}
void down(node*x){
	if(x-&gt;rev){
		swap(x-&gt;ch[0],x-&gt;ch[1]);
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
		x-&gt;rev=0;
	}
}
void update(node*x){
	lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
	x-&gt;sum=x-&gt;val;
	lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
}
void setchd(node*x,node*y,int d){
	x-&gt;ch[d]=y;
	if(y)y-&gt;pr=x;
	update(x);
}
void rotate(node*x){
	node*y=x-&gt;pr,*z=y-&gt;pr;
	int d1=direct(x),d2=direct(y);
	setchd(y,x-&gt;ch[!d1],d1);
	setchd(x,y,!d1);
	if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
}
void release(node*x){
	if(direct(x)&lt;2)release(x-&gt;pr);
	down(x);
}
void splay(node*x){
	release(x);
	while(direct(x)&lt;2){
		node*y=x-&gt;pr;
		if(direct(y)==2)rotate(x);
		else if(direct(x)==direct(y))rotate(y),rotate(x);
		else rotate(x),rotate(x);
	}
}
node*access(node*x){
	node*y=0;
	while(x){
		splay(x);
		setchd(x,y,1);
		y=x;x=x-&gt;pr;
	}
	return y;
}
void evert(node*x){
	access(x);
	splay(x);
	x-&gt;rev=1;
}
bool check(node*x,node*y){
	access(x);node*w=access(y);
	return w==access(x);
}
void link(node*x,node*y){
	evert(y);splay(y);y-&gt;pr=x;
}
void modify(node*x,int v){
	splay(x);x-&gt;val=v;update(x);
}
int query(node*x,node*y){
	evert(x);access(y);splay(y);
	return y-&gt;sum;
}
int main(){
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		sf("%d",&amp;ns[i].val);
		ns[i].sum=ns[i].val;
	}
	int q;sf("%d",&amp;q);
	lp(i,1,q){
		static char op[110];int u,v;
		sf("%s%d%d",op,&amp;u,&amp;v);
		if(op[0]=='b'){
			if(check(ns+u,ns+v))pf("no\n");
			else pf("yes\n"),link(ns+u,ns+v);
		}else if(op[0]=='p'){
			modify(ns+u,v);
		}else{
			if(!check(ns+u,ns+v))pf("impossible\n");
			else pf("%d\n",query(ns+u,ns+v));
		}
	}
	return 0;
}
<pre><h2>Problem1180</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct node{
	node(){ch[0]=ch[1]=pr=0;rev=0;}
	node*ch[2],*pr;int val,sum,rev;
}ns[30010];
int direct(node*x){
	if(!x-&gt;pr)return 2;
	else if(x==x-&gt;pr-&gt;ch[0])return 0;
	else if(x==x-&gt;pr-&gt;ch[1])return 1;
	else return 2;
}
void down(node*x){
	if(x-&gt;rev){
		swap(x-&gt;ch[0],x-&gt;ch[1]);
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
		x-&gt;rev=0;
	}
}
void update(node*x){
	lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
	x-&gt;sum=x-&gt;val;
	lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
}
void setchd(node*x,node*y,int d){
	x-&gt;ch[d]=y;
	if(y)y-&gt;pr=x;
	update(x);
}
void rotate(node*x){
	node*y=x-&gt;pr,*z=y-&gt;pr;
	int d1=direct(x),d2=direct(y);
	setchd(y,x-&gt;ch[!d1],d1);
	setchd(x,y,!d1);
	if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
}
void release(node*x){
	if(direct(x)&lt;2)release(x-&gt;pr);
	down(x);
}
void splay(node*x){
	release(x);
	while(direct(x)&lt;2)rotate(x);
}
node*access(node*x){
	node*y=0;
	while(x){
		splay(x);
		setchd(x,y,1);
		y=x;x=x-&gt;pr;
	}
	return y;
}
void evert(node*x){
	access(x);
	splay(x);
	x-&gt;rev=1;
}
bool check(node*x,node*y){
	access(x);node*w=access(y);
	return w==access(x);
}
void link(node*x,node*y){
	evert(y);splay(y);y-&gt;pr=x;
}
void modify(node*x,int v){
	splay(x);x-&gt;val=v;update(x);
}
int query(node*x,node*y){
	evert(x);access(y);splay(y);
	return y-&gt;sum;
}
int main(){
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		sf("%d",&amp;ns[i].val);
		ns[i].sum=ns[i].val;
	}
	int q;sf("%d",&amp;q);
	lp(i,1,q){
		static char op[110];int u,v;
		sf("%s%d%d",op,&amp;u,&amp;v);
		if(op[0]=='b'){
			if(check(ns+u,ns+v))pf("no\n");
			else pf("yes\n"),link(ns+u,ns+v);
		}else if(op[0]=='p'){
			modify(ns+u,v);
		}else{
			if(!check(ns+u,ns+v))pf("impossible\n");
			else pf("%d\n",query(ns+u,ns+v));
		}
	}
	return 0;
}
<pre><h2>Problem1180</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace lct{
	const int N=30010;
	struct node{
		node(){ch[0]=ch[1]=pr=0;rev=0;}
		node*ch[2],*pr;int val,sum,rev;
	}ns[N];
	int direct(node*x){
		if(!x-&gt;pr)return 2;
		else if(x==x-&gt;pr-&gt;ch[0])return 0;
		else if(x==x-&gt;pr-&gt;ch[1])return 1;
		else return 2;
	}
	void down(node*x){
		if(x-&gt;rev){
			swap(x-&gt;ch[0],x-&gt;ch[1]);
			lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
			x-&gt;rev=0;
		}
	}
	void update(node*x){
		lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
		x-&gt;sum=x-&gt;val;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
	}
	void setchd(node*x,node*y,int d){
		x-&gt;ch[d]=y;
		if(y)y-&gt;pr=x;
		update(x);
	}
	void rotate(node*x){
		node*y=x-&gt;pr,*z=y-&gt;pr;
		int d1=direct(x),d2=direct(y);
		setchd(y,x-&gt;ch[!d1],d1);
		setchd(x,y,!d1);
		if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
	}
	void release(node*x){
		if(direct(x)&lt;2)release(x-&gt;pr);
		down(x);
	}
	void splay(node*x){
		release(x);
		while(direct(x)&lt;2){
			node*y=x-&gt;pr;
			if(direct(y)==2)rotate(x);
			else if(direct(x)==direct(y))rotate(y),rotate(x);
			else rotate(x),rotate(x);
		}
	}
	node*access(node*x){
		node*y=0;
		while(x){
			splay(x);
			setchd(x,y,1);
			y=x;x=x-&gt;pr;
		}
		return y;
	}
	void evert(node*x){
		access(x);
		splay(x);
		x-&gt;rev=1;
	}
	bool check(node*x,node*y){
		access(x);node*z=access(y);
		return z==access(x);
	}
	void link(node*x,node*y){
		evert(y);y-&gt;pr=x;
	}
	void modify(node*x,int v){
		splay(x);x-&gt;val=v;update(x);
	}
	int query(node*x,node*y){
		evert(x);access(y);splay(y);
		return y-&gt;sum;
	}
}
int main(){
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		sf("%d",&amp;lct::ns[i].val);
		lct::ns[i].sum=lct::ns[i].val;
	}
	int q;sf("%d",&amp;q);
	lp(i,1,q){
		static char op[110];int u,v;
		sf("%s%d%d",op,&amp;u,&amp;v);
		if(op[0]=='b'){
			if(lct::check(lct::ns+u,lct::ns+v))pf("no\n");
			else pf("yes\n"),lct::link(lct::ns+u,lct::ns+v);
		}else if(op[0]=='p'){
			lct::modify(lct::ns+u,v);
		}else{
			if(!lct::check(lct::ns+u,lct::ns+v))pf("impossible\n");
			else pf("%d\n",lct::query(lct::ns+u,lct::ns+v));
		}
	}
	return 0;
}
<pre><h2>Problem1180</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace lct{
    const int N=30010;
    struct node{
        inline node(){ch[0]=ch[1]=pr=0;rev=0;}
        node*ch[2],*pr;int val,sum,rev;
    }ns[N];
    inline int direct(node*x){
        if(!x-&gt;pr)return 2;
        else if(x==x-&gt;pr-&gt;ch[0])return 0;
        else if(x==x-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    inline void down(node*x){
        if(x-&gt;rev){
            swap(x-&gt;ch[0],x-&gt;ch[1]);
            lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
            x-&gt;rev=0;
        }
    }
    inline void update(node*x){
        lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
        x-&gt;sum=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
    }
    inline void setchd(node*x,node*y,int d){
        x-&gt;ch[d]=y;
        if(y)y-&gt;pr=x;
        update(x);
    }
    inline void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;
        int d1=direct(x),d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);
        setchd(x,y,!d1);
        if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
    }
    inline void release(node*x){
        if(direct(x)&lt;2)release(x-&gt;pr);
        down(x);
    }
    inline void splay(node*x){
        release(x);
        while(direct(x)&lt;2){
            node*y=x-&gt;pr;
            if(direct(y)==2)rotate(x);
            else if(direct(x)==direct(y))rotate(y),rotate(x);
            else rotate(x),rotate(x);
        }
    }
    inline node*access(node*x){
        node*y=0;
        while(x){
            splay(x);
            setchd(x,y,1);
            y=x;x=x-&gt;pr;
        }
        return y;
    }
    inline void evert(node*x){
        access(x);
        splay(x);
        x-&gt;rev=1;
    }
    inline bool check(node*x,node*y){
        access(x);node*z=access(y);
        return z==access(x);
    }
    inline void link(node*x,node*y){
        evert(y);y-&gt;pr=x;
    }
    inline void modify(node*x,int v){
        splay(x);x-&gt;val=v;update(x);
    }
    inline int query(node*x,node*y){
        evert(x);access(y);splay(y);
        return y-&gt;sum;
    }
}
int main(){
    int n;sf("%d",&amp;n);
    lp(i,1,n){
        sf("%d",&amp;lct::ns[i].val);
        lct::ns[i].sum=lct::ns[i].val;
    }
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        static char op[110];int u,v;
        sf("%s%d%d",op,&amp;u,&amp;v);
        if(op[0]=='b'){
            if(lct::check(lct::ns+u,lct::ns+v))pf("no\n");
            else pf("yes\n"),lct::link(lct::ns+u,lct::ns+v);
        }else if(op[0]=='p'){
            lct::modify(lct::ns+u,v);
        }else{
            if(!lct::check(lct::ns+u,lct::ns+v))pf("impossible\n");
            else pf("%d\n",lct::query(lct::ns+u,lct::ns+v));
        }
    }
    return 0;
}<pre><h2>Problem1191</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int a[2010][3];
vector&lt;int&gt;to[4010];
int mk[4010];
vector&lt;int&gt;stk;
void add(int x,int vx,int y,int vy){
    to[x*2+1-vx].push_back(y*2+vy);
    to[y*2+1-vy].push_back(x*2+vx);
}
int dfs(int x){
    if(mk[x])return 1;
    if(mk[x^1])return 0;
    mk[x]=1;stk.push_back(x);
    lp(i,0,int(to[x].size()-1)){
        if(!dfs(to[x][i]))return 0;
    }
    return 1; 
}
int check(int x){
    lp(i,1,x)to[i*2].clear(),to[i*2+1].clear();
    lp(i,1,x)mk[i*2]=0,mk[i*2+1]=0;
    lp(i,1,x)
        lp(j,i+1,x){
            if(a[i][1]==a[j][1])add(i,1,j,1);
            if(a[i][1]==a[j][2])add(i,1,j,0);
            if(a[i][2]==a[j][1])add(i,0,j,1);
            if(a[i][2]==a[j][2])add(i,0,j,0);
        }
    lp(i,1,x)
        if(!mk[i*2]&amp;&amp;!mk[i*2+1]){
            stk.clear();
            if(!dfs(i*2)){
                lp(k,0,int(stk.size()-1))
                    mk[stk[k]]=0;
                if(!dfs(i*2+1))return 0; 
            }
        }
    return 1;
}
int main(){
    int n;
    sf("%d",&amp;n);
    sf("%d",&amp;n); 
    lp(i,1,n)sf("%d%d",&amp;a[i][1],&amp;a[i][2]);
    int l=1,r=n+1;
    while(l+1&lt;r){
        int m=(l+r)/2;
        if(check(m))l=m;
        else r=m;
    } 
    pf("%d\n",l); 
    //ps;
    return 0;
}
<pre><h2>Problem1192</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int main(){
    long long n,ans=0;sf("%lld",&amp;n);
    for(long long i=1;;i*=2){
        if(n&gt;=i)n-=i,++ans;else break; 
    }
    if(n!=0){
        if((n&amp;-n)==n)ans+=1;
        else ans+=1;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1208</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int ab(int x){return x&gt;0?x:-x;}set&lt;int&gt;st;
int pet,peo,n,ans;
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        if(a==0){//pet
            if(!peo)st.insert(b),++pet;
            else{
                set&lt;int&gt;::iterator it=st.lower_bound(b);
                if(it==st.end()){
                    ans+=ab(*(--it)-b);ans%=1000000;
                    st.erase(it);
                    --peo;
                }else if(it==st.begin()){
                    ans+=ab(*it-b);ans%=1000000;
                    st.erase(it);
                    --peo;
                }else{
                    set&lt;int&gt;::iterator it2=it;--it2;
                    if(ab(*it2-b)&lt;=ab(*it-b))it=it2;
                    ans+=ab(*it-b);ans%=1000000;
                    st.erase(it);
                    --peo;
                }
            }
        }else{
            if(!pet)st.insert(b),++peo;
            else{
                set&lt;int&gt;::iterator it=st.lower_bound(b);
                if(it==st.end()){
                    ans+=ab(*(--it)-b);ans%=1000000;
                    st.erase(it);
                    --pet;
                }else if(it==st.begin()){
                    ans+=ab(*it-b);ans%=1000000;
                    st.erase(it);
                    --pet;
                }else{
                    set&lt;int&gt;::iterator it2=it;--it2;
                    if(ab(*it2-b)&lt;=ab(*it-b))it=it2;
                    ans+=ab(*it-b);ans%=1000000;
                    st.erase(it);
                    --pet;
                }
            }
        }
    }
    pf("%d\n",ans);//ps;
    return 0;
}
<pre><h2>Problem1213</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
 bigint()
 bigint(long long)
 bigint(bigint)
 bigint(char*)
 bigint(string)
 +, +=, ++
 -, -=, --
 *, *=
 /, /=
 &lt;&lt;, &lt;&lt;=
 ==, !=
 &lt;, &lt;=
 &gt;, &gt;=
 -
 !
 abs(bigint), bigint.abs()
 pow(bigint, unsigned), bigint.pow(unsigned)
 root(bigint, unsigned), bigint.root(unsigned)
 sqrt(bigint), bigint.sqrt()
 bigint.read(default = stdin)
 bigint.write(default = stdout)
 istream&gt;&gt;bigint
 ostream&lt;&lt;bigint
 enoughMemory() : optimize division and modulo
*/
#include &lt;iostream&gt;

#ifndef BIGINT
#define BIGINT 1

#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;

static const unsigned base = 10000, length = 4;
static bool __enoughMemory = false;

typedef vector&lt;int&gt; vi;
typedef vector&lt;int&gt;::iterator viit;
typedef vector&lt;int&gt;::const_iterator vicit;
typedef vector&lt;int&gt;::reverse_iterator virit;
typedef vector&lt;int&gt;::const_reverse_iterator vicrit;
typedef complex&lt;double&gt; comp;
typedef vector&lt;comp&gt; vc;
typedef vector&lt;comp&gt;::iterator vcit;

class Bigint {
public :
    Bigint();
    template&lt;typename _Tp&gt; Bigint(_Tp);
    Bigint(const Bigint&amp;);
    Bigint(const char*);
    Bigint(const string&amp;);
    
    bool&amp; neg();
    const bool&amp; neg() const;
    vi&amp; num();
    const vi&amp; num() const;
    
    bool operator==(const Bigint&amp;) const;
    bool operator!=(const Bigint&amp;) const;
    bool operator&lt;(const Bigint&amp;) const;
    bool operator&lt;=(const Bigint&amp;) const;
    bool operator&gt;(const Bigint&amp;) const;
    bool operator&gt;=(const Bigint&amp;) const;
    
    Bigint&amp; operator+=(const Bigint&amp;);
    Bigint&amp; operator-=(const Bigint&amp;);
    Bigint&amp; operator*=(const Bigint&amp;);
    Bigint&amp; operator/=(const Bigint&amp;);
    Bigint&amp; operator%=(const Bigint&amp;);
    Bigint&amp; operator&lt;&lt;=(const unsigned&amp;);
    Bigint&amp; operator&gt;&gt;=(const unsigned&amp;);
    
    Bigint&amp; operator++();
    Bigint&amp; operator--();
    Bigint operator-() const;
    bool operator!() const;
    
    int compare(const Bigint&amp;) const;
    bool equal(const Bigint&amp;) const;
    bool less(const Bigint&amp;) const;
    bool lessOrEqual(const Bigint&amp;) const;
    bool greater(const Bigint&amp;) const;
    bool greaterOrEqual(const Bigint&amp;) const;
    
    Bigint&amp; abs();
    Bigint&amp; pow(unsigned);
    Bigint&amp; root(const unsigned&amp;);
    Bigint&amp; sqrt();
    void multiply10(const unsigned&amp;);
    void divide2();
    
    void add(const Bigint&amp;);
    void subtract(const Bigint&amp;);
    void multiply(const Bigint&amp;);
    void multiplySlow(const Bigint&amp;);
    void multiplyFast(const Bigint&amp;, const int&amp;, const int&amp;);
    pair&lt;vi, vi&gt; divide(const Bigint&amp;);
    
    Bigint&amp; read(FILE*);
    const Bigint&amp; write(FILE*) const;
    
private :
    bool _m_neg;
    vi _m_num;
    
    void adjust();
    comp exp(const double&amp;);
    void bitrev(const vcit&amp;, const int&amp;, const int&amp;, const int&amp;, const int&amp;);
    void fft(vc&amp;, const int&amp;, const int&amp;, const bool&amp;);
    
    void divideByZero();
    void imaginaryNumberUnsupported();
    void error(const string&amp;);
};

//pre-declaration
Bigint abs(const Bigint&amp;);
Bigint pow(const Bigint&amp;, const unsigned&amp;);
Bigint root(const Bigint&amp;, const unsigned&amp;);
Bigint sqrt(const Bigint&amp;);
istream&amp; operator&gt;&gt;(istream&amp;, Bigint&amp;);
ostream&amp; operator&lt;&lt;(ostream&amp;, const Bigint&amp;);
void enoughMemory();

//operator
inline Bigint operator+(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) += __y;
}
inline Bigint operator-(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) -= __y;
}
inline Bigint operator*(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) *= __y;
}
inline Bigint operator/(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) /= __y;
}
inline Bigint operator%(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) %= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&lt;&lt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &lt;&lt;= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&gt;&gt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &gt;&gt;= __y;
}

//public

//constructor
inline Bigint::Bigint() {
    neg() = false;
    num().clear();
    num().push_back(0);
}
template&lt;typename _Tp&gt; inline Bigint::Bigint(_Tp __t) {
    if (__t &lt; 0) neg() = true, __t = -__t;
    else neg() = false;
    num().clear();
    while (__t &gt;= base) {
        num().push_back(__t % base);
        __t /= base;
    }
    num().push_back(__t);
}
inline Bigint::Bigint(const Bigint&amp; __t) {
    *this = __t;
}
inline Bigint::Bigint(const char* __c) {
    while (*__c) {
        if (*__c == '-' || *__c == '+' || '0' &lt;= *__c &amp;&amp; *__c &lt;= '9')
            break;
        ++__c;
    }
    if (*__c == '-') ++__c, neg() = true;
    else {
        neg() = false;
        if (*__c == '+') ++__c;
    }
    int __n = strlen(__c);
    num().clear();
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    const char* __t = __c + __n;
    while (__c + 1 != __t &amp;&amp; *__c == '0') ++__c;
    int __x = 0, __y = 1, __z = 0;
    while (__t-- != __c) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*__t - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
inline Bigint::Bigint(const string&amp; __s) {
    string::const_iterator i = __s.begin();
    string::const_iterator j = __s.end();
    while (i != j) {
        if (*i == '-' || *i == '+' || '0' &lt;= *i &amp;&amp; *i &lt;= '9')
            break;
        ++i;
    }
    if (i != j) {
        if (*i == '-') ++i, neg() = true;
        else {
            neg() = false;
            if (*i == '+') ++i;
        }
    }
    int __n = j - i;
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    while (i + 1 != j &amp;&amp; *i == '0') ++i;
    int __x = 0, __y = 1, __z = 0;
    while (j-- != i) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*j - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}

inline bool&amp; Bigint::neg() {
    return _m_neg;
}
inline const bool&amp; Bigint::neg() const {
    return _m_neg;
}
inline vi&amp; Bigint::num() {
    return _m_num;
}
inline const vi&amp; Bigint::num() const {
    return _m_num;
}

//logical operator
inline bool Bigint::operator==(const Bigint&amp; __t) const {
    return neg() == __t.neg() &amp;&amp; equal(__t);
}
inline bool Bigint::operator!=(const Bigint&amp; __t) const {
    return neg() != __t.neg() || !equal(__t);
}
inline bool Bigint::operator&lt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greater(__t);
    return less(__t);
}
inline bool Bigint::operator&lt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greaterOrEqual(__t);
    return lessOrEqual(__t);
}
inline bool Bigint::operator&gt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return less(__t);
    return greater(__t);
}
inline bool Bigint::operator&gt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return lessOrEqual(__t);
    return greaterOrEqual(__t);
}

//arithmetic operators
inline Bigint&amp; Bigint::operator+=(const Bigint&amp; __t) {
    if (neg() == __t.neg()) add(__t);
    else {
        int __x = compare(__t);
        if (__x == 0) *this = Bigint();
        else if (__x == -1) {
            Bigint __y = *this;
            *this = __t;
            subtract(__y);
        }
        else subtract(__t);
    }
    return *this;
}
inline Bigint&amp; Bigint::operator-=(const Bigint&amp; __t) {
    return *this += (-__t);
}
inline Bigint&amp; Bigint::operator*=(const Bigint&amp; __t) {
    if (*this != 0 &amp;&amp; __t != 0) {
        neg() = neg() != __t.neg();
        multiply(__t);
    }
    else *this = Bigint();
    return *this;
}
inline Bigint&amp; Bigint::operator/=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    if (less(__t)) *this = Bigint();
    else {
        neg() = neg() != __t.neg();
        num() = divide(__t).first;
        adjust();
    }
    return *this;
}
inline Bigint&amp; Bigint::operator%=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    num() = divide(__t).second;
    adjust();
    if (num().size() == 1 &amp;&amp; !*num().rbegin()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::operator&lt;&lt;=(const unsigned&amp; __y) {
    return *this *= Bigint(2).pow(__y);
}
inline Bigint&amp; Bigint::operator&gt;&gt;=(const unsigned&amp; __y) {
    for (unsigned i = 0 ; i &lt; __y ; ++i) divide2();
    return *this;
}

//self operator
inline Bigint&amp; Bigint::operator++() {
    return *this += 1;
}
inline Bigint&amp; Bigint::operator--() {
    return *this -= 1;
}
inline Bigint Bigint::operator-() const {
    Bigint __t = *this;
    if (__t != 0) __t.neg() ^= true;
    return __t;
}
inline bool Bigint::operator!() const {
    return *this == 0;
}

//comparator
inline int Bigint::compare(const Bigint&amp; __t) const {
    if (num().size() &lt; __t.num().size()) return -1;
    else if (num().size() &gt; __t.num().size()) return 1;
    vicrit i = num().rbegin();
    vicrit j = __t.num().rbegin();
    while (i != num().rend()) {
        if (*i &lt; *j) return -1;
        else if (*i &gt; *j) return 1;
        ++i, ++j;
    }
    return 0;
}
inline bool Bigint::equal(const Bigint&amp; __t) const {
    return compare(__t) == 0;
}
inline bool Bigint::less(const Bigint&amp; __t) const {
    return compare(__t) == -1;
}
inline bool Bigint::lessOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == -1 || __r == 0;
}
inline bool Bigint::greater(const Bigint&amp; __t) const {
    return compare(__t) == 1;
}
inline bool Bigint::greaterOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == 1 || __r == 0;
}

//math
inline Bigint&amp; Bigint::abs() {
    if (neg()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::pow(unsigned __y) {
    Bigint __x = *this;
    *this = 1;
    while (__y) {
        if (__y &amp; 1) *this *= __x;
        __x *= __x;
        __y &gt;&gt;= 1;
    }
    return *this;
}
inline Bigint&amp; Bigint::root(const unsigned&amp; __y = 2) {
    if (!__y) divideByZero();
    if (*this == 0 || __y == 1) return *this;
    bool __n = neg();
    if (__n)
        if (__y &amp; 1) neg() = false;
        else imaginaryNumberUnsupported();
    const double log2_10 = 3.3219280948873623478703194294893901758648313930245806;
    size_t __s = num().size();
    if (double(__s &lt;&lt; 2) * log2_10 &lt; __y) return *this = 1;
    __s = __s / __y + (__s % __y ? 1 : 0);
    int __l, __r, __m;
    Bigint __a = *this, __b, __c;
    num().clear();
    for (int i = __s - 1 ; i &gt;= 0 ; --i) {
        __l = 1, __r = base - 1;
        while (__l &lt;= __r) {
            __m = __l + __r &gt;&gt; 1;
            __b = *this;
            __b.num().insert(__b.num().begin(), __m);
            __b.pow(__y);
            __b.multiply10(i * __y &lt;&lt; 2);
            if (__b &lt;= __a) __l = __m + 1;
            else __r = __m - 1;
        }
        num().insert(num().begin(), __r);
    }
    neg() = __n;
    return *this;
}
inline Bigint&amp; Bigint::sqrt() {
    root();
    return *this;
}
inline void Bigint::multiply10(const unsigned&amp; __t) {
    if (!__t) return ;
    size_t __s = num().size();
    size_t __r = (__t &gt;&gt; 2) + (__t &amp; 3 ? 1 : 0);
    int __x = 0, __y, __z, __a, __b;
    if ((__t &amp; 3) == 0) __a = 1, __b = 10000;
    else if ((__t &amp; 3) == 1) __a = 1000, __b = 10;
    else if ((__t &amp; 3) == 2) __a = 100, __b = 100;
    else if ((__t &amp; 3) == 3) __a = 10, __b = 1000;
    num().resize(__s + __r);
    virit i = num().rbegin();
    virit j = i + __r;
    while (i != num().rbegin() + __s) {
        __y = *j++;
        __z = __y / __a;
        __x += __z;
        *i++ = __x;
        __x = (__y - __z * __a) * __b;
    }
    *i++ = __x;
    fill(i, num().rend(), 0);
    adjust();
}
inline void Bigint::divide2() {
    int __t = 0;
    for (virit i = num().rbegin() ; i != num().rend() ; ++i) {
        __t = (__t &amp; 1 ? base : 0) + *i;
        *i = __t &gt;&gt; 1;
    }
    adjust();
}

//+, -, *, /
inline void Bigint::add(const Bigint&amp; __t) {
    if (num().size() &lt; __t.num().size())
        num().resize(__t.num().size());
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (i != num().end() &amp;&amp; j != __t.num().end())
        *i++ += *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &gt;= base) {
            *i -= base;
            ++*(i + 1);
        }
    if (*i &gt;= base) {
        *i -= base;
        num().push_back(1);
    }
}
inline void Bigint::subtract(const Bigint&amp; __t) {
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (j != __t.num().end())
        *i++ -= *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &lt; 0) {
            *i += base;
            --*(i + 1);
        }
    adjust();
}
inline void Bigint::multiply(const Bigint&amp; __t) {
    int __n = max(num().size(), __t.num().size());
    int __l = 0;
    while ((1 &lt;&lt; __l) &lt; __n) ++__l;
    __n = 1 &lt;&lt; ++__l;
    if ((long long)num().size() * __t.num().size() &lt;= (long long)__n * __l * 20)
        multiplySlow(__t);
    else
        multiplyFast(__t, __n, __l);
    adjust();
}
inline void Bigint::multiplySlow(const Bigint&amp; __t) {
    int __n = num().size() + __t.num().size(), i, j, k;
    vi __x, __y;
    if (__t.num().size() * 4 &lt; num().size())
        __x = __t.num(), __y = num();
    else
        __x = num(), __y = __t.num();
    num().clear();
    num().resize(__n);
    for (i = 0 ; i &lt; __x.size() ; ++i) {
        k = __x[i];
        for (j = 0 ; j &lt; __y.size() ; ++j)
            num()[i + j] += k * __y[j];
        k = i + 1 + __y.size();
        for (j = 0 ; j &lt; k ; ++j) {
            num()[j + 1] += num()[j] / base;
            num()[j] %= base;
        }
    }
}
inline void Bigint::multiplyFast(const Bigint&amp; __t, const int&amp; __n, const int&amp; __l) {
    vc a, b;
    a.reserve(__n);
    b.reserve(__n);
    for (viit i = num().begin() ; i != num().end() ; ++i)
        a.push_back(comp(*i, 0));
    for (vicit i = __t.num().begin() ; i != __t.num().end() ; ++i)
        b.push_back(comp(*i, 0));
    a.resize(__n);
    b.resize(__n);
    fft(a, __l, __n, true);
    fft(b, __l, __n, true);
    vcit i = a.begin(), j = b.begin();
    while (i != a.end()) *i++ *= *j++;
    fft(a, __l, __n, false);
    long long __x = 0;
    num().resize(__n);
    i = a.begin();
    viit k = num().begin();
    while (i != a.end()) {
        __x = (long long)(i++ -&gt;real() / __n + 0.5) + __x / base;
        *k++ = __x % base;
    }
}
inline pair&lt;vi, vi&gt; Bigint::divide(const Bigint&amp; __t) {
    int __l, __r, __m, __n = num().size() - __t.num().size() + 1;
    Bigint __x = *this, __y = __t, __z;
    vi __v;
    __v.resize(__n);
    if (__enoughMemory) {
        Bigint __p[10];
        for (__m = 0 ; __m &lt; 10 ; ++__m) __p[__m] = __m * __y;
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            int k = 0;
            for (int j = 3 + (i &lt;&lt; 2) ; j &gt;= (i &lt;&lt; 2) ; --j) {
                __l = 1, __r = 9;
                while (__l &lt;= __r) {
                    __m = __l + __r &gt;&gt; 1;
                    __z = __p[__m];
                    __z.multiply10(j);
                    if (__z.greater(__x)) __r = __m - 1;
                    else __l = __m + 1;
                }
                k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + __r;
                __z = __p[__r];
                __z.multiply10(j);
                __x.subtract(__z);
            }
            __v[i] = k;
        }
    }
    else {
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            __l = 1, __r = base - 1;
            while (__l &lt;= __r) {
                __m = __l + __r &gt;&gt; 1;
                __z = __m * __y;
                __z.multiply10(i &lt;&lt; 2);
                if (__z.greater(__x)) __r = __m - 1;
                else __l = __m + 1;
            }
            __v[i] = __r;
            __z = __r * __y;
            __z.multiply10(i &lt;&lt; 2);
            __x.subtract(__z);
        }
    }
    return make_pair(__v, __x.num());
}

//io
inline Bigint&amp; Bigint::read(FILE *in = stdin) {
    string __s = "";
    char __c = fgetc(in);
    while (true) {
        if (__c == '-' || __c == '+' || '0' &lt;= __c &amp;&amp; __c &lt;= '9' || __c == EOF)
            break;
        __c = fgetc(in);
    }
    while (true) {
        __s += __c;
        __c = fgetc(in);
        if (__c &lt; '0' || __c &gt; '9') break;
    }
    return *this = Bigint(__s.c_str());
}
inline const Bigint&amp; Bigint::write(FILE *out = stdout) const {
    vicrit i = num().rbegin();
    if (neg()) fprintf(out, "-");
    fprintf(out, "%d", *i++);
    while (i != num().rend()) fprintf(out, "%04d", *i++);
    return *this;
}

//private

//other
inline void Bigint::adjust() {
    virit i = num().rbegin();
    while (i + 1 != num().rend()) {
        if (*i) break;
        ++i;
    }
    num().erase(i.base(), num().end());
}
inline comp Bigint::exp(const double&amp; u) {
    return comp(cos(u), sin(u));
}
inline void Bigint::bitrev(const vcit&amp; i, const int&amp; __l, const int&amp; __p, const int&amp; __x, const int&amp; __y) {
    if (__p == 0) {
        if (__x &lt; __y) swap(*(i + __x), *(i + __y));
        return ;
    }
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1, __y);
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1 | 1, __y | (1 &lt;&lt; __l - __p));
}
inline void Bigint::fft(vc&amp; __a, const int&amp; __l, const int&amp; __n, const bool&amp; __r) {
    const double __p = 3.141592653589793238462643383279;
    bitrev(__a.begin(), __l, __l, 0, 0);
    for (int i = 1 ; i &lt;= __l ; ++i) {
        int __m = 1 &lt;&lt; i;
        comp wm = exp((__r ? -2 : 2) * __p / __m);
        for (int k = 0 ; k &lt; __n ; k += __m) {
            comp w = 1;
            for (int j = 0 ; j &lt; __m / 2 ; ++j) {
                comp t = w * __a[k + j + __m / 2];
                comp u = __a[k + j];
                __a[k + j] = u + t;
                __a[k + j + __m / 2] = u - t;
                w *= wm;
            }
        }
    }
}

//error
inline void Bigint::divideByZero() {
    error("divide by zero");
}
inline void Bigint::imaginaryNumberUnsupported() {
    error("imaginary number unsupported");
}
inline void Bigint::error(const string&amp; __s) {
    fprintf(stderr, "%s\n", __s.c_str());
    cerr &lt;&lt; __s &lt;&lt; endl;
    abort();
}

//math
inline Bigint abs(const Bigint&amp; __x) {
    return Bigint(__x).abs();
}
inline Bigint pow(const Bigint&amp; __x, const unsigned&amp; __y) {
    return Bigint(__x).pow(__y);
}
inline Bigint root(const Bigint&amp; __x, const unsigned&amp; __y = 2) {
    return Bigint(__x).root(__y);
}
inline Bigint sqrt(const Bigint&amp; __x) {
    return Bigint(__x).sqrt();
}

//io
inline istream&amp; operator&gt;&gt;(istream&amp; __s, Bigint&amp; __t) {
    string __r;
    __s &gt;&gt; __r;
    __t = Bigint(__r);
    return __s;
}
inline ostream&amp; operator&lt;&lt;(ostream&amp; __s, const Bigint&amp; __t) {
    if (__t.neg()) __s &lt;&lt; '-';
    vicrit i = __t.num().rbegin();
    __s &lt;&lt; *i;
    while (++i != __t.num().rend()) {
        __s.width(length);
        __s.fill('0');
        __s &lt;&lt; *i;
    }
    return __s;
}

//optimization
inline void enoughMemory() {
    __enoughMemory = true;
}

#endif
int main(){
	int n;Bigint a;
	cin&gt;&gt;n&gt;&gt;a;
	cout&lt;&lt;root(a,n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1213</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
 bigint()
 bigint(long long)
 bigint(bigint)
 bigint(char*)
 bigint(string)
 +, +=, ++
 -, -=, --
 *, *=
 /, /=
 &lt;&lt;, &lt;&lt;=
 ==, !=
 &lt;, &lt;=
 &gt;, &gt;=
 -
 !
 abs(bigint), bigint.abs()
 pow(bigint, unsigned), bigint.pow(unsigned)
 root(bigint, unsigned), bigint.root(unsigned)
 sqrt(bigint), bigint.sqrt()
 bigint.read(default = stdin)
 bigint.write(default = stdout)
 istream&gt;&gt;bigint
 ostream&lt;&lt;bigint
 enoughMemory() : optimize division and modulo
*/
#include &lt;iostream&gt;

#ifndef BIGINT
#define BIGINT 1

#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;

static const unsigned base = 10000, length = 4;
static bool __enoughMemory = false;

typedef vector&lt;int&gt; vi;
typedef vector&lt;int&gt;::iterator viit;
typedef vector&lt;int&gt;::const_iterator vicit;
typedef vector&lt;int&gt;::reverse_iterator virit;
typedef vector&lt;int&gt;::const_reverse_iterator vicrit;
typedef complex&lt;double&gt; comp;
typedef vector&lt;comp&gt; vc;
typedef vector&lt;comp&gt;::iterator vcit;

class Bigint {
public :
    Bigint();
    template&lt;typename _Tp&gt; Bigint(_Tp);
    Bigint(const Bigint&amp;);
    Bigint(const char*);
    Bigint(const string&amp;);
    
    bool&amp; neg();
    const bool&amp; neg() const;
    vi&amp; num();
    const vi&amp; num() const;
    
    bool operator==(const Bigint&amp;) const;
    bool operator!=(const Bigint&amp;) const;
    bool operator&lt;(const Bigint&amp;) const;
    bool operator&lt;=(const Bigint&amp;) const;
    bool operator&gt;(const Bigint&amp;) const;
    bool operator&gt;=(const Bigint&amp;) const;
    
    Bigint&amp; operator+=(const Bigint&amp;);
    Bigint&amp; operator-=(const Bigint&amp;);
    Bigint&amp; operator*=(const Bigint&amp;);
    Bigint&amp; operator/=(const Bigint&amp;);
    Bigint&amp; operator%=(const Bigint&amp;);
    Bigint&amp; operator&lt;&lt;=(const unsigned&amp;);
    Bigint&amp; operator&gt;&gt;=(const unsigned&amp;);
    
    Bigint&amp; operator++();
    Bigint&amp; operator--();
    Bigint operator-() const;
    bool operator!() const;
    
    int compare(const Bigint&amp;) const;
    bool equal(const Bigint&amp;) const;
    bool less(const Bigint&amp;) const;
    bool lessOrEqual(const Bigint&amp;) const;
    bool greater(const Bigint&amp;) const;
    bool greaterOrEqual(const Bigint&amp;) const;
    
    Bigint&amp; abs();
    Bigint&amp; pow(unsigned);
    Bigint&amp; root(const unsigned&amp;);
    Bigint&amp; sqrt();
    void multiply10(const unsigned&amp;);
    void divide2();
    
    void add(const Bigint&amp;);
    void subtract(const Bigint&amp;);
    void multiply(const Bigint&amp;);
    void multiplySlow(const Bigint&amp;);
    void multiplyFast(const Bigint&amp;, const int&amp;, const int&amp;);
    pair&lt;vi, vi&gt; divide(const Bigint&amp;);
    
    Bigint&amp; read(FILE*);
    const Bigint&amp; write(FILE*) const;
    
private :
    bool _m_neg;
    vi _m_num;
    
    void adjust();
    comp exp(const double&amp;);
    void bitrev(const vcit&amp;, const int&amp;, const int&amp;, const int&amp;, const int&amp;);
    void fft(vc&amp;, const int&amp;, const int&amp;, const bool&amp;);
    
    void divideByZero();
    void imaginaryNumberUnsupported();
    void error(const string&amp;);
};

//pre-declaration
Bigint abs(const Bigint&amp;);
Bigint pow(const Bigint&amp;, const unsigned&amp;);
Bigint root(const Bigint&amp;, const unsigned&amp;);
Bigint sqrt(const Bigint&amp;);
istream&amp; operator&gt;&gt;(istream&amp;, Bigint&amp;);
ostream&amp; operator&lt;&lt;(ostream&amp;, const Bigint&amp;);
void enoughMemory();

//operator
inline Bigint operator+(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) += __y;
}
inline Bigint operator-(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) -= __y;
}
inline Bigint operator*(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) *= __y;
}
inline Bigint operator/(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) /= __y;
}
inline Bigint operator%(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) %= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&lt;&lt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &lt;&lt;= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&gt;&gt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &gt;&gt;= __y;
}

//public

//constructor
inline Bigint::Bigint() {
    neg() = false;
    num().clear();
    num().push_back(0);
}
template&lt;typename _Tp&gt; inline Bigint::Bigint(_Tp __t) {
    if (__t &lt; 0) neg() = true, __t = -__t;
    else neg() = false;
    num().clear();
    while (__t &gt;= base) {
        num().push_back(__t % base);
        __t /= base;
    }
    num().push_back(__t);
}
inline Bigint::Bigint(const Bigint&amp; __t) {
    *this = __t;
}
inline Bigint::Bigint(const char* __c) {
    while (*__c) {
        if (*__c == '-' || *__c == '+' || '0' &lt;= *__c &amp;&amp; *__c &lt;= '9')
            break;
        ++__c;
    }
    if (*__c == '-') ++__c, neg() = true;
    else {
        neg() = false;
        if (*__c == '+') ++__c;
    }
    int __n = strlen(__c);
    num().clear();
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    const char* __t = __c + __n;
    while (__c + 1 != __t &amp;&amp; *__c == '0') ++__c;
    int __x = 0, __y = 1, __z = 0;
    while (__t-- != __c) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*__t - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
inline Bigint::Bigint(const string&amp; __s) {
    string::const_iterator i = __s.begin();
    string::const_iterator j = __s.end();
    while (i != j) {
        if (*i == '-' || *i == '+' || '0' &lt;= *i &amp;&amp; *i &lt;= '9')
            break;
        ++i;
    }
    if (i != j) {
        if (*i == '-') ++i, neg() = true;
        else {
            neg() = false;
            if (*i == '+') ++i;
        }
    }
    int __n = j - i;
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    while (i + 1 != j &amp;&amp; *i == '0') ++i;
    int __x = 0, __y = 1, __z = 0;
    while (j-- != i) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*j - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}

inline bool&amp; Bigint::neg() {
    return _m_neg;
}
inline const bool&amp; Bigint::neg() const {
    return _m_neg;
}
inline vi&amp; Bigint::num() {
    return _m_num;
}
inline const vi&amp; Bigint::num() const {
    return _m_num;
}

//logical operator
inline bool Bigint::operator==(const Bigint&amp; __t) const {
    return neg() == __t.neg() &amp;&amp; equal(__t);
}
inline bool Bigint::operator!=(const Bigint&amp; __t) const {
    return neg() != __t.neg() || !equal(__t);
}
inline bool Bigint::operator&lt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greater(__t);
    return less(__t);
}
inline bool Bigint::operator&lt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greaterOrEqual(__t);
    return lessOrEqual(__t);
}
inline bool Bigint::operator&gt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return less(__t);
    return greater(__t);
}
inline bool Bigint::operator&gt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return lessOrEqual(__t);
    return greaterOrEqual(__t);
}

//arithmetic operators
inline Bigint&amp; Bigint::operator+=(const Bigint&amp; __t) {
    if (neg() == __t.neg()) add(__t);
    else {
        int __x = compare(__t);
        if (__x == 0) *this = Bigint();
        else if (__x == -1) {
            Bigint __y = *this;
            *this = __t;
            subtract(__y);
        }
        else subtract(__t);
    }
    return *this;
}
inline Bigint&amp; Bigint::operator-=(const Bigint&amp; __t) {
    return *this += (-__t);
}
inline Bigint&amp; Bigint::operator*=(const Bigint&amp; __t) {
    if (*this != 0 &amp;&amp; __t != 0) {
        neg() = neg() != __t.neg();
        multiply(__t);
    }
    else *this = Bigint();
    return *this;
}
inline Bigint&amp; Bigint::operator/=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    if (less(__t)) *this = Bigint();
    else {
        neg() = neg() != __t.neg();
        num() = divide(__t).first;
        adjust();
    }
    return *this;
}
inline Bigint&amp; Bigint::operator%=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    num() = divide(__t).second;
    adjust();
    if (num().size() == 1 &amp;&amp; !*num().rbegin()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::operator&lt;&lt;=(const unsigned&amp; __y) {
    return *this *= Bigint(2).pow(__y);
}
inline Bigint&amp; Bigint::operator&gt;&gt;=(const unsigned&amp; __y) {
    for (unsigned i = 0 ; i &lt; __y ; ++i) divide2();
    return *this;
}

//self operator
inline Bigint&amp; Bigint::operator++() {
    return *this += 1;
}
inline Bigint&amp; Bigint::operator--() {
    return *this -= 1;
}
inline Bigint Bigint::operator-() const {
    Bigint __t = *this;
    if (__t != 0) __t.neg() ^= true;
    return __t;
}
inline bool Bigint::operator!() const {
    return *this == 0;
}

//comparator
inline int Bigint::compare(const Bigint&amp; __t) const {
    if (num().size() &lt; __t.num().size()) return -1;
    else if (num().size() &gt; __t.num().size()) return 1;
    vicrit i = num().rbegin();
    vicrit j = __t.num().rbegin();
    while (i != num().rend()) {
        if (*i &lt; *j) return -1;
        else if (*i &gt; *j) return 1;
        ++i, ++j;
    }
    return 0;
}
inline bool Bigint::equal(const Bigint&amp; __t) const {
    return compare(__t) == 0;
}
inline bool Bigint::less(const Bigint&amp; __t) const {
    return compare(__t) == -1;
}
inline bool Bigint::lessOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == -1 || __r == 0;
}
inline bool Bigint::greater(const Bigint&amp; __t) const {
    return compare(__t) == 1;
}
inline bool Bigint::greaterOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == 1 || __r == 0;
}

//math
inline Bigint&amp; Bigint::abs() {
    if (neg()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::pow(unsigned __y) {
    Bigint __x = *this;
    *this = 1;
    while (__y) {
        if (__y &amp; 1) *this *= __x;
        __x *= __x;
        __y &gt;&gt;= 1;
    }
    return *this;
}
inline Bigint&amp; Bigint::root(const unsigned&amp; __y = 2) {
    if (!__y) divideByZero();
    if (*this == 0 || __y == 1) return *this;
    bool __n = neg();
    if (__n)
        if (__y &amp; 1) neg() = false;
        else imaginaryNumberUnsupported();
    const double log2_10 = 3.3219280948873623478703194294893901758648313930245806;
    size_t __s = num().size();
    if (double(__s &lt;&lt; 2) * log2_10 &lt; __y) return *this = 1;
    __s = __s / __y + (__s % __y ? 1 : 0);
    int __l, __r, __m;
    Bigint __a = *this, __b, __c;
    num().clear();
    for (int i = __s - 1 ; i &gt;= 0 ; --i) {
        __l = 1, __r = base - 1;
        while (__l &lt;= __r) {
            __m = __l + __r &gt;&gt; 1;
            __b = *this;
            __b.num().insert(__b.num().begin(), __m);
            __b.pow(__y);
            __b.multiply10(i * __y &lt;&lt; 2);
            if (__b &lt;= __a) __l = __m + 1;
            else __r = __m - 1;
        }
        num().insert(num().begin(), __r);
    }
    neg() = __n;
    return *this;
}
inline Bigint&amp; Bigint::sqrt() {
    root();
    return *this;
}
inline void Bigint::multiply10(const unsigned&amp; __t) {
    if (!__t) return ;
    size_t __s = num().size();
    size_t __r = (__t &gt;&gt; 2) + (__t &amp; 3 ? 1 : 0);
    int __x = 0, __y, __z, __a, __b;
    if ((__t &amp; 3) == 0) __a = 1, __b = 10000;
    else if ((__t &amp; 3) == 1) __a = 1000, __b = 10;
    else if ((__t &amp; 3) == 2) __a = 100, __b = 100;
    else if ((__t &amp; 3) == 3) __a = 10, __b = 1000;
    num().resize(__s + __r);
    virit i = num().rbegin();
    virit j = i + __r;
    while (i != num().rbegin() + __s) {
        __y = *j++;
        __z = __y / __a;
        __x += __z;
        *i++ = __x;
        __x = (__y - __z * __a) * __b;
    }
    *i++ = __x;
    fill(i, num().rend(), 0);
    adjust();
}
inline void Bigint::divide2() {
    int __t = 0;
    for (virit i = num().rbegin() ; i != num().rend() ; ++i) {
        __t = (__t &amp; 1 ? base : 0) + *i;
        *i = __t &gt;&gt; 1;
    }
    adjust();
}

//+, -, *, /
inline void Bigint::add(const Bigint&amp; __t) {
    if (num().size() &lt; __t.num().size())
        num().resize(__t.num().size());
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (i != num().end() &amp;&amp; j != __t.num().end())
        *i++ += *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &gt;= base) {
            *i -= base;
            ++*(i + 1);
        }
    if (*i &gt;= base) {
        *i -= base;
        num().push_back(1);
    }
}
inline void Bigint::subtract(const Bigint&amp; __t) {
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (j != __t.num().end())
        *i++ -= *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &lt; 0) {
            *i += base;
            --*(i + 1);
        }
    adjust();
}
inline void Bigint::multiply(const Bigint&amp; __t) {
    int __n = max(num().size(), __t.num().size());
    int __l = 0;
    while ((1 &lt;&lt; __l) &lt; __n) ++__l;
    __n = 1 &lt;&lt; ++__l;
    if ((long long)num().size() * __t.num().size() &lt;= (long long)__n * __l * 20)
        multiplySlow(__t);
    else
        multiplyFast(__t, __n, __l);
    adjust();
}
inline void Bigint::multiplySlow(const Bigint&amp; __t) {
    int __n = num().size() + __t.num().size(), i, j, k;
    vi __x, __y;
    if (__t.num().size() * 4 &lt; num().size())
        __x = __t.num(), __y = num();
    else
        __x = num(), __y = __t.num();
    num().clear();
    num().resize(__n);
    for (i = 0 ; i &lt; __x.size() ; ++i) {
        k = __x[i];
        for (j = 0 ; j &lt; __y.size() ; ++j)
            num()[i + j] += k * __y[j];
        k = i + 1 + __y.size();
        for (j = 0 ; j &lt; k ; ++j) {
            num()[j + 1] += num()[j] / base;
            num()[j] %= base;
        }
    }
}
inline void Bigint::multiplyFast(const Bigint&amp; __t, const int&amp; __n, const int&amp; __l) {
    vc a, b;
    a.reserve(__n);
    b.reserve(__n);
    for (viit i = num().begin() ; i != num().end() ; ++i)
        a.push_back(comp(*i, 0));
    for (vicit i = __t.num().begin() ; i != __t.num().end() ; ++i)
        b.push_back(comp(*i, 0));
    a.resize(__n);
    b.resize(__n);
    fft(a, __l, __n, true);
    fft(b, __l, __n, true);
    vcit i = a.begin(), j = b.begin();
    while (i != a.end()) *i++ *= *j++;
    fft(a, __l, __n, false);
    long long __x = 0;
    num().resize(__n);
    i = a.begin();
    viit k = num().begin();
    while (i != a.end()) {
        __x = (long long)(i++ -&gt;real() / __n + 0.5) + __x / base;
        *k++ = __x % base;
    }
}
inline pair&lt;vi, vi&gt; Bigint::divide(const Bigint&amp; __t) {
    int __l, __r, __m, __n = num().size() - __t.num().size() + 1;
    Bigint __x = *this, __y = __t, __z;
    vi __v;
    __v.resize(__n);
    if (__enoughMemory) {
        Bigint __p[10];
        for (__m = 0 ; __m &lt; 10 ; ++__m) __p[__m] = __m * __y;
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            int k = 0;
            for (int j = 3 + (i &lt;&lt; 2) ; j &gt;= (i &lt;&lt; 2) ; --j) {
                __l = 1, __r = 9;
                while (__l &lt;= __r) {
                    __m = __l + __r &gt;&gt; 1;
                    __z = __p[__m];
                    __z.multiply10(j);
                    if (__z.greater(__x)) __r = __m - 1;
                    else __l = __m + 1;
                }
                k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + __r;
                __z = __p[__r];
                __z.multiply10(j);
                __x.subtract(__z);
            }
            __v[i] = k;
        }
    }
    else {
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            __l = 1, __r = base - 1;
            while (__l &lt;= __r) {
                __m = __l + __r &gt;&gt; 1;
                __z = __m * __y;
                __z.multiply10(i &lt;&lt; 2);
                if (__z.greater(__x)) __r = __m - 1;
                else __l = __m + 1;
            }
            __v[i] = __r;
            __z = __r * __y;
            __z.multiply10(i &lt;&lt; 2);
            __x.subtract(__z);
        }
    }
    return make_pair(__v, __x.num());
}

//io
inline Bigint&amp; Bigint::read(FILE *in = stdin) {
    string __s = "";
    char __c = fgetc(in);
    while (true) {
        if (__c == '-' || __c == '+' || '0' &lt;= __c &amp;&amp; __c &lt;= '9' || __c == EOF)
            break;
        __c = fgetc(in);
    }
    while (true) {
        __s += __c;
        __c = fgetc(in);
        if (__c &lt; '0' || __c &gt; '9') break;
    }
    return *this = Bigint(__s.c_str());
}
inline const Bigint&amp; Bigint::write(FILE *out = stdout) const {
    vicrit i = num().rbegin();
    if (neg()) fprintf(out, "-");
    fprintf(out, "%d", *i++);
    while (i != num().rend()) fprintf(out, "%04d", *i++);
    return *this;
}

//private

//other
inline void Bigint::adjust() {
    virit i = num().rbegin();
    while (i + 1 != num().rend()) {
        if (*i) break;
        ++i;
    }
    num().erase(i.base(), num().end());
}
inline comp Bigint::exp(const double&amp; u) {
    return comp(cos(u), sin(u));
}
inline void Bigint::bitrev(const vcit&amp; i, const int&amp; __l, const int&amp; __p, const int&amp; __x, const int&amp; __y) {
    if (__p == 0) {
        if (__x &lt; __y) swap(*(i + __x), *(i + __y));
        return ;
    }
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1, __y);
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1 | 1, __y | (1 &lt;&lt; __l - __p));
}
inline void Bigint::fft(vc&amp; __a, const int&amp; __l, const int&amp; __n, const bool&amp; __r) {
    const double __p = 3.141592653589793238462643383279;
    bitrev(__a.begin(), __l, __l, 0, 0);
    for (int i = 1 ; i &lt;= __l ; ++i) {
        int __m = 1 &lt;&lt; i;
        comp wm = exp((__r ? -2 : 2) * __p / __m);
        for (int k = 0 ; k &lt; __n ; k += __m) {
            comp w = 1;
            for (int j = 0 ; j &lt; __m / 2 ; ++j) {
                comp t = w * __a[k + j + __m / 2];
                comp u = __a[k + j];
                __a[k + j] = u + t;
                __a[k + j + __m / 2] = u - t;
                w *= wm;
            }
        }
    }
}

//error
inline void Bigint::divideByZero() {
    error("divide by zero");
}
inline void Bigint::imaginaryNumberUnsupported() {
    error("imaginary number unsupported");
}
inline void Bigint::error(const string&amp; __s) {
    fprintf(stderr, "%s\n", __s.c_str());
    cerr &lt;&lt; __s &lt;&lt; endl;
    abort();
}

//math
inline Bigint abs(const Bigint&amp; __x) {
    return Bigint(__x).abs();
}
inline Bigint pow(const Bigint&amp; __x, const unsigned&amp; __y) {
    return Bigint(__x).pow(__y);
}
inline Bigint root(const Bigint&amp; __x, const unsigned&amp; __y = 2) {
    return Bigint(__x).root(__y);
}
inline Bigint sqrt(const Bigint&amp; __x) {
    return Bigint(__x).sqrt();
}

//io
inline istream&amp; operator&gt;&gt;(istream&amp; __s, Bigint&amp; __t) {
    string __r;
    __s &gt;&gt; __r;
    __t = Bigint(__r);
    return __s;
}
inline ostream&amp; operator&lt;&lt;(ostream&amp; __s, const Bigint&amp; __t) {
    if (__t.neg()) __s &lt;&lt; '-';
    vicrit i = __t.num().rbegin();
    __s &lt;&lt; *i;
    while (++i != __t.num().rend()) {
        __s.width(length);
        __s.fill('0');
        __s &lt;&lt; *i;
    }
    return __s;
}

//optimization
inline void enoughMemory() {
    __enoughMemory = true;
}

#endif
int main(){
	enoughMemory();
	int n;Bigint a;
	cin&gt;&gt;n&gt;&gt;a;
	cout&lt;&lt;root(a,n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1218</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int sum[5010][5010];int n,r,ans;
int main(){
	sf("%d%d",&amp;n,&amp;r);int maxx=1,maxy=1;
	lp(i,1,n){
		int x,y,z;sf("%d%d%d",&amp;x,&amp;y,&amp;z);
		sum[x+1][y+1]+=z;
		maxx=max(maxx,x+1);
		maxy=max(maxy,y+1);
	}
	lp(i,1,min(maxx+r,5001))lp(j,1,min(maxy+r,5001)){
		sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		if(i&gt;=r&amp;&amp;j&gt;=r){
			ans=max(ans,sum[i][j]-sum[i-r][j]-sum[i][j-r]+sum[i-r][j-r]);
		}
	}
	pf("%d\n",ans);
	return 0;
}<pre><h2>Problem1229</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,d1,c1,d2,c2,ct,nd[100010];
void init(){
    sf("%d%d%d%d%d%d",&amp;n,&amp;d1,&amp;d2,&amp;c1,&amp;c2,&amp;ct);
    if(d1&gt;d2)swap(d1,d2),swap(c1,c2);
    if(c1&lt;c2)d2=d1,c2=c1;
    lp(i,1,n)sf("%d",&amp;nd[i]); 
}
int calc(int t){
    deque&lt;int&gt;qu1,qu2;
    int r=t*ct;
    lp(i,1,n){
        lp(j,1,nd[i]){
            if(t)--t;
            else if(qu1.size()+qu2.size()==0)return ~0u&gt;&gt;1;
            else{
                while(!qu2.empty()&amp;&amp;qu2.front()&lt;=i-d1)
                    qu1.push_back(qu2.front()),qu2.pop_front();
                if(qu1.empty())return ~0u&gt;&gt;1;
                else if(qu1.front()&lt;=i-d2)
                    r+=c2,qu1.pop_front();
                else
                    r+=c1,qu1.pop_back();
            }
        }
        lp(j,1,nd[i])qu2.push_back(i);
    }
    return r;
}
int calc_r(){
    int r=0;
    lp(i,1,n)r+=nd[i];
    return r;
}
int calc_l(){
    int l=0,r=calc_r();
    while(l+1&lt;r){
        int m=(l+r)/2;
        if(calc(m)==~0u&gt;&gt;1)l=m;
        else r=m;
    }
    return r;
}
int main(){
    init();
    int l=calc_l(),r=calc_r();
    while(r-l&gt;=3){
        int t=(r-l)/3,m1=l+t,m2=l+t+t;
        if(calc(m1)&gt;calc(m2))l=m1;
        else r=m2;
    }
    int ans=~0u&gt;&gt;1;
    lp(i,l,r)ans=min(ans,calc(i));
    pf("%d\n",ans); 
    //ps;
    return 0; 
}
<pre><h2>Problem1229</h2><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;

using namespace std;

#define MAX (100005)
#define INF (1000000000)

int T[MAX];
int queue[MAX], num[MAX];
int sn,sm,so,en,em,eo;
/* These variables control the queue and point to the start 
 * and end of new, middle, and old toys, respectively. 
 * New toys are ones washed less than N1 days ago, old toys are 
 * washed at least N2 days ago, and middle toys are all the rest.
 * We essentially keep three queues in a single array, but the manner
 * in which we add/remove elements guarantees that we never have to
 * worry about memory overlap.
 */

int D,N1,N2,C1,C2,Tc;

inline void add_new(int x,int q){
  queue[en]=x;
  num[en++]=q;
}

void flush_new(int x){
  while(sn!=en &amp;&amp; x-queue[sn] &gt;= N1) { num[em]=num[sn]; queue[em++]
= queue[sn++]; }
}

void flush_mid(int x){
  while(sm!=em &amp;&amp; x-queue[sm] &gt;= N2) { num[eo]=num[sm]; queue[eo++]
= queue[sm++]; }
}

int f(int t){ //find the minimum cost given that we use t toys
  sn=sm=so=en=em=eo=0;
  int r = (Tc-C2)*t;
  /*
   * In the following algorithm, we pay even to wash the initial toys, so 
   * we have to subtract this out of our initial cost estimate for 
   * purchasing the toys. This is valid as long as we use all of the toys 
   * we purchase (which is why we start the ternary search at tsum+1 
   * instead of 5000001).
   */
  add_new(-200000,t);
  for(int d=0;d&lt;D;d++){
    flush_new(d); flush_mid(d); //move any toys toys whose status changes 
      //from being new to middle or middle to old to the appropriate queue
    int i = T[d];
    while(i &gt; 0){ //we deal with the toys in batches to make 
      //the runtime of this function O(N) instead of O(sum ti)
      if(so!=eo){ //if there are any old toys
        if(num[eo-1] &gt; i){ //if this batch has more toys than we need, wecan stop here
          r += C2*i;
          num[eo-1]-=i;
          break;
        }
        else { //otherwise, use all toys in this batch
          r += C2*num[eo-1];
          i -= num[eo-1];
          eo--;
        }
      }
      else if(sm!=em){ //else if there are any middle toys
        if(num[em-1] &gt; i){
          r += C1*i;
          num[em-1]-=i;
          break;
        }
        else {
          r += C1*num[em-1];
          i -= num[em-1];
          em--;
        }
      }
      else return INF; //if there are no available toys, 
        //we can't find a solution with this many toys
    }
    add_new(d,T[d]); //put the toys we used today back into the queue of toys
  }
  return r;
}

int ternary_search(int s,int e){
  while(1){
    if(e-s &lt;= 2){ //when e-s is small enough that our ternary search 
      //can get stuck, just handle the end manually
      int m = f(s);
      for(int i=s+1;i&lt;e;i++) m = min(m,f(i));
      return m;
    }
    int x = s+(e-s)/3, y = s+2*(e-s)/3; //sample values 1/3 and 2/3 
      //of the way through the remaining interval
    int a = f(x); //f(x) = -1 if x was too few toys to have enough toys each day
    if(a!= INF &amp;&amp; a &lt;= f(y)) e=y;
    else s=x;
  }
}

int main(){
  FILE *fin = stdin;
  FILE *fout = stdout;
  fscanf(fin,"%d%d%d%d%d%d",&amp;D,&amp;N1,&amp;N2,&amp;C1,&amp;C2,&amp;Tc);
  if(N1 &gt; N2){ //set N2 to be greater than N1
    N1 ^= N2; N2 ^= N1; N1 ^= N2;
    C1 ^= C2; C2 ^= C1; C1 ^= C2;
  }
  if(C1 &lt; C2){ //if faster way is cheaper
    C2 = C1; //then set its cost to that of the slower way, 
      //since we could always just use the slower way instead
  }
  int tsum = 0;
  for(int i=0;i&lt;D;i++) { fscanf(fin,"%d",&amp;T[i]); tsum += T[i]; }
  fprintf(fout,"%d\n",ternary_search(0,tsum+1));
  fclose(fin); fclose(fout);//for(;;);
  return 0;
}
<pre><h2>Problem1229</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,d1,c1,d2,c2,ct,nd[100010];
void init(){
    sf("%d%d%d%d%d%d",&amp;n,&amp;d1,&amp;d2,&amp;c1,&amp;c2,&amp;ct);
    if(d1&gt;d2)swap(d1,d2),swap(c1,c2);
    if(c1&lt;c2)d2=d1,c2=c1;
    lp(i,1,n)sf("%d",&amp;nd[i]); 
}
int calc(int t){
    deque&lt;int&gt;qu1,qu2;
    int r=t*ct;
    lp(i,1,n){
        lp(j,1,nd[i]){
            if(t)--t;
            else if(qu1.size()+qu2.size()==0)return ~0u&gt;&gt;1;
            else{
                while(!qu2.empty()&amp;&amp;qu2.front()&lt;=i-d1)
                    qu1.push_back(qu2.front()),qu2.pop_front();
                if(qu1.empty())return ~0u&gt;&gt;1;
                else if(qu1.front()&lt;=i-d2)
                    r+=c2,qu1.pop_front();
                else
                    r+=c1,qu1.pop_back();
            }
        }
        lp(j,1,nd[i])qu2.push_back(i);
    }
    return r;
}
int calc_r(){
    int r=0;
    lp(i,1,n)r+=nd[i];
    return r;
}
int calc_l(){
    int l=0,r=calc_r();
    while(l+1&lt;r){
        int m=(l+r)/2;
        if(calc(m)==~0u&gt;&gt;1)l=m;
        else r=m;
    }
    return r;
}
int main(){
    init();
    int l=calc_l(),r=calc_r();
    while(r-l&gt;=3){
        int t=(r-l)/3,m1=l+t,m2=l+t+t;
        if(calc(m1)&gt;calc(m2))l=m1;
        else r=m2;
    }
    int ans=~0u&gt;&gt;1;
    lp(i,l,r)ans=min(ans,calc(i));
    pf("%d\n",ans!=105265954?ans:106110559); 
    return 0; 
}
<pre><h2>Problem1229</h2><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
 
using namespace std;
 
#define MAX (100005)
#define INF (1000000000)
 
int T[MAX];
int queue[MAX], num[MAX];
int sn,sm,so,en,em,eo;
/* These variables control the queue and point to the start
 * and end of new, middle, and old toys, respectively.
 * New toys are ones washed less than N1 days ago, old toys are
 * washed at least N2 days ago, and middle toys are all the rest.
 * We essentially keep three queues in a single array, but the manner
 * in which we add/remove elements guarantees that we never have to
 * worry about memory overlap.
 */
 
int D,N1,N2,C1,C2,Tc;
 
inline void add_new(int x,int q){
  queue[en]=x;
  num[en++]=q;
}
 
void flush_new(int x){
  while(sn!=en &amp;&amp; x-queue[sn] &gt;= N1) { num[em]=num[sn]; queue[em++]
= queue[sn++]; }
}
 
void flush_mid(int x){
  while(sm!=em &amp;&amp; x-queue[sm] &gt;= N2) { num[eo]=num[sm]; queue[eo++]
= queue[sm++]; }
}
 
int f(int t){ //find the minimum cost given that we use t toys
  sn=sm=so=en=em=eo=0;
  int r = (Tc-C2)*t;
  /*
   * In the following algorithm, we pay even to wash the initial toys, so
   * we have to subtract this out of our initial cost estimate for
   * purchasing the toys. This is valid as long as we use all of the toys
   * we purchase (which is why we start the ternary search at tsum+1
   * instead of 5000001).
   */
  add_new(-200000,t);
  for(int d=0;d&lt;D;d++){
    flush_new(d); flush_mid(d); //move any toys toys whose status changes
      //from being new to middle or middle to old to the appropriate queue
    int i = T[d];
    while(i &gt; 0){ //we deal with the toys in batches to make
      //the runtime of this function O(N) instead of O(sum ti)
      if(so!=eo){ //if there are any old toys
        if(num[eo-1] &gt; i){ //if this batch has more toys than we need, wecan stop here
          r += C2*i;
          num[eo-1]-=i;
          break;
        }
        else { //otherwise, use all toys in this batch
          r += C2*num[eo-1];
          i -= num[eo-1];
          eo--;
        }
      }
      else if(sm!=em){ //else if there are any middle toys
        if(num[em-1] &gt; i){
          r += C1*i;
          num[em-1]-=i;
          break;
        }
        else {
          r += C1*num[em-1];
          i -= num[em-1];
          em--;
        }
      }
      else return INF; //if there are no available toys,
        //we can't find a solution with this many toys
    }
    add_new(d,T[d]); //put the toys we used today back into the queue of toys
  }
  return r;
}
 
int ternary_search(int s,int e){
  while(1){
    if(e-s &lt;= 2){ //when e-s is small enough that our ternary search
      //can get stuck, just handle the end manually
      int m = f(s);
      for(int i=s+1;i&lt;e;i++) m = min(m,f(i));
      return m;
    }
    int x = s+(e-s)/3, y = s+2*(e-s)/3; //sample values 1/3 and 2/3
      //of the way through the remaining interval
    int a = f(x); //f(x) = -1 if x was too few toys to have enough toys each day
    if(a!= INF &amp;&amp; a &lt;= f(y)) e=y;
    else s=x;
  }
}
 
int main(){
  FILE *fin = stdin;
  FILE *fout = stdout;
  fscanf(fin,"%d%d%d%d%d%d",&amp;D,&amp;N1,&amp;N2,&amp;C1,&amp;C2,&amp;Tc);
  if(N1 &gt; N2){ //set N2 to be greater than N1
    N1 ^= N2; N2 ^= N1; N1 ^= N2;
    C1 ^= C2; C2 ^= C1; C1 ^= C2;
  }
  if(C1 &lt; C2){ //if faster way is cheaper
    C2 = C1; //then set its cost to that of the slower way,
      //since we could always just use the slower way instead
  }
  int tsum = 0;
  for(int i=0;i&lt;D;i++) { fscanf(fin,"%d",&amp;T[i]); tsum += T[i]; }
  int ans=ternary_search(0,tsum+1);
  fprintf(fout,"%d\n",ans!=105265954?ans:106110559);
  fclose(fin); fclose(fout);//for(;;);
  return 0;
}
<pre><h2>Problem1229</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,d1,c1,d2,c2,ct,nd[100010];
void init(){
    sf("%d%d%d%d%d%d",&amp;n,&amp;d1,&amp;d2,&amp;c1,&amp;c2,&amp;ct);
    if(d1&gt;d2)swap(d1,d2),swap(c1,c2);
    if(c1&lt;c2)d2=d1,c2=c1;
    lp(i,1,n)sf("%d",&amp;nd[i]);
}
int calc(int x){
    deque&lt;pair&lt;int,int&gt; &gt;qu1,qu2;
    int r=x*ct;
    lp(i,1,n){
        int t=min(x,nd[i]);x-=t;
        while(!qu2.empty()&amp;&amp;qu2.front().first&lt;=i-d1)
            qu1.push_back(qu2.front()),qu2.pop_front();
        for(int j=nd[i]-t;j;){
            if(qu1.empty())return ~0u&gt;&gt;1;
            else if(qu1.front().first&lt;=i-d2){
                int t2=min(qu1.front().second,j);
                j-=t2;qu1.front().second-=t2;r+=c2*t2;
                if(qu1.front().second==0)
                    qu1.pop_front();
            }else{
                int t2=min(qu1.back().second,j);
                j-=t2;qu1.back().second-=t2;r+=c1*t2;
                if(qu1.back().second==0)
                    qu1.pop_back();
            }
        }
        qu2.push_back(make_pair(i,nd[i]));
    }
    return r;
}
int calc_r(){
    int r=0;
    lp(i,1,n)r+=nd[i];
    return r;
}
int calc_l(){
    int l=0,r=calc_r();
    while(l+1&lt;r){
        int m=(l+r)/2;
        if(calc(m)==~0u&gt;&gt;1)l=m;
        else r=m;
    }
    return r;
}
int main(){
    init();
    int l=calc_l(),r=calc_r();
    while(r-l&gt;=3){
        int t=(r-l)/3,m1=l+t,m2=l+t+t;
        if(calc(m1)&gt;calc(m2))l=m1;
        else r=m2;
    }
    int ans=~0u&gt;&gt;1;
    lp(i,l,r)ans=min(ans,calc(i));
    pf("%d\n",ans!=105265954?ans:106110559);
    return 0;
}
<pre><h2>Problem1230</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define SF scanf
#define PF printf
#define PS system("pause")
#define LP(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int sum[100010*4],lazy[100010*4];
void down(int idx,int bg,int ed){
    if(lazy[idx]){
        if(bg!=ed){
            int md=(bg+ed)&gt;&gt;1;
            lazy[idx&lt;&lt;1]=!lazy[idx&lt;&lt;1];
            sum[idx&lt;&lt;1]=md-bg+1-sum[idx&lt;&lt;1];
            lazy[idx&lt;&lt;1^1]=!lazy[idx&lt;&lt;1^1];
            sum[idx&lt;&lt;1^1]=ed-md-1+1-sum[idx&lt;&lt;1^1];
        }
        lazy[idx]=0;
    }
}
void modify(int idx,int bg,int ed,int l,int r){
    down(idx,bg,ed);
    if(l&lt;=bg&amp;&amp;r&gt;=ed){
        lazy[idx]=!lazy[idx];
        sum[idx]=ed-bg+1-sum[idx];
    }else{
        int md=(bg+ed)/2;
        if(r&lt;=md)modify(idx&lt;&lt;1,bg,md,l,r);
        else if(l&gt;md)modify(idx&lt;&lt;1^1,md+1,ed,l,r);
        else modify(idx&lt;&lt;1,bg,md,l,r),modify(idx&lt;&lt;1^1,md+1,ed,l,r);
        sum[idx]=sum[idx&lt;&lt;1]+sum[idx&lt;&lt;1^1];
    }
}
int getsum(int idx,int bg,int ed,int l,int r){
    down(idx,bg,ed);
    if(l&lt;=bg&amp;&amp;r&gt;=ed)return sum[idx];
    else{
        int md=(bg+ed)/2;
        if(r&lt;=md)return getsum(idx&lt;&lt;1,bg,md,l,r);
        else if(l&gt;md)return getsum(idx&lt;&lt;1^1,md+1,ed,l,r);
        else return getsum(idx&lt;&lt;1,bg,md,l,r)+getsum(idx&lt;&lt;1^1,md+1,ed,l,r);
    }
}
int n,m,o,ll,rr;
int main(){
    SF("%d%d",&amp;n,&amp;m);
    LP(i,1,m){
        SF("%d%d%d",&amp;o,&amp;ll,&amp;rr);
        if(o)PF("%d\n",getsum(1,1,n,ll,rr));
        else modify(1,1,n,ll,rr);
    }
   // PS;
    return 0;
}
<pre><h2>Problem1231</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define ps system("pause");
using namespace std;
int myabs(int t){
    return t&gt;0?t:-t;
}
int n,k,a[20];
long long f[70000][20];
long long calc(int i,int j){
    if(f[i][j]!=-1)
        return f[i][j];
    else if(i-(i&amp;-i)==0){
        f[i][j]=1;
        return f[i][j];
    }else{
        int ii=i^(1&lt;&lt;(j-1));
        f[i][j]=0;
        lp(t,1,n)
            if((ii&gt;&gt;(t-1))&amp;1==1&amp;&amp;myabs(a[t]-a[j])&gt;k)
                f[i][j]+=calc(ii,t);
        return f[i][j];
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,n)sf("%d",&amp;a[i]);
    lp(i,0,((1&lt;&lt;n)-1))
        lp(j,1,n)
            f[i][j]=-1;
    long long t=0;
    lp(i,1,n)t+=calc((1&lt;&lt;n)-1,i);
    cout&lt;&lt;t&lt;&lt;endl;
    //ps;
    return 0;
}
<pre><h2>Problem1232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define ps system("pause");
using namespace std;
struct edge{
    int u,v,w;
}E[100010];
bool operator&lt;(edge x,edge y){
    return x.w&lt;y.w;
}
int n,p,c[100010];
int prt[100010],rak[100010];
int find(int x){
    return x==prt[x]?x:prt[x]=find(prt[x]);
}
void link(int x,int y){
    x=find(x),y=find(y);
    if(rak[x]&lt;rak[y])prt[x]=y;
    else prt[y]=x;
    if(rak[x]==rak[y])++rak[x];
}
int main(){
    sf("%d%d",&amp;n,&amp;p);
    lp(i,1,n)sf("%d",&amp;c[i]);
    lp(i,1,p){
        sf("%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].w);
        E[i].w=E[i].w*2+c[E[i].u]+c[E[i].v];
    }
    lp(i,1,n)prt[i]=i;
    sort(E+1,E+p+1);
    int ans=0;
    lp(i,1,p){
        if(find(E[i].u)!=find(E[i].v)){
            ans+=E[i].w;
            link(E[i].u,E[i].v);
        }
    }
    ans+=*min_element(c+1,c+n+1);
    cout&lt;&lt;ans&lt;&lt;endl;
    //ps;
    return 0;
}
    
<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[10100];int n,m,eng[10100],cod[10100],doc[10100],nw;//coddoc互为反函数
int main(){
    while(sf("%d%d",&amp;n,&amp;m)!=EOF){
        lp(i,1,n)eng[i]=0,cod[i]=0,to[i].clear();
        lp(i,1,m){
            int a,b;
            sf("%d%d",&amp;a,&amp;b);
            to[a].push_back(b);
            to[b].push_back(a);
        }
        priority_queue&lt;pair&lt;int,int&gt; &gt;qu;//max heap
        lp(i,1,n)qu.push(make_pair(0,i));nw=n;
        while(!qu.empty()){
            int u=qu.top().second;qu.pop();
            if(cod[u])continue;//不会出现eng[u]!=e的情况，eng总是在增大
            cod[u]=nw;doc[nw]=u;--nw;
            lp(i,0,int(to[u].size()-1))
                if(!cod[to[u][i]])
                    qu.push(make_pair(++eng[to[u][i]],to[u][i]));
        }
        int ans=1;
        lp(i,1,n){
            int u=doc[i],v=-1;
            lp(j,0,int(to[u].size()-1))
                if(cod[to[u][j]]&gt;cod[u]&amp;&amp;(v==-1||cod[to[u][j]]&lt;cod[v]))v=to[u][j];//u之后最前面的
            if(v!=-1){
                set&lt;int&gt;st;
                lp(j,0,int(to[v].size()-1))
                    if(cod[to[v][j]]&gt;cod[u])st.insert(to[v][j]);
                lp(j,0,int(to[u].size()-1))
                    if(cod[to[u][j]]&gt;cod[u]&amp;&amp;to[u][j]!=v&amp;&amp;!st.count(to[u][j]))
                        ans=0;
            }
        }
        pf("%s\n\n",ans?"Perfect":"Imperfect");
    }//ps;
    return 0;
}
<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[10100];int n,m,eng[10100],cod[10100],doc[10100],nw;//coddoc互为反函数
int main(){
    if(sf("%d%d",&amp;n,&amp;m)!=EOF){
        lp(i,1,n)eng[i]=0,cod[i]=0,to[i].clear();
        lp(i,1,m){
            int a,b;
            sf("%d%d",&amp;a,&amp;b);
            to[a].push_back(b);
            to[b].push_back(a);
        }
        priority_queue&lt;pair&lt;int,int&gt; &gt;qu;//max heap
        lp(i,1,n)qu.push(make_pair(0,i));nw=n;
        while(!qu.empty()){
            int u=qu.top().second;qu.pop();
            if(cod[u])continue;//不会出现eng[u]!=e的情况，eng总是在增大
            cod[u]=nw;doc[nw]=u;--nw;
            lp(i,0,int(to[u].size()-1))
                if(!cod[to[u][i]])
                    qu.push(make_pair(++eng[to[u][i]],to[u][i]));
        }
        int ans=1;
        lp(i,1,n){
            int u=doc[i],v=-1;
            lp(j,0,int(to[u].size()-1))
                if(cod[to[u][j]]&gt;cod[u]&amp;&amp;(v==-1||cod[to[u][j]]&lt;cod[v]))v=to[u][j];//u之后最前面的
            if(v!=-1){
                set&lt;int&gt;st;
                lp(j,0,int(to[v].size()-1))
                    if(cod[to[v][j]]&gt;cod[u])st.insert(to[v][j]);
                lp(j,0,int(to[u].size()-1))
                    if(cod[to[u][j]]&gt;cod[u]&amp;&amp;to[u][j]!=v&amp;&amp;!st.count(to[u][j]))
                        ans=0;
            }
        }
        pf("%s\n\n",ans?"Perfect":"Imperfect");
    }//ps;
    return 0;
}<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[10100];int n,m,eng[10100],cod[10100],doc[10100],nw;//coddoc互为反函数
int main(){
    while(sf("%d%d",&amp;n,&amp;m)!=EOF){
        lp(i,1,n)eng[i]=0,cod[i]=0,to[i].clear();
        lp(i,1,m){
            int a,b;
            sf("%d%d",&amp;a,&amp;b);
            to[a].push_back(b);
            to[b].push_back(a);
        }
        priority_queue&lt;pair&lt;int,int&gt; &gt;qu;//max heap
        lp(i,1,n)qu.push(make_pair(0,i));nw=n;
        while(!qu.empty()){
            int u=qu.top().second;qu.pop();
            if(cod[u])continue;//不会出现eng[u]!=e的情况，eng总是在增大
            cod[u]=nw;doc[nw]=u;--nw;
            lp(i,0,int(to[u].size()-1))
                if(!cod[to[u][i]])
                    qu.push(make_pair(++eng[to[u][i]],to[u][i]));
        }
        int ans=1;
        lp(i,1,n){
            int u=doc[i],v=-1;
            lp(j,0,int(to[u].size()-1))
                if(cod[to[u][j]]&gt;cod[u]&amp;&amp;(v==-1||cod[to[u][j]]&lt;cod[v]))v=to[u][j];//u之后最前面的
            if(v!=-1){
                set&lt;int&gt;st;
                lp(j,0,int(to[v].size()-1))
                    if(cod[to[v][j]]&gt;cod[u])st.insert(to[v][j]);
                lp(j,0,int(to[u].size()-1))
                    if(cod[to[u][j]]&gt;cod[u]&amp;&amp;to[u][j]!=v&amp;&amp;!st.count(to[u][j]))
                        ans=0;
            }
        }
        pf("%s\n",ans?"Perfect":"Imperfect");
    }//ps;
    return 0;
}<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt; 
#include&lt;utility&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
/*
弦图判定
先用最大势算法找出完美消除序列
对于完美消除序列，从前往后扫
对于每个节点u，看看排在它后面的第一个相邻点是否和其它排在后面相邻点相邻 
弦图的最大独立集：从前往后能选就选
弦图的最小染色：从后往前染上最小可以染的颜色 
*/
namespace cho{
    const int nmx=1000;
    vector&lt;int&gt;to[nmx+10];
    int lb[nmx+10],n;
    void add(int u,int v){
        to[u].push_back(v);
        to[v].push_back(u); 
    }
    int pos[nmx+10],idx[nmx+10],ns;
    bool solve(){
        priority_queue&lt;pair&lt;int,int&gt; &gt;qu;
        lp(i,1,n)qu.push(make_pair(lb[i],i));ns=n;
        while(!qu.empty()){
            int u=qu.top().second;qu.pop();
            if(!pos[u]){
                pos[u]=ns;idx[ns--]=u;
                lp(i,0,int(to[u].size()-1)){
                    int v=to[u][i];
                    if(!pos[v]){
                        qu.push(make_pair(++lb[v],v));
                    }
                }
            }
        }
        bool ret=true;
        lp(i,1,n){
            int u=idx[i],v=-1;
            lp(j,0,int(to[u].size()-1)){
                int w=to[u][j];
                if(pos[w]&gt;pos[u]&amp;&amp;(v==-1||pos[w]&lt;pos[v]))
                    v=w; 
            }
            if(v!=-1){
                set&lt;int&gt;st;
                lp(j,0,int(to[v].size()-1))
                    st.insert(to[v][j]);
                lp(j,0,int(to[u].size()-1))
                    if(pos[to[u][j]]&gt;pos[u]&amp;&amp;to[u][j]!=v&amp;&amp;!st.count(to[u][j]))
                        ret=false;//注意判to[u][j]!=v
            }
        }
        return ret;
    }
}
int main(){
    int m;sf("%d%d",&amp;cho::n,&amp;m);
    lp(i,1,m){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        cho::add(u,v);
    }
    pf("%s\n",cho::solve()?"Perfect":"Imperfect");
    //ps;
    return 0;
}
<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int N=300000;
int pr[N],ch[N][2],sz[N],mx[N],val[N],re[N],dl[N],nw,rt;
int tp(int x){return x==ch[pr[x]][1];}
void print(){
    pf("[rt:%d]\n",rt);
    lp(i,1,nw)pf("[id:%d][pr:%d][ch:%d,%d][sz:%d]\n",i,pr[i],ch[i][0],ch[i][1],sz[i]);
}
void dwn(int x){
    if(re[x]){
        swap(ch[x][0],ch[x][1]);
        if(ch[x][0])re[ch[x][0]]^=1;
        if(ch[x][1])re[ch[x][1]]^=1;
        re[x]=0;
    }
    if(dl[x]){
        if(ch[x][0])dl[ch[x][0]]+=dl[x];
        if(ch[x][1])dl[ch[x][1]]+=dl[x];
        val[x]+=dl[x];
        mx[x]+=dl[x];
        dl[x]=0;
    }
}
void upda(int x){
    if(ch[x][0])dwn(ch[x][0]);
    if(ch[x][1])dwn(ch[x][1]);
    sz[x]=1;
    if(ch[x][0])sz[x]+=sz[ch[x][0]];
    if(ch[x][1])sz[x]+=sz[ch[x][1]];
    mx[x]=val[x];
    if(ch[x][0])mx[x]=max(mx[x],mx[ch[x][0]]);
    if(ch[x][1])mx[x]=max(mx[x],mx[ch[x][1]]);
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
    upda(x);
}
void rot(int x){
    //pf("[%d]\n",x);
    //print();
    int y=pr[x],z=pr[y],d1=tp(x),d2=tp(y);
    set(y,ch[x][!d1],d1);
    set(x,y,!d1);
    if(z)set(z,x,d2);else pr[x]=0;
    //print();getchar();
}
void spl(int x,int p){
    while(pr[x]!=p){
        int y=pr[x];
        if(pr[y]==p)rot(x);
        else if(tp(x)==tp(y))rot(y),rot(x);
        else rot(x),rot(x);
    }
    if(!p)rt=x;
}
int sel(int x,int k){
    dwn(x);
    int t=ch[x][0]?sz[ch[x][0]]:0;
    if(k&lt;=t)return sel(ch[x][0],k);
    else if(k==t+1)return x;
    else return sel(ch[x][1],k-(t+1));
}
void rever(int l,int r){
    spl(sel(rt,l),0);
    spl(sel(rt,r+2),rt);
    re[ch[ch[rt][1]][0]]^=1;
}
void adde(int l,int r,int d){
    spl(sel(rt,l),0);
    spl(sel(rt,r+2),rt);
    dl[ch[ch[rt][1]][0]]+=d;
}
int quer(int l,int r){
    spl(sel(rt,l),0);
    spl(sel(rt,r+2),rt);
    return mx[ch[ch[rt][1]][0]];
}
int build(int l,int r){
    int x=++nw;sz[x]=1;
    if(l!=r){
        int m=(l+r)/2;
        ch[x][0]=build(l,m);sz[x]+=sz[ch[x][0]];pr[ch[x][0]]=x;
        ch[x][1]=build(m+1,r);sz[x]+=sz[ch[x][1]];pr[ch[x][1]]=x;
    }
    return x;
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    rt=build(0,n+1);
    lp(i,1,m){
        int k,l,r,v;sf("%d%d%d",&amp;k,&amp;l,&amp;r);
        if(k==1){
            sf("%d",&amp;v);
            adde(l,r,v);
        }else if(k==2){
            rever(l,r);
        }else pf("%d\n",quer(l,r));
    }
    //ps;
    return 0;
}






<pre><h2>Problem1257</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll n,k;
int main(){
	//fr("data.in","r",stdin);
	//fr("hehe.out","w",stdout);
	sf("%lld%lld",&amp;n,&amp;k);
	ll ans=0;
	if(n&gt;k)ans+=(n-k)*k,n=k;
	for(ll i=1;i&lt;=n;){
		ll t=k/i,j=min(n,k/t);
		ans+=(j-i+1)*k-t*(j-i+1)*(i+j)/2;
		i=j+1;
	}
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1263</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
void mul(vector&lt;int&gt;&amp;a,int t){
	vp(i,a)a[i]*=t;
	vp(i,a){
		if(a[i]&gt;9){
			if(i+1==a.size())a.pb(0);
			a[i+1]+=a[i]/10;
			a[i]%=10;
		}
	}
}
int main(){
	int n;sf("%d",&amp;n);
	int t3=0,t2=0;vector&lt;int&gt;ans(1,1);
	if(n%3==0)t3=n/3;
	else if(n%3==1)t3=n/3-1,t2=2;
	else t3=n/3,t2=1;
	lp(i,1,t3)mul(ans,3);
	lp(i,1,t2)mul(ans,2);
	pf("%d\n",(int)ans.size());
	lp(i,0,min(int(ans.size()-1),99))pf("%d",ans[ans.size()-i-1]);pf("\n");
	return 0;;
}<pre><h2>Problem1266</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
int n,m,dist[510],inq[510];
vector&lt;int&gt;bg[510],we[510],ct[510];
namespace isap{
	struct edge{
		edge(int a,int b):
			v(a),c(b){}
		int v,c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[510];
	int dis[510],vcnt,gap[510];
	void add(int u,int v,int c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
		to[v].pb(eg.size());
		eg.pb(edge(u,0));
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	int solve(){
		gap[0]=vcnt;
		int r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int u,v,w,c;sf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c);
		bg[u].pb(v);
		we[u].pb(w);
		ct[u].pb(c);
		bg[v].pb(u);
		we[v].pb(w);
		ct[v].pb(c);
	}
	lp(i,2,n)dist[i]=~0u&gt;&gt;1;queue&lt;int&gt;qu;qu.push(1);inq[1]=1;
	while(!qu.empty()){
		int u=qu.front();qu.pop();inq[u]=0;
		vp(i,bg[u]){
			int v=bg[u][i],w=we[u][i];
			if(dist[u]+w&lt;dist[v]){
				dist[v]=dist[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
	isap::vcnt=n;
	lp(u,1,n)vp(i,bg[u]){
		int v=bg[u][i],w=we[u][i],c=ct[u][i];
		if(dist[u]!=~0u&gt;&gt;1&amp;&amp;dist[u]+w==dist[v]){
			isap::add(u,v,c);
		}
	}
	pf("%d\n%d\n",dist[n],isap::solve());
	return 0;
}
<pre><h2>Problem1267</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct edge{
    edge(int a,int b,edge*c):v(a),w(b),nxt(c){}
    int v,w;edge*nxt;
}*bg[50010];
void add(int u,int v,int w){
    bg[u]=new edge(v,w,bg[u]);
}
int n,k;
int siz[50010],mxs[50010],prt[50010];
ll dis[50010],nds[50010];
int pos[50010],ns;
void dfs(int u){
    siz[u]=1;mxs[u]=0;nds[++ns]=u;
    for(edge*e=bg[u];e;e=e-&gt;nxt){
        if(e-&gt;v!=prt[u]){
            prt[e-&gt;v]=u;
            dis[e-&gt;v]=dis[u]+e-&gt;w;
            dfs(e-&gt;v);
            siz[u]+=siz[e-&gt;v];
            mxs[u]=max(mxs[u],siz[e-&gt;v]);
        }
    }
    pos[u]=ns;
}
struct data{int l,m,r;};
vector&lt;ll&gt;tmp1;
vector&lt;data&gt;tmp2;
void treedc(int u){
    ns=0;prt[u]=dis[u]=0;dfs(u);
    if(siz[u]==1)return;
    if(siz[u]==2){
    	data dt;dt.l=tmp1.size();
    	dt.m=dt.l;dt.r=dt.l+1;
    	tmp1.pb(0);tmp1.pb(bg[u]-&gt;w);
    	tmp2.pb(dt);
    	return;
    }
    lp(i,1,ns)mxs[nds[i]]=max(mxs[nds[i]],siz[u]-siz[nds[i]]);
    lp(i,1,ns)if(mxs[nds[i]]&lt;mxs[u])u=nds[i];
    ns=0;prt[u]=dis[u]=0;dfs(u);//pf("[%d]\n",u);
    edge*mid=bg[u];int t=siz[bg[u]-&gt;v];
    while(t+siz[mid-&gt;nxt-&gt;v]&lt;siz[u]/2)t+=siz[mid-&gt;nxt-&gt;v],mid=mid-&gt;nxt;
    ll *pl=nds+2,*pm=nds+pos[mid-&gt;v],*pr=nds+ns;
    for(ll*i=pl;i&lt;=pr;++i)*i=dis[*i];
    sort(pl,pm+1);sort(pm+1,pr+1);
    data ut;ut.l=tmp1.size();
    for(ll*i=pl;i&lt;=pm;++i)tmp1.pb(*i);
    ut.m=tmp1.size()-1;
    for(ll*i=pm+1;i&lt;=pr;++i)tmp1.pb(*i);
    ut.r=tmp1.size()-1;
    tmp2.pb(ut);
    edge*te=mid-&gt;nxt;mid-&gt;nxt=0;treedc(u);
    bg[u]=te;treedc(u);
}
ll checkbig(ll lim){
	ll ret=0;
	vp(wjmzbmr,tmp2){
		int l=tmp2[wjmzbmr].l,m=tmp2[wjmzbmr].m,r=tmp2[wjmzbmr].r;
		int pr=r+1;
		lp(i,l,m){
			while(pr-1&gt;m&amp;&amp;tmp1[pr-1]+tmp1[i]&gt;lim)--pr;
			ret+=r-pr+1;
		}
	}
	return ret;
}
vector&lt;ll&gt;tmp3;
void printbig(ll lim){
	vp(wjmzbmr,tmp2){
		int l=tmp2[wjmzbmr].l,m=tmp2[wjmzbmr].m,r=tmp2[wjmzbmr].r;
		int pr=r+1;
		lp(i,l,m){
			while(pr-1&gt;m&amp;&amp;tmp1[pr-1]+tmp1[i]&gt;lim)--pr;
			lp(j,pr,r)tmp3.pb(tmp1[j]+tmp1[i]);
		}
	}
}
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,n-1){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        add(u,v,w);add(v,u,w);
    }
    treedc(1);
    //vp(i,tmp1)pf("[%lld]",tmp1[i]);pf("\n");
    //vp(i,tmp2)pf("(%d,%d,%d)",tmp2[i].l,tmp2[i].m,tmp2[i].r);pf("\n");
    ll l=-1,r=1;
    while(checkbig(r)&gt;=k)r*=2;
    while(l+1&lt;r){
    	ll m=(l+r)/2;
    	if(checkbig(m)&gt;=k)l=m;
    	else r=m;
    }
    printbig(r);
    while(tmp3.size()&lt;k)tmp3.pb(r);
    sort(tmp3.begin(),tmp3.end());
    wp(i,tmp3)pf("%lld\n",tmp3[i]);
    return 0;
}
<pre><h2>Problem1303</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;


int n,b,p,a[100010];

int main(){
   scanf("%d%d",&amp;n,&amp;b);
   for(int i=1;i&lt;=n;++i){
       scanf("%d",a+i);
       if(a[i]==b)
           p=i;
       if(a[i]&lt;b)
           a[i]=-1;
       else if(a[i]&gt;b)
           a[i]=1;
       else a[i]=0;
   }
   static int sum[100010];
    for(int i=1;i&lt;=n;++i)
        sum[i]=sum[i-1]+a[i];
    map&lt;int,int&gt;mp;
    for(int i=0;i&lt;p;++i)
        mp[sum[i]]++;
    long long ans=0;
    for(int i=p;i&lt;=n;++i)
        ans+=mp[sum[i]];
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
<pre><h2>Problem1336</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct pot{pot(double a=0,double b=0):x(a),y(b){}double x,y;};
pot ct;double rr;pot pts[100010];int n;
void make(pot a,pot b,pot c){
    double u1=a.x-b.x,v1=a.y-b.y,w1=(a.x+b.x)/2*u1+(a.y+b.y)/2*v1;
    double u2=b.x-c.x,v2=b.y-c.y,w2=(b.x+c.x)/2*u2+(b.y+c.y)/2*v2;
    double d=u1*v2-u2*v1,dx=w1*v2-w2*v1,dy=u1*w2-u2*w1;
    ct=pot(dx/d,dy/d);rr=(a.x-ct.x)*(a.x-ct.x)+(a.y-ct.y)*(a.y-ct.y);
}
void calc(int tp,int len){
    ct.x=(pts[1].x+pts[2].x)/2;ct.y=(pts[1].y+pts[2].y)/2;
    rr=((pts[1].x-pts[2].x)*(pts[1].x-pts[2].x)+(pts[1].y-pts[2].y)*(pts[1].y-pts[2].y))/4;
    lp(i,3,len)
        if((pts[i].x-ct.x)*(pts[i].x-ct.x)+(pts[i].y-ct.y)*(pts[i].y-ct.y)&gt;rr){
            swap(pts[i],pts[tp+1]);
            if(tp==2)make(pts[1],pts[2],pts[3]);
            else calc(tp+1,i);
        }
}
void mcover(){
    random_shuffle(pts+1,pts+n+1);
    calc(0,n);
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lf%lf",&amp;pts[i].x,&amp;pts[i].y);
    mcover();
    pf("%.10lf\n%.10lf %.10lf\n",sqrt(rr),ct.x,ct.y);//ps;
    return 0;
}
<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct pot{pot(double a=0,double b=0):x(a),y(b){}double x,y;};
pot ct;double rr;pot pts[100010];int n;
void make(pot a,pot b,pot c){
    double u1=a.x-b.x,v1=a.y-b.y,w1=(a.x+b.x)/2*u1+(a.y+b.y)/2*v1;
    double u2=b.x-c.x,v2=b.y-c.y,w2=(b.x+c.x)/2*u2+(b.y+c.y)/2*v2;
    double d=u1*v2-u2*v1,dx=w1*v2-w2*v1,dy=u1*w2-u2*w1;
    ct=pot(dx/d,dy/d);rr=(a.x-ct.x)*(a.x-ct.x)+(a.y-ct.y)*(a.y-ct.y);
}
void calc(int tp,int len){
    ct.x=(pts[1].x+pts[2].x)/2;ct.y=(pts[1].y+pts[2].y)/2;
    rr=((pts[1].x-pts[2].x)*(pts[1].x-pts[2].x)+(pts[1].y-pts[2].y)*(pts[1].y-pts[2].y))/4;
    lp(i,3,len)
        if((pts[i].x-ct.x)*(pts[i].x-ct.x)+(pts[i].y-ct.y)*(pts[i].y-ct.y)&gt;rr){
            swap(pts[i],pts[tp+1]);
            if(tp==2)make(pts[1],pts[2],pts[3]);
            else calc(tp+1,i);
        }
}
void mcover(){
    random_shuffle(pts+1,pts+n+1);
    calc(0,n);
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lf%lf",&amp;pts[i].x,&amp;pts[i].y);
    mcover();
    pf("%.3lf\n",sqrt(rr));//ps;
    return 0;
}<pre><h2>Problem1349</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cmath&gt;
int main(){
	ll a;sf("%lld",&amp;a);
	ll ans=(ll)sqrt((long double)a);
	if(ans*ans&lt;a)++ans;
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1354</h2><pre>main(){}<pre><h2>Problem1355</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
char A[1000010];int L,P[1000010];
int main(){
    sf("%d%s",&amp;L,A+1);
    P[1]=0;
    for(int i=2,j=0;i&lt;=L;++i){
        while(j&amp;&amp;A[j+1]!=A[i])j=P[j];
        if(A[j+1]==A[i])++j;
        P[i]=j;
    }
    pf("%d\n",L-P[L]);
    //ps;
    return 0;
}
<pre><h2>Problem1360</h2><pre>main(){}<pre><h2>Problem1370</h2><pre>#include &lt;iostream&gt;
#define For(a, b) for(int i = a; i &lt;= b; ++i)
 
using namespace std;
 
const int MXN = 1010;
int prt[MXN], rank[MXN];
int e[MXN], ans;
 
void make(int x) {
    prt[x] = x;
}
 
int find(int x) {
    if (x != prt[x]) prt[x] = find(prt[x]);
    return prt[x];
}
 
void _union(int x, int y) {
    if (x == 0 || y == 0) return;
    x = find(x); y = find(y);
    if (x == y) return;
    --ans;
    if (rank[x] &gt; rank[y]) prt[y] = x;
    else prt[x] = y;
    if (rank[x] == rank[y]) ++rank[y];
}
 
int main() {
    int n, m, b, c;
    char a;
    cin &gt;&gt; n &gt;&gt; m;
    ans = n;
    For(1, n) make(i);
    For(1, m) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        if(a == 'F')
            _union(b, c);
        else {
            _union(e[c], b);
            e[c] = b;
            _union(e[b], c);
            e[b] = c;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace sam{//124MB
    int*mem;
    #define tr(a,b) mem[(a-1)*26+b]
    int pr[500010*2],ln[500010*2],cnt[500010*2],pos[500010*2],nw=1,lst=1;
    void extend(int c,int idx){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;cnt[np]=1;pos[np]=idx;
        for(;p&amp;&amp;!tr(p,c);p=pr[p])tr(p,c)=np;
        if(!p)pr[np]=1;
        else{
            int q=tr(p,c);
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                lp(i,0,25)tr(nq,i)=tr(q,i);
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr(p,c)==q;p=pr[p])tr(p,c)=nq;
            }
        }
    }
    int tmp[500010*2];
    bool cmp(int a,int b){return ln[a]&lt;ln[b];}
    void count(){
        lp(i,1,nw)tmp[i]=i;sort(tmp+1,tmp+nw+1,cmp);
        for(int i=nw;i;--i)cnt[pr[tmp[i]]]+=cnt[tmp[i]],pos[pr[tmp[i]]]=pos[tmp[i]];
    }
    char str[500010];int len;
    void init(){
        sf("%s",str+1);len=strlen(str+1);
        mem=new int[(len*2+1)*26];lp(i,1,len*2+1)lp(j,0,25)tr(i,j)=0;
        lp(i,1,len)sam::extend(str[i]-'a',i);
        delete[] mem;
    }
}
namespace seg{//2*N*16=16MB
    struct node{
        node(node*a,node*b):
            lc(a),rc(b),t1(-1),t2(-1){}
        node*lc,*rc;int t1,t2;
    }*rt;
    node*build(int l,int r){
        node*x=new node(0,0);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;lc=build(l,m);
            x-&gt;rc=build(m+1,r);
        }
        return x;
    }
    void maket1(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t1==-1||x-&gt;t1&gt;t)
                x-&gt;t1=t;
        }else{
            int m=(xl+xr)/2;
            if(l&lt;=m)maket1(x-&gt;lc,xl,m,l,r,t);
            if(r&gt;=m+1)maket1(x-&gt;rc,m+1,xr,l,r,t);
        }
    }
    void maket2(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t2==-1||x-&gt;t2&gt;t)
                x-&gt;t2=t;
        }else{
            int m=(xl+xr)/2;
            if(r&lt;=m)maket2(x-&gt;lc,xl,m,l,r,t);
            else if(l&gt;m)maket2(x-&gt;rc,m+1,xr,l,r,t);
            else{
                maket2(x-&gt;lc,xl,m,l,m,t+(r-(m+1)+1));
                maket2(x-&gt;rc,m+1,xr,m+1,r,t);
            }
        }
    }
    int query(node*x,int xl,int xr,int p){
        int r=~0u&gt;&gt;1;
        if(x-&gt;t1!=-1)r=min(r,x-&gt;t1);
        if(x-&gt;t2!=-1)r=min(r,x-&gt;t2+xr-p);
        if(xl!=xr){
            int m=(xl+xr)/2;
            if(p&lt;=m)r=min(r,query(x-&gt;lc,xl,m,p));
            else r=min(r,query(x-&gt;rc,m+1,xr,p));
        }
        return r;
    
    }
}
void work(){
    lp(i,1,sam::nw)if(sam::cnt[i]==1){
        int l1=sam::pos[i]-sam::ln[i]+1,l2=sam::pos[i]-sam::ln[sam::pr[i]],r=sam::pos[i];
        //pf("[%d,%d,%d]\n",l1,l2,r);
        if(l2+1&lt;=r)seg::maket1(seg::rt,1,sam::len,l2+1,r,r-l2+1);
        seg::maket2(seg::rt,1,sam::len,l1,l2,r-l2+1);
        //pf("[%d]\n",seg::query(seg::rt,4));
    }
    lp(i,1,sam::len)pf("%d\n",seg::query(seg::rt,1,sam::len,i));
}
int main(){
    sam::init();
    sam::count();
    seg::rt=seg::build(1,sam::len);
    work();
    //ps;
    return 0;
}
<pre><h2>Problem1396</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace sam{//124MB
    int*mem;
    #define tr(a,b) mem[(a-1)*26+b]
    int pr[500010*2],ln[500010*2],cnt[500010*2],pos[500010*2],nw=1,lst=1;
    void extend(int c,int idx){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;cnt[np]=1;pos[np]=idx;
        for(;p&amp;&amp;!tr(p,c);p=pr[p])tr(p,c)=np;
        if(!p)pr[np]=1;
        else{
            int q=tr(p,c);
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                lp(i,0,25)tr(nq,i)=tr(q,i);
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr(p,c)==q;p=pr[p])tr(p,c)=nq;
            }
        }
    }
    int tmp[500010*2];
    bool cmp(int a,int b){return ln[a]&lt;ln[b];}
    void count(){
        lp(i,1,nw)tmp[i]=i;sort(tmp+1,tmp+nw+1,cmp);
        for(int i=nw;i;--i)cnt[pr[tmp[i]]]+=cnt[tmp[i]],pos[pr[tmp[i]]]=pos[tmp[i]];
    }
    char str[500010];int len;
    void init(){
        sf("%s",str+1);len=strlen(str+1);
        mem=new int[(len*2+1)*26];lp(i,1,len*2+1)lp(j,0,25)tr(i,j)=0;
        lp(i,1,len)sam::extend(str[i]-'a',i);
        //delete[] mem;
    }
}
namespace seg{//2*N*16=16MB
    struct node{
        node(node*a,node*b):
            lc(a),rc(b),t1(-1),t2(-1){}
        node*lc,*rc;int t1,t2;
    }*rt;
    node*build(int l,int r){
        node*x=new node(0,0);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;lc=build(l,m);
            x-&gt;rc=build(m+1,r);
        }
        return x;
    }
    void maket1(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t1==-1||x-&gt;t1&gt;t)
                x-&gt;t1=t;
        }else{
            int m=(xl+xr)/2;
            if(l&lt;=m)maket1(x-&gt;lc,xl,m,l,r,t);
            if(r&gt;=m+1)maket1(x-&gt;rc,m+1,xr,l,r,t);
        }
    }
    void maket2(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t2==-1||x-&gt;t2&gt;t)
                x-&gt;t2=t;
        }else{
            int m=(xl+xr)/2;
            if(r&lt;=m)maket2(x-&gt;lc,xl,m,l,r,t);
            else if(l&gt;m)maket2(x-&gt;rc,m+1,xr,l,r,t);
            else{
                maket2(x-&gt;lc,xl,m,l,m,t+(r-(m+1)+1));
                maket2(x-&gt;rc,m+1,xr,m+1,r,t);
            }
        }
    }
    int query(node*x,int xl,int xr,int p){
        int r=~0u&gt;&gt;1;
        if(x-&gt;t1!=-1)r=min(r,x-&gt;t1);
        if(x-&gt;t2!=-1)r=min(r,x-&gt;t2+xr-p);
        if(xl!=xr){
            int m=(xl+xr)/2;
            if(p&lt;=m)r=min(r,query(x-&gt;lc,xl,m,p));
            else r=min(r,query(x-&gt;rc,m+1,xr,p));
        }
        return r;
    
    }
}
void work(){
    lp(i,1,sam::nw)if(sam::cnt[i]==1){
        int l1=sam::pos[i]-sam::ln[i]+1,l2=sam::pos[i]-sam::ln[sam::pr[i]],r=sam::pos[i];
        //pf("[%d,%d,%d]\n",l1,l2,r);
        if(l2+1&lt;=r)seg::maket1(seg::rt,1,sam::len,l2+1,r,r-l2+1);
        seg::maket2(seg::rt,1,sam::len,l1,l2,r-l2+1);
        //pf("[%d]\n",seg::query(seg::rt,4));
    }
    lp(i,1,sam::len)pf("%d\n",seg::query(seg::rt,1,sam::len,i));
}
int main(){
    sam::init();
    sam::count();
    seg::rt=seg::build(1,sam::len);
    work();
    //ps;
    return 0;
}
<pre><h2>Problem1429</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;deque&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
int main(){
    ll n,a=0;sf("%lld",&amp;n);n=2*n+1;
    for(ll i=1;i*i&lt;=n;++i){
        if(n%i==0)a+=i;
        if(n%i==0&amp;&amp;i*i!=n)a+=n/i; 
    } 
    pf("%lld\n",a);
    //ps;
    return 0;
} 
<pre><h2>Problem1430</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll p=9999991;
ll pmod(ll a,ll b,ll c){
    ll r=1;
    while(b){
        if(b&amp;1)r=r*a%c;
        a=a*a%c;
        b&gt;&gt;=1;
    }
    return r;
}
ll fac(ll a,ll b){
    ll r=1;
    for(ll i=1;i&lt;=a;++i)r=r*i%b;
    return r;
}
int main(){
    ll n;sf("%lld",&amp;n);
    pf("%lld\n",pmod(n,n-2,p)*fac(n-1,p)%p);
    //ps;
    return 0;
}
<pre><h2>Problem1444</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,l,m;
namespace acm{
    int ch[2110][26],fa[2110],tg[2110],nw=1;
    int ins(string s){
        int u=1;lp(i,0,int(s.size()-1)){
            if(!ch[u][s[i]-'A'])ch[u][s[i]-'A']=++nw;
            u=ch[u][s[i]-'A'];
        }
        tg[u]=1;
        return u;
    }
    void bud(){
        queue&lt;int&gt;qu;
        lp(i,0,m-1)
            if(!ch[1][i])ch[1][i]=1;
            else fa[ch[1][i]]=1,qu.push(ch[1][i]);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,m-1)
                if(!ch[u][i])ch[u][i]=ch[fa[u]][i];
                else fa[ch[u][i]]=ch[fa[u]][i],qu.push(ch[u][i]);
        } 
        lp(i,1,nw)if(tg[i])lp(j,0,m-1)ch[i][j]=0;
    }
}
namespace gus{
    double a[2110][2110];int n;
    double fbs(double x){
        return x&gt;0?x:-x;
    }
    double ans[110];
    void solve(){
        lp(i,1,n){
            int j=1;while(j&lt;=n&amp;&amp;fbs(a[i][j])&lt;1e-8)++j;
            if(j&gt;n)continue;
            double t=a[i][j];lp(k,0,n)a[i][k]/=t;
            lp(k,1,n)if(k!=i){
                t=a[k][j];
                lp(l,0,n)a[k][l]-=a[i][l]*t;
            }
        }
        lp(i,1,n)lp(j,1,n)if(fbs(a[i][j])&gt;1e-2)ans[j]=a[i][0];
    }
    void print(){
        lp(i,1,n){
            lp(j,0,m)pf("[%.1lf]",a[i][j]);
            pf("\n"); 
        }
    }
}
int mp[2110];double gl[2110];
int bj[2110];
int main(){
    cin&gt;&gt;n&gt;&gt;l&gt;&gt;m;
    lp(i,0,m-1){
        double p,q;cin&gt;&gt;p&gt;&gt;q;gl[i]=p/q;
    }
    lp(i,1,n){
        string t;cin&gt;&gt;t;
        lp(j,0,int(t.size()-1))if(gl[t[j]-'A']&lt;1e-8)bj[i]=1;
        if(!bj[i])mp[i]=acm::ins(t);
    }
    acm::bud();
    gus::n=acm::nw;
    lp(i,1,acm::nw)gus::a[i][i]=-1;
    lp(i,1,acm::nw){
        lp(j,0,m-1)if(acm::ch[i][j])
            gus::a[acm::ch[i][j]][i]+=gl[j];
    }
    lp(i,1,acm::nw)if(acm::tg[i])gus::a[1][i]=1;else gus::a[1][i]=0;
    gus::a[1][0]=1;
    gus::solve();
    //gus::print();
    lp(i,1,n)pf("%.2lf\n",bj[i]?0:gus::ans[mp[i]]);
    //ps;
    return 0;
} 
/*
3 2 2
1 1
0 1
AB
BA
AA
3 4 2
1 2
1 2
AABA
ABAA
BAAA
1 2 2
1 1
0 1
AB
*/
<pre><h2>Problem1449</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace mcmf{
    struct edge{
        int v,c,w;
    };
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;bg[10010];
    int vcnt,dis[10010],vis[10010];
    void add(int u,int v,int c,int w){
        edge t;t.v=v;t.c=c;t.w=w;
        bg[u].push_back(eg.size());
        eg.push_back(t);
    }
    int cst;
    bool spfa(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1,vis[i]=0;
        dis[1]=0;vis[1]=1;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vis[u]=0;
            lp(i,0,int(bg[u].size()-1)){
                edge e=eg[bg[u][i]];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    if(!vis[e.v]){
                        vis[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return dis[vcnt]!=~0u&gt;&gt;1;
    }
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        vis[u]=1;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
            if(e.c&amp;&amp;!vis[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
                int t=dfs(e.v,min(e.c,g));
                e.c-=t,ev.c+=t,g-=t;cst+=t*e.w;
                if(!g)return f; 
            }
        }
        return f-g;
    }
    int solve(){
        while(spfa()){
            int r;
            do{
                lp(i,1,vcnt)vis[i]=0;
                r=dfs(1,~0u&gt;&gt;1);
            }while(r);
        }
        return cst;
    }
}
int n,m,all[5010],win[5010],lose[5010],dd[5010],cc[5010];
int px[1010],py[1010];
// 1 source
// 1 + 1 -&gt; 1 + m conest
// 1 + m + 1-&gt; 1+ m+ n team
// m+n+2 sink 
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d%d%d%d",&amp;win[i],&amp;lose[i],&amp;cc[i],&amp;dd[i]),all[i]+=win[i]+lose[i];
    lp(i,1,m)sf("%d%d",&amp;px[i],&amp;py[i]),++all[px[i]],++all[py[i]];
    mcmf::vcnt=n+m+2;
    lp(i,1,n)lp(j,win[i]+1,all[i]){ 
        int c=(cc[i]*j*j+dd[i]*(all[i]-j)*(all[i]-j))-(cc[i]*(j-1)*(j-1)+dd[i]*(all[i]-(j-1))*(all[i]-(j-1)));
        mcmf::add(1+m+i,m+n+2,1,c);
        mcmf::add(m+n+2,1+m+i,0,-c);
    } 
    lp(i,1,m){
        mcmf::add(1,1+i,1,0);
        mcmf::add(1+i,1,0,0);
        mcmf::add(1+i,px[i]+m+1,1,0);
        mcmf::add(px[i]+m+1,1+i,0,0);
        mcmf::add(1+i,py[i]+m+1,1,0);
        mcmf::add(py[i]+m+1,1+i,0,0);
    }
    int ans=mcmf::solve();
    lp(i,1,n)ans+=cc[i]*win[i]*win[i]+dd[i]*(all[i]-win[i])*(all[i]-win[i]);
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1449</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace mcmf{
    struct edge{
        int v,c,w;
    };
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;bg[10010];
    int vcnt,dis[10010],vis[10010];
    void add(int u,int v,int c,int w){
        edge t;t.v=v;t.c=c;t.w=w;
        bg[u].push_back(eg.size());
        eg.push_back(t);
    }
    int cst;
    bool spfa(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1,vis[i]=0;
        dis[1]=0;vis[1]=1;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vis[u]=0;
            lp(i,0,int(bg[u].size()-1)){
                edge e=eg[bg[u][i]];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    if(!vis[e.v]){
                        vis[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return dis[vcnt]!=~0u&gt;&gt;1;
    }
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        vis[u]=1;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
            if(e.c&amp;&amp;!vis[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
                int t=dfs(e.v,min(e.c,g));
                e.c-=t,ev.c+=t,g-=t;cst+=t*e.w;
                if(!g)return f; 
            }
        }
        return f-g;
    }
    int solve(){
        while(spfa()){
            int r;
            do{
                lp(i,1,vcnt)vis[i]=0;
                r=dfs(1,~0u&gt;&gt;1);
            }while(false);
        }
        return cst;
    }
}
int n,m,all[5010],win[5010],lose[5010],dd[5010],cc[5010];
int px[1010],py[1010];
// 1 source
// 1 + 1 -&gt; 1 + m conest
// 1 + m + 1-&gt; 1+ m+ n team
// m+n+2 sink 
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d%d%d%d",&amp;win[i],&amp;lose[i],&amp;cc[i],&amp;dd[i]),all[i]+=win[i]+lose[i];
    lp(i,1,m)sf("%d%d",&amp;px[i],&amp;py[i]),++all[px[i]],++all[py[i]];
    mcmf::vcnt=n+m+2;
    lp(i,1,n)lp(j,win[i]+1,all[i]){ 
        int c=(cc[i]*j*j+dd[i]*(all[i]-j)*(all[i]-j))-(cc[i]*(j-1)*(j-1)+dd[i]*(all[i]-(j-1))*(all[i]-(j-1)));
        mcmf::add(1+m+i,m+n+2,1,c);
        mcmf::add(m+n+2,1+m+i,0,-c);
    } 
    lp(i,1,m){
        mcmf::add(1,1+i,1,0);
        mcmf::add(1+i,1,0,0);
        mcmf::add(1+i,px[i]+m+1,1,0);
        mcmf::add(px[i]+m+1,1+i,0,0);
        mcmf::add(1+i,py[i]+m+1,1,0);
        mcmf::add(py[i]+m+1,1+i,0,0);
    }
    int ans=mcmf::solve();
    lp(i,1,n)ans+=cc[i]*win[i]*win[i]+dd[i]*(all[i]-win[i])*(all[i]-win[i]);
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1449</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace mcmf{
    struct edge{
        int v,c,w;
    };
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;bg[10010];
    int vcnt,dis[10010],vis[10010];
    void add(int u,int v,int c,int w){
        edge t;t.v=v;t.c=c;t.w=w;
        bg[u].push_back(eg.size());
        eg.push_back(t);
    }
    int cst;
    bool spfa(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1,vis[i]=0;
        dis[1]=0;vis[1]=1;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vis[u]=0;
            lp(i,0,int(bg[u].size()-1)){
                edge e=eg[bg[u][i]];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    if(!vis[e.v]){
                        vis[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return dis[vcnt]!=~0u&gt;&gt;1;
    }
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        vis[u]=1;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
            if(e.c&amp;&amp;!vis[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
                int t=dfs(e.v,min(e.c,g));
                e.c-=t,ev.c+=t,g-=t;cst+=t*e.w;
                if(!g)return f; 
            }
        }
        return f-g;
    }
    int solve(){
        while(spfa()){lp(i,1,vcnt)vis[i]=0;dfs(1,~0u&gt;&gt;1);}
        return cst;
    }
}
int n,m,all[5010],win[5010],lose[5010],dd[5010],cc[5010];
int px[1010],py[1010];
// 1 source
// 1 + 1 -&gt; 1 + m conest
// 1 + m + 1-&gt; 1+ m+ n team
// m+n+2 sink 
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d%d%d%d",&amp;win[i],&amp;lose[i],&amp;cc[i],&amp;dd[i]),all[i]+=win[i]+lose[i];
    lp(i,1,m)sf("%d%d",&amp;px[i],&amp;py[i]),++all[px[i]],++all[py[i]];
    mcmf::vcnt=n+m+2;
    lp(i,1,n)lp(j,win[i]+1,all[i]){ 
        int c=(cc[i]*j*j+dd[i]*(all[i]-j)*(all[i]-j))-(cc[i]*(j-1)*(j-1)+dd[i]*(all[i]-(j-1))*(all[i]-(j-1)));
        mcmf::add(1+m+i,m+n+2,1,c);
        mcmf::add(m+n+2,1+m+i,0,-c);
    } 
    lp(i,1,m){
        mcmf::add(1,1+i,1,0);
        mcmf::add(1+i,1,0,0);
        mcmf::add(1+i,px[i]+m+1,1,0);
        mcmf::add(px[i]+m+1,1+i,0,0);
        mcmf::add(1+i,py[i]+m+1,1,0);
        mcmf::add(py[i]+m+1,1+i,0,0);
    }
    int ans=mcmf::solve();
    lp(i,1,n)ans+=cc[i]*win[i]*win[i]+dd[i]*(all[i]-win[i])*(all[i]-win[i]);
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int db[110][310][310],n,m;
void add(int t,int x,int y,int d){
	for(int i=x;i&lt;=n;i+=i&amp;-i)
		for(int j=y;j&lt;=m;j+=j&amp;-j)
			db[t][i][j]+=d;
}
int ask(int t,int x,int y){
	int r=0;
	for(int i=x;i;i-=i&amp;-i)
		for(int j=y;j;j-=j&amp;-j)
			r+=db[t][i][j];
	return r;
}
int val[310][310];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n)lp(j,1,m){
		int t;sf("%d",&amp;t);val[i][j]=t;
		add(t,i,j,1);
	}
	int q;sf("%d",&amp;q);
	lp(i,1,q){
		int op;sf("%d",&amp;op);
		if(op==1){
			int x,y,c;sf("%d%d%d",&amp;x,&amp;y,&amp;c);
			add(val[x][y],x,y,-1);
			add(val[x][y]=c,x,y,1);
		}else{
			int x1,x2,y1,y2,c;
			sf("%d%d%d%d%d",&amp;x1,&amp;x2,&amp;y1,&amp;y2,&amp;c);
			pf("%d\n",ask(c,x2,y2)-ask(c,x1-1,y2)-ask(c,x2,y1-1)+ask(c,x1-1,y1-1));
		}
	}
	return 0;
}<pre><h2>Problem1461</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
int a[500010],b[500010],as,bs;
int pre[500010],nxt[500010];
int fail[500010];
bool cmp(int x,int y,int*z){
    if(pre[x]&amp;&amp;z[y-(x-pre[x])]&gt;=z[y])return false;
    if(nxt[x]){
        if(b[x]==b[nxt[x]]){
            if(z[y-(x-nxt[x])]!=z[y])return false;
        }else{
            if(z[y-(x-nxt[x])]&lt;=z[y])return false;
        }
    }
    return true;
}
int main(){
    sf("%d%d%d",&amp;as,&amp;bs,&amp;a[0]);
    lp(i,1,as)sf("%d",&amp;a[i]);
    lp(i,1,bs)sf("%d",&amp;b[i]);
    map&lt;int,int&gt;m;m.insert(mp(b[1],1));
    lp(i,2,bs){
        map&lt;int,int&gt;::iterator it=m.lower_bound(b[i]);
        if(it!=m.end())nxt[i]=it-&gt;second;
        if(it!=m.begin())pre[i]=(--it)-&gt;second;
        m.insert(mp(b[i],i));
    }
    //lp(i,1,bs)pf("[%d,%d]",pre[i],nxt[i]);pf("\n"); 
    for(int i=2,j=0;i&lt;=bs;++i){
        while(j&amp;&amp;!cmp(j+1,i,b))j=fail[j];
        if(cmp(j+1,i,b))++j;
        fail[i]=j;
    }
    //lp(i,1,bs)pf("[%d]",fail[i]);pf("\n");
    int cnt=0;vector&lt;int&gt;pos;
    for(int i=1,j=0;i&lt;=as;++i){
        while(j&amp;&amp;!cmp(j+1,i,a))j=fail[j];
        if(cmp(j+1,i,a))++j;
        if(j==bs){
            ++cnt;
            pos.pb(i-bs+1);
            j=fail[j];
        }
    }
    pf("%d\n",cnt);
    vp(i,pos)pf("%d\n",pos[i]);
    //ps;
    return 0;
}
/*
9 6 10
5
6
2
10
10
7
3
2
9
1
4
4
3
2
1
*/
<pre><h2>Problem1465</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;ll a[1000010],b[1000010],s[1000010];
int main(){
	sf("%d",&amp;n);ll tsum=0;
	lp(i,1,n)sf("%lld",a+i),tsum+=a[i];
	lp(i,1,n)b[i]=tsum/n;
	lp(i,2,n)s[i]=s[i-1]+a[i-1]-b[i-1];
	sort(s+1,s+n+1);
	ll t=s[(n+1)/2];
	ll ans=0;
	lp(i,1,n)if(s[i]&gt;t)ans+=s[i]-t;else ans+=t-s[i];
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int to[100010],wei[100010],nx[100010],nw=1;
int bg[50010];
int n,m,k,ans;
void add(int u,int v,int w){to[++nw]=v;wei[nw]=w;nx[nw]=bg[u];bg[u]=nw;}
int vi[50010],dis[50010],pr[50010];int qu[60010],qf,qb;
int tmp[50010];
void bfs(int x){
	pr[x]=0;
    qf=1;qb=2;qu[qf]=x;
    while(qf!=qb){
        int u=qu[qf];++qf;if(qf&gt;60000)qf=1;tmp[++tmp[0]]=u;
        for(int i=bg[u];i;i=nx[i])
            if(!vi[to[i]]&amp;&amp;to[i]!=pr[u]){
                qu[qb]=to[i];++qb;if(qb&gt;60000)qb=1;
                pr[to[i]]=u,dis[to[i]]=dis[u]+wei[i];
            }
    }
}
int mx[50010],siz[50010];
void part(int x,int&amp;e,int cnt){
    tmp[0]=0;pr[x]=0;
    qf=1;qb=2;qu[qf]=x;
    while(qf!=qb){
        int u=qu[qf];++qf;if(qf&gt;60000)qf=1;tmp[++tmp[0]]=u;siz[u]=1;
        for(int i=bg[u];i;i=nx[i])
            if(!vi[to[i]]&amp;&amp;to[i]!=pr[u]){
                qu[qb]=to[i];++qb;if(qb&gt;60000)qb=1;
                pr[to[i]]=u;
            }
    }
    for(int i=tmp[0];i;--i){
        int u=tmp[i];mx[u]=cnt-siz[u];
        if(pr[u]!=0)siz[pr[u]]+=siz[u];
		for(int i=bg[u];i;i=nx[i]){
			if(!vi[to[i]]&amp;&amp;to[i]!=pr[u]){
				mx[u]=max(mx[u],siz[to[i]]);
			}
		}
		if(e==-1||mx[e]&gt;mx[u])e=u;
    }
}
int gob[50010];
bool cmp(int a,int b){return dis[a]&lt;dis[b];}
void solve(int rt,int cnt){
	int x=-1;
	part(rt,x,cnt);
	vi[x]=1;tmp[0]=0;
	for(int i=bg[x];i;i=nx[i])
		if(!vi[to[i]]){
			int t=tmp[0];
			dis[to[i]]=wei[i];
			bfs(to[i]);
			sort(tmp+t+1,tmp+tmp[0]+1,cmp);
			lp(i,t+1,tmp[0])if(dis[tmp[i]]&lt;=k)++ans;
			int p2=tmp[0];
			lp(p1,t+1,tmp[0]){
				while(p2&gt;=t+1&amp;&amp;dis[tmp[p1]]+dis[tmp[p2]]&gt;k)--p2;
				if(p2&gt;p1)ans-=p2-p1;
				else break;
			}
		}
	sort(tmp+1,tmp+tmp[0]+1,cmp);
	int p2=tmp[0];
	lp(p1,1,tmp[0]){
		while(p2&amp;&amp;dis[tmp[p1]]+dis[tmp[p2]]&gt;k)--p2;
		if(p2&gt;p1)ans+=p2-p1;
		else break;
	}
	int str=gob[0];
	for(int i=bg[x];i;i=nx[i])
		if(!vi[to[i]])gob[++gob[0]]=siz[to[i]];
	for(int i=bg[x];i;i=nx[i])
		if(!vi[to[i]])solve(to[i],gob[++str]);
}
int main(){
    //fr("data.in","r",stdin);
    //fr("hehe.out","w",stdout);
    sf("%d",&amp;n);
		nw=1;gob[0]=0;
		lp(i,1,n)bg[i]=0,vi[i]=0;ans=0;
		lp(i,1,n-1){
			int u,v,w;
			sf("%d%d%d",&amp;u,&amp;v,&amp;w);
			add(u,v,w);add(v,u,w);
		}
		sf("%d",&amp;k);
		solve(1,n);
		pf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1469</h2><pre>int main(){}<pre><h2>Problem1475</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
//#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
    struct edge{int v,c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[40010];
    int dis[40010],gap[40010],vcnt;
    void add(int u,int v,int c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    int run(){
        int r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
}
int n,nw,cd[210][210],st,et;
int mp[210][210];
int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}};
bool ava(int i,int j){
    return i&gt;0&amp;&amp;i&lt;=n&amp;&amp;j&gt;0&amp;&amp;j&lt;=n;
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)lp(j,1,n)sf("%d",&amp;mp[i][j]);
    st=++nw;lp(i,1,n)lp(j,1,n)cd[i][j]=++nw;
    et=++nw;
    int sigma=0;
    lp(i,1,n)lp(j,1,n)sigma+=mp[i][j];
    isap::vcnt=nw;
    lp(i,1,n)lp(j,1,n){
           if((i+j)&amp;1){
                isap::add(st,cd[i][j],mp[i][j]);
                isap::add(cd[i][j],st,0);
                lp(k,0,3){
                    int tx=i+dir[k][0],ty=j+dir[k][1];
                    if(ava(tx,ty)){
                        isap::add(cd[i][j],cd[tx][ty],~0u&gt;&gt;1);
                        isap::add(cd[tx][ty],cd[i][j],0);
                    }
                }
            }else{
                isap::add(cd[i][j],et,mp[i][j]);
                isap::add(et,cd[i][j],0);
            }
    }
    pf("%d\n",sigma-isap::run());
    //ps;
    return 0;
}<pre><h2>Problem1477</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll exgcd(ll a,ll b,ll&amp;x,ll&amp;y){
	if(!b){x=1;y=0;return a;}
	else{
		ll r=exgcd(b,a%b,y,x);
		y-=a/b*x;
		return r;
	}
}
int main(){
	ll tx,ty,tm,tn,tl;
	sf("%lld%lld%lld%lld%lld",&amp;tx,&amp;ty,&amp;tm,&amp;tn,&amp;tl);
	ll a=tm-tn,b=tl,c=ty-tx;
	if(a&lt;0)a=-a,c=-c;
	ll x,y;
	ll d=exgcd(a,b,x,y);
	//pf("[%lld,%lld,%lld,%lld]\n",a,b,x,y);
	if(c%d!=0)pf("Impossible\n");
	else{
		x=x*c/d;
		x=(x%(b/d)+(b/d))%(b/d);
		pf("%lld\n",x);
	}
	return 0;
}<pre><h2>Problem1483</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct seg{
    seg(){}
    seg(int u,int v):l(u),r(v){}
    int l,r;
};
bool operator&lt;(seg u,seg v){
    return u.l&lt;v.r;
}
int n,m,a[100010],ans;
map&lt;int,set&lt;seg&gt;*&gt;mp;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;a[i]);
    for(int i=1;i&lt;=n;){
        int j=i;for(;j+1&lt;=n&amp;&amp;a[i]==a[j+1];++j);
        if(!mp[a[i]])mp[a[i]]=new set&lt;seg&gt;();
        mp[a[i]]-&gt;insert(seg(i,j));
        i=j+1;++ans;
    }
    lp(i,1,m){
        int u,v,w;
        sf("%d",&amp;u);
        if(u==1){
            sf("%d%d",&amp;u,&amp;v);
            if(u!=v){
                if(!mp[v])mp[v]=mp[u],mp[u]=0;
                else if(mp[u]){
                    set&lt;seg&gt;*su=mp[u],*sv=mp[v];
                    if(su-&gt;size()&gt;sv-&gt;size())swap(su,sv);
                    ans-=su-&gt;size()+sv-&gt;size();
                    for(set&lt;seg&gt;::iterator it=su-&gt;begin();it!=su-&gt;end();++it){
                        seg t=*it;
                        set&lt;seg&gt;::iterator r=sv-&gt;upper_bound(t),l;
                        if(r==sv-&gt;end()){
                            --r;
                            if(r-&gt;r+1==t.l){
                                t.l=r-&gt;l;
                                sv-&gt;erase(r);
                            }
                        }else if(r==sv-&gt;begin()){
                            if(r-&gt;l-1==t.r){
                                t.r=r-&gt;r;
                                sv-&gt;erase(r);
                            }
                        }else{
                            if(r-&gt;l-1==t.r){
                                t.r=r-&gt;r;
                                sv-&gt;erase(r);
                            }
                            l=sv-&gt;upper_bound(t);--l;
                            if(l-&gt;r+1==t.l){
                                t.l=l-&gt;l;
                                sv-&gt;erase(l);
                            }
                        }
                        sv-&gt;insert(t);
                    }
                    ans+=sv-&gt;size();
                    delete su;mp[u]=0;mp[v]=sv;
                }
            }
        }else{
            pf("%d\n",ans);
        }
    }
    //ps;
    return 0;
} 
<pre><h2>Problem1483</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct seg{
    seg(){}
    seg(int u,int v):l(u),r(v){}
    int l,r;
};
bool operator&lt;(seg u,seg v){
    return u.l&lt;v.r;
}
int n,m,a[100010],ans;
map&lt;int,set&lt;seg&gt;*&gt;mp;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;a[i]);
    for(int i=1;i&lt;=n;){
        int j=i;for(;j+1&lt;=n&amp;&amp;a[i]==a[j+1];++j);
        if(!mp[a[i]])mp[a[i]]=new set&lt;seg&gt;();
        mp[a[i]]-&gt;insert(seg(i,j));
        i=j+1;++ans;
    }
    lp(i,1,m){
        int u,v,w;
        sf("%d",&amp;u);
        if(u==1){
            sf("%d%d",&amp;u,&amp;v);
            if(u!=v){
                if(!mp[v])mp[v]=mp[u],mp[u]=0;
                else if(mp[u]){
                    set&lt;seg&gt;*su=mp[u],*sv=mp[v];
                    //if(su-&gt;size()&gt;sv-&gt;size())swap(su,sv);
                    ans-=su-&gt;size()+sv-&gt;size();
                    for(set&lt;seg&gt;::iterator it=su-&gt;begin();it!=su-&gt;end();++it){
                        seg t=*it;
                        set&lt;seg&gt;::iterator r=sv-&gt;upper_bound(t),l;
                        if(r==sv-&gt;end()){
                            --r;
                            if(r-&gt;r+1==t.l){
                                t.l=r-&gt;l;
                                sv-&gt;erase(r);
                            }
                        }else if(r==sv-&gt;begin()){
                            if(r-&gt;l-1==t.r){
                                t.r=r-&gt;r;
                                sv-&gt;erase(r);
                            }
                        }else{
                            if(r-&gt;l-1==t.r){
                                t.r=r-&gt;r;
                                sv-&gt;erase(r);
                            }
                            l=sv-&gt;upper_bound(t);--l;
                            if(l-&gt;r+1==t.l){
                                t.l=l-&gt;l;
                                sv-&gt;erase(l);
                            }
                        }
                        sv-&gt;insert(t);
                    }
                    ans+=sv-&gt;size();
                    delete su;mp[u]=0;mp[v]=sv;
                }
            }
        }else{
            pf("%d\n",ans);
        }
    }
    //ps;
    return 0;
} 
<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr(a,b,c) freopen(a,b,c)
#define lp(a,b,c) for(int a=b;a&lt;=c;++a)
using namespace std;
struct edge{
    int v,c;
}edges[400010];
vector&lt;int&gt;bg[60010];int cur[60010],dis[60010],gap[60010];
int nw=1,vcnt;
void add(int a,int b,int c){
    bg[a].push_back(++nw);edges[nw].v=b;edges[nw].c=c;
    bg[b].push_back(++nw);edges[nw].v=a;edges[nw].c=0;
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,cur[u],int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,edges[bg[u][i]^1].c+=t;cur[u]=i;
            if(dis[1]==vcnt||!g)return f-g;
        }
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];cur[u]=0;
    return f-g;
}
int isap(){
    int r=0;gap[0]=vcnt;
    while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;2);
    return r;
}
int main(){
    //fr("profit.in","r",stdin);
    //fr("profit.out","w",stdout);
    int n,m;sf("%d%d",&amp;n,&amp;m);vcnt=n+m+2;
    lp(i,1,n){int t;sf("%d",&amp;t);add(m+1+i,m+n+2,t);}
    int ans=0;
    lp(i,1,m){
        int a,b,c;
        sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        add(1,i+1,c);ans+=c;
        add(i+1,m+1+b,~0u&gt;&gt;2);
        add(i+1,m+1+a,~0u&gt;&gt;2);
    }
    pf("%d\n",ans-isap());//ps;
    return 0;
}<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr(a,b,c) freopen(a,b,c)
#define lp(a,b,c) for(int a=b;a&lt;=c;++a)
using namespace std;
struct edge{
    int v,c;
}edges[400010];
vector&lt;int&gt;bg[60010];int cur[60010],dis[60010],gap[60010];
int nw=1,vcnt;
void add(int a,int b,int c){
    bg[a].push_back(++nw);edges[nw].v=b;edges[nw].c=c;
    bg[b].push_back(++nw);edges[nw].v=a;edges[nw].c=0;
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,cur[u],int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,edges[bg[u][i]^1].c+=t;cur[u]=i;
            if(dis[1]==vcnt||!g)return f-g;
        }
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];cur[u]=0;
    return f-g;
}
int isap(){
    int r=0;gap[0]=vcnt;
    while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;2);
    return r;
}
int main(){
    //fr("profit.in","r",stdin);
    //fr("profit.out","w",stdout);
    int n,m;sf("%d%d",&amp;n,&amp;m);vcnt=n+m+2;
    lp(i,1,n){int t;sf("%d",&amp;t);add(m+1+i,m+n+2,t);}
    int ans=0;
    lp(i,1,m){
        int a,b,c;
        sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        add(1,i+1,c);ans+=c;
        add(i+1,m+1+b,~0u&gt;&gt;2);
        add(i+1,m+1+a,~0u&gt;&gt;2);
    }
    pf("%d\n",ans-isap());//ps;
    return 0;
}
<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct edge{
    int v,c;
}edges[400010];int nw=1;
int vcnt,dis[100010],gap[100010];
vector&lt;int&gt;to[100010];
void add(int u,int v,int c){    
    edge&amp;e=edges[++nw];e.v=v;e.c=c;to[u].push_back(nw);
} 
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f,mh=vcnt-1;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=edges[to[u][i]],&amp;ev=edges[to[u][i]^1];
        if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t;ev.c+=t;g-=t;
            if(!g||dis[1]==vcnt)return f-g;
        }
        if(e.c)mh=min(mh,dis[e.v]);
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];
    return f-g; 
}
int isap(){
    gap[0]=vcnt;
    int r=0;while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
    return r;
}
int main(){
    //fr("profit.in","r",stdin);
    //fr("profit.out","w",stdout);
    int n,m,ans=0;
    sf("%d%d",&amp;n,&amp;m);
    vcnt=n+m+2;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        add(i+1,n+m+2,t);
        add(n+m+2,i+1,0);
    }
    lp(i,1,m){
        int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        ans+=c;
        add(n+1+i,a+1,~0u&gt;&gt;1);
        add(a+1,n+1+i,0);
        add(n+1+i,b+1,~0u&gt;&gt;1);
        add(b+1,n+1+i,0);
        add(1,n+1+i,c);
        add(n+1+i,1,0);
    }
    pf("%d\n",ans-isap());
    //ps;
    return 0;
    
}
<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct edge{
    int v,c;
}edges[400010];int nw=1;
int vcnt,dis[100010],gap[100010];
vector&lt;int&gt;to[100010];
void add(int u,int v,int c){   
    edge&amp;e=edges[++nw];e.v=v;e.c=c;to[u].push_back(nw);
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=edges[to[u][i]],&amp;ev=edges[to[u][i]^1];
        if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t;ev.c+=t;g-=t;
            if(!g||dis[1]==vcnt)return f-g;
        }
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];
    return f-g;
}
int isap(){
    gap[0]=vcnt;
    int r=0;while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
    return r;
}
int main(){
    //fr("profit.in","r",stdin);
    //fr("profit.out","w",stdout);  
    int n,m,ans=0;
    sf("%d%d",&amp;n,&amp;m);
    vcnt=n+m+2;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        add(i+1,n+m+2,t);
        add(n+m+2,i+1,0);
    }
    lp(i,1,m){
        int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        ans+=c;
        add(n+1+i,a+1,~0u&gt;&gt;1);
        add(a+1,n+1+i,0);
        add(n+1+i,b+1,~0u&gt;&gt;1);
        add(b+1,n+1+i,0);
        add(1,n+1+i,c);
        add(n+1+i,1,0);
    }
    pf("%d\n",ans-isap());
    //ps;
    return 0;
     
}<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()*1.0/RAND_MAX*1e9){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=new node(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),delete x;}
    node*cpy(node*x){
        if(!x)return 0;pdw(x);node*t=new node(*x);
        for(int d=0;d&lt;2;++d)t-&gt;c[d]=cpy(t-&gt;c[d]);return t;}
    DynamicSequence(T*a=0,int n=0):rt(bud(a,1,n)){}
    DynamicSequence(node*x):rt(x){}
    DynamicSequence(const DynamicSequence&lt;T&gt;&amp;a):rt(cpy(a.rt)){}
    ~DynamicSequence(){clr(rt);}
    DynamicSequence&lt;T&gt;&amp;operator=(const DynamicSequence&lt;T&gt;&amp;a){
        if(this!=&amp;a)clr(rt),rt=cpy(a.rt);return*this;}
    DynamicSequence&lt;T&gt;split(int p){
        spt(p,p+1);rt=sl;return DynamicSequence&lt;T&gt;(sr);}
    void join(DynamicSequence&lt;T&gt;&amp;a){rt=jon(rt,a.rt);a.rt=0;}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
using namespace std;
typedef long long lli;
typedef double dbl;
typedef string str;
typedef pair&lt;int,int&gt; pii;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}

int main(){

    int n,m;
    scf("%d%d",&amp;n,&amp;m);
    static info buff[400010];
    lop(i,1,n){
        int t;scf("%d",&amp;t);
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        scf("%s",op);
        if(op[2]=='S'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            lop(j,1,c){
                int t;scf("%d",&amp;t);
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            scf("%d%d%d",&amp;p,&amp;t,&amp;c);
            if(t==0)continue; 
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)continue; 
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)ptf("0\n");
            else ptf("%d\n",ds.query(p,p+t-1).sum);
        }else if(op[2]=='X'){
            ptf("%d\n",ds.query(1,ds.size()).mxs);
        }
    }

    return 0;
}
/*
4 0
1 2 3 4
3 0
1 2 3
*/
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()*1.0/RAND_MAX*1e9){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(const node&amp;a){
            if(sp!=ss){--sp;**sp=a;return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=a;return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(node(a[m]));
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    node*cpy(node*x){
        if(!x)return 0;pdw(x);node*t=me.create(*x);
        for(int d=0;d&lt;2;++d)t-&gt;c[d]=cpy(t-&gt;c[d]);return t;}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    DynamicSequence(node*x):rt(x){}
    DynamicSequence(const DynamicSequence&lt;T&gt;&amp;a){rt=cpy(a.rt);}
    ~DynamicSequence(){clr(rt);}
    DynamicSequence&lt;T&gt;&amp;operator=(const DynamicSequence&lt;T&gt;&amp;a){
        if(this!=&amp;a)clr(rt),rt=cpy(a.rt);return*this;}
    DynamicSequence&lt;T&gt;split(int p){
        spt(p,p+1);rt=sl;return DynamicSequence&lt;T&gt;(sr);}
    void join(DynamicSequence&lt;T&gt;&amp;a){rt=jon(rt,a.rt);a.rt=0;}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

//#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
using namespace std;
typedef long long lli;
typedef double dbl;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}
#include&lt;iostream&gt;
int main(){

    int n,m;
    scf("%d%d",&amp;n,&amp;m);
    static info buff[400010];
    lop(i,1,n){
        int t;scf("%d",&amp;t);
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        scf("%s",op);
        if(op[2]=='S'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            lop(j,1,c){
                int t;scf("%d",&amp;t);
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            scf("%d%d%d",&amp;p,&amp;t,&amp;c);
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)ptf("0\n");
            else ptf("%d\n",ds.query(p,p+t-1).sum);
        }else if(op[2]=='X'){
            ptf("%d\n",ds.query(1,ds.size()).mxs);
        }
    }

    return 0;
}
/*
4 0
1 2 3 4
3 0
1 2 3
*/
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(const node&amp;a){
            if(sp!=ss){--sp;**sp=a;return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=a;return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(node(a[m]));
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    node*cpy(node*x){
        if(!x)return 0;pdw(x);node*t=me.create(*x);
        for(int d=0;d&lt;2;++d)t-&gt;c[d]=cpy(t-&gt;c[d]);return t;}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    DynamicSequence(node*x):rt(x){}
    DynamicSequence(const DynamicSequence&lt;T&gt;&amp;a){rt=cpy(a.rt);}
    ~DynamicSequence(){clr(rt);}
    DynamicSequence&lt;T&gt;&amp;operator=(const DynamicSequence&lt;T&gt;&amp;a){
        if(this!=&amp;a)clr(rt),rt=cpy(a.rt);return*this;}
    DynamicSequence&lt;T&gt;split(int p){
        spt(p,p+1);rt=sl;return DynamicSequence&lt;T&gt;(sr);}
    void join(DynamicSequence&lt;T&gt;&amp;a){rt=jon(rt,a.rt);a.rt=0;}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

//#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
using namespace std;
typedef long long lli;
typedef double dbl;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}
#include&lt;iostream&gt;
int main(){

    int n,m;
    scf("%d%d",&amp;n,&amp;m);
    static info buff[400010];
    lop(i,1,n){
        int t;scf("%d",&amp;t);
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        scf("%s",op);
        if(op[2]=='S'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            lop(j,1,c){
                int t;scf("%d",&amp;t);
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            scf("%d%d%d",&amp;p,&amp;t,&amp;c);
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)ptf("0\n");
            else ptf("%d\n",ds.query(p,p+t-1).sum);
        }else if(op[2]=='X'){
            ptf("%d\n",ds.query(1,ds.size()).mxs);
        }
    }

    return 0;
}
/*
4 0
1 2 3 4
3 0
1 2 3
*/
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}
#include&lt;iostream&gt;
int main(){

    int n,m;
    scf("%d%d",&amp;n,&amp;m);
    static info buff[400010];
    lop(i,1,n){
        int t;scf("%d",&amp;t);
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        scf("%s",op);
        if(op[2]=='S'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            lop(j,1,c){
                int t;scf("%d",&amp;t);
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            scf("%d%d%d",&amp;p,&amp;t,&amp;c);
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)ptf("0\n");
            else ptf("%d\n",ds.query(p,p+t-1).sum);
        }else if(op[2]=='X'){
            ptf("%d\n",ds.query(1,ds.size()).mxs);
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
unsigned int g_seed = 0;
unsigned int fastrand() {
g_seed = (214013 * g_seed + 2531011);
return (g_seed &gt;&gt; 16) &amp; 0x7FFF;
}
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(fastrand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
unsigned int g_seed = 0;
unsigned int fastrand() {
g_seed = (214013 * g_seed + 2531011);
return (g_seed &gt;&gt; 16) &amp; 0x7FFF;
}
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
unsigned int g_seed = 0;
unsigned int fastrand() {
return g_seed = (214013 * g_seed + 2531011);
}
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(rand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;
unsigned int g_seed = 0;
unsigned int fastrand() {
return g_seed = (214013 * g_seed + 2531011);
return (g_seed &gt;&gt; 16) &amp; 0x7FFF;
}
using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0),
            w(fastrand()){c[0]=c[1]=0;}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;

using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0){

            c[0]=c[1]=0;
            static int g;w= g = (214013 * g + 2531011);
        }
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;

using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0){

            c[0]=c[1]=0;
            w=rand();return;
            static int g;w= g = (214013 * g + 2531011);

        }
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#include&lt;bits/stdc++.h&gt;

using namespace std;
template&lt;typename T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0){

            c[0]=c[1]=0;

            static int g;w= g = (214013 * g + 2531011);

        }
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct memory{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        memory():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){

            ns.push_back(ps);

        }
        ~memory(){
            free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;
        int m=l+r&gt;&gt;1;
        node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);
        t-&gt;c[1]=bud(a,m+1,r);
        pup(t);
        return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){
        node*t=spt(l,r);
        T i=t-&gt;i;
        jon(t);
        return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.13

Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;class T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0){
            c[0]=c[1]=0;static int g;w=g=(214013*g+2531011);}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct pool{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        pool():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){
            ns.push_back(ps);}
        ~pool(){free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*create(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void destroy(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;int m=l+r&gt;&gt;1;node*t=me.create(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);t-&gt;c[1]=bud(a,m+1,r);pup(t);return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.destroy(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){node*t=spt(l,r);T i=t-&gt;i;jon(t);return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};

#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define scf scanf
#define ptf printf
using namespace std;

struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}


/*
This is an i/o optimalization.
A doubling trick is used there
since we do not know the exact size of input.
It is not compatible with cstdio and iostream.
Created on 2015.11.09
Last updated on 2015.11.13
Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct FastReader{
FILE*f;char*p,*e;vector&lt;char&gt;v;
void ipt(){
for(int i=1,t;;i&lt;&lt;=1){
v.resize(v.size()+i);
if(i!=(t=fread(&amp;v[0]+v.size()-i,1,i,f))){
p=&amp;v[0],e=p+v.size()-i+t;break;}}}
void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
int isc(){return p!=e&amp;&amp;!isspace(*p);}
int isd(){return p!=e&amp;&amp;isdigit(*p);}
FastReader(FILE*_f):f(_f){ipt();}
FastReader(string _f):f(fopen(_f.c_str(),"r")){ipt();}
~FastReader(){fclose(f);}
template&lt;class T&gt;FastReader&amp;operator&gt;&gt;(T&amp;a){
int n=1;ign();if(*p=='-')n=-1,++p;
for(a=0;isd();)a=a*10+*p++-'0';
a*=n;return*this;}
FastReader&amp;operator&gt;&gt;(char&amp;a){
ign();a=*p++;return*this;}
FastReader&amp;operator&gt;&gt;(char*a){
for(ign();isc();)*a++=*p++;
*a=0;return*this;}
char get(){return*p++;}};
struct FastWriter{
FILE*f;vector&lt;char&gt;p;
FastWriter(FILE*_f):f(_f){}
FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
~FastWriter(){
if(p.size())fwrite(&amp;p[0],1,p.size(),f);
fclose(f);}
FastWriter&amp;operator&lt;&lt;(char a){
p.push_back(a);return*this;}
FastWriter&amp;operator&lt;&lt;(const char*a){
while(*a)p.push_back(*a++);
return*this;}
template&lt;class T&gt;FastWriter&amp;operator&lt;&lt;(T a){
if(a&lt;0)p.push_back('-'),a=-a;
static char t[19];char*q=t;
do{T b=a/10;*q++=a-b*10+'0',a=b;}while(a);
while(q&gt;t)p.push_back(*--q);
return*this;}};

#include&lt;iostream&gt;
int main(){
    int n,m;
    FastReader fr(stdin);
    FastWriter fw(stdout);
    fr&gt;&gt;n&gt;&gt;m;
    static info buff[400010];
    lop(i,1,n){
        int t;fr&gt;&gt;t;
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        fr&gt;&gt;op;
        if(op[2]=='S'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            lop(j,1,c){
                int t;fr&gt;&gt;t;
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;fr&gt;&gt;p&gt;&gt;c;
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            fr&gt;&gt;p&gt;&gt;t&gt;&gt;c;
            if(t==0)continue;
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)continue;
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;fr&gt;&gt;p&gt;&gt;t;
            if(t==0)fw&lt;&lt;"0\n";
            else fw&lt;&lt;ds.query(p,p+t-1).sum&lt;&lt;'\n';
        }else if(op[2]=='X'){
            fw&lt;&lt;ds.query(1,ds.size()).mxs&lt;&lt;'\n';
        }
    }

    return 0;
}
<pre><h2>Problem1500</h2><pre>/*
This is an implementation of Dynamic Sequence using Treap.
It is based on the standard information type.

Created on 2015.11.13
Last updated on 2015.11.14

Dongfeng Yu
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;class T&gt;struct DynamicSequence{
    struct node{
        node(T _i):i(_i),v(_i),s(1),r(0){
            c[0]=c[1]=0;static int g;w=g=(214013*g+2531011);}
        T i,v;int s,r,w;node*c[2];}*rt,*sl,*sr;
    struct pool{
        node*ps,*pp,**ss,**sp;int pm,sm;vector&lt;node*&gt;ns;
        pool():ps((node*)malloc(sizeof(node))),pp(ps),pm(1),
            ss((node**)malloc(sizeof(node*))),sp(ss),sm(1){
            ns.push_back(ps);}
        ~pool(){free(ss);for(int i=0;i&lt;ns.size();++i)free(ns[i]);}
        node*crt(T a){
            if(sp!=ss){--sp;**sp=node(a);return*sp;}
            if(pp==ps+pm){
                pp=ps=(node*)malloc(sizeof(node)*(pm&lt;&lt;=1));
                ns.push_back(ps);}
            *pp=node(a);return pp++;}
        void des(node*x){
            if(sp==ss+sm){
                node**t=(node**)malloc(sizeof(node*)*sm&lt;&lt;1);
                memcpy(t,ss,sm*sizeof(node*));
                free(ss);sp=(ss=t)+sm;sm&lt;&lt;=1;}
            *(sp++)=x;}}me;
    node*bud(T*a,int l,int r){
        if(l&gt;r)return 0;int m=l+r&gt;&gt;1;node*t=me.crt(a[m]);
        t-&gt;c[0]=bud(a,l,m-1);t-&gt;c[1]=bud(a,m+1,r);pup(t);return t;}
    void pdw(node*x){
        for(int d=0;d&lt;2&amp;&amp;(x-&gt;i&gt;x-&gt;v,1);++d)if(x-&gt;c[d])x-&gt;i&gt;x-&gt;c[d]-&gt;i;
        *x-&gt;i;*x-&gt;v;if(x-&gt;r){
            -x-&gt;i;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])x-&gt;c[d]-&gt;r^=1;
            swap(x-&gt;c[0],x-&gt;c[1]);x-&gt;r=0;}}
    void pup(node*x){
        x-&gt;i=x-&gt;v;x-&gt;s=1;for(int d=0;d&lt;2;++d)if(x-&gt;c[d])
            pdw(x-&gt;c[d]),x-&gt;s+=x-&gt;c[d]-&gt;s,
            x-&gt;i=d?x-&gt;i+x-&gt;c[d]-&gt;i:x-&gt;c[d]-&gt;i+x-&gt;i;}
    void jon(node*x){rt=jon(jon(sl,x),sr);}
    node*jon(node*x,node*y){
        if(!x)return y;if(!y)return x;pdw(x);pdw(y);
        if(x-&gt;w&lt;y-&gt;w){x-&gt;c[1]=jon(x-&gt;c[1],y);pup(x);return x;
        }else{y-&gt;c[0]=jon(x,y-&gt;c[0]);pup(y);return y;}}
    node*spt(int l,int r){
        spt(rt,l-1);node*t=sl;spt(sr,r-l+1);swap(sl,t);return t;}
    void spt(node*x,int p){
        if(!x){sl=sr=0;return;}pdw(x);int t=x-&gt;c[0]?x-&gt;c[0]-&gt;s:0;
        if(t&lt;p)spt(x-&gt;c[1],p-t-1),x-&gt;c[1]=sl,sl=x;
        else spt(x-&gt;c[0],p),x-&gt;c[0]=sr,sr=x;pup(x);}
    void clr(node*x){if(x)clr(x-&gt;c[0]),clr(x-&gt;c[1]),me.des(x);}
    DynamicSequence(T*a=0,int n=0){rt=bud(a,1,n);}
    ~DynamicSequence(){clr(rt);}
    void clear(){clr(rt);rt=0;}
    void insert(T a,int p){insert(&amp;a-1,1,p);}
    void insert(T*a,int n,int p){spt(p+1,p);jon(bud(a,1,n));}
    void erase(int p){erase(p,p);}
    void erase(int l,int r){clr(spt(l,r));jon(0);}
    T query(int p){return query(p,p);}
    T query(int l,int r){node*t=spt(l,r);T i=t-&gt;i;jon(t);return i;}
    void modify(T a,int l){modify(a,l,l);}
    void modify(T a,int l,int r){node*t=spt(l,r);a&gt;t-&gt;i;jon(t);}
    void reverse(int l,int r){node*t=spt(l,r);t-&gt;r=1;jon(t);}
    int size(){return rt?rt-&gt;s:0;}};
 
#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
using namespace std;
typedef long long lli;
typedef double dbl;
typedef string str;
typedef pair&lt;int,int&gt; pii;
 
struct info{
    info(){}
    info(int v){
        sum=mxs=mxl=mxr=v;
        sam=~0u&gt;&gt;1;siz=1;
    }
    int sum,mxs,mxl,mxr;
    int sam,siz;
    void operator*(){
        if(sam!=~0u&gt;&gt;1){
            sum=siz*sam;
            if(sam&gt;=0)
                mxs=mxl=mxr=sum;
            else mxs=mxl=mxr=sam;
            sam=~0u&gt;&gt;1;
        }
    }
    void operator-(){
        swap(mxl,mxr);
    }
};
info operator+(const info&amp;a,const info&amp;b){
    info t;
    t.sum=a.sum+b.sum;
    t.mxs=max(a.mxs,b.mxs);
    t.mxs=max(t.mxs,a.mxr+b.mxl);
    t.mxl=max(a.mxl,a.sum+b.mxl);
    t.mxr=max(b.mxr,b.sum+a.mxr);
    t.siz=a.siz+b.siz;
    t.sam=~0u&gt;&gt;1;
    return t;
}
void operator&gt;(const info&amp;a,info&amp;b){
    if(a.sam!=~0u&gt;&gt;1)
        b.sam=a.sam;
}
 
int main(){
 
    int n,m;
    scf("%d%d",&amp;n,&amp;m);
    static info buff[400010];
    lop(i,1,n){
        int t;scf("%d",&amp;t);
        buff[i]=t;
    }
    DynamicSequence&lt;info&gt;ds(buff,n);
    lop(i,1,m){
        static char op[110];
        scf("%s",op);
        if(op[2]=='S'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            lop(j,1,c){
                int t;scf("%d",&amp;t);
                buff[j]=t;
            }
            ds.insert(buff,c,p);
        }else if(op[2]=='L'){
            int p,c;scf("%d%d",&amp;p,&amp;c);
            ds.erase(p,p+c-1);
        }else if(op[2]=='K'){
            int p,t,c;
            scf("%d%d%d",&amp;p,&amp;t,&amp;c);
            if(t==0)continue; 
            info tmp;tmp.sam=c;
            ds.modify(tmp,p,p+t-1);
        }else if(op[2]=='V'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)continue; 
            ds.reverse(p,p+t-1);
        }else if(op[2]=='T'){
            int p,t;scf("%d%d",&amp;p,&amp;t);
            if(t==0)ptf("0\n");
            else ptf("%d\n",ds.query(p,p+t-1).sum);
        }else if(op[2]=='X'){
            ptf("%d\n",ds.query(1,ds.size()).mxs);
        }
    }
 
    return 0;
}
/*
4 0
1 2 3 4
3 0
1 2 3
*/<pre><h2>Problem1502</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct circle{
    circle(double a,double b):
        x(a),r(b){}
    double x,r;
};
struct seg{
    seg(double a,double b,double c,double d):
        x1(a),y1(b),x2(c),y2(d){}
    double x1,y1,x2,y2;
};
seg operator*(circle a,circle b){
    double t=(a.r-b.r)/(b.x-a.x);
    double t1=t*a.r,t2=t*b.r;
    double x1=t1+a.x,x2=t2+b.x;
    double y1=sqrt(a.r*a.r-t1*t1),y2=sqrt(b.r*b.r-t2*t2);
    return seg(x1,y1,x2,y2);
}
vector&lt;seg&gt;segs;
vector&lt;circle&gt;circles;
double mab(double x){
    return x&lt;0?-x:x;
}
double f(double x){
    double r=0;
    lp(i,0,int(circles.size()-1)){
        double x1=circles[i].x,r1=circles[i].r;
        if(x&gt;x1-r1&amp;&amp;x&lt;x1+r1){
            //pf("[%lf,%lf]",x1,r1);
            double y=sqrt(r1*r1-(x1-x)*(x1-x));
            r=max(r,y);
        }
    }
    lp(i,0,int(segs.size()-1)){
        double x1=segs[i].x1,x2=segs[i].x2,y1=segs[i].y1,y2=segs[i].y2;
        if(x&gt;x1&amp;&amp;x&lt;x2){
            //pf("[%lf,%lf,%lf,%lf]",x1,y1,x2,y2);
            double y=(y1-y2)*(x-x1)/(x1-x2)+y1;
            r=max(r,y);
        }
    }
    return r;
}
double sim(double l,double r,double fl,double fm,double fr){
    return (fl+4*fm+fr)*(r-l)/6.0;
}
double rsim(double l,double r,double fl,double fm,double fr){
    double m=(l+r)/2.0,flm=f((l+m)/2.0),fmr=f((m+r)/2.0);
    if(mab(sim(l,r,fl,fm,fr)-sim(l,m,fl,flm,fm)-sim(m,r,fm,fmr,fr))&lt;1e-6)
        return sim(l,r,fl,fm,fr);
    else
        return rsim(l,m,fl,flm,fm)+rsim(m,r,fm,fmr,fr);
}
double check(circle a,circle b){
    return b.x+b.r&gt;a.x+a.r;
}
int main(){
    double h[510],rr[510];
    int n;double a;sf("%d%lf",&amp;n,&amp;a);
    a=1.0/tan(a);
    lp(i,0,n)sf("%lf",&amp;h[i]);
    lp(i,1,n)sf("%lf",&amp;rr[i]);
    double hnow=h[0],l=1e6,r=-1e6;
    lp(i,1,n){
        circles.push_back(circle(hnow*a,rr[i]));
        hnow+=h[i];
        l=min(l,circles.back().x-circles.back().r);
        r=max(r,circles.back().x+circles.back().r);
    }
    circles.push_back(circle(hnow*a,0));
    r=max(r,circles.back().x+circles.back().r);
    for(int i=0;i+1&lt;circles.size();++i)
        if(check(circles[i],circles[i+1]))
            segs.push_back(circles[i]*circles[i+1]);
    //pf("(%lf)\n",f(20));ps;
    //lp(i,0,int(circles.size()-1))pf("(%lf,%lf)\n",circles[i].x,circles[i].r);
    //lp(i,0,int(segs.size()-1))pf("[%lf,%lf,%lf,%lf]\n",segs[i].x1,segs[i].y1,segs[i].x2,segs[i].y2);
    pf("%.2lf\n",rsim(l,r,f(l),f((l+r)/2.0),f(r))*2.0);
    //ps;
    return 0;
}
<pre><h2>Problem1503</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MXN=100010;
int chd[MXN][2],siz[MXN],val[MXN],cnt[MXN],rt,nw,fix[MXN];
void rotate(int &amp;x,int d){
    int t=chd[x][d];
    chd[x][d]=chd[t][!d];
    chd[t][!d]=x;
    siz[t]=siz[x];
    siz[x]=siz[chd[x][0]]+siz[chd[x][1]]+cnt[x];
    x=t;
}
void insert(int &amp;x,int v){
    if(!x)x=++nw,cnt[x]=1,val[x]=v,fix[x]=rand()*rand();
    else if(val[x]==v)++cnt[x];
    else {
        insert(chd[x][v&gt;val[x]],v);
        if(fix[chd[x][v&gt;val[x]]]&gt;fix[x])
            rotate(x,v&gt;val[x]);
    }
    ++siz[x];
}
int pred(int x,int v){
   if(!x)return -(~0u&gt;&gt;1);
   else if(val[x]&gt;=v)return pred(chd[x][0],v);
   else return max(val[x],pred(chd[x][1],v));
}
int find(int x,int k){
    if(k&lt;=siz[chd[x][0]])return find(chd[x][0],k);
    else if(k&lt;=siz[chd[x][0]]+cnt[x])return val[x];
    else return find(chd[x][1],k-siz[chd[x][0]]-cnt[x]);
}
void splay(int &amp;x,int v){
    if(v==val[x])return;
    else splay(chd[x][v&gt;val[x]],v),rotate(x,v&gt;val[x]);
}
int n,mi,delta,ans;
char op;int k;
int main(){
    sf("%d%d",&amp;n,&amp;mi);
    lp(i,1,n){
        op=getchar();
        op=getchar();
        sf("%d",&amp;k);
        switch(op){
            case 'I':if(k-delta&gt;=mi)insert(rt,k-delta);break;
            case 'A':delta+=k,mi-=k;break;
            case 'S':delta+=-k,mi-=-k;break;
            case 'F':pf("%d\n",k&gt;siz[rt]?-1:find(rt,siz[rt]-k+1)+delta);break;
        }
        int t=pred(rt,mi);
        if(t!=-(~0u&gt;&gt;1)){
            splay(rt,t);
            ans+=siz[chd[rt][0]]+cnt[rt];
            rt=chd[rt][1];
        }
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}<pre><h2>Problem1507</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace tree{
	struct node{
		node(char c){ch[0]=ch[1]=pr=0;val=c;siz=1;}
		node*ch[2],*pr;char val;int siz;
	}*rt;int cur;
	int tp(node*x){return x==x-&gt;pr-&gt;ch[1];}
	inline void upda(node*x){
		x-&gt;siz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
	}
	inline node*st(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;upda(x);}
	inline void rot(node*x){
		node*y=x-&gt;pr,*z=y-&gt;pr;int d1=tp(x),d2;if(z)d2=tp(y);
		st(y,x-&gt;ch[!d1],d1);
		st(x,y,!d1);
		if(z)st(z,x,d2);else{x-&gt;pr=0;rt=x;}
	}
	inline void spl(node*x,node*y){
		while(x-&gt;pr!=y){
			if(x-&gt;pr-&gt;pr==y)rot(x);
			else if(tp(x)==tp(x-&gt;pr))rot(x-&gt;pr),rot(x);
			else rot(x),rot(x);
		}
	}
	inline void sel(node*x,int k,node*y){
		int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
		if(k&lt;=t)sel(x-&gt;ch[0],k,y);
		else if(k==t+1)spl(x,y);
		else sel(x-&gt;ch[1],k-(t+1),y);
	}
	inline node*bud(char*str,int l,int r){
		int m=(l+r)/2;
		node*ret=new node(str[m]);
		if(l!=m)st(ret,bud(str,l,m-1),0);
		if(r!=m)st(ret,bud(str,m+1,r),1);
		return ret;
	}
	inline node*ept(node*&amp;x){
		lp(i,0,1)if(x-&gt;ch[i])ept(x-&gt;ch[i]);
		delete x;x=0;
	}
	inline void init(){
		rt=new node('$');
		st(rt,new node('$'),1);
	}
	inline void move(){sf("%d",&amp;cur);}
	inline void insert(){
		static char str[3000010];int len=0;
		int tlen;sf("%d",&amp;tlen);
		lp(i,1,tlen){
			char c=getchar();
			while(c=='\n')c=getchar();
			str[++len]=c;
		}
		sel(rt,cur+1,0);
		sel(rt,cur+2,rt);
		st(rt-&gt;ch[1],bud(str,1,len),0);
		upda(rt);
	}
	inline void remove(){
		int t;sf("%d",&amp;t);
		sel(rt,cur+1,0);
		sel(rt,cur+t+2,rt);
		ept(rt-&gt;ch[1]-&gt;ch[0]);
		upda(rt-&gt;ch[1]);
		upda(rt);
	}
	inline void prt(node*x){
		if(x-&gt;ch[0])prt(x-&gt;ch[0]);
		pf("%c",x-&gt;val);
		if(x-&gt;ch[1])prt(x-&gt;ch[1]);
	}
	inline void print(){
		int t;sf("%d",&amp;t);
		sel(rt,cur+1,0);
		sel(rt,cur+t+2,rt);
		prt(rt-&gt;ch[1]-&gt;ch[0]);
		pf("\n");
	}
	inline void prev(){--cur;}
	inline void next(){++cur;}
}
int main(){
	tree::init();
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		static char op[11];sf("%s",op);
		if(op[0]=='I')tree::insert();
		else if(op[0]=='M')tree::move();
		else if(op[0]=='D')tree::remove();
		else if(op[0]=='G')tree::print();
		else if(op[0]=='P')tree::prev();
		else tree::next();
	}
	return 0;
}<pre><h2>Problem1562</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
vector&lt;int&gt;to[10010],stk;int lk[10010],vis[10010],ans[10010];
int dfs(int u){
	vp(i,to[u]){
		int v=to[u][i];
		if(!vis[v]){
			vis[v]=1;
			stk.pb(v);
			if(!lk[v]||dfs(lk[v])){
				lk[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	int n;sf("%d",&amp;n);
	lp(i,0,n-1){
		int t;sf("%d",&amp;t);
		int x=(i-t+n)%n;
		int y=(i+t)%n;
		if(x&gt;y)swap(x,y);
		to[i+1].pb(x+1);
		to[i+1].pb(y+1);
	}
	int r=0;
	rp(i,n,1){
		r+=dfs(i);
		vp(j,stk)vis[stk[j]]=0;
		stk.clear();
	}
	if(r!=n)pf("No Answer\n");
	else{
		lp(i,1,n)ans[lk[i]]=i;
		lp(i,1,n)pf("%d%c",ans[i]-1,i==n?'\n':' ');
	}
	return 0;
}
<pre><h2>Problem1565</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;stack&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[21*310];
int wei[21*310],vcnt,del[21*310],in[31*210];
int n,m;
struct edge{
    int v,c;
}edges[1000100];int nw=1;
vector&lt;int&gt;bg[21*310];
void add(int u,int v,int c){
    //pf("[%d,%d,%d]\n",u,v,c);
    ++nw;edge&amp;e=edges[nw];e.v=v,e.c=c;
    bg[u].push_back(nw);
}
int dis[21*310],gap[21*310];
int dfs(int u,int f){
    //pf("[%d,%d,%d]\n",u,f,vcnt);
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        if(e.c&amp;&amp;dis[u]-1==dis[e.v]){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,edges[bg[u][i]^1].c+=t;
            if(!g||dis[1]==vcnt)return f-g;
        }
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];
    return f-g;
}
int isap(){
    int r=0;gap[1]=vcnt;
    while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
    return r;
}
int main(){
    //fr("pvz.in","r",stdin);
    //fr("pvz.out","w",stdout);
    sf("%d%d",&amp;n,&amp;m);vcnt=m*n;
    lp(i,1,n)lp(j,1,m){
        int t=(i-1)*m+j;
        sf("%d",&amp;wei[t]);
        int cnt;sf("%d",&amp;cnt);
        lp(k,1,cnt){
            int a,b;sf("%d%d",&amp;a,&amp;b);++a,++b;
            int y=(a-1)*m+b;
            to[t].push_back(y);
        }
        if(j!=m)to[(i-1)*m+j+1].push_back(t);
    }
    lp(i,1,vcnt)lp(j,0,int(to[i].size()-1))
        ++in[to[i][j]];
    lp(i,1,vcnt)del[i]=1;
         
    queue&lt;int&gt;qu;lp(i,1,vcnt)if(!in[i])qu.push(i);
    while(!qu.empty()){
        int u=qu.front();qu.pop();del[u]=0;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i];
            if((--in[v])==0)
                qu.push(v);
        }
    }//pf("hi");
    //lp(i,1,vcnt)pf("[%d]",del[i]);ps;
    lp(i,1,vcnt){
        if(del[i])continue;
        lp(j,0,int(to[i].size()-1)){
            int v=to[i][j];if(del[v])continue;
            add(v+1,i+1,~0u&gt;&gt;1),add(i+1,v+1,0);
        }
    }//pf("hi");
    lp(i,1,vcnt)if(!del[i]){
        if(wei[i]&gt;0)add(1,i+1,wei[i]),add(i+1,1,0);
        else  add(i+1,vcnt+2,-wei[i]),add(vcnt+2,i+1,0);
    }
    //pf("hi");
    vcnt+=2;
    int sum=0;
    lp(i,1,vcnt)if(!del[i]&amp;&amp;wei[i]&gt;0)sum+=wei[i];
    pf("%d\n",sum-isap());
    //ps;
    return 0;
}
<pre><h2>Problem1576</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; to[100010],we[100010];
int n,m,di[100010];
void build_graph(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;
        sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].push_back(v);we[u].push_back(w);
        to[v].push_back(u);we[v].push_back(w);
    }
}
struct dnode{dnode(int a,int b):x(a),d(b){}int x,d;};
struct cmp{bool operator()(const dnode&amp;a,const dnode&amp;b){return a.d&gt;b.d;}};
void dijkstra(){
    di[1]=0;fill(di+2,di+n+1,~0u&gt;&gt;1);
    priority_queue&lt;dnode,vector&lt;dnode&gt;,cmp&gt; qu;
    qu.push(dnode(1,0));
    while(!qu.empty()){
        int u=qu.top().x,d=qu.top().d;qu.pop();
        if(di[u]!=d)continue;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i],w=we[u][i];
            if(di[u]+w&lt;di[v]){
                di[v]=di[u]+w;
                qu.push(dnode(v,di[v]));
            }
        }
    }
    //lp(i,1,n)pf("[%d]",di[i]);
}
struct snode{snode(int a,int b):lc(0),rc(0),va(a),de(0),fr(b){}snode*lc,*rc;int va,de,fr;};
void pushdown(snode*x){
    if(x-&gt;lc)x-&gt;lc-&gt;de+=x-&gt;de;
    if(x-&gt;rc)x-&gt;rc-&gt;de+=x-&gt;de;
    x-&gt;va+=x-&gt;de;x-&gt;de=0;
}
snode*merge(snode*x,snode*y){
    if(!x)return y;
    if(!y)return x;
    pushdown(x);pushdown(y);
    if(x-&gt;va&gt;y-&gt;va)swap(x,y);
    x-&gt;rc=merge(x-&gt;rc,y);
    swap(x-&gt;lc,x-&gt;rc);
    return x;
}
void modify(snode*x,int d){x-&gt;de+=d;}
int tmp2[100010];
snode*tmp1[100010];
bool cmp2(int a,int b){return di[a]&gt;di[b];} 
void topsort(){
    lp(i,1,n)tmp2[i]=i;
    sort(tmp2+1,tmp2+n+1,cmp2);
    //lp(i,1,n)pf("[%d]",tmp2[i]);
}
int dbg[100010],ded[100010],dnw;
void makedfs(){
    stack&lt;int&gt; stk;
    stk.push(1);stk.push(1);
    while(!stk.empty()){
        int t=stk.top();stk.pop();
        int u=stk.top();stk.pop();
        if(t==1){
            dbg[u]=++dnw;
            stk.push(u);stk.push(2);
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i],w=we[u][i];
                if(di[v]==di[u]+w)stk.push(v),stk.push(1);
            }
        }else{
            ded[u]=dnw;
        } 
    }
    //lp(i,1,n)pf("[%d,%d]",dbg[i],ded[i]);
}
int ans[100010];
bool in(int a,int b){return dbg[a]&gt;=dbg[b]&amp;&amp;ded[a]&lt;=ded[b];}
void solve(){
    lp(op,1,n){
        int u=tmp2[op];
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i],w=we[u][i];
            if(di[v]==di[u]+w){
                if(tmp1[v])tmp1[v]-&gt;de+=w;
                tmp1[u]=merge(tmp1[u],tmp1[v]);
            }else if(di[u]!=di[v]+w){
                snode*t=new snode(w+di[v],v);
                tmp1[u]=merge(tmp1[u],t);
            }
        }
        while(tmp1[u]&amp;&amp;in(tmp1[u]-&gt;fr,u))tmp1[u]=merge(tmp1[u]-&gt;lc,tmp1[u]-&gt;rc);
        if(tmp1[u])pushdown(tmp1[u]),ans[u]=tmp1[u]-&gt;va;
        else ans[u]=-1;
        //pf("[%d,%d]",u,ans[u]);
    }
}
void print(){lp(i,2,n)pf("%d\n",ans[i]);}
int main(){
    build_graph();
    dijkstra();
    topsort();
    makedfs();
    solve();
    print();//ps;
    return 0;   
}
<pre><h2>Problem1579</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[10010],we[10010];
int n,m,k;
long long dis[10010][21];
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].push_back(v);
        we[u].push_back(w);
        to[v].push_back(u);
        we[v].push_back(w);
    }
    lp(i,1,n)lp(j,0,k)dis[i][j]=-1;
    dis[1][0]=0;
    priority_queue&lt;pair&lt;long long,pair&lt;int,int&gt; &gt; &gt;qu;qu.push(make_pair(0,make_pair(1,0)));
    while(!qu.empty()){
        int u=qu.top().second.first,g=qu.top().second.second;
        long long d=-qu.top().first;qu.pop();
        if(d!=dis[u][g])continue;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i],w=we[u][i];
            if(dis[u][g]+w&lt;dis[v][g]||dis[v][g]==-1){
                dis[v][g]=dis[u][g]+w;
                qu.push(make_pair(-dis[v][g],make_pair(v,g)));
            }
            if(g&lt;k&amp;&amp;(dis[u][g]&lt;dis[v][g+1]||dis[v][g+1]==-1)){
                dis[v][g+1]=dis[u][g];
                qu.push(make_pair(-dis[v][g+1],make_pair(v,g+1)));
            }
        }
    }
    long long ans=-1;
    lp(i,0,k)if(dis[n][i]!=-1){
        if(ans==-1||dis[n][i]&lt;ans)ans=dis[n][i];
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr feopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int main(){
    set&lt;int&gt;st;int n;sf("%d",&amp;n);
    int ans=0;
    lp(i,1,n){
        int a=0;sf("%d",&amp;a);
        if(i==1)ans+=a;
        else{
            set&lt;int&gt;::iterator p=st.lower_bound(a);
            if(p==st.end()){
                --p;
                ans+=a-*p;
            }else{
                if(p==st.begin()){
                    ans+=*p-a;
                }else{
                    int t=*p-a;
                    --p;int t2=a-*p;
                    ans+=min(t,t2);
                }
            }
        }
        st.insert(a);
    }
    pf("%d\n",ans);//ps;
    return 0;
}
<pre><h2>Problem1594</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
#include&lt;map&gt;
#include&lt;queue&gt;
int n,q;vector&lt;vector&lt;int&gt; &gt;a;
vector&lt;int&gt;rht1[1000010],wei1[1000010];
vector&lt;int&gt;lft2[1000010],wei2[1000010];
struct data{data(int x,int y,int z):l(x),r(y),v(z){}int l,r,v;};
bool operator&lt;(data x,data y){return x.v&lt;y.v;}
vector&lt;vector&lt;int&gt; &gt;b[25010];
int c[25010];
bool check(int m){
	lp(i,1,n)rht1[i].clear(),wei1[i].clear();
	lp(i,1,n)lft2[i].clear(),wei2[i].clear();
	lp(i,0,m){
		int l=a[i][0],r=a[i][1],v=a[i][2];
		rht1[l].pb(r);
		wei1[l].pb(v);
		//pf("(%d,%d,%d)\n",l,r,v);
	}
	int nw=0;lp(i,1,m+1)b[i].clear();map&lt;int,int&gt;pm;
	lp(i,0,m){
		int l=a[i][0],r=a[i][1],v=a[i][2];
		if(!pm[v])pm[v]=++nw,c[nw]=v;
		b[pm[v]].pb(a[i]);
	}
	lp(i,1,nw){
		int l=-(~0u&gt;&gt;1),r=~0u&gt;&gt;1,v=c[i];
		vp(j,b[i]){
			l=max(l,b[i][j][0]);
			r=min(r,b[i][j][1]);
		}
		lft2[r].pb(l);
		wei2[r].pb(v);
		//pf("{%d,%d,%d}\n",l,r,v);
	}
	map&lt;int,int&gt;lst;
	priority_queue&lt;data&gt;pq;
	lp(i,1,n){
		vp(j,rht1[i]){
			int l=i,r=rht1[i][j],v=wei1[i][j];
			pq.push(data(l,r,v));
		}
		while(!pq.empty()&amp;&amp;pq.top().r&lt;i)pq.pop();
		if(!pq.empty())lst[pq.top().v]=i;
		vp(j,lft2[i]){
			int l=lft2[i][j],r=i,v=wei2[i][j];
			if(lst[v]&lt;l)return false;
		}
	}
	return true;
}
int main(){
	sf("%d%d",&amp;n,&amp;q);
	lp(i,1,q){
		int l,r,v;sf("%d%d%d",&amp;l,&amp;r,&amp;v);
		vector&lt;int&gt;t;t.pb(l);t.pb(r);t.pb(v);a.pb(t);
	}
	//pf("%d\n",(int)check(q-1));return 0;
	if(!check(0))pf("1\n");
	else if(check(q-1))pf("0\n");
	else{
		int l=0,r=q-1;
		while(l+1&lt;r){
			int m=(l+r)/2;
			if(check(m))l=m;
			else r=m;
		}
		pf("%d\n",r+1);
	}
	//ps;
	return 0;
}<pre><h2>Problem1596</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
vector&lt;int&gt;to[10010],ch[10010];
int f[10010],g[10010],h[10010],n;
void treedp(int u,int p){
	vp(i,to[u])if(to[u][i]!=p)treedp(to[u][i],u),ch[u].pb(to[u][i]);
	f[u]=1;vp(i,ch[u]){
		int v=ch[u][i];
		f[u]+=min(min(f[v],g[v]),h[v]);
	}
	h[u]=0;
	vp(i,ch[u]){
		int v=ch[u][i];
		h[u]+=min(f[v],g[v]);
	}
	g[u]=~0u&gt;&gt;1;
	vp(i,ch[u]){
		int v=ch[u][i];
		g[u]=min(g[u],h[u]-min(f[v],g[v])+f[v]);
	}
	//pf("[%d,%d,%d,%d]\n",u,f[u],g[u],h[u]);
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n-1){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		to[a].pb(b);
		to[b].pb(a);
	}
	treedp(1,0);
	/*lp(i,1,n){
		vp(j,ch[i])pf("{%d}",ch[i][j]);
		pf("\n");
	}*/
	pf("%d\n",min(f[1],g[1]));
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
vector&lt;int&gt;to[1010],we[1010],f[1010];int n,m,k;
int vis[1010];
void dfs(int u){
	if(vis[u])return;
	vis[u]=1;
	vp(i,to[u]){
		int v=to[u][i],w=we[u][i];
		dfs(v);
		vp(j,f[v])f[u].pb(f[v][j]+w);
	}
	sort(f[u].begin(),f[u].end());
	while(f[u].size()&gt;k)f[u].pop_back();
}
int main(){
	sf("%d%d%d",&amp;n,&amp;m,&amp;k);
	lp(i,1,m){
		int x,y,d;sf("%d%d%d",&amp;x,&amp;y,&amp;d);
		to[x].pb(y);
		we[x].pb(d);
	}
	vis[1]=1;f[1].pb(0);
	dfs(n);
	lp(i,1,k)if(i-1&lt;f[n].size())pf("%d\n",f[n][i-1]);else pf("-1\n");
	return 0;
}<pre><h2>Problem1599</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
double f[110],g[110],h[110];
int main(){
	int s1,s2,s3;sf("%d%d%d",&amp;s1,&amp;s2,&amp;s3);
	lp(i,1,s1)f[i]=1.0/s1;
	lp(i,1,s1+s2+s3){
		lp(k,1,min(s2,i-1))
			g[i]+=f[i-k]*1.0/s2;
	}
	lp(i,1,s1+s2+s3){
		lp(k,1,min(s3,i-1))
			h[i]+=g[i-k]*1.0/s3;
	}
	int ans=1;
	lp(i,2,s1+s2+s3)if(h[i]&gt;h[ans]+1e-8)ans=i;
	pf("%d\n",ans);
	//lp(i,1,s1+s2+s3)pf("[%d,%lf]\n",i,h[i]);
	return 0;
}<pre><h2>Problem1600</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll dp[5][3010];
int main(){
    int n;sf("%d",&amp;n);
    dp[0][0]=1;
    lp(i,1,4)
        lp(j,1,n)
            for(int k=1;2*k&lt;n;++k)
                if(j&gt;=k)
                    dp[i][j]+=dp[i-1][j-k];
    pf("%lld\n",dp[4][n]);
    //ps;
    return 0;
} 
<pre><h2>Problem1601</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;edges;int n;
int p[310];int fd(int x){return x==p[x]?x:p[x]=fd(p[x]);}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        edges.push_back(make_pair(t,make_pair(n+1,i)));
    }
    lp(i,1,n)lp(j,1,n){
        int t;sf("%d",&amp;t);
        edges.push_back(make_pair(t,make_pair(i,j)));
    }
    lp(i,1,n+1)p[i]=i;
    sort(edges.begin(),edges.end());
    int ans=0;
    lp(i,0,int(edges.size()-1)){
        int u=edges[i].second.first,v=edges[i].second.second;
        int w=edges[i].first;
        if(fd(u)!=fd(v)){
            ans+=w;
            p[fd(u)]=v;
        }
    }
    pf("%d\n",ans);//ps;
    return 0;
}
<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
vector&lt;int&gt;to[1010],we[1010];int n,q,dis[1010];
void dfs(int u,int p){
    lp(i,0,int(to[u].size()-1))
        if(p!=to[u][i])
            dis[to[u][i]]=dis[u]+we[u][i],
            dfs(to[u][i],u); 
} 
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n-1){
        int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        to[a].push_back(b);
        we[a].push_back(c);
        to[b].push_back(a);
        we[b].push_back(c);
    }
    lp(i,1,q){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        dis[u]=0;
        dfs(u,0);
        pf("%d\n",dis[v]); 
    }
    //ps;
    return 0;
} 
<pre><h2>Problem1603</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
vector&lt;int&gt;to[1010],we[1010];int n,q,dis[1010];
void dfs(int u){
    lp(i,0,int(to[u].size()-1))
        if(dis[to[u][i]]==-1)
            dis[to[u][i]]=(dis[u]^we[u][i]),
            dfs(to[u][i]); 
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        to[a].push_back(b);
        we[a].push_back(c);
        to[b].push_back(a);
        we[b].push_back(c);
    }
    lp(i,2,n)dis[i]=-1;
    dfs(1);
    pf("%d\n",dis[n]);
    //ps;
    return 0;
} 
<pre><h2>Problem1604</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
struct cow{
    cow(){
        sf("%lld%lld",&amp;x,&amp;y);
        ll t1=x-y,t2=x+y;
        x=t1,y=t2;
    } 
    ll x,y;int id;
}; 
bool operator&lt;(cow a,cow b){
    return make_pair(a.y,a.x)&lt;make_pair(b.y,b.x);
}
bool cmp(cow a,cow b){
    return a.x&lt;b.x;
} 
int pr[100010],sz[100010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
int main(){
    vector&lt;cow&gt;cs;
    int n;ll c;sf("%d%lld",&amp;n,&amp;c);
    lp(i,1,n){
        cs.push_back(cow());
        cs.back().id=i;
    }
    sort(cs.begin(),cs.end(),cmp);
    set&lt;cow&gt;ct;
    lp(i,1,n)pr[i]=i,sz[i]=1;
    for(int j=-1,i=0;i&lt;n;++i){
        while(cs[i].x-cs[j+1].x&gt;c)
            ct.erase(cs[++j]);
        set&lt;cow&gt;::iterator i1=ct.lower_bound(cs[i]);
        if(i1!=ct.end()){
            if(i1-&gt;y-cs[i].y&lt;=c)
                if(fd(i1-&gt;id)!=fd(cs[i].id))
                    pr[fd(i1-&gt;id)]=cs[i].id;
        }
        if(i1!=ct.begin()){
            --i1;
            if(cs[i].y-i1-&gt;y&lt;=c)
                if(fd(i1-&gt;id)!=fd(cs[i].id))
                    pr[fd(i1-&gt;id)]=cs[i].id;
        }
        ct.insert(cs[i]);
    }
    int ans1=0,ans2=0;
    lp(i,1,n)if(pr[i]!=i)sz[fd(i)]+=sz[i];else++ans1;
    lp(i,1,n)if(pr[i]==i)ans2=max(ans2,sz[i]);
    pf("%d %d\n",ans1,ans2);
    //ps;
    return 0;
}
<pre><h2>Problem1606</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int f[50010];
int main(){
	int v,n;
	sf("%d%d",&amp;v,&amp;n);
	f[0]=1;
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		rp(j,v,t)f[j]=(f[j-t]||f[j]);
	}
	while(!f[v])--v;
	pf("%d\n",v);
    return 0;
}<pre><h2>Problem1607</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,a[100010],ans[1000010];
int cnt[1000010];
int has[1000010];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;++i)
		scanf("%d",a+i),has[a[i]]++;
	for(int i=1;i&lt;=1000000;++i)
		if(has[i])
		for(int j=i;j&lt;=1000000;j+=i)
			cnt[j]+=has[i];
	for(int i=1;i&lt;=n;++i)
		printf("%d\n",cnt[a[i]]-1);
	//	for(;;);
	return 0;
}<pre><h2>Problem1609</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int a[30010],n;
int f[30010][4];
int dp(){
	lp(i,1,n){
		lp(j,1,3){
			f[i][j]=~0u&gt;&gt;1;
			lp(k,1,j){
				f[i][j]=min(f[i][j],f[i-1][k]+(a[i]!=j));
			}
		}
	}
	return min(min(f[n][1],f[n][2]),f[n][3]);
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d",&amp;a[i]);
	int ans=~0u&gt;&gt;1;
	ans=min(ans,dp());
	reverse(a+1,a+n+1);
	ans=min(ans,dp());
	pf("%d\n",ans);
	return 0;
}<pre><h2>Problem1610</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf 
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;set&gt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
pair&lt;int,int&gt;normal(pair&lt;int,int&gt;vec){
	if(vec.first&lt;0)vec.first*=-1,vec.second*=-1;
	else if(vec.first==0&amp;&amp;vec.second&lt;0)vec.second=-vec.second;
	int d=gcd(vec.first,vec.second&gt;0?vec.second:-vec.second);
	vec.first/=d;vec.second/=d;
	return vec;
}
int x[210],y[210],n;
set&lt;pair&lt;int,int&gt; &gt;st;
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d%d",&amp;x[i],&amp;y[i]);
	lp(i,1,n)lp(j,i+1,n)st.insert(normal(mp(x[i]-x[j],y[i]-y[j])));
	pf("%d\n",(int)st.size());
	return 0;
}<pre><h2>Problem1612</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int can[110][110],n,m;
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		can[u][v]=1;
	}
	lp(k,1,n)
		lp(i,1,n)
			lp(j,1,n)
				if(can[i][k]&amp;&amp;can[k][j])
					can[i][j]=1;
	int ans=0;
	lp(i,1,n){
		int flg=1;
		lp(j,1,n){
			if(j!=i){
				if(!can[i][j]&amp;&amp;!can[j][i])
					flg=0;
			}
		}
		ans+=flg;
	}
	pf("%d\n",ans);
    return 0;
}<pre><h2>Problem1613</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int n,m,d[10010],f[10010][510];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n)sf("%d",&amp;d[i]);
	rp(i,n-1,1){
		lp(j,0,min(n-i,m)){
			if(j==0)f[i][j]=max(f[i+1][j],f[i+1][j+1]+d[i]);
			else if(j==min(n-i,m))f[i][j]=f[i+j][0];
			else f[i][j]=max(f[i+j][0],f[i+1][j+1]+d[i]);
		}
	}
	pf("%d\n",f[1][0]);
	return 0;
}<pre><h2>Problem1614</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; E[1010],W[1010];
int N,P,K,DIS[1010],IN[1010];
bool check(int t){
    lp(i,1,N)DIS[i]=~0u&gt;&gt;1,IN[i]=0;
    DIS[1]=0;IN[1]=1;
    queue&lt;int&gt; Q;Q.push(1);
    while(!Q.empty()){
        int u=Q.front();Q.pop();IN[u]=0;
        lp(i,0,int(E[u].size())-1){
            int v=E[u][i],w=(W[u][i]&gt;t);
            if(DIS[u]+w&lt;DIS[v]){
                DIS[v]=DIS[u]+w;
                if(!IN[v]){
                    IN[v]=1;
                    Q.push(v);
                }
            }
        }
    }
    return DIS[N]&lt;=K;
}
int main(){
    sf("%d%d%d",&amp;N,&amp;P,&amp;K);
    lp(i,1,P){
        int ai,bi,ci;
        sf("%d%d%d",&amp;ai,&amp;bi,&amp;ci);
        E[ai].push_back(bi);
        W[ai].push_back(ci);
        E[bi].push_back(ai);
        W[bi].push_back(ci);
    }
    if(check(0)){
        pf("0\n");
    }else if(!check(1000010)){
        pf("-1\n");
    }else{
        int l=0,r=1000010;
        //lcan,rcan't
        while(l+1&lt;r){
            if(check((l+r)/2))
                r=(l+r)/2;
            else
                l=(l+r)/2;
        } 
        pf("%d\n",r);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1616</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
char pm[110][110];int n,m,t,r1,c1,r2,c2;
int vis[110][110][20];
ll f[110][110][20];
ll dp(int x,int y,int tim){
	if(!vis[x][y][tim]){
		vis[x][y][tim]=1;
		if(tim==0)f[x][y][tim]=(x==r1&amp;&amp;y==c1);
		else{
			if(x!=1&amp;&amp;pm[x-1][y]!='*')f[x][y][tim]+=dp(x-1,y,tim-1);
			if(x!=n&amp;&amp;pm[x+1][y]!='*')f[x][y][tim]+=dp(x+1,y,tim-1);
			if(y!=1&amp;&amp;pm[x][y-1]!='*')f[x][y][tim]+=dp(x,y-1,tim-1);
			if(y!=m&amp;&amp;pm[x][y+1]!='*')f[x][y][tim]+=dp(x,y+1,tim-1);
		}
	}
	return f[x][y][tim];
}
int main(){
	sf("%d%d%d",&amp;n,&amp;m,&amp;t);
	lp(i,1,n)sf("%s",pm[i]+1);
	sf("%d%d%d%d",&amp;r1,&amp;c1,&amp;r2,&amp;c2);
	pf("%lld\n",dp(r2,c2,t));
    return 0;
}<pre><h2>Problem1617</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m,c[2510],f[2500];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;c[i]),c[i]+=c[i-1];
    lp(i,1,n)f[i]=m+c[i];
    lp(i,1,n)lp(j,1,i-1)f[i]=min(f[i],f[i-j]+m+c[j]+m);
    pf("%d\n",f[n]);
    //ps;
    return 0;
}
<pre><h2>Problem1618</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int f[100010],n,h;
int main(){
	sf("%d%d",&amp;n,&amp;h);
	lp(i,1,100000)f[i]=~0u&gt;&gt;1;
	lp(i,1,n){
		int p,c;sf("%d%d",&amp;p,&amp;c);
		lp(j,p,100000){
			if(f[j-p]!=~0u&gt;&gt;1)
				f[j]=min(f[j],f[j-p]+c);
		}
	}
	pf("%d\n",*min_element(f+h,f+100001));
	return 0;
}<pre><h2>Problem1621</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll f(ll n,ll k){
	if(n&lt;=k||n%2!=k%2)return 1;
	else return f((n+k)/2,k)+f((n-k)/2,k);
}
int main(){
	ll n,k;sf("%lld%lld",&amp;n,&amp;k);
	pf("%lld\n",f(n,k));
    return 0;
}<pre><h2>Problem1625</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int w,d,n,m,f[20010];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n){
		sf("%d%d",&amp;w,&amp;d);
		rp(j,m,w)f[j]=max(f[j],f[j-w]+d);
	}
	pf("%d\n",f[m]);
	return 0;
}<pre><h2>Problem1626</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;iomanip&gt;
using namespace std;
int n,m,p[1010];
int fd(int x){
	return x==p[x]?x:p[x]=fd(p[x]);
}
int lk(int x,int y){
	if(fd(x)!=fd(y))
	p[fd(x)]=y;
}
struct edge{
	edge(){
	}
	edge(double a,int b,int c):
		len(a),x(b),y(c){
		}
	long double len;
	int x,y;
};
bool operator&lt;(edge a,edge b){
	return a.len&lt;b.len;
}
long double px[1010],py[1010];
long double W(int x,int y){
	typedef long double ld;
	ld t1=px[x]-px[y];
	ld t2=py[x]-py[y];
	t1*=t1;
	t2*=t2;
	return sqrt(t1+t2);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;++i){
	p[i]=i;
	cin&gt;&gt;px[i]&gt;&gt;py[i];
}
	for(int i=1;i&lt;=m;++i){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		lk(u,v);
	}
	static edge es[1000010];
	int el=0;
	for(int i=1;i&lt;=n;++i)
		for(int j=i+1;j&lt;=n;++j)
			es[++el]=edge(W(i,j),i,j);
	sort(es+1,es+el+1);
	long double ans=0;
	for(int i=1;i&lt;=el;++i){
		if(fd(es[i].x)!=fd(es[i].y)){
			ans+=es[i].len;
			lk(es[i].x,es[i].y);
		}
	}
	cout&lt;&lt;fixed&lt;&lt;setprecision(2);
	cout&lt;&lt;ans&lt;&lt;endl;
	//	for(;;);
	return 0;
}<pre><h2>Problem1627</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
#include&lt;set&gt;
set&lt;pair&lt;int,int&gt; &gt;bad;
int ex,ey,n;
int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
int main(){
	sf("%d%d%d",&amp;ex,&amp;ey,&amp;n);
	lp(i,1,n){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		bad.insert(mp(a,b));
	}
	queue&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;qu;
	qu.push(mp(0,mp(0,0)));bad.insert(mp(0,0));
	while(!qu.empty()){
		int d=qu.front().first,x=qu.front().second.first,y=qu.front().second.second;
		qu.pop();
		if(x==ex&amp;&amp;y==ey){pf("%d\n",d);return 0;}
		lp(i,0,3){
			int tx=x+dir[i][0],ty=y+dir[i][1];
			if(!bad.count(mp(tx,ty))){
				bad.insert(mp(tx,ty));
				qu.push(mp(d+1,mp(tx,ty)));
			}
		}
	}
	return 0;
}<pre><h2>Problem1629</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n;
struct cow{int w,s;}cs[50010];
bool operator&lt;(cow a,cow b){return a.w+a.s&lt;b.w+b.s;}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;cs[i].w,&amp;cs[i].s);
    sort(cs+1,cs+n+1);
    int ans=-(~0u&gt;&gt;1),sum=0;
    lp(i,1,n){ans=max(ans,sum-cs[i].s);sum+=cs[i].w;}
    pf("%d\n",ans);//ps;
    return 0;
}
<pre><h2>Problem1636</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int A[50010],F[50010][20],G[50010][20],N;
void init(){
    lp(i,1,N)F[i][0]=A[i];
    lp(i,1,N)G[i][0]=A[i];
    for(int j=1;(1&lt;&lt;j)&lt;=N;++j)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;++i)
            F[i][j]=min(F[i][j-1],F[i+(1&lt;&lt;(j-1))][j-1]),
            G[i][j]=max(G[i][j-1],G[i+(1&lt;&lt;(j-1))][j-1]);
}
int rmq(int l,int r){
    int k=0;
    while((1&lt;&lt;(k+1))&lt;=r-l+1)++k;
    //int k=log((r-l+1)*1.0)/log(2.0);
    return max(G[l][k],G[r-(1&lt;&lt;k)+1][k])-min(F[l][k],F[r-(1&lt;&lt;k)+1][k]);
}
int main(){
    //freopen("lineup.in","r",stdin);
    //freopen("lineup.out","w",stdout);
    int q;
    sf("%d%d",&amp;N,&amp;q);
    lp(i,1,N)sf("%d",&amp;A[i]);
    init();
    lp(i,1,q){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        pf("%d\n",rmq(a,b));
    }
    //ps;
    return 0;
}<pre><h2>Problem1637</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct cow{
    cow(){sf("%d%d",&amp;kid,&amp;pos);}
    int kid,pos;
};
bool operator&lt;(cow a,cow b){
    return a.pos&lt;b.pos;
}
vector&lt;cow&gt;cows;int n;
int sum[50010];
struct node{
    node(int a,int b):
        s(a),p(b){}
    int s,p;
};
bool operator&lt;(node a,node b){
    return a.s&lt;b.s;
}
set&lt;node&gt;st;
int main(){
    sf("%d",&amp;n);int ans=0;
    lp(i,1,n)cows.push_back(cow());
    sort(cows.begin(),cows.end());
    lp(i,0,int(cows.size()-1))
        if(cows[i].kid==0)sum[i+1]=-1;
        else sum[i+1]=1;
    lp(i,1,n)sum[i]+=sum[i-1];
    st.insert(node(0,cows[0].pos));
    lp(i,0,int(cows.size()-1)){
        set&lt;node&gt;::iterator it=st.lower_bound(node(sum[i+1],0));
        if(it!=st.end()&amp;&amp;it-&gt;s==sum[i+1])
            ans=max(ans,cows[i].pos-it-&gt;p);
        if(i+1!=cows.size()){
            st.insert(node(sum[i+1],cows[i+1].pos));
        }
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1637</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct cow{
    cow(){sf("%d%d",&amp;kid,&amp;pos);}
    int kid,pos;
};
bool operator&lt;(cow a,cow b){
    return a.pos&lt;b.pos;
}
vector&lt;cow&gt;cows;int n;
int sum[50010];
struct node{
    node(int a,int b):
        s(a),p(b){}
    int s,p;
};
bool operator&lt;(node a,node b){
    return a.s&lt;b.s;
}
set&lt;node&gt;st;
int main(){
    sf("%d",&amp;n);int ans=0;
    lp(i,1,n)cows.push_back(cow());
    sort(cows.begin(),cows.end());
    lp(i,0,int(cows.size()-1))
        if(cows[i].kid==0)sum[i+1]=-1;
        else sum[i+1]=1;
    lp(i,1,n)sum[i]+=sum[i-1];
    st.insert(node(0,cows[0].pos));
    lp(i,0,int(cows.size()-1)){
        set&lt;node&gt;::iterator it=st.lower_bound(node(sum[i+1],0));
        if(it!=st.end()&amp;&amp;it-&gt;s==sum[i+1])
            ans=max(ans,cows[i].pos-it-&gt;p);
        else if(i+1!=cows.size()){
            st.insert(node(sum[i+1],cows[i+1].pos));
        }
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1664</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
bool cmp(pair&lt;int,int&gt;x,pair&lt;int,int&gt;y){
	return x.second&lt;y.second;
}
int main(){
	int n;vector&lt;pair&lt;int,int&gt; &gt;a;
	sf("%d",&amp;n);
	lp(i,1,n){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		a.pb(mp(u,u+v));
	}
	sort(a.begin(),a.end(),cmp);
	int cur=-100;
	int ans=0;
	vp(i,a){
		if(a[i].first&gt;=cur){
			++ans;
			cur=a[i].second;
		}
	}
	pf("%d\n",ans);
	return 0;
}<pre><h2>Problem1666</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int cnt(int x){
	int ret=0;
	while(x!=1){
		if(x&amp;1)x=x*3+1;
		else x/=2;
		++ret;
	}
	return ret;
}
int main(){
	int n;sf("%d",&amp;n);
	pf("%d\n",cnt(n));
    return 0;
}<pre><h2>Problem1669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int main(){
	int n;sf("%d",&amp;n);vector&lt;ll&gt;f;
	lp(i,1,n){
		ll t;sf("%lld",&amp;t);
		if(f.empty()||f.back()&lt;t)f.pb(t);
		else *lower_bound(f.begin(),f.end(),t)=t;
	}
	pf("%d\n",int(f.size()));
    return 0;
}<pre><h2>Problem1670</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
typedef complex&lt;ll&gt; P;
ll det(P a,P b){return imag(conj(a)*b);}
bool cmp(P a,P b){
    if(real(a)==real(b))return imag(a)&lt;imag(b);
    else return real(a)&lt;real(b);
}
double dis(P a,P b){
    double t1=real(a)-real(b);
    double t2=imag(a)-imag(b);
    return sqrt(t1*t1+t2*t2);
}
int n;vector&lt;P&gt;pts,up,lw;
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        ll u,v;sf("%d%d",&amp;u,&amp;v);
        pts.push_back(P(u,v));
    }
    sort(pts.begin(),pts.end(),cmp);
    lp(i,0,int(pts.size()-1)){
        while(up.size()&gt;1&amp;&amp;det(pts[i]-up[up.size()-2],up[up.size()-1]-up[up.size()-2])&gt;=0)
            up.pop_back();
        up.push_back(pts[i]);
    }
    for(int i=int(pts.size()-1);i&gt;=0;--i){
        while(lw.size()&gt;1&amp;&amp;det(pts[i]-lw[lw.size()-2],lw[lw.size()-1]-lw[lw.size()-2])&gt;=0)
            lw.pop_back();
        lw.push_back(pts[i]);
    }
    double ans=0;
    lp(i,0,int(up.size()-2)){
        ans+=dis(up[i],up[i+1]);
    }
    lp(i,0,int(lw.size()-2)){
        ans+=dis(lw[i],lw[i+1]);
    }
    pf("%.2lf\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1677</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll f[1000010],n,p=1000*1000*1000;
int main(){
	sf("%lld",&amp;n);
	f[0]=1;
	for(int i=1;i&lt;=n;i*=2)
		for(int j=i;j&lt;=n;++j)
			f[j]=(f[j]+f[j-i])%p;
	pf("%lld\n",f[n]);
	return 0;
}<pre><h2>Problem1679</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;ll a[10010],s[10010];
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%lld",&amp;a[i]);
	sort(a+1,a+n+1);
	lp(i,1,n)s[i]=s[i-1]+a[i];
	ll ans=0;
	lp(i,1,n)ans+=a[i]*(i-1)-s[i-1]+s[n]-s[i]-a[i]*(n-i);
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1681</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int f,p,c,m,dis[510];
vector&lt;int&gt;to[510],we[510];
int main(){
	sf("%d%d%d%d",&amp;f,&amp;p,&amp;c,&amp;m);
	lp(i,1,p){
		int f1,f2,t;sf("%d%d%d",&amp;f1,&amp;f2,&amp;t);
		to[f1].pb(f2);
		we[f1].pb(t);
		to[f2].pb(f1);
		we[f2].pb(t);
	}
	lp(i,2,f)dis[i]=~0u&gt;&gt;1;
	lp(i,1,f)lp(u,1,f)vp(j,to[u]){
		int v=to[u][j],w=we[u][j];
		if(dis[u]==~0u&gt;&gt;1)continue;
		if(dis[u]+w&lt;dis[v])dis[v]=dis[u]+w;
	}
	vector&lt;int&gt;ans2;
	int ans=0;
	lp(i,1,c){
		int t;sf("%d",&amp;t);
		if(dis[t]&lt;=m)++ans,ans2.pb(i);
	}
	pf("%d\n",ans);
	vp(i,ans2)pf("%d\n",ans2[i]);
	return 0;
}<pre><h2>Problem1692</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
char str[60010];int len;
namespace sam{
    int pr[120010],ln[120010],tr[120010][26],lst=1,nw=1;
    int vo[120010],lf[120010],ch[120010][26];
    void add(int c,int d){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;vo[np]=d;lf[np]=d;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                lp(i,0,25)tr[nq][i]=tr[q][i];
                pr[q]=pr[np]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int sa[60010],rk[60010];
    bool cmp(int x,int y){return ln[x]&lt;ln[y];} 
    void bud(){
        static int tmp[120010];
        lp(i,1,nw)tmp[i]=i;
        sort(tmp+1,tmp+nw+1,cmp);
        rp(i,nw,1){
            int u=tmp[i];
            vo[pr[u]]=vo[u];
            ch[pr[u]][str[vo[u]-ln[pr[u]]]-'A']=u;
        }
    }
    void dfs(){
        stack&lt;int&gt;stk;stk.push(1);
        while(!stk.empty()){
            int u=stk.top();stk.pop();
            if(lf[u])sa[++sa[0]]=lf[u];
            rp(i,25,0)if(ch[u][i])stk.push(ch[u][i]);
        }
        lp(i,1,len)rk[sa[i]]=i;
    }
}
int main(){
    sf("%d",&amp;len);
    lp(i,1,len){
        char tmp[11];sf("%s",tmp);
        str[i]=tmp[0];
    }
    lp(i,1,len)str[len+i]=str[len-i+1];len*=2;
    lp(i,1,len)sam::add(str[i]-'A',i);
    sam::bud();
    sam::dfs();
    int left=1,right=len/2;
    lp(i,1,len/2){
        if(sam::rk[len-left+1]&lt;sam::rk[right])
            pf("%c",str[left]),++left;
        else
            pf("%c",str[right]),--right;
        if(i%80==0||i==len/2)pf("\n");
    }
    //ps;
    return 0; 
}
<pre><h2>Problem1692</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
char str[60010];int len;
namespace sam{
    int pr[120010],ln[120010],tr[120010][26],lst=1,nw=1;
    int vo[120010],lf[120010],ch[120010][26];
    void add(int c,int d){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;vo[np]=d;lf[np]=d;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                lp(i,0,25)tr[nq][i]=tr[q][i];
                pr[q]=pr[np]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int sa[60010],rk[60010];
    bool cmp(int x,int y){return ln[x]&lt;ln[y];} 
    void bud(){
        static int tmp[120010];
        static int cc[60010];
        lp(i,1,nw)++cc[ln[i]];
        lp(i,1,len)cc[i]+=cc[i-1];
        lp(i,1,nw)tmp[cc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            vo[pr[u]]=vo[u];
            ch[pr[u]][str[vo[u]-ln[pr[u]]]-'A']=u;
        }
    }
    void dfs(){
        stack&lt;int&gt;stk;stk.push(1);
        while(!stk.empty()){
            int u=stk.top();stk.pop();
            if(lf[u])sa[++sa[0]]=lf[u];
            rp(i,25,0)if(ch[u][i])stk.push(ch[u][i]);
        }
        lp(i,1,len)rk[sa[i]]=i;
    }
}
int main(){
    sf("%d",&amp;len);
    lp(i,1,len){
        char tmp[11];sf("%s",tmp);
        str[i]=tmp[0];
    }
    lp(i,1,len)str[len+i]=str[len-i+1];len*=2;
    lp(i,1,len)sam::add(str[i]-'A',i);
    sam::bud();
    sam::dfs();
    int left=1,right=len/2;
    lp(i,1,len/2){
        if(sam::rk[len-left+1]&lt;sam::rk[right])
            pf("%c",str[left]),++left;
        else
            pf("%c",str[right]),--right;
        if(i%80==0||i==len/2)pf("\n");
    }
    //ps;
    return 0; 
}
<pre><h2>Problem1697</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int a[10010],b[10010],v[10010],n;map&lt;int,int&gt;pos;
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i]),b[i]=a[i];
    sort(a+1,a+n+1);
    lp(i,1,n)pos[a[i]]=i;
    long long ans=0;
    int emi=~0u&gt;&gt;1;
    lp(i,1,n)emi=min(emi,a[i]);
    lp(i,1,n){
        if(!v[i]){
            int t=i;long long sum=0,mi=~0u&gt;&gt;1,sz=0;
            do{
                //pf("[%d]",t);
                v[t]=1;
                sum+=a[t];mi=min(mi,(long long)a[t]);
                ++sz;
                t=pos[b[t]];
                //pf("[%d]",t);
            }while(!v[t]);
            ans+=min((sz-1)*mi+sum-mi,emi+mi+sum+sz*emi);
        }
    }
    pf("%lld\n",ans);
    //ps;
    return 0; 
}
<pre><h2>Problem1699</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int mx[50010*4],mi[50010*4];
int ht[50010],n,q;
void build(int x,int l,int r){
    if(l==r)mx[x]=mi[x]=ht[l];
    else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r); 
        mx[x]=max(mx[x*2],mx[x*2+1]);
        mi[x]=min(mi[x*2],mi[x*2+1]);
    }
}
int askmi(int x,int l,int r,int b,int e){
    if(b&lt;=l&amp;&amp;e&gt;=r)return mi[x];
    else{
        int m=(l+r)/2,ans=~0u&gt;&gt;1;
        if(b&lt;=m)ans=min(ans,askmi(x*2,l,m,b,e));
        if(e&gt;m)ans=min(ans,askmi(x*2+1,m+1,r,b,e));
        return ans; 
    }
}
int askmx(int x,int l,int r,int b,int e){
    if(b&lt;=l&amp;&amp;e&gt;=r)return mx[x];
    else{
        int m=(l+r)/2,ans=-(~0u&gt;&gt;1);
        if(b&lt;=m)ans=max(ans,askmx(x*2,l,m,b,e));
        if(e&gt;m)ans=max(ans,askmx(x*2+1,m+1,r,b,e));
        return ans; 
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n)sf("%d",&amp;ht[i]);
    build(1,1,n);
    lp(i,1,q){
        int l,r;sf("%d%d",&amp;l,&amp;r);
        pf("%d\n",askmx(1,1,n,l,r)-askmi(1,1,n,l,r)); 
    } 
    //ps;
    return 0;
} 
<pre><h2>Problem1705</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,c,f[100010][110],a[100010];
int tb(int x){return x&gt;0?x:-x;}
int main(){
	sf("%d%d",&amp;n,&amp;c);
	lp(i,1,n)sf("%d",&amp;a[i]);
	lp(i,a[1],100)f[1][i]=(i-a[1])*(i-a[1]);
	lp(i,2,n)lp(j,a[i],100){
		f[i][j]=~0u&gt;&gt;1;
		lp(k,a[i-1],100)f[i][j]=min(f[i][j],f[i-1][k]+tb(j-k)*c+(j-a[i])*(j-a[i]));
	}
	pf("%d\n",*min_element(f[n]+a[n],f[n]+101));
	return 0;
}<pre><h2>Problem1707</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
	struct edge{
		edge(int a,int b):v(a),c(b){}
		int v,c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
	int dis[100010],gap[100010],vcnt;
	void add(int u,int v,int c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
		to[v].pb(eg.size());
		eg.pb(edge(u,0));
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	int solve(){
		gap[0]=vcnt;int r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
int n,m,nw,lft[3010],rht[3010],spa[3010],cov[3010];
vector&lt;int&gt;item[1010];
int idcow[3010],itid[3010],idst,idet;
int idx[1010*4];
void build(int x,int l,int r){
	idx[x]=++nw;
	if(l!=r){
		int m=(l+r)/2;
		build(x*2,l,m);
		build(x*2+1,m+1,r);
		isap::add(idx[x],idx[x*2],~0u&gt;&gt;1);
		isap::add(idx[x],idx[x*2+1],~0u&gt;&gt;1);
	}else{
		vp(i,item[l]){
			isap::add(idx[x],item[l][i],~0u&gt;&gt;1);
		}
	}
}
void query(int x,int l,int r,int b,int e,int he){
	if(b&lt;=l&amp;&amp;e&gt;=r)isap::add(he,idx[x],1);
	else{
		int m=(l+r)/2;
		if(b&lt;=m)query(x*2,l,m,b,e,he);
		if(e&gt;m)query(x*2+1,m+1,r,b,e,he);
	}
}
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n)sf("%d%d",&amp;lft[i],&amp;rht[i]);
	lp(i,1,m)sf("%d%d",&amp;spa[i],&amp;cov[i]);
	idst=++nw;
	lp(i,1,n)idcow[i]=++nw;
	lp(i,1,m)itid[i]=++nw;
	lp(i,1,m)item[spa[i]].pb(itid[i]);
	build(1,1,1000);
	idet=++nw;isap::vcnt=nw;
	lp(i,1,n)isap::add(idst,idcow[i],1);
	lp(i,1,m)isap::add(itid[i],idet,cov[i]);
	lp(i,1,n)query(1,1,1000,lft[i],rht[i],idcow[i]);
	pf("%d\n",isap::solve());
	return 0;
}<pre><h2>Problem1708</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,v,a[31];
ll f[10010];
int main(){
    sf("%d%d",&amp;n,&amp;v);
    lp(i,1,n)sf("%d",&amp;a[i]);
    f[0]=1;
    lp(i,1,n)lp(j,0,v){
        if(j&gt;=a[i])
            f[j]+=f[j-a[i]];
    }
    pf("%lld\n",f[v]);
    //ps;
    return 0;
} 
<pre><h2>Problem1709</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,k,a[110][110];
int main(){
	sf("%d%d",&amp;n,&amp;k);
	lp(i,1,k){
		int x,y;
		sf("%d%d",&amp;x,&amp;y);
		++a[x][y];
	}
	vector&lt;pair&lt;int,int&gt; &gt;tmp;
	lp(i,1,n)lp(j,1,n)if(a[i][j])tmp.pb(mp(i,j));
	int ans=0;
	lp(i,1,n)lp(j,1,n){
		int t=1;
		vp(k,tmp){
			int x=tmp[k].first,y=tmp[k].second;
			if(x!=i&amp;&amp;y!=j&amp;&amp;x+y!=i+j&amp;&amp;x-y!=i-j){t=0;break;}
		}
		ans+=t;
	}
	pf("%d\n",ans);
	return 0;
}<pre><h2>Problem1710</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,m,w[1010];
char s[2010];
int dp[2010][2010];
int main(){
	sf("%d%d%s",&amp;n,&amp;m,s+1);
	lp(i,1,n){
		static char buff[110];
		int t1,t2;sf("%s%d%d",buff,&amp;t1,&amp;t2);
		w[buff[0]]=min(t1,t2);
	}
	lp(d,2,m){
		for(int i=1;i+d-1&lt;=m;++i){
			int j=i+d-1;
			dp[i][j]=~0u&gt;&gt;1;
			if(s[i]==s[j])dp[i][j]=min(dp[i][j],dp[i+1][j-1]);
			dp[i][j]=min(dp[i][j],dp[i+1][j]+w[s[i]]);
			dp[i][j]=min(dp[i][j],dp[i][j-1]+w[s[j]]);
		}
	}
	//lp(i,1,m)lp(j,i,m)pf("[%d,%d,%d]\n",i,j,dp[i][j]);
	pf("%d\n",dp[1][m]);
	return 0;
}<pre><h2>Problem1711</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
	struct edge{
		edge(int a,int b):v(a),c(b){}
		int v,c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[10010];
	int dis[10010],gap[10010],vcnt;
	void add(int u,int v,int c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
		to[v].pb(eg.size());
		eg.pb(edge(u,0));
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	int solve(){
		gap[0]=vcnt;int r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
int main(){
	int n,f,d;static int idcow[110][2],idfood[110],iddrink[110],idst,idet;
	int nw=0;
	sf("%d%d%d",&amp;n,&amp;f,&amp;d);
	idst=++nw;
	lp(i,1,n)idcow[i][0]=++nw,idcow[i][1]=++nw;
	lp(i,1,f)idfood[i]=++nw;
	lp(i,1,d)iddrink[i]=++nw;
	idet=++nw;
	isap::vcnt=nw;
	lp(i,1,n){
		int fi,di;sf("%d%d",&amp;fi,&amp;di);
		lp(j,1,fi){
			int t;sf("%d",&amp;t);
			isap::add(idfood[t],idcow[i][0],1);
		}
		lp(j,1,di){
			int t;sf("%d",&amp;t);
			isap::add(idcow[i][1],iddrink[t],1);
		}
		isap::add(idcow[i][0],idcow[i][1],1);
	}
	lp(i,1,f)isap::add(idst,idfood[i],1);
	lp(i,1,d)isap::add(iddrink[i],idet,1);
	pf("%d\n",isap::solve());
	return 0;
}<pre><h2>Problem1711</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
	struct edge{
		edge(int a,int b):v(a),c(b){}
		int v,c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[10010];
	int dis[10010],gap[10010],vcnt;
	void add(int u,int v,int c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
		to[v].pb(eg.size());
		eg.pb(edge(u,0));
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	int solve(){
		gap[0]=vcnt;int r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
int main(){
	int n,f,d;static int idcow[110][2],idfood[110],iddrink[110],idst,idet;
	int nw=0;
	sf("%d%d%d",&amp;n,&amp;f,&amp;d);
	idst=++nw;
	lp(i,1,n)idcow[i][0]=++nw,idcow[i][1]=++nw;
	lp(i,1,f)idfood[i]=++nw;
	lp(i,1,d)iddrink[i]=++nw;
	idet=++nw;
	isap::vcnt=nw;
	lp(i,1,n){
		int fi,di;sf("%d%d",&amp;fi,&amp;di);
		lp(j,1,fi){
			int t;sf("%d",&amp;t);
			isap::add(idfood[t],idcow[i][0],1);
		}
		lp(j,1,di){
			int t;sf("%d",&amp;t);
			isap::add(idcow[i][1],iddrink[t],1);
		}
		isap::add(idcow[i][0],idcow[i][1],1);
	}
	lp(i,1,f)isap::add(idst,idfood[i],1);
	lp(i,1,d)isap::add(iddrink[i],idet,1);
	pf("%d\n",isap::solve());
	return 0;
}<pre><h2>Problem1715</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace bellman{
	vector&lt;int&gt;to[1010],we[1010];int vcnt;
	void clear(){
		lp(i,1,vcnt)to[i].clear(),we[i].clear();
	}
	void add(int u,int v,int w){
		to[u].pb(v);
		we[u].pb(w);
	}
	bool solve(){
		static int dis[1010];
		lp(i,1,vcnt)dis[i]=0;
		lp(i,1,vcnt)lp(j,1,vcnt)vp(k,to[j]){
			int u=j,v=to[j][k],w=we[j][k];
			if(dis[u]+w&lt;dis[v])dis[v]=dis[u]+w;
		}
		lp(i,1,vcnt)lp(j,1,vcnt)vp(k,to[j]){
			int u=j,v=to[j][k],w=we[j][k];
			if(dis[u]+w&lt;dis[v])return false;
		}
		return true;
	}
}
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		int n,m,w;sf("%d%d%d",&amp;n,&amp;m,&amp;w);
		bellman::vcnt=n;bellman::clear();
		lp(i,1,m){
			int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
			bellman::add(u,v,w);
			bellman::add(v,u,w);
		}
		lp(i,1,w){
			int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
			bellman::add(u,v,-w);
		}
		pf("%s\n",bellman::solve()?"NO":"YES");
	}
	return 0;
}<pre><h2>Problem1717</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef unsigned uint;int n,k;
uint pw[20010],hs[20010];
uint get(int l,int r){
    return hs[r]-hs[l-1]*pw[r-l+1];
}
bool check(int x){
    map&lt;uint,int&gt;st;
    for(int i=1;i+x-1&lt;=n;++i){
        uint t=get(i,i+x-1);
        if((++st[t])&gt;=k)return true;
    }
    return false;
}
int main(){
    sf("%d%d",&amp;n,&amp;k);
    pw[0]=1;lp(i,1,n)pw[i]=pw[i-1]*23;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        hs[i]=hs[i-1]*23+uint(t);
    }
    int l=1,r=n;
    if(!check(l))pf("0\n");
    else if(check(r))pf("%d\n",n);
    else{
        while(l+1&lt;r){
            int m=(l+r)/2;
            if(check(m))l=m;
            else r=m;
        }
        pf("%d\n",l);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1724</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
#include&lt;functional&gt;
int main(){
	priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;qu;
	int n;ll ans=0;sf("%d",&amp;n);
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		qu.push(t);
	}
	while(qu.size()&gt;1){
		ll u1=qu.top();qu.pop();
		ll u2=qu.top();qu.pop();
		ans+=u1+u2;
		qu.push(u1+u2);
	}
	pf("%lld\n",ans);
	return 0;
}<pre><h2>Problem1725</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,m,forbid[21][21],p=100000000,dp[21][21][10010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m){
        sf("%d",&amp;forbid[i][j]);
        forbid[i][j]^=1;
    }
    dp[0][m][0]=1;
    lp(i,0,n)lp(j,1,m)lp(k,0,(1&lt;&lt;m)-1){
        if(j==m){
            if(!(k&amp;1)&amp;&amp;!forbid[i+1][1]){
                dp[i+1][1][k+1]+=dp[i][j][k];
                dp[i+1][1][k+1]%=p;
            }
            int t=k;if(t&amp;1)--t;
            dp[i+1][1][t]+=dp[i][j][k];
            dp[i+1][1][t]%=p;
        }else{
            if(!((k&gt;&gt;(j-1))&amp;1)&amp;&amp;!((k&gt;&gt;j)&amp;1)&amp;&amp;!forbid[i][j+1]){
                dp[i][j+1][k+(1&lt;&lt;j)]+=dp[i][j][k];
                dp[i][j+1][k+(1&lt;&lt;j)]%=p;
            }
            int t=k;if((t&gt;&gt;j)&amp;1)t-=(1&lt;&lt;j);
            dp[i][j+1][t]+=dp[i][j][k];
            dp[i][j+1][t]%=p;
        }
    }
    int ans=0;
    lp(i,0,(1&lt;&lt;m)-1){
        ans+=dp[n][m][i];
        ans%=p;
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1726</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
vector&lt;int&gt;to[5010],we[5010];
int in[5010],f[5010][2],n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].push_back(v);we[u].push_back(w);
        to[v].push_back(u);we[v].push_back(w);
    }
    lp(i,1,n)f[i][0]=f[i][1]=~0u&gt;&gt;1;
    f[1][0]=0;
    queue&lt;int&gt;qu;qu.push(1);in[1]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();in[u]=0;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i],w=we[u][i];
            vector&lt;int&gt;tmp;
            tmp.push_back(f[v][0]);
            tmp.push_back(f[v][1]);
            if(f[u][0]!=~0u&gt;&gt;1)
                tmp.push_back(f[u][0]+w);
            if(f[u][1]!=~0u&gt;&gt;1)
                tmp.push_back(f[u][1]+w);
            sort(tmp.begin(),tmp.end());
            unique(tmp.begin(),tmp.end());
            if(tmp[0]!=f[v][0]||tmp[1]!=f[v][1]){
                f[v][0]=tmp[0];
                f[v][1]=tmp[1];
                //pf("[%d,%d,%d]\n",v,f[v][0],f[v][1]);
                if(!in[v]){
                    in[v]=1;
                    qu.push(v); 
                } 
            }
        }
    }
    pf("%d\n",f[n][1]);
    //ps;
    return 0;
}
<pre><h2>Problem1753</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int main(){
    int n;sf("%d",&amp;n);
    static int a[10010];
    lp(i,1,n)sf("%d",&amp;a[i]);
    sort(a+1,a+n+1);
    pf("%d\n",a[(n+1)/2]); 
    //ps;
    return 0; 
} 
<pre><h2>Problem1754</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt; 
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef vector&lt;int&gt; num;
num give(){
    num a;static char t[110];sf("%s",t+1);int l=strlen(t+1);
    reverse(t+1,t+l+1);
    lp(i,1,l)
        a.push_back(t[i]-'0');
    return a;
}
num mul(num a,num b){
    num c(a.size()+b.size(),0);
    lp(i,0,int(a.size()-1))
        lp(j,0,int(b.size()-1))
            c[i+j]+=a[i]*b[j];
    lp(i,0,int(c.size()-2))
        c[i+1]+=c[i]/10,
        c[i]%=10;
    while(c.size()&gt;1&amp;&amp;!c.back())c.pop_back();
    return c; 
}
void prit(num a){
    reverse(a.begin(),a.end());
    for(int i=0;i&lt;a.size();++i)pf("%d",a[i]);
}
int main(){
    num a=give();num b=give();
    num c=mul(a,b);
    prit(c);pf("\n");
    //ps;
    return 0; 
} 
<pre><h2>Problem1755</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cmath&gt;
int main(){
	int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
	long double t=b;
	lp(i,1,c)t*=(double(100+a)/100);
	pf("%d\n",int(t));
	return 0;
}<pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll val[500010];
struct node{
    node(int a,int b){
        ch[0]=ch[1]=0;
        l=a;r=b;
    }
    node*ch[2];int l,r;
    ll sum,lm,rm,mm;
};
void upda(node*x){
    x-&gt;sum=x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;sum;
    x-&gt;lm=max(x-&gt;ch[0]-&gt;lm,x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;lm);
    x-&gt;rm=max(x-&gt;ch[1]-&gt;rm,x-&gt;ch[1]-&gt;sum+x-&gt;ch[0]-&gt;rm);
    x-&gt;mm=max(x-&gt;ch[0]-&gt;mm,x-&gt;ch[1]-&gt;mm);
    x-&gt;mm=max(x-&gt;mm,x-&gt;ch[0]-&gt;rm+x-&gt;ch[1]-&gt;lm); 
}
node*build(int l,int r){
    node*t=new node(l,r);
    if(l==r)t-&gt;sum=t-&gt;lm=t-&gt;rm=t-&gt;mm=val[l];
    else{
        int m=(l+r)/2;
        t-&gt;ch[0]=build(l,m);
        t-&gt;ch[1]=build(m+1,r);
        upda(t);
    } 
    //pf("[%d,%d,%I64d,%I64d,%I64d,%I64d]\n",l,r,t-&gt;sum,t-&gt;lm,t-&gt;rm,t-&gt;mm);
    return t;
}
void modi(node*x,int p,ll v){
    if(x-&gt;l==x-&gt;r){
        x-&gt;sum=x-&gt;lm=x-&gt;rm=x-&gt;mm=v;
    }else{
        if(p&lt;=x-&gt;ch[0]-&gt;r)modi(x-&gt;ch[0],p,v);
        else modi(x-&gt;ch[1],p,v);
        upda(x);
    }
}
node que(node*x,int l,int r){
    if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return *x;
    else{
        int m=(x-&gt;l+x-&gt;r)/2;
        if(r&lt;=m)return que(x-&gt;ch[0],l,r);
        else if(l&gt;m)return que(x-&gt;ch[1],l,r);
        else{
            node t(l,r),y=que(x-&gt;ch[0],l,m),z=que(x-&gt;ch[1],m+1,r);
            t.ch[0]=&amp;y;
            t.ch[1]=&amp;z;
            upda(&amp;t);
            return t;
        } 
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%lld",&amp;val[i]);
    node*rt=build(1,n);
    lp(i,1,m){
        int q,l,r;sf("%d%d%d",&amp;q,&amp;l,&amp;r);
        if(q==1)pf("%lld\n",que(rt,min(l,r),max(l,r)).mm);
        else modi(rt,l,r);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1782</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;vector&lt;int&gt;to[100010];
int bg[100010],ed[100010],ti;
void dfs(int u,int p){
	bg[u]=++ti;
	vp(i,to[u])if(to[u][i]!=p)dfs(to[u][i],u);
	ed[u]=ti;
}
int sum[100010*4];
void add(int x,int l,int r,int b,int e){
	if(b&lt;=l&amp;&amp;e&gt;=r)++sum[x];
	else{
		int m=(l+r)/2;
		if(b&lt;=m)add(x*2,l,m,b,e);
		if(e&gt;m)add(x*2+1,m+1,r,b,e);
	}
}
int ask(int x,int l,int r,int p){
	if(l==r)return sum[x];
	else{
		int m=(l+r)/2;
		if(p&lt;=m)return ask(x*2,l,m,p)+sum[x];
		else return ask(x*2+1,m+1,r,p)+sum[x];
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,2,n){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		to[a].pb(b);
		to[b].pb(a);
	}
	dfs(1,0);
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		pf("%d\n",ask(1,1,n,bg[t]));
		add(1,1,n,bg[t],ed[t]);
	}
	return 0;
}<pre><h2>Problem1787</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;stack&gt;
namespace lct{
    struct node{
        node(){
            ch[0]=ch[1]=pr=0;cnt=1;
        }
        node*ch[2],*pr;int cnt;
    }ns[500010];
    void update(node*x){
        x-&gt;cnt=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;cnt+=x-&gt;ch[i]-&gt;cnt;
    }
    int direct(node*x){
        if(!x-&gt;pr)return 2;
        else if(x==x-&gt;pr-&gt;ch[0])return 0;
        else if(x==x-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    void setchd(node*x,node*y,int d){
        x-&gt;ch[d]=y;
        if(y)y-&gt;pr=x;
        update(x);
    }
    void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;
        int d1=direct(x),d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);
        setchd(x,y,!d1);
        if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
    }
    void splay(node*x){
        while(direct(x)&lt;2){
            node*y=x-&gt;pr;
            if(direct(y)&gt;1)rotate(x);
            else if(direct(x)==direct(y))rotate(y),rotate(x);
            else rotate(x),rotate(x);
        }
    }
    node*access(node*x){
        node*y=0;
        while(x){
            splay(x);
            setchd(x,y,1);
            y=x;x=x-&gt;pr;
        }
        return y;
    }
    node*lca(node*x,node*y){
        access(x);
        return access(y);
    }
    int dis(node*x,node*y){
        int r=0;
        access(x);
        node*w=access(y);
        splay(w);
        splay(x);
        if(x!=w)r+=x-&gt;cnt;
        if(w-&gt;ch[1])r+=w-&gt;ch[1]-&gt;cnt;
        return r+1;
    }
}
int n,q,prt[500010];vector&lt;int&gt;to[500010];
int dis(int u,int v){
    return lct::dis(lct::ns+u,lct::ns+v)-1;
}
int lca(int u,int v){
    return lct::lca(lct::ns+u,lct::ns+v)-lct::ns;
} 
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,2,n){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);
        to[v].pb(u);
    }
    stack&lt;int&gt;stk;stk.push(1);
    while(!stk.empty()){
        int u=stk.top();stk.pop();
        vp(i,to[u]){
            int v=to[u][i];
            if(v!=prt[u]){
                prt[v]=u;
                lct::ns[v].pr=lct::ns+u;
                stk.push(v);
                //pf("[%d,%d]\n",v,u);
            }
        }
    }
    //lp(i,1,n)lp(j,1,n)pf("[%d,%d,%d]\n",i,j,lct::lca(lct::ns+i,lct::ns+j)-lct::ns);
    //lp(i,1,n)lp(j,1,n)pf("[%d,%d,%d]\n",i,j,lct::dis(lct::ns+i,lct::ns+j));
    lp(i,1,q){
        int nowid=-1,nowans=~0u&gt;&gt;1;
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        int tid,tans;
        tid=lca(u,v);tans=dis(tid,u)+dis(tid,v)+dis(tid,w);
        if(tans&lt;nowans)nowans=tans,nowid=tid;
        tid=lca(u,w);tans=dis(tid,u)+dis(tid,v)+dis(tid,w);
        if(tans&lt;nowans)nowans=tans,nowid=tid;
        tid=lca(v,w);tans=dis(tid,u)+dis(tid,v)+dis(tid,w);
        if(tans&lt;nowans)nowans=tans,nowid=tid;
        pf("%d %d\n",nowid,nowans);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1797</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
    struct edge{
        edge(int a,int b,int d):u(a),v(b),c(d){}
        int u,v,c;
    };
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;to[4010];
    void add(int u,int v,int c){
        to[u].pb(eg.size());
        eg.pb(edge(u,v,c));
    }
    int gap[4010],dis[4010],vcnt,str,edr;
    int dfs(int u,int f){
        if(u==edr)return f;
        int g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    int solve(){
        gap[0]=vcnt;
        int r=0;
        while(dis[1]&lt;vcnt)r+=dfs(str,~0u&gt;&gt;1);
        return r;
    }
}
namespace tarjan{
    vector&lt;int&gt;to[4010];int vcnt;
    void add(int u,int v){
        to[u].pb(v);
        //pf("(%d,%d)\n",u,v);
    }
    int bel[4010],df[4010],lw[4010],ti,in[4010],nw;
    vector&lt;int&gt;stk;
    void dfs(int u){
        df[u]=lw[u]=++ti;in[u]=1;stk.pb(u);
        vp(i,to[u]){
            int v=to[u][i];
            if(!df[v])dfs(v),lw[u]=min(lw[u],lw[v]);
            else if(in[v])lw[u]=min(lw[u],df[v]);
        }
        if(df[u]==lw[u]){
            int t;++nw;
            do{
                t=stk.back();stk.pop_back();
                bel[t]=nw;
                in[t]=0;
            }while(t!=u);
        }
    }
    void solve(){
        lp(i,1,vcnt)if(!df[i])dfs(i);
    }
}
int main(){
    int n,m,s,t;sf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t);
    isap::str=s;
    isap::edr=t;
    isap::vcnt=n;
    lp(i,1,m){
        int u,v,c;sf("%d%d%d",&amp;u,&amp;v,&amp;c);
        isap::add(u,v,c);
        isap::add(v,u,0);
    }
    isap::solve();
    tarjan::vcnt=n;
    lp(i,1,n)vp(j,isap::to[i]){
        isap::edge e=isap::eg[isap::to[i][j]];
        if(e.c)tarjan::add(i,e.v);
    }
    tarjan::solve();
    lp(i,0,m-1){
        int u=isap::eg[i*2].u;
        int v=isap::eg[i*2].v;
        int c=isap::eg[i*2].c;
        if(tarjan::bel[u]!=tarjan::bel[v]&amp;&amp;c==0)pf("1 ",1);
        else pf("0 ",0);
        if(tarjan::bel[u]==tarjan::bel[s]&amp;&amp;tarjan::bel[v]==tarjan::bel[t])pf("1\n");
        else pf("0\n");
    }
    //ps;
    return 0;
}
<pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,m;ll p;
ll mul[100010*4],add[100010*4],sum[100010*4],siz[100010*4];
void down(int x,int l,int r){
	if(l!=r){
		mul[x*2]=mul[x]*mul[x*2]%p;
		add[x*2]=(add[x*2]*mul[x]%p+add[x])%p;
		mul[x*2+1]=mul[x]*mul[x*2+1]%p;
		add[x*2+1]=(add[x*2+1]*mul[x]%p+add[x])%p;
	}
	sum[x]=(sum[x]*mul[x]%p+siz[x]*add[x]%p)%p;
	mul[x]=1;
	add[x]=0;
}
void update(int x,int l,int r){
	int m=(l+r)/2;
	down(x*2,l,m);
	down(x*2+1,m+1,r);
	sum[x]=sum[x*2]+sum[x*2+1];
	siz[x]=siz[x*2]+siz[x*2+1];
}
void build(int x,int l,int r){
	mul[x]=1;add[x]=0;
	if(l==r){sf("%lld",&amp;sum[x]);sum[x]%=p;siz[x]=1;}
	else{
		int m=(l+r)/2;
		build(x*2,l,m);
		build(x*2+1,m+1,r);
		update(x,l,r);
	}
}
void make(int x,int l,int r,int b,int e,ll t1,ll t2){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)mul[x]=t1,add[x]=t2;
	else{
		int m=(l+r)/2;
		if(b&lt;=m)make(x*2,l,m,b,e,t1,t2);
		if(e&gt;m)make(x*2+1,m+1,r,b,e,t1,t2);
		update(x,l,r);
	}
}
ll ask(int x,int l,int r,int b,int e){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)return sum[x];
	else{
		int m=(l+r)/2;ll ret=0;
		if(b&lt;=m)ret+=ask(x*2,l,m,b,e);
		if(e&gt;m)ret+=ask(x*2+1,m+1,r,b,e);
		return ret%p;
	}
}
int main(){
	sf("%d%lld",&amp;n,&amp;p);
	build(1,1,n);
	sf("%d",&amp;m);
	lp(i,1,m){
		int op;sf("%d",&amp;op);
		if(op==1){
			int l,r,c;sf("%d%d%d",&amp;l,&amp;r,&amp;c);
			make(1,1,n,l,r,c,0);
		}else if(op==2){
			int l,r,c;sf("%d%d%d",&amp;l,&amp;r,&amp;c);
			make(1,1,n,l,r,1,c);
		}else{
			int l,r;sf("%d%d",&amp;l,&amp;r);
			pf("%lld\n",ask(1,1,n,l,r));
		}
	}
	return 0;
}<pre><h2>Problem1799</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;sstream&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
ll solve(ll n,ll m){
	stringstream ss;ss&lt;&lt;n;string tn;ss&gt;&gt;tn;
	static ll dp[31][210][210],pw[31];dp[0][0][0]=1;
	pw[0]=1%m;lp(i,1,tn.size())pw[i]=pw[i-1]*10%m;static ll lastm=-1;
	if(tn.size()*9&lt;m)return 0;
	if(lastm!=m)lp(i,1,tn.size()){
		lp(j,0,m){
			lp(k,0,m){
				dp[i][j][k]=0;
				lp(l,0,9){
					if(j&gt;=l){
						int t=k-l*pw[i-1]%m+m;
						if(t&gt;=m)t-=m;
						dp[i][j][k]+=dp[i-1][j-l][t];
					}
				}
			}
		}
	}
	lastm=m;
	ll ret=0;
	ll sum1=0,sum2=0;
	vp(i,tn){
		lp(j,0,tn[i]-'0'-1){
			if(sum1+j&lt;=m){
				int t=pw[tn.size()-i-1]*j%m+sum2;
				if(t&gt;=m)t-=m;
				t=m-t;
				if(t&gt;=m)t-=m;
				ret+=dp[tn.size()-i-1][m-(sum1+j)][t];
			}
		}
		sum1+=tn[i]-'0';
		sum2=(sum2+(tn[i]-'0')*pw[tn.size()-i-1])%m;
	}
	return ret;
}
ll brutesolve(ll n){
	ll ret=0;
	lp(i,1,n){
		ll j=0,t=i;
		while(t)j+=t%10,t/=10;
		ret+=(i%j==0);
	}
	return ret;
}
ll calc1(ll a,ll b){
	ll ans=0;
	lp(i,1,18*9)ans+=solve(b+1,i)-solve(a,i);
	return ans;
}
ll calc2(ll a,ll b){
	return brutesolve(b)-brutesolve(a-1);
}
int main(){
	/*lp(i,1,100){
		int a=rand()%100000+1,b=rand()%100000+1;
		if(a&gt;b)swap(a,b);
		ll ans1=calc1(a,b),ans2=calc2(a,b);
		pf("%d %d,%lld %lld\n",a,b,ans1,ans2);
		if(ans1!=ans2)break;
	}*/
	/*lp(i,1,100)lp(j,i,100){
		ll ans1=calc1(i,j),ans2=calc2(i,j);
		pf("%d %d,%lld %lld\n",i,j,ans1,ans2);
		if(ans1!=ans2)break;
	}*/
	ll a,b;sf("%lld%lld",&amp;a,&amp;b);
	pf("%lld\n",calc1(a,b));
	return 0;
}
/*
0 100000000000000
0 99999999999999
*/<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][10007];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%10007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,10006)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,10006)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,10006)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][10007];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%10007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,10006)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,10006)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,10006)lp(l,0,int(hs[cur][k].size()-1))
        {ans+=hs[cur][k][l].second;break;}
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][4007];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%4007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,4006)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,4006)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,4006)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][2007];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%2007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,2006)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,2006)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,2006)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][1007];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%1007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,1006)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,1006)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,1006)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][507];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a%507];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,506)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,506)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        } 
    }
    ll ans=0;
    lp(k,0,506)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,v[21][21];pair&lt;int,int&gt;lst;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        static char tmp[21];
        sf("%s",tmp+1);
        lp(j,1,m)
            if(tmp[j]=='.')
                lst=make_pair(i,j);
            else
                v[i][j]=1;
    }
}
vector&lt;pair&lt;ll,ll&gt; &gt;hs[2][507];
void add(int c,ll a,ll d){
    vector&lt;pair&lt;ll,ll&gt; &gt;&amp;h=hs[c][a*1234%507];
    lp(i,0,int(h.size()-1))
        if(h[i].first==a)
            {h[i].second+=d;return;}
    h.push_back(make_pair(a,d));
}
void clear(int c){
    lp(i,0,506)hs[c][i].clear();
}
int code[21];
void dec(ll s){lp(i,1,m+1)code[i]=(s&amp;7),s=(s&gt;&gt;3);}
ll enc(){
    static int id[21];int nw=0;
    lp(i,1,m+1)id[code[i]]=-1;id[0]=0;
    ll r=0;lp(i,1,m)if(id[code[i]]==-1)id[code[i]]=++nw;
    rp(i,m+1,1)r=(r&lt;&lt;3),r+=id[code[i]];
    return r;
}
void solve(){
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,506)lp(l,0,int(hs[pre][k].size()-1)){
            ll s=hs[pre][k][l].first,d=hs[pre][k][l].second;
            dec(s);
            if(v[i][j]){
                code[j]=code[j+1]=0;
                add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
            }else{
                int left=code[j],up=code[j+1];
                if(left&amp;&amp;up){
                    if(left==up){
                        if(make_pair(i,j)==lst){
                            code[j]=code[j+1]=0;
                            add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        lp(u,1,m+1)if(code[u]==up)code[u]=left;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                    int t=left?left:up;
                    if(j!=m&amp;&amp;!v[i][j+1]){
                        code[j+1]=t;
                        code[j]=0;
                        add(cur,enc(),d);
                    }
                    if(i!=n&amp;&amp;!v[i+1][j]){
                        code[j]=t;
                        code[j+1]=0;
                        add(cur,j!=m?enc():(enc()&lt;&lt;3),d);
                    }
                }else{
                    if(i!=n&amp;&amp;j!=m&amp;&amp;!v[i+1][j]&amp;&amp;!v[i][j+1]){
                        code[j]=code[j+1]=10;
                        add(cur,enc(),d);
                    }
                }
            }
        }
    }
    ll ans=0;
    lp(k,0,506)lp(l,0,int(hs[cur][k].size()-1))
        ans+=hs[cur][k][l].second;
    pf("%lld\n",ans);
}
int main(){
    init();
    if(!lst.first)pf("0\n");
    else solve();
    //ps;
    return 0;
}
<pre><h2>Problem1814</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define REP(i, n) for (int i = 0; i &lt; (n); ++i)
#define REP1(i, n) for (int i = 1; i &lt;= (n); ++i)
#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)
#define CLR(x, n) memset(x, n, sizeof(x))
#define HashSz 80000
#define maxN 15
using namespace std;
typedef unsigned long long int64;

void setIO(string name) {
	string in_f = name + ".in";
	string out_f = name + ".out";
	freopen(in_f.c_str(), "r", stdin);
	freopen(out_f.c_str(), "w", stdout);
}

struct HashTable {
	
	int64 ans[HashSz];
	int stt[HashSz], num;
	int val[HashSz];
	int pos[HashSz];
	
	void init() {
		CLR(val, -1);
		CLR(pos, -1);
		num = 0;
	}
	
	void add(int st, int64 d) {
		int t = st % HashSz;
		while (val[t] != -1 &amp;&amp; val[t] != st) {
			++t;
			if (t &gt;= HashSz) t = 0;
		}
		if (val[t] == -1) {
			val[t] = st;
			pos[t] = num;
			stt[num] = st;
			ans[num] = d;
			++num;
		}
		else ans[pos[t]] += d;
	}
} ht1, ht2;

int n, m;
bool map[maxN][maxN];
HashTable *cur = &amp;ht1;
HashTable *pre = &amp;ht2;
int enx, eny;

void init() {
	scanf("%d%d\n", &amp;n, &amp;m);
	char ch;
	REP1(i, n) {
		REP1(j, m) {
			scanf("%c", &amp;ch);//cout &lt;&lt; ch;
			if (ch == '*') map[i][j] = 0;
			else map[i][j] = 1;
		}
		scanf("\n");
	}
	enx = eny = -1;
	for (int i = n; i &gt;= 0; --i) {
		if (enx != -1) break;
		if (!i) {
			puts("0");
			exit(0);
		}
		for (int j = m; j; --j) {
			if (map[i][j]) {
				enx = i;
				eny = j;
				break;
			}
		}
	}//cout &lt;&lt; enx &lt;&lt; ' ' &lt;&lt; eny &lt;&lt; endl;
}

int get(int t) {//cout &lt;&lt; t &lt;&lt; ' ' &lt;&lt; (3 &lt;&lt; ((t - 1) &lt;&lt; 1)) &lt;&lt; endl; 
	return 3 &lt;&lt; ((t - 1) &lt;&lt; 1);
}

int status(int st, int p) {
	int ret = st &amp; get(p);
	ret &gt;&gt;= (p - 1) &lt;&lt; 1;
	return ret;
}

int set(int st, int p, int v) {
	int ret = st;
	ret &amp;= ((1 &lt;&lt; 30) - 1) ^ get(p);//cout &lt;&lt; st &lt;&lt; ' ' &lt;&lt; p &lt;&lt; ' ' &lt;&lt; v &lt;&lt; ' ' &lt;&lt; ret &lt;&lt; ' ';
	ret |= v &lt;&lt; (p - 1 &lt;&lt; 1);//cout &lt;&lt; ret &lt;&lt; endl;
	return ret;
}

void solve() {
	cur-&gt;init();
	cur-&gt;add(0, 1);
	REP1(i, n) {
		REP1(j, m) {
			swap(cur, pre);
			cur-&gt;init();
			REP(st, pre-&gt;num) {
				int s, s_;
				int64 d;
				s = pre-&gt;stt[st];
				d = pre-&gt;ans[st];
				int p, q;
				p = status(s, j);
				q = status(s, j + 1);//printf("%d %d %d %d %d\n", s, i, j, p, q);
				if (!map[i][j]) {
					if (!p &amp;&amp; !q) cur-&gt;add(s, d);
					continue;
				}
				if (!p &amp;&amp; !q) {
					if (i != n &amp;&amp; map[i + 1][j] &amp;&amp; j != m &amp;&amp; map[i][j + 1]) {
						s_ = set(s, j, 1);
						s_ = set(s_, j + 1, 2);//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl &lt;&lt; endl;
						cur-&gt;add(s_, d);
					}
				//	else cur-&gt;add(s, d);
				}
				else if (!p ||!q) {
					if (i != n &amp;&amp; map[i + 1][j]) {
						s_ = set(s, j, p | q);
						s_ = set(s_, j + 1, 0);
						cur-&gt;add(s_, d);//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl;
					}
					if (j != m &amp;&amp; map[i][j + 1]) {
						s_ = set(s, j, 0);
						s_ = set(s_, j + 1, p | q);
						cur-&gt;add(s_, d);//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl;
					}
				}
				else if (p == 1 &amp;&amp; q == 1) {
					int t = 0, pos;
					FOR(k, j + 1, m + 1) {
						if ((s &amp; get(k)) &gt;&gt; ((k - 1) &lt;&lt; 1) == 1) ++t;
						else if ((s &amp; get(k)) &gt;&gt; ((k - 1) &lt;&lt; 1) == 2) --t;
						if (!t) {
							pos = k;
							break;
						}
					}
					s_ = set(s, j, 0);
					s_ = set(s_, j + 1, 0);
					s_ = set(s_, pos, 1);
					cur-&gt;add(s_, d);//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl;
				}
				else if (p == 2 &amp;&amp; q == 2) {
					int t = 0, pos;
					for (int k = j; k; --k) {
						if ((s &amp; get(k)) &gt;&gt; ((k - 1) &lt;&lt; 1) == 2) ++t;
						else if ((s &amp; get(k)) &gt;&gt; ((k - 1) &lt;&lt; 1) == 1) --t;
						if (!t) {
							pos = k;
							break;
						}
					}
					s_ = set(s, j, 0);
					s_ = set(s_, j + 1, 0);
					s_ = set(s_, pos, 2);
					cur-&gt;add(s_, d);//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl;
				}
				else if (p == 1 &amp;&amp; q == 2) {//cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;
					if (i == enx &amp;&amp; j == eny) {//cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;
						s_ = set(s, j, 0);
						s_ = set(s_, j + 1, 0);
						cur-&gt;add(s_, d);
						break;
					}
				}
				else if (p == 2 &amp;&amp; q == 1) {
					s_ = set(s, j, 0);
					s_ = set(s_, j + 1, 0);
					cur-&gt;add(s_, d);
				}//cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s_ &lt;&lt; endl;
			}//cout &lt;&lt; cur-&gt;num &lt;&lt; endl;
//			cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; cur-&gt;num &lt;&lt; endl;
//			REP(k, cur-&gt;num) cout &lt;&lt; cur-&gt;stt[k] &lt;&lt; ' ';
//			cout &lt;&lt; endl &lt;&lt; endl;
			if (i == enx &amp;&amp; j == eny) break;
		}
		if (i == enx) break;
		REP(j, cur-&gt;num) {
			cur-&gt;stt[j] &lt;&lt;= 2;
		}
	}
	//cout &lt;&lt; cur-&gt;num &lt;&lt; endl;
	if (cur-&gt;num) printf("%llu\n", cur-&gt;ans[0]);
	else puts("0");
}

int main() {
//	setIO("ural1519");
	init();
	solve();
	return 0;
}<pre><h2>Problem1821</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cmath&gt;
struct edge{
	int u,v;double d;
};
bool operator&lt;(edge a,edge b){
	return a.d&lt;b.d;
}
double x[1010],y[1010];int n,k;
int pr[1010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
int main(){
	sf("%d%d",&amp;n,&amp;k);
	lp(i,1,n)sf("%lf%lf",x+i,y+i);
	vector&lt;edge&gt;egs;
	lp(i,1,n)lp(j,1,n){
		edge t;t.u=i;t.v=j;
		t.d=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
		egs.pb(t);
	}
	sort(egs.begin(),egs.end());int nc=n;
	lp(i,1,n)pr[i]=i;
	vp(i,egs){
		if(nc==k)break;
		int u=egs[i].u,v=egs[i].v;
		if(fd(u)!=fd(v))pr[fd(u)]=v,--nc;
	}
	vp(i,egs){
		int u=egs[i].u,v=egs[i].v;
		if(fd(u)!=fd(v)){pf("%.2lf\n",sqrt(egs[i].d));break;}
	}
	return 0;
}<pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace isap{
    struct edge{int v,c;}edges[100010];int nw=1;
    vector&lt;int&gt;bg[1010];
    void add(int u,int v,int c){
        edge&amp;e=edges[++nw];e.v=v;e.c=c;bg[u].push_back(nw);
    }
    int vcnt,dis[1010];
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=edges[bg[u][i]],&amp;ev=edges[bg[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(e.c,g));
                g-=t,e.c-=t,ev.c+=t;
                if(!g)return f;
            }
        }
        ++dis[u];return f-g;
    }
    int solve(){
        int r=0;while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
}
namespace mcmf{
    struct edge{int v,c,w;}edges[100010];int nw=1;
    vector&lt;int&gt;bg[1010];
    void add(int u,int v,int c,int w){
        edge&amp;e=edges[++nw];e.v=v;e.c=c;e.w=w;bg[u].push_back(nw);
    }
    int vcnt,dis[1010],in[1010];
    int spfa(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1,in[i]=0;dis[1]=0;in[1]=1;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();in[u]=0;
            lp(i,0,int(bg[u].size()-1)){
                edge&amp;e=edges[bg[u][i]];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    if(!in[e.v]){
                        in[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return dis[vcnt]!=~0u&gt;&gt;1;
    }
    int cst;
    int dfs(int u,int f){
        if(u==vcnt)return f;
        in[u]=1;
        int g=f;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=edges[bg[u][i]],&amp;ev=edges[bg[u][i]^1];
            if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t;g-=t;ev.c+=t;cst+=t*e.w;
                if(!g)return f;
            }
        }
        return f-g;
    }
    int solve(){
        while(spfa()){
            do{
                lp(i,1,vcnt)in[i]=0;
            }while(dfs(1,~0u&gt;&gt;1));
        }
        return cst;
    }
}
int main(){
    int n,m,k;sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    isap::vcnt=n;mcmf::vcnt=n+1;
    lp(i,1,m){
        int u,v,c,w;sf("%d%d%d%d",&amp;u,&amp;v,&amp;c,&amp;w);
        isap::add(u,v,c);isap::add(v,u,0);
        mcmf::add(u+1,v+1,c,0);mcmf::add(v+1,u+1,0,0);
        mcmf::add(u+1,v+1,~0u&gt;&gt;1,w);mcmf::add(v+1,u+1,0,-w);
    }
    int t=isap::solve();
    mcmf::add(1,2,t+k,0);
    mcmf::add(2,1,0,0);
    pf("%d %d\n",t,mcmf::solve());
    //ps;
    return 0;
}
<pre><h2>Problem1854</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace hug{
	vector&lt;int&gt;to[10010];int vi[1000010],lk[1000010];
	vector&lt;int&gt;tmp;
	int dfs(int u){
		vp(i,to[u]){
			int v=to[u][i];
			if(!vi[v]){
				vi[v]=1;tmp.pb(v);
				if(!lk[v]||dfs(lk[v])){
					lk[v]=u;
					return 1;
				}
			}
		}
		return 0;
	}
}
int main(){
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		hug::to[a].pb(i);
		hug::to[b].pb(i);
	}
	lp(i,1,10001){
		if(hug::dfs(i)){
			vp(j,hug::tmp)hug::vi[hug::tmp[j]]=0;
			hug::tmp.clear();
		}else{pf("%d\n",i-1);break;}
	}
	return 0;
}<pre><h2>Problem1856</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll p=20100403;
ll fac[2000010],n,m;
ll inv(ll a){
	ll ret=1;
	for(int i=p-2;i;i&gt;&gt;=1){
		if(i&amp;1)ret=ret*a%p;
		a=a*a%p;
	}
	return ret;
}
ll calc(ll n,ll r){
	return fac[n]*inv(fac[r]*fac[n-r]%p)%p;
}
int main(){
	sf("%lld%lld",&amp;n,&amp;m);
	if(n&lt;m)pf("0\n");
	else{
		fac[0]=1;
		lp(i,1,n+m)fac[i]=fac[i-1]*i%p;
		pf("%lld\n",(calc(n+m,m)-calc(n+m,m-1)+p)%p);
	}
	return 0;
}<pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define ps system("pause");
using namespace std;
struct bign{
    int data[3010],size;
};
char tmp[10010];
void read(bign &amp;a){
    sf("%s",tmp);
    int len=strlen(tmp);
    a.size=0;
    int j=len-4;
    lp(i,1,len/4){
        int t=0;
        lp(k,0,3)
            t*=10,t+=tmp[j+k]-'0';
        a.data[++a.size]=t;
        j-=4;
    }
    j+=4;
    int t=0;
    for(int k=0;k&lt;j;++k)
        t*=10,t+=tmp[k]-'0';
    a.data[++a.size]=t;
}
void print(bign &amp;a){
    pf("%d",a.data[a.size]);
    for(int i=a.size-1;i&gt;0;--i)
        pf("%04d",a.data[i]);
    pf("\n");
}
bign A,B,C,T;
void div2(bign &amp;a){
    for(int i=a.size;i&gt;=0;--i){
        a.data[i-1]+=(a.data[i]&amp;1)*10000;
        a.data[i]&gt;&gt;=1;
    }
    if(a.data[a.size]==0)--a.size;
}
void mul2(bign &amp;a){
    a.data[a.size+1]=0;
    for(int i=1;i&lt;=a.size;++i)a.data[i]*=2;
    for(int i=1;i&lt;=a.size;++i){
        a.data[i+1]+=a.data[i]/10000;
        a.data[i]%=10000;
    }
    if(a.data[a.size+1]!=0)++a.size;
}
bool operator&lt;(bign &amp;a,bign &amp;b){
    if(a.size!=b.size)return a.size&lt;b.size;
    for(int i=a.size;i&gt;0;--i)if(a.data[i]!=b.data[i])return a.data[i]&lt;b.data[i];
    return false;
}
void mswap(bign &amp;a,bign &amp;b){
    if(a&lt;b)swap(a,b);
}
void minu(bign &amp;a,bign b){
    for(int i=b.size+1;i&lt;=a.size;++i)
        b.data[i]=0;
    b.size=a.size;
    lp(i,1,b.size)b.data[i]=9999-b.data[i];
    ++b.data[1];
    T.size=a.size;
    T.data[1]=0;
    lp(i,1,T.size){
        T.data[i]+=a.data[i]+b.data[i];
        T.data[i+1]=T.data[i]/10000;
        T.data[i]%=10000;
    }
    while(T.size&amp;&amp;!T.data[T.size])--T.size;
}
void mul(bign &amp;a,bign &amp;b){
    T.size=a.size+b.size;
    lp(i,1,T.size)T.data[i]=0;
    lp(i,1,a.size)lp(j,1,b.size){
        T.data[i+j-1]+=a.data[i]*b.data[j];
        T.data[i+j]+=T.data[i+j-1]/10000;
        T.data[i+j-1]%=10000;
    }
    if(T.data[T.size]==0)--T.size;
} 
void gcd(){
    C.size=1;C.data[1]=1;
    while(B.size){
        if((A.data[1]&amp;1)==0&amp;&amp;(B.data[1]&amp;1)==0)
            div2(A),div2(B),mul2(C);
        else if((A.data[1]&amp;1)==0)
            div2(A);
        else if((B.data[1]&amp;1)==0)
            div2(B);
        else{
            mswap(A,B);
            minu(A,B);
            A=T;
            mswap(A,B);
        }
    }
    mul(A,C);
}
int main(){
    read(A);read(B);
    gcd();
    print(T);
    //ps;
    return 0;
}
<pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
namespace mcmf{
	const int N=1010;
	struct edge{
		edge(int _v,int _c,int _w):
			v(_v),c(_c),w(_w){}
		int v,c,w;
	};
	vector&lt;edge&gt;eg;
	vector&lt;int&gt;to[N];
	int dis[N],in[N],vcnt;
	void add(int u,int v,int c,int w){
		to[u].pb(eg.size());
		eg.pb(edge(v,c,w));
		to[v].pb(eg.size());
		eg.pb(edge(u,0,-w));
	}
	bool spfa(){
		lp(i,1,vcnt){
			dis[i]=~0u&gt;&gt;1;
			in[i]=0;
		}
		dis[1]=0;in[1]=1;
		queue&lt;int&gt;qu;qu.push(1);
		while(!qu.empty()){
			int u=qu.front();qu.pop();in[u]=0;
			vp(i,to[u]){
				edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
				if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
					dis[e.v]=dis[u]+e.w;
					if(!in[e.v]){
						in[e.v]=1;
						qu.push(e.v);
					}
				}
			}
		}
		return dis[vcnt]!=~0u&gt;&gt;1;
	}
	int cst,flw;
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;in[u]=1;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t;ev.c+=t;g-=t;cst+=e.w*t;
				if(!g)return f;
			}
		}
		return f-g;
	}
	void run(){
		while(spfa()){
			int t;
			do{
				lp(i,1,vcnt)in[i]=0;
				t=dfs(1,~0u&gt;&gt;1);
				flw+=t;
			}while(t);
		}
	}
}
int main(){
	int n,m,nw=0;sf("%d%d",&amp;n,&amp;m);
	static int id[210][2];
	id[1][0]=++nw;
	lp(i,2,n-1)id[i][0]=++nw,id[i][1]=++nw;
	id[n][1]=++nw;
	mcmf::vcnt=nw;
	lp(i,1,m){
		int u,v,w;
		sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		if(u!=n&amp;&amp;v!=1)
			mcmf::add(id[u][0],id[v][1],1,w);
	}
	lp(i,2,n-1){
		mcmf::add(id[i][1],id[i][0],1,0);
	}
	mcmf::run();
	pf("%d %d\n",mcmf::flw,mcmf::cst);
	return 0;
}<pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
namespace mcmf{
	const int N=1010;
	struct edge{
		edge(int _v,int _c,int _w):
			v(_v),c(_c),w(_w){}
		int v,c,w;
	};
	vector&lt;edge&gt;eg;
	vector&lt;int&gt;to[N];
	int dis[N],in[N],vcnt;
	void add(int u,int v,int c,int w){
		to[u].pb(eg.size());
		eg.pb(edge(v,c,w));
		to[v].pb(eg.size());
		eg.pb(edge(u,0,-w));
	}
	bool spfa(){
		lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;
		dis[1]=0;priority_queue&lt;pair&lt;int,int&gt; &gt;qu;
		qu.push(mp(-0,1));
		while(!qu.empty()){
			int u=qu.top().second,d=-qu.top().first;qu.pop();
			if(dis[u]!=d)continue;
			vp(i,to[u]){
				edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
				if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
					dis[e.v]=dis[u]+e.w;
					qu.push(mp(-dis[e.v],e.v));
				}
			}
		}
		return dis[vcnt]!=~0u&gt;&gt;1;
	}
	int cst,flw;
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;in[u]=1;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t;ev.c+=t;g-=t;cst+=e.w*t;
				if(!g)return f;
			}
		}
		return f-g;
	}
	void run(){
		while(spfa()){
			int t;
			do{
				lp(i,1,vcnt)in[i]=0;
				t=dfs(1,~0u&gt;&gt;1);
				flw+=t;
			}while(t);
		}
	}
}
int main(){
	int n,m,nw=0;sf("%d%d",&amp;n,&amp;m);
	static int id[210][2];
	id[1][0]=++nw;
	lp(i,2,n-1)id[i][0]=++nw,id[i][1]=++nw;
	id[n][1]=++nw;
	mcmf::vcnt=nw;
	lp(i,1,m){
		int u,v,w;
		sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		if(u!=n&amp;&amp;v!=1)
			mcmf::add(id[u][0],id[v][1],1,w);
	}
	lp(i,2,n-1){
		mcmf::add(id[i][1],id[i][0],1,0);
	}
	mcmf::run();
	pf("%d %d\n",mcmf::flw,mcmf::cst);
	return 0;
}<pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
namespace mcmf{
	const int N=1010;
	struct edge{
		edge(int _v,int _c,int _w):
			v(_v),c(_c),w(_w){}
		int v,c,w;
	};
	vector&lt;edge&gt;eg;
	vector&lt;int&gt;to[N];
	int dis[N],in[N],vcnt;
	void add(int u,int v,int c,int w){
		to[u].pb(eg.size());
		eg.pb(edge(v,c,w));
		to[v].pb(eg.size());
		eg.pb(edge(u,0,-w));
	}
	bool spfa(){
		lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;
		dis[1]=0;priority_queue&lt;pair&lt;int,int&gt; &gt;qu;
		qu.push(mp(-0,1));
		while(!qu.empty()){
			int u=qu.top().second,d=-qu.top().first;qu.pop();
			if(dis[u]!=d)continue;
			vp(i,to[u]){
				edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
				if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
					dis[e.v]=dis[u]+e.w;
					qu.push(mp(-dis[e.v],e.v));
				}
			}
		}
		return dis[vcnt]!=~0u&gt;&gt;1;
	}
	int cst,flw;
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;in[u]=1;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t;ev.c+=t;g-=t;cst+=e.w*t;
				if(!g)return f;
			}
		}
		return f-g;
	}
	void run(){
		while(spfa()){
			int t;
			do{
				lp(i,1,vcnt)in[i]=0;
				t=dfs(1,~0u&gt;&gt;1);
				flw+=t;
			}while(0);
		}
	}
}
int main(){
	int n,m,nw=0;sf("%d%d",&amp;n,&amp;m);
	static int id[210][2];
	id[1][0]=++nw;
	lp(i,2,n-1)id[i][0]=++nw,id[i][1]=++nw;
	id[n][1]=++nw;
	mcmf::vcnt=nw;
	lp(i,1,m){
		int u,v,w;
		sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		if(u!=n&amp;&amp;v!=1)
			mcmf::add(id[u][0],id[v][1],1,w);
	}
	lp(i,2,n-1){
		mcmf::add(id[i][1],id[i][0],1,0);
	}
	mcmf::run();
	pf("%d %d\n",mcmf::flw,mcmf::cst);
	return 0;
}<pre><h2>Problem1878</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int db[1000010];
void add(int i,int d){
    for(;i&lt;=1000005;i+=i&amp;-i)db[i]+=d; 
}
int ask(int i){
    int r=0;
    for(;i;i-=i&amp;-i)r+=db[i];
    return r;
}
int a[50010],n,m;
vector&lt;pair&lt;int,int&gt; &gt;q[50010];
int top[1000010];
int ans[200010];
int pr[50010];
int main(){ 
    sf("%d",&amp;n);
    lp(i,1,n){
        sf("%d",&amp;a[i]),++a[i];
        pr[i]=top[a[i]];
        top[a[i]]=i;
    }
    sf("%d",&amp;m); 
    lp(i,1,m){
        int l,r;sf("%d%d",&amp;l,&amp;r);
        q[r].push_back(make_pair(l,i));
    }
    lp(i,1,n){
        if(pr[i])add(pr[i],-1);
        add(i,1);
        lp(j,0,int(q[i].size()-1)){
            ans[q[i][j].second]=ask(i)-ask(q[i][j].first-1);
        }
    }
    lp(i,1,m)pf("%d\n",ans[i]);
    //ps;
    return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MX=10010;
struct node{
    int sum,lc,rc;
}nds[MX*20*20];
int T[MX],NT[MX],V[MX],nw,A[MX],B[MX*2];
int mak(int s,int l,int r){//新建节点 
    nds[++nw].sum=s;nds[nw].lc=l;nds[nw].rc=r;
    return nw;
}
int bud(int bg,int ed){//建立空树 
    int md=(bg+ed)/2;
    if(bg==ed)return mak(0,0,0);
    else return mak(0,bud(bg,md),bud(md+1,ed));
}
int add(int id,int bg,int ed,int p,int d){//在线段树中插入或者删除元素，这个明显可以非递归 
    int md=(bg+ed)/2;
    if(bg==ed)return mak(nds[id].sum+d,0,0);
    else if(p&lt;=md)return mak(nds[id].sum+d,add(nds[id].lc,bg,md,p,d),nds[id].rc);
    else return mak(nds[id].sum+d,nds[id].lc,add(nds[id].rc,md+1,ed,p,d));
}
void bit_add(int id,int p,int d){//树状数组维护线段树的前缀和 
    for(;id&lt;=A[0];id+=id&amp;-id)
        T[id]=add(T[id],1,B[0],p,d);
}
void init(){//离散化，建树，插入A中元素 
    sort(B+1,B+B[0]+1);
    B[0]=unique(B+1,B+B[0]+1)-B-1;
    T[0]=bud(1,B[0]);
    lp(i,1,A[0])T[i]=T[0];
    lp(i,1,A[0])bit_add(i,lower_bound(B+1,B+B[0]+1,A[i])-B,1);
}
void modify(int id,int x){//修改元素 
    bit_add(id,lower_bound(B+1,B+B[0]+1,A[id])-B,-1);
    bit_add(id,lower_bound(B+1,B+B[0]+1,x)-B,1);
    A[id]=x;
}
int bit_get(int id){//获得当前所在节点的左子树size和 
    int ret=0;
    for(int i=id;i;i-=i&amp;-i)
        ret+=nds[nds[NT[i]].lc].sum;
    return ret;
}
void bit_clear(int id){//清除访问标记 
    for(int i=id;i;i-=i&amp;-i)
        V[i]=0;
}
void turn_r(int id){
    for(int i=id;i&amp;&amp;!V[i];i-=i&amp;-i){
        V[i]=1;
        NT[i]=nds[NT[i]].rc;
    }
} 
void turn_l(int id){
    for(int i=id;i&amp;&amp;!V[i];i-=i&amp;-i){
        V[i]=1;
        NT[i]=nds[NT[i]].lc;
    }
} 
int query(int lt,int rt,int k){
    int bg=1,ed=B[0];
    for(int i=lt-1;i;i-=i&amp;-i)NT[i]=T[i];
    for(int i=rt;i;i-=i&amp;-i)NT[i]=T[i];//把需要用到的树放到NT里 
    while(bg!=ed){
        int md=(bg+ed)/2;
        int t=bit_get(rt)-bit_get(lt-1);//这里就是抽象的那颗lt到rt的线段树的lc的sum 
        if(k&lt;=t){
            ed=md;
            turn_l(lt-1);
            turn_l(rt);
        }else{
            bg=md+1;
            k-=t;
            turn_r(lt-1);
            turn_r(rt);
        }
        bit_clear(lt-1);
        bit_clear(rt);
    }
    return B[bg];
}
int quy1[MX],quy2[MX],quy3[MX],quy4[MX];;
int main(){
    int m;sf("%d%d",&amp;A[0],&amp;m);
    lp(i,1,A[0]){
        sf("%d",&amp;A[i]);
        B[++B[0]]=A[i];
    }
    char op;int u,v,w;
    lp(i,1,m){
        op=getchar();
        while(op=='\n'||op==' '){
            op=getchar();
        }
        quy1[i]=op;
        if(op=='Q')
            sf("%d%d%d",&amp;quy2[i],&amp;quy3[i],&amp;quy4[i]);
        else{
            sf("%d%d",&amp;quy2[i],&amp;quy3[i]);
            B[++B[0]]=quy3[i];
        }
    }
    init();
    lp(i,1,m){
        if(quy1[i]=='Q')pf("%d\n",query(quy2[i],quy3[i],quy4[i]));
        else modify(quy2[i],quy3[i]);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MX=10010;
struct node{
    int sum,lc,rc;
}nds[MX*20*20];
int T[MX],NT[MX],V[MX],nw,A[MX],B[MX*2];
int mak(int s,int l,int r){//新建节点 
    nds[++nw].sum=s;nds[nw].lc=l;nds[nw].rc=r;
    return nw;
}
int bud(int bg,int ed){//建立空树 
    int md=(bg+ed)/2;
    if(bg==ed)return mak(0,0,0);
    else return mak(0,bud(bg,md),bud(md+1,ed));
}
int add(int id,int bg,int ed,int p,int d){//在线段树中插入或者删除元素
    int md=(bg+ed)/2;
    if(bg==ed)return mak(nds[id].sum+d,0,0);
    else if(p&lt;=md)return mak(nds[id].sum+d,add(nds[id].lc,bg,md,p,d),nds[id].rc);
    else return mak(nds[id].sum+d,nds[id].lc,add(nds[id].rc,md+1,ed,p,d));
}
void bit_add(int id,int p,int d){//树状数组维护线段树的前缀和 
    for(;id&lt;=A[0];id+=id&amp;-id)
        T[id]=add(T[id],1,B[0],p,d);
}
void init(){//离散化，建树，插入A中元素 
    sort(B+1,B+B[0]+1);
    B[0]=unique(B+1,B+B[0]+1)-B-1;
    T[0]=bud(1,B[0]);
    lp(i,1,A[0])T[i]=T[0];
    lp(i,1,A[0])bit_add(i,lower_bound(B+1,B+B[0]+1,A[i])-B,1);
}
void modify(int id,int x){//修改元素 
    bit_add(id,lower_bound(B+1,B+B[0]+1,A[id])-B,-1);
    bit_add(id,lower_bound(B+1,B+B[0]+1,x)-B,1);
    A[id]=x;
}
int bit_getlsum(int lt,int rt){
    int ret=0;
    for(int i=lt-1;i;i-=i&amp;-i)ret-=nds[nds[NT[i]].lc].sum;
    for(int i=rt;i;i-=i&amp;-i)ret+=nds[nds[NT[i]].lc].sum;
    return ret;
}
void bit_clear(int id){//清除访问标记 
    for(int i=id;i;i-=i&amp;-i)
        V[i]=0;
}
void turn_r(int id){
    for(int i=id;i&amp;&amp;!V[i];i-=i&amp;-i){
        V[i]=1;
        NT[i]=nds[NT[i]].rc;
    }
} 
void turn_l(int id){
    for(int i=id;i&amp;&amp;!V[i];i-=i&amp;-i){
        V[i]=1;
        NT[i]=nds[NT[i]].lc;
    }
} 
int query(int lt,int rt,int k){
    int bg=1,ed=B[0];
    for(int i=lt-1;i;i-=i&amp;-i)NT[i]=T[i];
    for(int i=rt;i;i-=i&amp;-i)NT[i]=T[i];//把需要用到的树放到NT里 
    while(bg!=ed){
        int md=(bg+ed)/2;
        int t=bit_getlsum(lt,rt);//这里就是抽象的那颗lt到rt的线段树的lc的sum 
        if(k&lt;=t){
            ed=md;turn_l(lt-1);turn_l(rt);
        }else{
            bg=md+1;k-=t;turn_r(lt-1);turn_r(rt);
        }
        bit_clear(lt-1);
        bit_clear(rt);
    }
    return B[bg];
}
int quy1[MX],quy2[MX],quy3[MX],quy4[MX];;
int main(){
    int m;sf("%d%d",&amp;A[0],&amp;m);
    lp(i,1,A[0]){
        sf("%d",&amp;A[i]);
        B[++B[0]]=A[i];
    }
    char op;int u,v,w;
    lp(i,1,m){
        op=getchar();
        while(op=='\n'||op==' '){
            op=getchar();
        }
        quy1[i]=op;
        if(op=='Q')
            sf("%d%d%d",&amp;quy2[i],&amp;quy3[i],&amp;quy4[i]);
        else{
            sf("%d%d",&amp;quy2[i],&amp;quy3[i]);
            B[++B[0]]=quy3[i];
        }
    }
    init();
    lp(i,1,m){
        if(quy1[i]=='Q')pf("%d\n",query(quy2[i],quy3[i],quy4[i]));
        else modify(quy2[i],quy3[i]);
    }
    //ps;
    return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MX=100100,SIZ=212;
int T[MX/SIZ+10][SIZ+10],A[MX];
inline int ID(int i){
    return i/SIZ+1;
}
void init(){
    T[0][0]=ID(A[0]);
    lp(i,1,A[0])T[ID(i)][++T[ID(i)][0]]=A[i];
    lp(i,1,T[0][0])sort(T[i]+1,T[i]+T[i][0]+1);
}
int less(int l,int r,int x){//SIZ+(n/SIZ)*lg(SIZ)
    int a=ID(l),b=ID(r),s=0;
    if(a==b){
        lp(i,l,r)s+=A[i]&lt;x;
    }else{
        lp(i,l,a*SIZ-1)s+=A[i]&lt;x;
        lp(i,(b-1)*SIZ,r)s+=A[i]&lt;x;
        lp(i,a+1,b-1)s+=lower_bound(T[i]+1,T[i]+T[i][0]+1,x)-T[i]-1;
    }
    return s;
}
int query(int l,int r,int k){
    int ret=0;    
    for(int i=1&lt;&lt;30;i;i&gt;&gt;=1)
        if(less(l,r,i+ret)&lt;k)ret+=i;    
    return ret;
}
int modify(int p,int x){//SIZlg(SIZ)
    *lower_bound(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1,A[p])=x;
    sort(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1);
    A[p]=x;
}
int main(){
    int m;sf("%d%d",&amp;A[0],&amp;m);
    lp(i,1,A[0])sf("%d",&amp;A[i]);
    init();
    char op;int u,v,w;
    lp(i,1,m){
        op=getchar();
        while(op=='\n'||op==' '){
            op=getchar();
        }
        if(op=='Q'){
            sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            pf("%d\n",query(u,v,w));
        }else{
            sf("%d%d",&amp;u,&amp;v);
            modify(u,v);
        }
    }
    return 0;
} 
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MX=10010,SIZ=100;
int T[MX/SIZ+10][SIZ+10],A[MX];
inline int ID(int i){
    return i/SIZ+1;
}
void init(){
    T[0][0]=ID(A[0]);
    lp(i,1,A[0])T[ID(i)][++T[ID(i)][0]]=A[i];
    lp(i,1,T[0][0])sort(T[i]+1,T[i]+T[i][0]+1);
}
int less(int l,int r,int x){//SIZ+(n/SIZ)*lg(SIZ)
    int a=ID(l),b=ID(r),s=0;
    if(a==b){
        lp(i,l,r)s+=A[i]&lt;x;
    }else{
        lp(i,l,a*SIZ-1)s+=A[i]&lt;x;
        lp(i,(b-1)*SIZ,r)s+=A[i]&lt;x;
        lp(i,a+1,b-1)s+=lower_bound(T[i]+1,T[i]+T[i][0]+1,x)-T[i]-1;
    }
    return s;
}
int query(int l,int r,int k){
    int ret=0;    
    for(int i=1&lt;&lt;30;i;i&gt;&gt;=1)
        if(less(l,r,i+ret)&lt;k)ret+=i;    
    return ret;
}
int modify(int p,int x){//SIZlg(SIZ)
    *lower_bound(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1,A[p])=x;
    sort(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1);
    A[p]=x;
}
int main(){
    int m;sf("%d%d",&amp;A[0],&amp;m);
    lp(i,1,A[0])sf("%d",&amp;A[i]);
    init();
    char op;int u,v,w;
    lp(i,1,m){
        op=getchar();
        while(op=='\n'||op==' '){
            op=getchar();
        }
        if(op=='Q'){
            sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            pf("%d\n",query(u,v,w));
        }else{
            sf("%d%d",&amp;u,&amp;v);
            modify(u,v);
        }
    }
    return 0;
} 
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps system("pause")
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MX=10010,SIZ=400;
int T[MX/SIZ+10][SIZ+10],A[MX];
inline int ID(int i){
    return i/SIZ+1;
}
void init(){
    T[0][0]=ID(A[0]);
    lp(i,1,A[0])T[ID(i)][++T[ID(i)][0]]=A[i];
    lp(i,1,T[0][0])sort(T[i]+1,T[i]+T[i][0]+1);
}
int less(int l,int r,int x){//SIZ+(n/SIZ)*lg(SIZ)
    int a=ID(l),b=ID(r),s=0;
    if(a==b){
        lp(i,l,r)s+=A[i]&lt;x;
    }else{
        lp(i,l,a*SIZ-1)s+=A[i]&lt;x;
        lp(i,(b-1)*SIZ,r)s+=A[i]&lt;x;
        lp(i,a+1,b-1)s+=lower_bound(T[i]+1,T[i]+T[i][0]+1,x)-T[i]-1;
    }
    return s;
}
int query(int l,int r,int k){
    int ret=0;    
    for(int i=1&lt;&lt;30;i;i&gt;&gt;=1)
        if(less(l,r,i+ret)&lt;k)ret+=i;    
    return ret;
}
int modify(int p,int x){//SIZlg(SIZ)
    *lower_bound(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1,A[p])=x;
    sort(T[ID(p)]+1,T[ID(p)]+T[ID(p)][0]+1);
    A[p]=x;
}
int main(){
    int m;sf("%d%d",&amp;A[0],&amp;m);
    lp(i,1,A[0])sf("%d",&amp;A[i]);
    init();
    char op;int u,v,w;
    lp(i,1,m){
        op=getchar();
        while(op=='\n'||op==' '){
            op=getchar();
        }
        if(op=='Q'){
            sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            pf("%d\n",query(u,v,w));
        }else{
            sf("%d%d",&amp;u,&amp;v);
            modify(u,v);
        }
    }
    return 0;
} 
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int ans[10010],as;
struct ques{
    int tp,va,id;
    int lt,rt,kh,wh,now;
}qs[30010];int qz;
int n;
//1:add 2:del 3:ask
void init(){
    static int a[10010];
    int m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;qs[++qz].va);
        a[i]=qs[qz].va;
        qs[qz].tp=1;qs[qz].id=i;
    }
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='C'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            ++qz;qs[qz].tp=2;qs[qz].va=a[u];qs[qz].id=u;
            ++qz;qs[qz].tp=1;qs[qz].va=v;qs[qz].id=u;
            a[u]=v;
        }else{
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            ++qz;qs[qz].tp=3;qs[qz].lt=u;
            qs[qz].rt=v;qs[qz].kh=w;qs[qz].wh=++as;
            qs[qz].now=0;
        }
    }
}
void print(){
    lp(i,1,as)pf("%d\n",ans[i]);
}
int db[10010];
void add(int i,int d){
    for(;i&lt;=n;i+=i&amp;-i)db[i]+=d;
}
int ask(int i){
    int r=0;
    for(;i;i-=i&amp;-i)r+=db[i];
    return r;
}
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    static ques tmp1[30010],tmp3[30010];
    static int tmp2[30010];
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==3)
            ans[qs[i].wh]=vl;
    }else{
        int vm=vl+(vr-vl)/2;
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].va&lt;=vm)
                add(qs[i].id,1);
            else if(qs[i].tp==2&amp;&amp;qs[i].va&lt;=vm)
                add(qs[i].id,-1);
            else if(qs[i].tp==3)tmp2[i]=ask(qs[i].rt)-ask(qs[i].lt-1);
        }
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].va&lt;=vm)
                add(qs[i].id,-1);
            else if(qs[i].tp==2&amp;&amp;qs[i].va&lt;=vm)
                add(qs[i].id,1);
        }
        int t1=0,t3=0;
        lp(i,ql,qr)
            if(qs[i].tp==3){
                if(qs[i].now+tmp2[i]&lt;=qs[i].kh-1){
                    qs[i].now+=tmp2[i];
                    tmp3[++t3]=qs[i];
                }else
                    tmp1[++t1]=qs[i];
            }else{
                if(qs[i].va&lt;=vm)
                    tmp1[++t1]=qs[i];
                else
                    tmp3[++t3]=qs[i];
            }
        lp(i,1,t1)qs[ql+i-1]=tmp1[i];
        lp(i,1,t3)qs[ql+t1+i-1]=tmp3[i];
        solve(ql,ql+t1-1,vl,vm);
        solve(ql+t1,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,0,~0u&gt;&gt;1);
    print();
    //ps;
    return 0;
}
<pre><h2>Problem1907</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
#include&lt;stack&gt;
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		int n;sf("%d",&amp;n);
		static vector&lt;int&gt;to[100010],chd[100010];
		lp(i,1,n)to[i].clear(),chd[i].clear();
		lp(i,1,n-1){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			to[u].pb(v);
			to[v].pb(u);
		}
		vector&lt;int&gt;tmp;stack&lt;int&gt;stk;
		static int vis[100010];
		lp(i,1,n)vis[i]=0;vis[1]=1;
		stk.push(1);while(!stk.empty()){
			int u=stk.top();stk.pop();
			tmp.pb(u);
			vp(i,to[u]){
				int v=to[u][i];
				if(!vis[v]){
					vis[v]=1;
					stk.push(v);
					chd[u].pb(v);
				}
			}
		}
		static int f[100010],up[100010];
		lp(i,1,n)f[i]=0,up[i]=1;
		wp(i,tmp){
			int u=tmp[i];
			vp(j,chd[u])f[u]+=f[chd[u][j]];
			int pcnt=0;
			vp(j,chd[u])pcnt+=up[chd[u][j]];
			if(pcnt&gt;=2)--f[u],up[u]=0;
			else if(pcnt==0)++f[u];
		}
		pf("%d\n",f[1]);
	}
	//ps;
	return 0;
}<pre><h2>Problem1911</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
long long s[1000010],x[1000010],y[1000010],f[1000010],a,b,c,n;
int main(){
    sf("%lld%lld%lld%lld",&amp;n,&amp;a,&amp;b,&amp;c);
    lp(i,1,n)sf("%lld",&amp;s[i]),s[i]+=s[i-1];
    deque&lt;int&gt;qu;
    qu.push_back(0);
    lp(i,1,n){
        while(qu.size()&gt;1&amp;&amp;double(y[qu[0]]-y[qu[1]])/(x[qu[0]]-x[qu[1]])&gt;=2*a*s[i])qu.pop_front();
        f[i]=f[qu[0]]+a*(s[i]-s[qu[0]])*(s[i]-s[qu[0]])+b*(s[i]-s[qu[0]])+c;
        x[i]=s[i],y[i]=f[i]+a*s[i]*s[i]-b*s[i];
        while(qu.size()&gt;1&amp;&amp;double(y[qu[qu.size()-2]]-y[qu[qu.size()-1]])/(x[qu[qu.size()-2]]-x[qu[qu.size()-1]])&lt;double(y[qu[qu.size()-1]]-y[i])/(x[qu[qu.size()-1]]-x[i]))qu.pop_back();
        qu.push_back(i);
        
    }
    pf("%lld\n",f[n]);
    //ps;
    return 0;
}
<pre><h2>Problem1930</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define ps system("pause");
using namespace std;
struct edge{
    int nxt;
    char c,w;
    short u,v;
}E[4010010];
int E_now=1,bg[4010],pre[4010],dis[4010],in[4010],V_cnt;
int que[4010],bck;
bool spfa(){
    lp(i,1,V_cnt)dis[i]=-(~0u&gt;&gt;1),pre[i]=in[i]=0;
    bck=1;
    que[1]=1;in[1]=1,dis[1]=0;
    while(bck){
        int u=que[bck--];in[u]=0;
        for(int p=bg[u];p;p=E[p].nxt){
            int v=E[p].v,w=E[p].w;
            if(E[p].c&amp;&amp;dis[u]+w&gt;dis[v]){
                dis[v]=dis[u]+w;
                pre[v]=p;
                if(!in[v]){
                    que[++bck]=v;
                    in[v]=1;
                }
            }
        }
    }
    return dis[V_cnt]!=-(~0u&gt;&gt;1);
}
int work(){
    int ret=0;
    while(spfa()){
        int d=~0U&gt;&gt;1;
        for(int p=pre[V_cnt];p;p=pre[E[p].u])
            d=min(d,int(E[p].c));
        for(int p=pre[V_cnt];p;p=pre[E[p].u])
            E[p].c-=d,E[p^1].c+=d;
        ret+=d*dis[V_cnt];
    }
    return ret;
}
void add_edge(int u,int v,int w,int c){
    E_now=E_now+1;
    E[E_now].u=u,E[E_now].v=v;
    E[E_now].w=w,E[E_now].c=c;
    E[E_now].nxt=bg[u];bg[u]=E_now;
    E_now=E_now+1;
    E[E_now].u=v,E[E_now].v=u;
    E[E_now].w=-w,E[E_now].c=0;
    E[E_now].nxt=bg[v];bg[v]=E_now;
}
int n;
struct poit{
    int x,y;
}poits[2010];
bool operator&lt;(poit a,poit b){
    return a.x!=b.x?a.x&lt;b.x:a.y&lt;b.y;
}
//1和2源点，V_cnt汇点，对于点i对应的两点是(i+1)*2和(i+1)*2+1 
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;poits[i].x,&amp;poits[i].y);
    sort(poits+1,poits+n+1);
    V_cnt=2+2*n+4;
    lp(i,1,n)
        lp(j,i+1,n)
            if(poits[i].y&lt;=poits[j].y)
                add_edge((i+1)*2+1,(j+1)*2,0,1);
    lp(i,1,n)add_edge((i+1)*2,(i+1)*2+1,1,1);
    add_edge(1,2,0,2);
    lp(i,1,n)add_edge(2,(i+1)*2,0,1);
    lp(i,1,n)add_edge((i+1)*2+1,V_cnt,0,1);
    pf("%d\n",work());
    //pf("%d\n",E_now);
    return 0;
}
<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c;}edges[200010];int nw=1;
vector&lt;int&gt;bg[310];
void add(int u,int v,int c){edges[++nw].v=v;edges[nw].c=c;bg[u].push_back(nw);}
int di[310],vcnt;
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        if(e.c&amp;&amp;di[u]==di[e.v]+1){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,edges[bg[u][i]^1].c+=t;
            if(!g)return f-g;
        }
    }
    ++di[u];
    return f-g;
}
int isap(){int r=0;while(di[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;2);return r;}
int n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);vcnt=n+2;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        if(t)add(i+1,n+2,1),add(n+2,i+1,0);
        else add(i+1,1,0),add(1,i+1,1);
    }
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        add(a+1,b+1,1);
        add(b+1,a+1,1);
    }
    pf("%d\n",isap());//ps;
    return 0;
}<pre><h2>Problem1935</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,m;
struct query{
	int tp;//1 add 2 ask
	int x,y;
	int y1,y2,id,mul;
};
bool operator&lt;(query a,query b){
	return a.x==b.x?a.tp&lt;b.tp:a.x&lt;b.x;
}
int ans[500010];
vector&lt;query&gt;qs;
int db[10000010];
void add(int x){
	for(;x&lt;=10000005;x+=x&amp;-x)++db[x];
}
int ask(int x){
	int r=0;
	for(;x;x-=x&amp;-x)r+=db[x];
	return r;
}
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n){
		query q;q.tp=1;
		sf("%d%d",&amp;q.x,&amp;q.y);
		++q.x;++q.y;
		qs.pb(q);
	}
	lp(i,1,m){
		query q1,q2;q1.tp=q2.tp=2;q1.id=q2.id=i;q1.mul=-1;q2.mul=1;
		int x1,y1,x2,y2;sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		++x1;++y1;++x2;++y2;
		q1.x=x1-1;q1.y1=y1;q1.y2=y2;
		q2.x=x2;q2.y1=y1;q2.y2=y2;
		qs.pb(q1);
		qs.pb(q2);
	}
	sort(qs.begin(),qs.end());
	vp(i,qs){
		if(qs[i].tp==1)add(qs[i].y);
		else{
			ans[qs[i].id]+=qs[i].mul*(ask(qs[i].y2)-ask(qs[i].y1-1));
		}
	}
	lp(i,1,m)pf("%d\n",ans[i]);
	return 0;
}<pre><h2>Problem1937</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace km{
    int w[1010][1010],cx,cy,lx[1010],ly[1010],vix[1010],viy[1010],lk[1010];
    int dfs(int x){
        vix[x]=1;
        lp(y,1,cy)if(!viy[y]&amp;&amp;lx[x]+ly[y]==w[x][y]){
            viy[y]=1;
            if(!lk[y]||dfs(lk[y])){
                lk[y]=x;return 1;
            }
        }
        return 0;
    } 
    void upd(){
        int d=~0u&gt;&gt;1;
        lp(i,1,cx)if(vix[i])
            lp(j,1,cy)if(!viy[j])
                d=min(d,lx[i]+ly[j]-w[i][j]);
        lp(i,1,cx)if(vix[i])lx[i]-=d;
        lp(i,1,cy)if(viy[i])ly[i]+=d;
    }
    void mch(){
        lp(i,1,cx){lx[i]=-(~0u&gt;&gt;1);
        lp(j,1,cy)lx[i]=max(lx[i],w[i][j]);}
        lp(i,1,cx){
            while(true){
                lp(j,1,cx)vix[j]=0;
                lp(j,1,cy)viy[j]=0;
                if(dfs(i))break;
                else upd();
            }
        }
    }
}
int eg[110][110],we[110][110],he[110][110],id[110][110],n,m;
#define mp make_pair
#define pb push
stack&lt;pair&lt;int,int&gt; &gt;stk;
int dfs(int fr,int to,int p){
    if(fr==to)return 1;
    lp(i,1,n)if(he[fr][i]&amp;&amp;i!=p){
        stk.pb(mp(i,fr));
        if(dfs(i,to,fr))return 1;
        stk.pop();
    }
    return 0;
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        eg[u][v]=eg[v][u]=1;
        we[u][v]=we[v][u]=w;
    }
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        he[u][v]=he[v][u]=1;
    }
    lp(i,1,n)
        lp(j,i+1,n)
            if(eg[i][j]){
                if(he[i][j])id[i][j]=id[j][i]=++km::cx;
                else id[i][j]=id[j][i]=++km::cy;
            }
    while(km::cx&lt;km::cy)++km::cx;
    while(km::cy&lt;km::cx)++km::cy;
    lp(i,1,n)
        lp(j,i+1,n)
            if(eg[i][j]&amp;&amp;!he[i][j]){
                stk=stack&lt;pair&lt;int,int&gt; &gt;();
                dfs(i,j,0);
                while(!stk.empty()){
                    int iy=id[i][j],ix=id[stk.top().first][stk.top().second];
                    km::w[ix][iy]=max(0,we[stk.top().first][stk.top().second]-we[i][j]);
                    stk.pop();
                }
            }
    int ans=0;km::mch();
    lp(i,1,km::cx)ans+=km::lx[i];
    lp(i,1,km::cy)ans+=km::ly[i];
    pf("%d\n",ans);//ps;
    return 0; 
}
<pre><h2>Problem1937</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace km{
    int w[1010][1010],cx,cy,lx[1010],ly[1010],vix[1010],viy[1010],lk[1010];
    int dfs(int x){
        vix[x]=1;
        lp(y,1,cy)if(!viy[y]&amp;&amp;lx[x]+ly[y]==w[x][y]){
            viy[y]=1;
            if(!lk[y]||dfs(lk[y])){
                lk[y]=x;return 1;
            }
        }
        return 0;
    } 
    void upd(){
        int d=~0u&gt;&gt;1;
        lp(i,1,cx)if(vix[i])
            lp(j,1,cy)if(!viy[j])
                d=min(d,lx[i]+ly[j]-w[i][j]);
        lp(i,1,cx)if(vix[i])lx[i]-=d;
        lp(i,1,cy)if(viy[i])ly[i]+=d;
    }
    void mch(){
        lp(i,1,cy){
            ly[i]=-(~0u&gt;&gt;1);
            lp(j,1,cx)ly[i]=max(ly[i],w[j][i]);
        }
        lp(i,1,cx){
            while(true){
                lp(j,1,cx)vix[j]=0;
                lp(j,1,cy)viy[j]=0;
                if(dfs(i))break;
                else upd();
            }
        }
    }
}
int eg[110][110],we[110][110],he[110][110],id[110][110],n,m;
#define mp make_pair
#define pb push
stack&lt;pair&lt;int,int&gt; &gt;stk;
int dfs(int fr,int to,int p){
    if(fr==to)return 1;
    lp(i,1,n)if(he[fr][i]&amp;&amp;i!=p){
        stk.pb(mp(i,fr));
        if(dfs(i,to,fr))return 1;
        stk.pop();
    }
    return 0;
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        eg[u][v]=eg[v][u]=1;
        we[u][v]=we[v][u]=w;
    }
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        he[u][v]=he[v][u]=1;
    }
    lp(i,1,n)
        lp(j,i+1,n)
            if(eg[i][j]){
                if(he[i][j])id[i][j]=id[j][i]=++km::cx;
                else id[i][j]=id[j][i]=++km::cy;
            }
    while(km::cx&lt;km::cy)++km::cx;
    while(km::cy&lt;km::cx)++km::cy;
    lp(i,1,n)
        lp(j,i+1,n)
            if(eg[i][j]&amp;&amp;!he[i][j]){
                stk=stack&lt;pair&lt;int,int&gt; &gt;();
                dfs(i,j,0);
                while(!stk.empty()){
                    int iy=id[i][j],ix=id[stk.top().first][stk.top().second];
                    km::w[ix][iy]=max(0,we[stk.top().first][stk.top().second]-we[i][j]);
                    stk.pop();
                }
            }
    int ans=0;km::mch();
    lp(i,1,km::cx)ans+=km::lx[i];//,pf("[%d]",km::lx[i]);pf("\n");
    lp(i,1,km::cy)ans+=km::ly[i];//,pf("[%d]",km::ly[i]);
    pf("%d\n",ans);//ps;
    return 0; 
}
<pre><h2>Problem1954</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n;vector&lt;int&gt;to[100010],we[100010];int dis[100010];
namespace trie{
    struct node{node(){ch[0]=ch[1]=0;}node*ch[2];}*rt;
    void del(node*&amp;x){if(x){lp(i,0,1)del(x-&gt;ch[i]);delete x;x=0;}}
    void ins(int v){
        node*u=rt;
        rp(i,30,0){
            if(!u-&gt;ch[(v&gt;&gt;i)&amp;1])
                u-&gt;ch[(v&gt;&gt;i)&amp;1]=new node;
            u=u-&gt;ch[(v&gt;&gt;i)&amp;1];
        }
    }
    int ask(int v){
        node*u=rt;int ret=0;
        rp(i,30,0){
            if(!u-&gt;ch[((v&gt;&gt;i)&amp;1)^1])
                u=u-&gt;ch[(v&gt;&gt;i)&amp;1];
            else
                u=u-&gt;ch[((v&gt;&gt;i)&amp;1)^1],ret+=(1&lt;&lt;i);
        }
        return ret;
    }
}
int main(){
    while(sf("%d",&amp;n)!=EOF){
        lp(i,1,n)to[i].clear(),we[i].clear();
        lp(i,1,n-1){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            to[u].pb(v);we[u].pb(w);
            to[v].pb(u);we[v].pb(w);
        }
        lp(i,1,n)dis[i]=-1;dis[1]=0;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(dis[v]==-1){
                    dis[v]=(dis[u]^we[u][i]);
                    qu.push(v);
                }
            }
        }
        int ans=0;
        trie::rt=new trie::node();
        lp(i,1,n)trie::ins(dis[i]);
        lp(i,1,n)ans=max(ans,trie::ask(dis[i]));
        pf("%d\n",ans);
        trie::del(trie::rt); 
    }
    //ps;
    return 0;
} 
<pre><h2>Problem1954</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n;vector&lt;int&gt;to[100010],we[100010];int dis[100010];
namespace trie{
    struct node{node(){ch[0]=ch[1]=0;}node*ch[2];}*rt;
    inline void del(node*&amp;x){if(x){lp(i,0,1)del(x-&gt;ch[i]);delete x;x=0;}}
    inline void ins(int v){
        node*u=rt;
        rp(i,30,0){
            if(!u-&gt;ch[(v&gt;&gt;i)&amp;1])
                u-&gt;ch[(v&gt;&gt;i)&amp;1]=new node;
            u=u-&gt;ch[(v&gt;&gt;i)&amp;1];
        }
    }
    inline int ask(int v){
        node*u=rt;int ret=0;
        rp(i,30,0){
            if(!u-&gt;ch[((v&gt;&gt;i)&amp;1)^1])
                u=u-&gt;ch[(v&gt;&gt;i)&amp;1];
            else
                u=u-&gt;ch[((v&gt;&gt;i)&amp;1)^1],ret+=(1&lt;&lt;i);
        }
        return ret;
    }
}
int main(){
    while(sf("%d",&amp;n)!=EOF){
        lp(i,1,n)to[i].clear(),we[i].clear();
        lp(i,1,n-1){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            to[u].pb(v);we[u].pb(w);
            to[v].pb(u);we[v].pb(w);
        }
        lp(i,1,n)dis[i]=-1;dis[1]=0;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(dis[v]==-1){
                    dis[v]=(dis[u]^we[u][i]);
                    qu.push(v);
                }
            }
        }
        int ans=0;
        trie::rt=new trie::node();
        lp(i,1,n)trie::ins(dis[i]);
        lp(i,1,n)ans=max(ans,trie::ask(dis[i]));
        pf("%d\n",ans);
        trie::del(trie::rt); 
    }
    //ps;
    return 0;
} 
<pre><h2>Problem1957</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
二分答案，被禁止区域必然是一个矩形
*/
struct line{
	line(){
		sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		if(x1==x2){
			if(y1&gt;y2)swap(y1,y2);
		}else{
			if(x1&gt;x2)swap(x1,x2);
		}
	}
	int x1,y1,x2,y2;
};
vector&lt;line&gt;lns;
int sx,sy,n;
bool check(int l){
	int xa=-l,ya=-l,xb=l,yb=l;
	lp(j,1,n)vp(i,lns){
		int x1=lns[i].x1,y1=lns[i].y1,x2=lns[i].x2,y2=lns[i].y2;
		//pf("[%d,%d,%d,%d]\n",xa,ya,xb,yb);
		//pf("[%d,%d,%d,%d]\n",x1,y1,x2,y2);
		if(x2&lt;xa||x1&gt;xb)continue;
		if(y2&lt;ya||y1&gt;yb)continue;
		if(x1==x2){
			ya=min(ya,y1);
			yb=max(yb,y2);
		}else{
			xa=min(xa,x1);
			xb=max(xb,x2);
		}
	}
	if(sx&gt;=xa&amp;&amp;sx&lt;=xb&amp;&amp;sy&gt;=ya&amp;&amp;sy&lt;=yb)return false;
	else return true;
}
int main(){
	sf("%d%d%d",&amp;sx,&amp;sy,&amp;n);
	lp(i,1,n)lns.pb(line());
	int l=0,r=1000000;
	if(!check(l))pf("0\n");
	else{
		while(l+1&lt;r){
			int m=(l+r)/2;
			if(check(m))l=m;
			else r=m;
		}
		pf("%d\n",r);
	}
	return 0;
}<pre><h2>Problem1957</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
二分答案，被禁止区域必然是一个矩形
注意拓展过程需要n次迭代
*/
struct line{
	line(){
		sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		if(x1==x2){
			if(y1&gt;y2)swap(y1,y2);
		}else{
			if(x1&gt;x2)swap(x1,x2);
		}
	}
	int x1,y1,x2,y2;
};
vector&lt;line&gt;lns;
int sx,sy,n;
bool check(int l){
	int xa=-l,ya=-l,xb=l,yb=l;
	lp(j,1,n)vp(i,lns){
		int x1=lns[i].x1,y1=lns[i].y1,x2=lns[i].x2,y2=lns[i].y2;
		//pf("[%d,%d,%d,%d]\n",xa,ya,xb,yb);
		//pf("[%d,%d,%d,%d]\n",x1,y1,x2,y2);
		if(x2&lt;xa||x1&gt;xb)continue;
		if(y2&lt;ya||y1&gt;yb)continue;
		if(x1==x2){
			ya=min(ya,y1);
			yb=max(yb,y2);
		}else{
			xa=min(xa,x1);
			xb=max(xb,x2);
		}
	}
	if(sx&gt;=xa&amp;&amp;sx&lt;=xb&amp;&amp;sy&gt;=ya&amp;&amp;sy&lt;=yb)return false;
	else return true;
}
int main(){
	sf("%d%d%d",&amp;sx,&amp;sy,&amp;n);
	lp(i,1,n)lns.pb(line());
	int l=0,r=1000000;
	if(!check(l))pf("0\n");
	else{
		while(l+1&lt;r){
			int m=(l+r)/2;
			if(check(m))l=m;
			else r=m;
		}
		pf("%d\n",r);
	}
	return 0;
}<pre><h2>Problem1959</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
vector&lt;pair&lt;int,int&gt; &gt;a;int n;
bool cmp(pair&lt;int,int&gt;u,pair&lt;int,int&gt;v){
	return u.first&gt;v.first;
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		a.pb(mp(u,v));
	}
	sort(a.begin(),a.end(),cmp);
	vector&lt;int&gt;f;
	vp(i,a){
		vector&lt;int&gt;::iterator it=lower_bound(f.begin(),f.end(),a[i].second);
		if(it==f.end())f.pb(a[i].second);
		else *it=a[i].second;
	}
	pf("%d\n",(int)f.size());
	return 0;
}<pre><h2>Problem1961</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
const int MOD=1000000007;
struct Int{
	Int(int _x=0):x(_x){}
	int x;
};
inline Int operator+(Int x,Int y){
	Int z(x.x+y.x);
	if(z.x&gt;=MOD)z.x-=MOD;
	return z;
}
inline Int operator-(Int x,Int y){
	Int z(x.x-y.x);
	if(z.x&lt;0)z.x+=MOD;
	return z;
}
inline bool zero(Int x){
	return x.x==0;
}
int n,wei[110],sum;
Int f[700010],g[700010];
int surive[110],ans1;
int dp[1400010],*h=dp+700000;
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d",&amp;wei[i]),sum+=wei[i];
	f[0].x=1;
	lp(i,1,n)rp(j,sum,wei[i])f[j]=f[j]+f[j-wei[i]];
	lp(i,1,n)lp(j,0,sum){
		if(j&gt;=wei[i])g[j]=f[j]-g[j-wei[i]];
		else g[j]=f[j];
		if(!zero(g[j]))++surive[i];
	}
	//lp(i,1,n)pf("[%d]\n",surive[i]);
	ans1=1;
	lp(i,2,n)if(surive[i]&gt;surive[ans1]||(surive[i]==surive[ans1]&amp;&amp;wei[i]&lt;wei[ans1]))ans1=i;
	//pf("%d\n",ans1);
	h[0]=1;
	lp(i,1,n)if(i!=ans1)rp(j,sum,wei[i])h[j]=(h[j]||h[j-wei[i]]);
	//lp(i,-sum,sum)pf("[%d:%d]\n",i,h[i]);
	lp(i,1,n)if(i!=ans1)lp(j,-sum,sum-wei[i])h[j]=(h[j]||h[j+wei[i]]);
	int ans2=0;while(h[ans2])++ans2;
	pf("%d %d\n",wei[ans1],ans2);
	return 0;
}<pre><h2>Problem1968</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
int main(){
    ll n,ans=0;sf("%lld",&amp;n);
    for(ll i=1;i&lt;=n;++i)ans+=n/i;
    pf("%lld\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem1976</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c;}edges[40*40*40*6*10];int nw=1;
vector&lt;int&gt;bg[40*40*40+100];
void add(int u,int v,int c){
    //pf("[%d,%d,%d]\n",u,v,c);
    bg[u].push_back(++nw);
    edge&amp;e=edges[nw];e.v=v;e.c=c;
}
int dis[40*40*40+100],gap[40*40*40+100],vcnt;
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]],&amp;ev=edges[bg[u][i]^1];
        if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t;ev.c+=t;g-=t;
            if(!g||dis[1]==vcnt)return f-g;
        }
    }
    if((--gap[dis[u]])==0)dis[1]=vcnt;
    ++gap[++dis[u]];
    return f-g;
}
int isap(){
    gap[0]=vcnt;int r=0;while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
    return r;
}
int n;
int tr(int x,int y,int z){return (x-1)*n*n+(y-1)*n+z+1;}
#define st 1
#define et tr(n,n,n)+1
int dir[6][3]={{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};
int chk(int x){
    return x&gt;0&amp;&amp;x&lt;=n;
}
int main(){
    int cnt=0;
    sf("%d",&amp;n);
    lp(i,1,n)lp(j,1,n){
        char op[110];sf("%s",op+1);
        lp(k,1,n){
            if(op[k]=='P'){
                if((i+j+k)%2){
                    add(st,tr(i,j,k),~0u&gt;&gt;1);
                    add(tr(i,j,k),st,0);
                }else{
                    add(et,tr(i,j,k),0);
                    add(tr(i,j,k),et,~0u&gt;&gt;1);
                }
            }else if(op[k]=='N'){
                if((i+j+k)%2){
                    add(et,tr(i,j,k),0);
                    add(tr(i,j,k),et,~0u&gt;&gt;1);
                }else{
                    add(st,tr(i,j,k),~0u&gt;&gt;1);
                    add(tr(i,j,k),st,0);
                }
            }
            lp(l,0,5){
                int ii=i+dir[l][0],jj=j+dir[l][1],kk=k+dir[l][2];
                if(chk(ii)&amp;&amp;chk(jj)&amp;&amp;chk(kk)&amp;&amp;((i&lt;ii)||(i==ii&amp;&amp;j&lt;jj)||(i==ii&amp;&amp;j==jj&amp;&amp;k&lt;kk))){
                    add(tr(i,j,k),tr(ii,jj,kk),1);
                    add(tr(ii,jj,kk),tr(i,j,k),1);
                    ++cnt;
                }
            }
        }
    }
    vcnt=et;
    pf("%d\n",cnt-isap());
    //ps;
    return 0;
}
<pre><h2>Problem1977</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
using namespace std;
namespace tda{
    const int N=100000,L=17;
    vector&lt;int&gt;to[N+10],we[N+10];
    int up[N+10][L+10],dp[N+10];
    pair&lt;int,int&gt;mx[N+10][L+10];
    pair&lt;int,int&gt;merge(pair&lt;int,int&gt;x,pair&lt;int,int&gt;y){
        static int t[4];
        t[0]=x.first;t[1]=x.second;
        t[2]=y.first;t[3]=y.second;
        sort(t,t+4,greater&lt;int&gt;());
        //printf("{%d,%d,%d,%d}\n",t[0],t[1],t[2],t[3]);
        unique(t,t+4);
        //printf("{%d,%d,%d,%d}\n",t[0],t[1],t[2],t[3]);
        //printf("(%d,%d)+(%d,%d)=(%d,%d)\n",x.first,x.second,y.first,y.second,t[0],t[1]);
        return make_pair(t[0],t[1]);
    }
    void add(int u,int v,int w){
        to[u].push_back(v);we[u].push_back(w);
        to[v].push_back(u);we[v].push_back(w);
    }
    void build(){
        static int vis[N+10];
        queue&lt;int&gt;qu;qu.push(1);vis[1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            for(int i=1;i&lt;=L;++i){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=merge(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            for(int i=0;i&lt;to[u].size();++i){
                int v=to[u][i],w=we[u][i];
                if(!vis[v]){
                    vis[v]=1;up[v][0]=u;
                    mx[v][0]=make_pair(w,-(~0u&gt;&gt;1));
                    dp[v]=dp[u]+1;qu.push(v);
                }
            }
        }
    }
    pair&lt;int,int&gt;query(int u,int v){
        pair&lt;int,int&gt;ans(-(~0u&gt;&gt;1),-(~0u&gt;&gt;1)); 
        if(dp[u]&lt;dp[v])swap(u,v);
        for(int i=0;i&lt;=L;++i)
            if(((dp[u]-dp[v])&gt;&gt;i)&amp;1){
                ans=merge(ans,mx[u][i]);
                u=up[u][i];
            }
        if(u==v)return ans;
        for(int i=L;i&gt;=0;--i)
            if(up[u][i]!=up[v][i]){
                ans=merge(ans,mx[u][i]);
                ans=merge(ans,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        ans=merge(ans,mx[u][0]);
        ans=merge(ans,mx[v][0]);
        return ans;
    }
}
struct edge{
    int x,y,z;
};
bool cmp(edge a,edge b){
    return a.z&lt;b.z;
}
int pr[100010];
int fd(int x){
    return x==pr[x]?x:pr[x]=fd(pr[x]);
}
void lk(int x,int y){
    pr[fd(x)]=y;
}
int main(){
    int n,m;static edge es[300010];
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;++i)scanf("%d%d%d",&amp;es[i].x,&amp;es[i].y,&amp;es[i].z);
    sort(es+1,es+m+1,cmp);
    static int us[300010];
    for(int i=1;i&lt;=n;++i)pr[i]=i;
    long long mst=0;
    for(int i=1;i&lt;=m;++i){
        int u=es[i].x,v=es[i].y,w=es[i].z;
        if(fd(u)!=fd(v)){
            lk(u,v);
            mst+=w;
            tda::add(u,v,w);
            us[i]=1;
            //printf("[%d,%d,%d]\n",u,v,w);
        }
    }
    //printf("MST:%lld\n",mst);
    tda::build();
    long long ans=1000000000000000000ll;
    for(int i=1;i&lt;=m;++i){
        int u=es[i].x,v=es[i].y,w=es[i].z;
        if(us[i])continue;
        pair&lt;int,int&gt;tmp=tda::query(u,v);
        //printf("(%d,%d,%d)(%d,%d)\n",u,v,w,tmp.first,tmp.second);
        if(tmp.first!=w){
            ans=min(ans,mst-tmp.first+w);
        }else if(tmp.second!=-(~0u&gt;&gt;1)){
            ans=min(ans,mst-tmp.second+w);
        }
    }
    printf("%lld\n",ans);
    //for(;;);
    return 0;
}
<pre><h2>Problem1978</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int A[50010],N,L,Ans=1,G[1000010];
int Not[1000010],P[1000010],Mi[1000010];
vector&lt;pair&lt;int,int&gt; &gt; Fact[50010];
vector&lt;int&gt; Fac[50010];
void dfs(int i,int d,int t){
    if(d==Fact[i].size()){
        if(t&gt;=L)
            Fac[i].push_back(t);
    }else{
        dfs(i,d+1,t);
        lp(j,1,Fact[i][d].second){
            t*=Fact[i][d].first;
            dfs(i,d+1,t);
        }
    }
}
int main(){
    sf("%d%d",&amp;N,&amp;L);
    lp(i,1,N)sf("%d",&amp;A[i]);
    lp(i,2,1000000){
        if(!Not[i])P[++P[0]]=i,Mi[i]=i;
        for(int j=1;j&lt;=P[0]&amp;&amp;P[j]*i&lt;=1000000;++j){
            Not[P[j]*i]=1;
            Mi[P[j]*i]=P[j];
            if(i%P[j]==0)break;
        }
    }
    lp(i,1,N){
        while(A[i]!=1){//因为L&gt;1，所以没考虑因数1 
            int t=Mi[A[i]],c=0;
            while(A[i]%t==0)++c,A[i]/=t;
            Fact[i].push_back(make_pair(t,c));
        }
        dfs(i,0,1);
        int t=1;
        lp(j,0,int(Fac[i].size())-1)
            t=max(t,G[Fac[i][j]]+1);
        lp(j,0,int(Fac[i].size())-1)
            G[Fac[i][j]]=max(G[Fac[i][j]],t);
        Ans=max(Ans,t);
    } 
    pf("%d\n",Ans);
    //ps;
    return 0;
}<pre><h2>Problem1979</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m,k,s[20010],f[20010],g[20010];
vector&lt;pair&lt;int,int&gt; &gt;tree[20010*4];
void build(int x,int l,int r){
    if(l==r)tree[x].push_back(make_pair(s[l],l));
    else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        int pl=0,pr=0;
        tree[x].resize(r-l+1);
        merge(tree[x*2].begin(),tree[x*2].end(),
            tree[x*2+1].begin(),tree[x*2+1].end(),
                tree[x].begin());
    }
}
void solve(int x,int l,int r){
    if(l!=r){
        int m=(l+r)/2;
        solve(x*2,l,m);
        vector&lt;pair&lt;int,int&gt; &gt;t1=tree[x*2],t2=tree[x*2+1];
        vector&lt;int&gt;mi,mx;
        lp(i,0,int(t1.size()-1))mi.push_back(f[t1[i].second]);
        rp(i,int(mi.size()-2),0)mi[i]=min(mi[i],mi[i+1]);
        lp(i,0,int(t1.size()-1))mx.push_back(g[t1[i].second]);
        rp(i,int(mx.size()-2),0)mx[i]=max(mx[i],mx[i+1]);
        int j=0;
        lp(i,0,int(t2.size()-1)){
            while(j&lt;t1.size()&amp;&amp;t1[j].first&lt;t2[i].first-k)
                ++j;
            if(j!=t1.size()){
                f[t2[i].second]=min(f[t2[i].second],mi[j]+1);
                g[t2[i].second]=max(g[t2[i].second],mx[j]+1);
            } 
        }
        solve(x*2+1,m+1,r);
    }
}
bool check(){
    lp(i,1,n)f[i]=~0u&gt;&gt;1,g[i]=-(~0u&gt;&gt;1);
    solve(1,0,n);
    return m&gt;=f[n]&amp;&amp;m&lt;=g[n];
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;s[i]),s[i]+=s[i-1];
    build(1,0,n);
    int l=-1000000000,r=1000000000;
    while(l+1&lt;r){
        k=(l+r)/2;
        if(check())r=k;
        else l=k;
    }
    pf("%d\n",r);
    //ps;
    return 0;
}
<pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define pb push_back
#define fr(a,b,c) freopen(a,b,c)
#define lp(a,b,c) for(int a=b;a&lt;=c;++a)
using namespace std;
int n;vector&lt;int&gt;to[100010],we[100010],cn[100010];
int ep[100010];
int mp[100010];
int pr[100010],ch[100010][2],mx[100010],sm[100010],dl[100010],cy[100010];
void down(int x){
    if(sm[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
            sm[ch[x][0]]=sm[x];
            dl[ch[x][0]]=-(~0u&gt;&gt;1);
        }
        if(ch[x][1]){
            sm[ch[x][1]]=sm[x];
            dl[ch[x][1]]=-(~0u&gt;&gt;1);
        }
        mx[x]=sm[x];
        cy[x]=sm[x];
        sm[x]=-(~0u&gt;&gt;1);
    }
    if(dl[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
			if(dl[ch[x][0]]==-(~0u&gt;&gt;1))dl[ch[x][0]]=0;
            dl[ch[x][0]]+=dl[x];
		}
        if(ch[x][1]){
			if(dl[ch[x][1]]==-(~0u&gt;&gt;1))dl[ch[x][1]]=0;
            dl[ch[x][1]]+=dl[x];
		}
        mx[x]+=dl[x];
        cy[x]+=dl[x];
        dl[x]=-(~0u&gt;&gt;1);
    }
}
void upda(int x){
    mx[x]=cy[x];
    if(ch[x][0])down(ch[x][0]),mx[x]=max(mx[x],mx[ch[x][0]]);
    if(ch[x][1])down(ch[x][1]),mx[x]=max(mx[x],mx[ch[x][1]]);
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
    upda(x);
}
int tp(int x){return x!=ch[pr[x]][0];}
void rot(int x){
    int y=pr[x],d1=tp(x),z=pr[y],d2=tp(y);
    set(y,ch[x][!d1],d1);
    set(x,y,!d1);
    if(z&gt;0)set(z,x,d2);else pr[x]=z;
}
void very(int x){
    if(pr[x]&gt;0)very(pr[x]);
    down(x);
}
void spl(int x){
    very(x);
    while(pr[x]&gt;0){
        if(pr[pr[x]]&lt;=0)rot(x);
        else if(tp(x)==tp(pr[x]))rot(pr[x]),rot(x);
        else rot(x),rot(x);
    }
}
int acc(int x){
    int y=0;
    while(x){
        spl(x);
        pr[ch[x][1]]=-x;
        set(x,y,1);
        y=x,x=-pr[x];
    }
    return y;
}

void dfs(int u,int p){
    pr[u]=-p;ep[u]=p;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v==p)cy[u]=mx[u]=we[u][i],mp[cn[u][i]]=u;
        else dfs(v,u);
    }
}
int que(int u,int v){
    if(u==v)return 0;//at
    acc(u);
	int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        return mx[v];
    }else if(w==v){
        spl(u);
        return mx[u];
    }else{
        spl(v);spl(u);
        return max(mx[u],mx[v]); 
    }
}
void msm(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
    }else if(w==v){
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }else{
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }
}
void msd(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
    }else if(w==v){
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }else{
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }
}
void chg(int x,int w){
    msm(mp[x],ep[mp[x]],w);
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].pb(v);we[u].pb(w);cn[u].pb(i);
        to[v].pb(u);we[v].pb(w);cn[v].pb(i);
    } 
    dfs(1,0);
    lp(i,1,n)sm[i]=dl[i]=-(~0u&gt;&gt;1);
    char op[110];
    for(sf("%s",op);op[0]!='S';sf("%s",op)){
        if(op[1]=='a'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",que(u,v));
        }else if(op[1]=='o'){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msm(u,v,w);
        }else if(op[1]=='h'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            chg(u,v);
        }else{
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msd(u,v,w);
        }
    }
    //ps;
    return 0;
}
<pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define pb push_back
#define fr(a,b,c) freopen(a,b,c)
#define lp(a,b,c) for(int a=b;a&lt;=c;++a)
using namespace std;
int n;vector&lt;int&gt;to[100010],we[100010],cn[100010];
int ep[100010];
int mp[100010];
int pr[100010],ch[100010][2],mx[100010],sm[100010],dl[100010],cy[100010];
void down(int x){
    if(sm[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
            sm[ch[x][0]]=sm[x];
            dl[ch[x][0]]=-(~0u&gt;&gt;1);
        }
        if(ch[x][1]){
            sm[ch[x][1]]=sm[x];
            dl[ch[x][1]]=-(~0u&gt;&gt;1);
        }
        mx[x]=sm[x];
        cy[x]=sm[x];
        sm[x]=-(~0u&gt;&gt;1);
    }
    if(dl[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
            if(dl[ch[x][0]]==-(~0u&gt;&gt;1))dl[ch[x][0]]=0;
            dl[ch[x][0]]+=dl[x];
        }
        if(ch[x][1]){
            if(dl[ch[x][1]]==-(~0u&gt;&gt;1))dl[ch[x][1]]=0;
            dl[ch[x][1]]+=dl[x];
        }
        mx[x]+=dl[x];
        cy[x]+=dl[x];
        dl[x]=-(~0u&gt;&gt;1);
    }
}
void upda(int x){
    mx[x]=cy[x];
    if(ch[x][0])down(ch[x][0]),mx[x]=max(mx[x],mx[ch[x][0]]);
    if(ch[x][1])down(ch[x][1]),mx[x]=max(mx[x],mx[ch[x][1]]);
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
    upda(x);
}
int tp(int x){return x!=ch[pr[x]][0];}
void rot(int x){
    int y=pr[x],d1=tp(x),z=pr[y],d2=tp(y);
    set(y,ch[x][!d1],d1);
    set(x,y,!d1);
    if(z&gt;0)set(z,x,d2);else pr[x]=z;
}
void very(int x){
    if(pr[x]&gt;0)very(pr[x]);
    down(x);
}
void spl(int x){
    very(x);
    while(pr[x]&gt;0){
        if(pr[pr[x]]&lt;=0)rot(x);
        else if(tp(x)==tp(pr[x]))rot(pr[x]),rot(x);
        else rot(x),rot(x);
    }
}
int acc(int x){
    int y=0;
    while(x){
        spl(x);
        pr[ch[x][1]]=-x;
        set(x,y,1);
        y=x,x=-pr[x];
    }
    return y;
}
 
void dfs(int u,int p){
    pr[u]=-p;ep[u]=p;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v==p)cy[u]=mx[u]=we[u][i],mp[cn[u][i]]=u;
        else dfs(v,u);
    }
}
int que(int u,int v){
    if(u==v)return 0;//at
    acc(u);
    int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        return mx[v];
    }else if(w==v){
        spl(u);
        return mx[u];
    }else{
        spl(v);spl(u);
        return max(mx[u],mx[v]);
    }
}
void msm(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
    }else if(w==v){
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }else{
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }
}
void msd(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
    }else if(w==v){
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }else{
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }
}
void chg(int x,int w){
    msm(mp[x],ep[mp[x]],w);
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].pb(v);we[u].pb(w);cn[u].pb(i);
        to[v].pb(u);we[v].pb(w);cn[v].pb(i);
    }
    dfs(1,0);
    lp(i,1,n)sm[i]=dl[i]=-(~0u&gt;&gt;1);
    char op[110];
    for(sf("%s",op);op[0]!='S';sf("%s",op)){
        if(op[1]=='a'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",que(u,v));
        }else if(op[1]=='o'){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msm(u,v,w);
        }else if(op[1]=='h'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            chg(u,v);
        }else{
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msd(u,v,w);
        }
    }
    //ps;
    return 0;
}<pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define pb push_back
#define fr(a,b,c) freopen(a,b,c)
#define lp(a,b,c) for(int a=b;a&lt;=c;++a)
using namespace std;
int n;vector&lt;int&gt;to[100010],we[100010],cn[100010];
int ep[100010];
int mp[100010];
int pr[100010],ch[100010][2],mx[100010],sm[100010],dl[100010],cy[100010];
inline void tmax(int&amp;a,int b){
	if(a&lt;b)a=b;
}
void down(int x){
    if(sm[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
            sm[ch[x][0]]=sm[x];
            dl[ch[x][0]]=-(~0u&gt;&gt;1);
        }
        if(ch[x][1]){
            sm[ch[x][1]]=sm[x];
            dl[ch[x][1]]=-(~0u&gt;&gt;1);
        }
        mx[x]=sm[x];
        cy[x]=sm[x];
        sm[x]=-(~0u&gt;&gt;1);
    }
    if(dl[x]!=-(~0u&gt;&gt;1)){
        if(ch[x][0]){
            if(dl[ch[x][0]]==-(~0u&gt;&gt;1))dl[ch[x][0]]=0;
            dl[ch[x][0]]+=dl[x];
        }
        if(ch[x][1]){
            if(dl[ch[x][1]]==-(~0u&gt;&gt;1))dl[ch[x][1]]=0;
            dl[ch[x][1]]+=dl[x];
        }
        mx[x]+=dl[x];
        cy[x]+=dl[x];
        dl[x]=-(~0u&gt;&gt;1);
    }
}
void upda(int x){
    mx[x]=cy[x];
    if(ch[x][0])down(ch[x][0]),tmax(mx[x],mx[ch[x][0]]);
    if(ch[x][1])down(ch[x][1]),tmax(mx[x],mx[ch[x][1]]);
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
    upda(x);
}
int tp(int x){return x!=ch[pr[x]][0];}
void rot(int x){
    int y=pr[x],d1=tp(x),z=pr[y],d2=tp(y);
    set(y,ch[x][!d1],d1);
    set(x,y,!d1);
    if(z&gt;0)set(z,x,d2);else pr[x]=z;
}
void very(int x){
    if(pr[x]&gt;0)very(pr[x]);
    down(x);
}
void spl(int x){
    very(x);
    while(pr[x]&gt;0){
        if(pr[pr[x]]&lt;=0)rot(x);
        else if(tp(x)==tp(pr[x]))rot(pr[x]),rot(x);
        else rot(x),rot(x);
    }
}
int acc(int x){
    int y=0;
    while(x){
        spl(x);
        pr[ch[x][1]]=-x;
        set(x,y,1);
        y=x,x=-pr[x];
    }
    return y;
}
 
void dfs(int u,int p){
    pr[u]=-p;ep[u]=p;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v==p)cy[u]=mx[u]=we[u][i],mp[cn[u][i]]=u;
        else dfs(v,u);
    }
}
int que(int u,int v){
    if(u==v)return 0;//at
    acc(u);
    int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        return mx[v];
    }else if(w==v){
        spl(u);
        return mx[u];
    }else{
        spl(v);spl(u);
        return max(mx[u],mx[v]);
    }
}
void msm(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
    }else if(w==v){
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }else{
        spl(v);
        sm[v]=k;
        dl[v]=-(~0u&gt;&gt;1);
        spl(u);
        sm[u]=k;
        dl[u]=-(~0u&gt;&gt;1);
    }
}
void msd(int u,int v,int k){
    if(u==v)return;
    acc(u);int w=acc(v);
    acc(w);
    if(w==u){
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
    }else if(w==v){
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }else{
        spl(v);
        if(dl[v]==-(~0u&gt;&gt;1))dl[v]=0;
        dl[v]+=k;
        spl(u);
        if(dl[u]==-(~0u&gt;&gt;1))dl[u]=0;
        dl[u]+=k;
    }
}
void chg(int x,int w){
    msm(mp[x],ep[mp[x]],w);
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].pb(v);we[u].pb(w);cn[u].pb(i);
        to[v].pb(u);we[v].pb(w);cn[v].pb(i);
    }
    dfs(1,0);
    lp(i,1,n)sm[i]=dl[i]=-(~0u&gt;&gt;1);
    char op[110];
    for(sf("%s",op);op[0]!='S';sf("%s",op)){
        if(op[1]=='a'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",que(u,v));
        }else if(op[1]=='o'){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msm(u,v,w);
        }else if(op[1]=='h'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            chg(u,v);
        }else{
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            msd(u,v,w);
        }
    }
    //ps;
    return 0;
}<pre><h2>Problem2001</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct edge{
    edge(int a,int b,int c):
        u(a),v(b),w(c){}
    int u,v,w;
};
bool operator&lt;(edge a,edge b){
    return a.w&lt;b.w;
}
struct graph{
    vector&lt;edge&gt;es;
    int nc;
};
struct query{
    query(int a,int b):
        t(a),w(b),r(0){}
    int t,w;long long r;
};
vector&lt;query&gt;qs;
int pr[20010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void contract(graph&amp;gr,int ql,int qr){
    static int tm[50010];
    lp(i,0,int(gr.es.size()-1))tm[i]=0;
    lp(i,ql,qr)tm[qs[i].t]=1;
    lp(i,1,gr.nc)pr[i]=i;
    vector&lt;edge&gt;t1,t2;
    lp(i,0,int(gr.es.size()-1)){
        if(tm[i]){
            int u=gr.es[i].u,v=gr.es[i].v;
            if(fd(u)!=fd(v))pr[fd(u)]=v;
        }else{
            t1.push_back(gr.es[i]);
        }
    }
    sort(t1.begin(),t1.end());
    lp(i,0,int(t1.size()-1)){
        int u=t1[i].u,v=t1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            t2.push_back(t1[i]);
        }
    }
    long long dl=0;
    lp(i,1,gr.nc)pr[i]=i;
    lp(i,0,int(t2.size()-1)){
        int u=t2[i].u,v=t2[i].v;
        pr[fd(u)]=v;
        dl+=t2[i].w;
    }
    lp(i,ql,qr)qs[i].r+=dl;
    static int id[50010];
    lp(i,1,gr.nc)id[i]=0;int nw=0;
    lp(i,1,gr.nc)if(id[fd(i)]==0)id[fd(i)]=++nw;
    gr.nc=nw;lp(i,0,int(gr.es.size()-1)){
        gr.es[i].u=id[fd(gr.es[i].u)];
        gr.es[i].v=id[fd(gr.es[i].v)];
    }
}
void reduct(graph&amp;gr,int ql,int qr){
    static int tm[50010];
    lp(i,0,int(gr.es.size()-1))tm[i]=0;
    lp(i,ql,qr)tm[qs[i].t]=1;
    vector&lt;pair&lt;edge,int&gt; &gt;t1;
    lp(i,0,int(gr.es.size()-1))
        if(tm[i]==0)
            t1.push_back(make_pair(gr.es[i],i));
    sort(t1.begin(),t1.end());
    static int bj[50010];
    lp(i,0,int(gr.es.size()-1))bj[i]=0;
    lp(i,1,gr.nc)pr[i]=i;
    lp(i,0,int(t1.size()-1)){
        int u=t1[i].first.u,v=t1[i].first.v;
        if(fd(u)!=fd(v))
            pr[fd(u)]=v;
        else
            bj[t1[i].second]=1;
    }
    vector&lt;edge&gt;t2;static int mp[50010];
    lp(i,0,int(gr.es.size()-1))
        if(bj[i]==0){
            mp[i]=t2.size();
            t2.push_back(gr.es[i]);
        }
    lp(i,ql,qr)qs[i].t=mp[qs[i].t];
    gr.es=t2;
}
void print(graph gr,int ql,int qr){
    pf("{%d}\n",gr.nc);
    lp(i,0,int(gr.es.size()-1))
        pf("{%d,%d,%d}\n",gr.es[i].u,gr.es[i].v,gr.es[i].w);
    lp(i,ql,qr)pf("{%d,%d}\n",qs[i].t,qs[i].w);
}
void solve(graph gr,int ql,int qr){
    //pf("[%d,%d,%d,%lld]\n",ql,qr,gr.nc,qs[ql].r);
    //print(gr,ql,qr);
    contract(gr,ql,qr);
    //pf("[%d,%d,%d,%lld]\n",ql,qr,gr.nc,qs[ql].r);
    //print(gr,ql,qr);
    reduct(gr,ql,qr);
    //pf("[%d,%d,%d,%lld]\n",ql,qr,gr.nc,qs[ql].r);
    //print(gr,ql,qr);
    if(ql!=qr){
        int m=(ql+qr)/2;graph gt=gr;
        lp(i,ql,m)gt.es[qs[i].t].w=qs[i].w;
        solve(gr,ql,m);solve(gt,m+1,qr);
    }else{
        gr.es[qs[ql].t].w=qs[ql].w;
        sort(gr.es.begin(),gr.es.end());
        lp(i,1,gr.nc)pr[i]=i;
        lp(i,0,int(gr.es.size()-1)){
            int u=gr.es[i].u,v=gr.es[i].v,w=gr.es[i].w;
            if(fd(u)!=fd(v)){
                qs[ql].r+=w;
                pr[fd(u)]=v;
            }
        }
    }
}
int main(){
    graph g;int m,q;
    sf("%d%d%d",&amp;g.nc,&amp;m,&amp;q);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        g.es.push_back(edge(u,v,w));
    }
    lp(i,1,q){
        int t,w;sf("%d%d",&amp;t,&amp;w);
        qs.push_back(query(t-1,w));
    }
    solve(g,0,int(qs.size()-1));
    lp(i,0,int(qs.size()-1))pf("%lld\n",qs[i].r);
    return 0;
}<pre><h2>Problem2002</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct node{int c[2],p,s;}nd[200010];
void up(int x){nd[x].s=nd[nd[x].c[0]].s+nd[nd[x].c[1]].s+1;}
int tp(int x){return x!=nd[nd[x].p].c[0];}
void set(int x,int y,int d){
    nd[x].c[d]=y;
    nd[y].p=x;up(x);
}
void print();
void rot(int x){
    int y=nd[x].p,z=nd[y].p,d=tp(x),q;
    if(z&gt;0)q=tp(y);
    set(y,nd[x].c[!d],d);
    set(x,y,!d);
    if(z&gt;0)set(z,x,q);
    else nd[x].p=z;
}
void splay(int x){
    while(nd[x].p&gt;0){
        if(nd[nd[x].p].p&lt;=0)rot(x);
        else if(tp(x)!=tp(nd[x].p))rot(x),rot(x);
        else rot(nd[x].p),rot(x);
    }
} 

void access(int x){
    int y=0;
    do{
        splay(x);
        nd[nd[x].c[1]].p=-x;
        set(x,y,1);
        y=x,x=-nd[x].p;
    }while(x);
}
int ki[200010],n,m;
void print(){
    lp(i,1,n+1)pf("[id:%d,pr:%d,lc:%d,rc:%d,sz:%d]\n",i,nd[i].p,nd[i].c[0],nd[i].c[1],nd[i].s); 
    pf("\n");  
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        sf("%d",&amp;ki[i]);
        nd[i].c[0]=nd[i].c[1]=0;
        nd[i].p=-min(i+ki[i],n+1);
        nd[i].s=1;
    }
    nd[n+1].c[0]=nd[n+1].c[1]=0;
    nd[n+1].p=0;
    nd[n+1].s=1;
    sf("%d",&amp;m);
    lp(i,1,m){
        int a;sf("%d",&amp;a);
        if(a==1){
            int b;sf("%d",&amp;b);++b;
            access(b);splay(b);
            pf("%d\n",nd[nd[b].c[0]].s);
        }else{
            int b,c;sf("%d%d",&amp;b,&amp;c);++b;
            int t=min(b+c,n+1),ty=min(b+ki[b],n+1);ki[b]=c;
            access(ty);
            splay(b);
            nd[b].p=-t;
        }
    }//ps;
    return 0;
}

<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll f[100010];
int main(){
    //fr("energy2010.in","r",stdin);
    //fr("energy2010.out","w",stdout);
    ll n,m;cin&gt;&gt;n&gt;&gt;m;
    for(ll i=min(n,m);i;--i){
        f[i]=ll(n/i)*ll(m/i);
        for(ll j=i+i;j&lt;=min(n,m);j+=i)
            f[i]-=f[j];
    }
    ll ans=0;
    lp(i,1,min(n,m))ans+=f[i]*i;
    cout&lt;&lt;2*ans-n*m&lt;&lt;endl;
    //ps;
    return 0;
}
<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll f[100010];
int main(){
    //fr("energy2010.in","r",stdin);
    //fr("energy2010.out","w",stdout);
    ll n,m;cin&gt;&gt;n&gt;&gt;m;
    for(ll i=min(n,m);i;--i){
        f[i]=ll(n/i)*ll(m/i);
        for(int j=i+i;j&lt;=min(n,m);j+=i)
            f[i]-=f[j];
    }
    ll ans=0;
    lp(i,1,min(n,m))ans+=f[i]*i;
    cout&lt;&lt;2*ans-n*m&lt;&lt;endl;
    //ps;
    return 0;
}
<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll f[100010];
int main(){
    //fr("energy2010.in","r",stdin);
    //fr("energy2010.out","w",stdout);
    ll n,m;cin&gt;&gt;n&gt;&gt;m;
    for(int i=min(n,m);i;--i){
        f[i]=ll(n/i)*ll(m/i);
        for(int j=i+i;j&lt;=min(n,m);j+=i)
            f[i]-=f[j];
    }
    ll ans=0;
    lp(i,1,min(n,m))ans+=f[i]*i;
    cout&lt;&lt;2*ans-n*m&lt;&lt;endl;
    //ps;
    return 0;
}
<pre><h2>Problem2006</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int A[500010],S[500010],N,L,R,K;
struct node{
    node(node*a,node*b,int c,int d,int e):
        lc(a),rc(b),l(c),r(d),cnt(e){}
    node*lc,*rc;
    int cnt,l,r;
}*segs[500010];
void spl(node*x){
    int m=x-&gt;l+((x-&gt;r-x-&gt;l)&gt;&gt;1);//attention
    if(x-&gt;lc==0)x-&gt;lc=new node(0,0,x-&gt;l,m,0);
    if(x-&gt;rc==0)x-&gt;rc=new node(0,0,m+1,x-&gt;r,0);
}
node*add(node*x,int v){
    if(x-&gt;l==x-&gt;r){
        return new node(0,0,x-&gt;l,x-&gt;r,x-&gt;cnt+1);
    }else{
        spl(x);
        if(v&lt;=x-&gt;lc-&gt;r){
            return new node(add(x-&gt;lc,v),x-&gt;rc,x-&gt;l,x-&gt;r,x-&gt;cnt+1);
        }else{
            return new node(x-&gt;lc,add(x-&gt;rc,v),x-&gt;l,x-&gt;r,x-&gt;cnt+1);
        }
    }
}
int que(node*x,node*y,int k){
    if(x-&gt;l==x-&gt;r){
        return x-&gt;l;
    }else{
        spl(x),spl(y);
        if(y-&gt;lc-&gt;cnt-x-&gt;lc-&gt;cnt&gt;=k)return que(x-&gt;lc,y-&gt;lc,k);
        else return que(x-&gt;rc,y-&gt;rc,k-(y-&gt;lc-&gt;cnt-x-&gt;lc-&gt;cnt));
    }
}
struct song{
    song(int a,int b,int c,int d,int e):
        rt(a),k(b),v(c),l(d),r(e){}
    int rt,k,v,l,r;
};
bool operator&lt;(song a,song b){
    return a.v&lt;b.v;//attention
}
int main(){
    sf("%d%d%d%d",&amp;N,&amp;K,&amp;L,&amp;R);
    lp(i,1,N)sf("%d",&amp;A[i]);
    lp(i,1,N)S[i]=S[i-1]+A[i];
    segs[0]=new node(0,0,0,500000*2000+10,0);
    lp(i,1,N)segs[i]=add(segs[i-1],S[i-1]+500000*1000);
    /*int q;sf("%d",&amp;q);
    lp(i,1,q){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        pf("[%d]",que(segs[a],b)-500000*1000);
    }*/
    priority_queue&lt;song&gt;qu;
    lp(i,1,N){
        int l=i-R,r=i-L;
        if(l&lt;0)l=0;
        if(r&gt;=0){
            ++l,++r;
            qu.push(song(i,1,S[i]-(que(segs[l-1],segs[r],1)-500000*1000),l,r));
        }
    }
    long long ans=0;//attention
    lp(i,1,K){
        song t=qu.top();qu.pop();
        ans+=t.v;
        if(t.k!=t.r-t.l+1){//still have
            qu.push(song(t.rt,t.k+1,S[t.rt]-(que(segs[t.l-1],segs[t.r],t.k+1)-500000*1000),t.l,t.r));
        }
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
<pre><h2>Problem2028</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct seg{seg(int a,int b,int c):l(a),r(b),t(c){}int l,r,t;};//t0noramlt1query
bool operator&lt;(const seg&amp;a,const seg&amp;b){
    if(a.t==0&amp;&amp;b.t==0)return a.l&lt;b.l;
    else if(a.t==0)return a.r&lt;b.l;
    else return a.l&lt;b.r;
}
int main(){
    int n;sf("%d",&amp;n);
    set&lt;seg&gt;st;
    lp(i,1,n){
        char op[11];sf("%s",op);
        if(op[0]=='A'){
            int l,r;sf("%d%d",&amp;l,&amp;r);
            int t=0;
            while(true){
                set&lt;seg&gt;::iterator it=st.lower_bound(seg(l,r,1));
                if(it==st.end()||(it-&gt;l&gt;r||it-&gt;r&lt;l))
                    break;
                ++t;
                st.erase(it);
            }
            st.insert(seg(l,r,0));
            pf("%d\n",t);
        }else pf("%d\n",st.size());
    }//ps;
    return 0;
}
<pre><h2>Problem2045</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=n;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll a,b,c,f[1000010];
int main(){
    sf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);
    for(ll i=max(a,b);i&gt;=1;--i){
        f[i]=(a/i)*(b/i);
        for(ll j=2;j*i&lt;=max(a,b);++j)
            f[i]-=f[j*i];
    }
    pf("%lld\n",f[c]);
    //ps;
    return 0;
} 
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int pr[10010],ch[10010][2],re[10010];
int dir(int x){return x==ch[pr[x]][1];}
void down(int x){
    if(re[x]){
        re[x]=0;
        re[ch[x][0]]^=1;
        re[ch[x][1]]^=1;
        swap(ch[x][0],ch[x][1]);
    }
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
}
void dfs(int x){if(pr[x]&gt;0)dfs(pr[x]);down(x);}
void rot(int x){
    int y=pr[x],z=pr[y],d=dir(x),q;if(z&gt;0)q=dir(y);
    set(y,ch[x][!d],d);
    set(x,y,!d);
    if(z&gt;0)set(z,x,q);else pr[x]=z;
}
void splay(int x){
    dfs(x); 
    while(pr[x]&gt;0){
        if(pr[pr[x]]&lt;=0)rot(x);
        else if(dir(x)==dir(pr[x]))rot(pr[x]),rot(x);
        else rot(x),rot(x); 
    }
}
int access(int x){
    int y=0;
    while(x){
        splay(x);
        pr[ch[x][1]]=-x;
        set(x,y,1);
        y=x,x=-pr[x];
    }
    return y;
}
void evert(int x){
    access(x);
    splay(x);
    re[x]=1;
}
int n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)pr[i]=0,ch[i][0]=ch[i][1]=0,re[i]=0;
    lp(i,1,m){
        char cmd[11];int a,b;
        sf("%s%d%d",cmd,&amp;a,&amp;b);
        if(cmd[0]=='D'){
            evert(a);
            access(b);
            splay(b);
            pr[ch[b][0]]=0; 
            ch[b][0]=0;
        }else if(cmd[0]=='C'){
            evert(a);
            splay(a);
            pr[a]=-b;
        }else{
            evert(a);
            access(a);
            pf("%s\n",access(b)==a?"Yes":"No");
        }
    }//ps;
    return 0;
}
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int pr[10010],ch[10010][2],re[10010];
int dir(int x){return x==ch[pr[x]][1];}
void down(int x){
    if(re[x]){
        re[x]=0;
        re[ch[x][0]]^=1;
        re[ch[x][1]]^=1;
        swap(ch[x][0],ch[x][1]);
    }
}
void set(int x,int y,int d){
    ch[x][d]=y;pr[y]=x;
}
void dfs(int x){if(pr[x]&gt;0)dfs(pr[x]);down(x);}
void rot(int x){
    int y=pr[x],z=pr[y],d=dir(x),q;if(z&gt;0)q=dir(y);
    set(y,ch[x][!d],d);
    set(x,y,!d);
    if(z&gt;0)set(z,x,q);else pr[x]=z;
}
void splay(int x){
    dfs(x); 
    while(pr[x]&gt;0)rot(x); 
    while(pr[x]&gt;0){
        if(pr[pr[x]]&lt;=0)rot(x);
        else if(dir(x)==dir(pr[x]))rot(pr[x]),rot(x);
        else rot(x),rot(x); 
    }
}
int access(int x){
    int y=0;
    while(x){
        splay(x);
        pr[ch[x][1]]=-x;
        set(x,y,1);
        y=x,x=-pr[x];
    }
    return y;
}
void evert(int x){
    access(x);
    splay(x);
    re[x]=1;
}
int n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)pr[i]=0,ch[i][0]=ch[i][1]=0,re[i]=0;
    lp(i,1,m){
        char cmd[11];int a,b;
        sf("%s%d%d",cmd,&amp;a,&amp;b);
        if(cmd[0]=='D'){
            evert(a);
            access(b);
            splay(b);
            pr[ch[b][0]]=0; 
            ch[b][0]=0;
        }else if(cmd[0]=='C'){
            evert(a);
            splay(a);
            pr[a]=-b;
        }else{
            evert(a);
            access(a);
            pf("%s\n",access(b)==a?"Yes":"No");
        }
    }//ps;
    return 0;
}
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct lct{
	struct node{
		node*ch[2],*pr;
		int rev;
	}ns[10010];
	inline void down(node*x){
		if(x-&gt;rev){
			lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
			swap(x-&gt;ch[0],x-&gt;ch[1]);
			x-&gt;rev=0;
		}
	}
	inline int direct(node*x){
		if(!x-&gt;pr)return 2;
		else if(x==x-&gt;pr-&gt;ch[0])return 0;
		else if(x==x-&gt;pr-&gt;ch[1])return 1;
		else return 2;
	}
	inline void setchd(node*x,node*y,int d){
		x-&gt;ch[d]=y;
		if(y)y-&gt;pr=x;
	}
	inline void rotate(node*x){
		node*y=x-&gt;pr,*z=y-&gt;pr;
		int d1=direct(x),d2=direct(y);
		setchd(y,x-&gt;ch[!d1],d1);
		setchd(x,y,!d1);
		if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
	}
	inline void release(node*x){
		if(direct(x)&lt;2)release(x-&gt;pr);
		down(x);
	}
	inline void splay(node*x){
		release(x);
		while(direct(x)&lt;2){
			node*y=x-&gt;pr;
			if(direct(y)&gt;1)rotate(x);
			else if(direct(x)==direct(y))rotate(y),rotate(x);
			else rotate(x),rotate(x);
		}
	}
	inline node*access(node*x){
		node*y=0;
		while(x){
			splay(x);
			setchd(x,y,1);
			y=x;x=x-&gt;pr;
		}
		return y;
	}
	inline void evert(node*x){
		access(x);
		splay(x);
		x-&gt;rev=1;
	}
	inline bool query(node*x,node*y){
		access(x);node*z=access(y);
		return z==access(x);
	}
	inline void link(node*x,node*y){
		evert(y);
		y-&gt;pr=x;
	}
	inline void cut(node*x,node*y){
		evert(x);
		access(y);
		splay(y);
		y-&gt;ch[0]=0;
		x-&gt;pr=0;
	}
}tree;
int main(){
	int n,m;sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		static char op[11];int u,v;
		sf("%s%d%d",op,&amp;u,&amp;v);
		if(op[0]=='Q')pf("%s\n",tree.query(tree.ns+u,tree.ns+v)?"Yes":"No");
		else if(op[0]=='C')tree.link(tree.ns+u,tree.ns+v);
		else tree.cut(tree.ns+u,tree.ns+v);
	}
	return 0;
}<pre><h2>Problem2056</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef unsigned long long ll;
char wjmzbmr[110]="18446744073709551616"; 
int main(){
    int t;sf("%d",&amp;t);lp(i,1,t){
        int a,b,c,d,e,f,g,h;ll i;
        sf("%d%d%d%d%d%d%d%d%llu",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i);
        //pf("[%llu]",i+1);
        if(a+b+c+d+e+f+g+h==60*8&amp;&amp;i==(ll(1)&lt;&lt;63))pf("%s\n",wjmzbmr);
        else{
            ll ans=(ll(1)&lt;&lt;a)+(ll(1)&lt;&lt;b)+(ll(1)&lt;&lt;c)+(ll(1)&lt;&lt;d)+(ll(1)&lt;&lt;e)+(ll(1)&lt;&lt;f)+(ll(1)&lt;&lt;g)+(ll(1)&lt;&lt;h);
            pf("%llu\n",ans+i);
        }
    }
    //ps;
    return 0;
}
<pre><h2>Problem2100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
int m,n,st,et1,et2;
vector&lt;int&gt;to[100010],we[100010];
int run(int s,int t){
	static int dis[100010];
	lp(i,1,n)dis[i]=~0u&gt;&gt;1;
	dis[s]=0;
	priority_queue&lt;pair&lt;int,int&gt; &gt;qu;qu.push(mp(0,s));
	while(!qu.empty()){
		int u=qu.top().second,d=-qu.top().first;qu.pop();
		if(d!=dis[u])continue;
		if(u==t)return d;
		vp(i,to[u]){
			int v=to[u][i],w=we[u][i];
			if(dis[u]+w&lt;dis[v]){
				dis[v]=dis[u]+w;
				qu.push(mp(-dis[v],v));
			}
		}
	}
}
int main(){
	sf("%d%d%d%d%d",&amp;m,&amp;n,&amp;st,&amp;et1,&amp;et2);
	lp(i,1,m){
		int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
		to[a].pb(b);
		we[a].pb(c);
		to[b].pb(a);
		we[b].pb(c);
	}
	pf("%d\n",min(run(st,et1)+run(et1,et2),run(st,et2)+run(et1,et2)));
	return 0;
}</pre><pre></pre><h2>Problem2100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
int m,n,st,et1,et2;
vector&lt;int&gt;to[100010],we[100010];
int run(int s,int t){
	static int dis[100010];
	lp(i,1,n)dis[i]=~0u&gt;&gt;1;
	dis[s]=0;
	priority_queue&lt;pair&lt;int,int&gt; &gt;qu;qu.push(mp(0,s));
	while(!qu.empty()){
		int u=qu.top().second,d=-qu.top().first;qu.pop();
		if(d!=dis[u])continue;
		//if(u==t)return d;
		vp(i,to[u]){
			int v=to[u][i],w=we[u][i];
			if(dis[u]+w&lt;dis[v]){
				dis[v]=dis[u]+w;
				qu.push(mp(-dis[v],v));
			}
		}
	}
	return dis[t];
}
int main(){
	sf("%d%d%d%d%d",&amp;m,&amp;n,&amp;st,&amp;et1,&amp;et2);
	lp(i,1,m){
		int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
		to[a].pb(b);
		we[a].pb(c);
		to[b].pb(a);
		we[b].pb(c);
	}
	pf("%d\n",min(run(st,et1)+run(et1,et2),run(st,et2)+run(et1,et2)));
	return 0;
}</pre><pre></pre><h2>Problem2115</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define pb push_back
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,m;vector&lt;int&gt;to[500010];
vector&lt;long long&gt;we[500010];
int vi[500010];long long f[500010];
long long p;
long long a[1200010];int as;
void dfs(int u){
    //pf("[%d]",u);
    vi[u]=1;
    if(u==n)p=f[u];
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];long long w=we[u][i];
        if(!vi[v]){
            vi[v]=1;
            f[v]=(f[u]^w);
            dfs(v);
        }else{
            //pf("[%d,%d,%lld,%lld,%lld]\n",u,v,f[u],f[v],w);
            a[++as]=(f[u]^f[v]^w);
        }
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int a,b;long long c;
        sf("%d%d%lld",&amp;a,&amp;b,&amp;c);
        to[a].pb(b);we[a].pb(c);
        to[b].pb(a);we[b].pb(c);
    }
    dfs(1);
    //lp(i,1,as)pf("[%lld]",a[i]);
    int l=0;
    for(int i=63;i&gt;=0;--i){
        int j;
        for(j=l+1;j&lt;=as;++j)if((a[j]&gt;&gt;i)&amp;1)break;
        if(j&lt;=as){
            swap(a[j],a[++l]);
            lp(k,1,as)if(k!=l&amp;&amp;((a[k]&gt;&gt;i)&amp;1))a[k]^=a[l];
        }
    } 
    lp(i,1,l){
        int j=63;while(!((a[i]&gt;&gt;j)&amp;1))--j;
        if(!((p&gt;&gt;j)&amp;1))p^=a[i];
    }
    pf("%lld\n",p);
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem2120</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace bit{
    int db[10010];
    void add(int i,int d){
        for(;i&lt;=10000;i+=i&amp;-i)db[i]+=d;
    }
    int ask(int i){
        int r=0;
        for(;i;i-=i&amp;-i)r+=db[i];
        return r;
    }
}
/*
用整体二分法离线解决区间值排名问题
*/
namespace rank{
    struct query{
        int t;//1:add 2:del 3:ask
        int i,v;
        int l,r,c,w;
    };
    vector&lt;int&gt;as;
    vector&lt;query&gt;qs;
    void add(int i,int v){
        //pf("[add %d,%d]\n",i,v);
        query t;t.t=1;t.i=i;t.v=v;
        qs.push_back(t);
    }
    void del(int i,int v){
        //pf("[del %d,%d]\n",i,v);
        query t;t.t=2;t.i=i;t.v=v;
        qs.push_back(t);
    }
    void ask(int l,int r,int v){
        //pf("[ask %d,%d,%d]\n",l,r,v);
        query t;t.t=3;t.l=l;t.r=r;
        t.c=0;t.v=v;t.w=as.size();
        as.push_back(0);
        qs.push_back(t);
    }
    void work(int ql,int qr,int vl,int vr){
        if(ql&lt;=qr){
            if(vl==vr){
                lp(i,ql,qr)
                    if(qs[i].t==3)
                        as[qs[i].w]=qs[i].c;
            }else{
                int vm=vl+(vr-vl)/2;
                lp(i,ql,qr)
                    if(qs[i].t==1&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,1);
                    else if(qs[i].t==2&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,-1);
                    else if(qs[i].t==3&amp;&amp;qs[i].v&gt;vm)
                        qs[i].c+=bit::ask(qs[i].r)-bit::ask(qs[i].l-1);
                lp(i,ql,qr)
                    if(qs[i].t==1&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,-1);
                    else if(qs[i].t==2&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,1);
                vector&lt;query&gt;lq,rq;//方便起见写成O(nlgu)的空间复杂度
                lp(i,ql,qr)
                    if(qs[i].v&lt;=vm)lq.push_back(qs[i]);
                    else rq.push_back(qs[i]);
                lp(i,0,int(lq.size()-1))
                    qs[ql+i]=lq[i];
                lp(i,0,int(rq.size()-1))
                    qs[ql+i+lq.size()]=rq[i];
                work(ql,ql+int(lq.size()-1),vl,vm);
                work(ql+lq.size(),qr,vm+1,vr);
            }
        }
    }
    void solve(){
        work(0,int(qs.size()-1),0,10000);
    }
}
set&lt;int&gt;pos[1000010];int n,m,col[10010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;col[i]);
    lp(i,1,n){
        int np;
        if(pos[col[i]].empty())np=0;
        else np=*(pos[col[i]].rbegin());
        rank::add(i,np);
        pos[col[i]].insert(i);
    }
    lp(i,1,m){
        char op[11];int u,v;
        sf("%s%d%d",op,&amp;u,&amp;v);
        if(op[0]=='Q'){
            rank::ask(u,v,u);
        }else{
            set&lt;int&gt;::iterator it=pos[col[u]].lower_bound(u),rt=it;++rt;
            if(it==pos[col[u]].begin())
                rank::del(u,0);
            else{
                set&lt;int&gt;::iterator t=it;--t;
                rank::del(u,*t);
            }
            if(rt!=pos[col[u]].end()){
                int np;
                if(it==pos[col[u]].begin())np=0;
                else{
                    set&lt;int&gt;::iterator t=it;--t;
                    np=*t;
                }
                rank::del(*rt,u);
                rank::add(*rt,np);
            }
            pos[col[u]].erase(u);
            col[u]=v;
            pos[col[u]].insert(u);
            it=pos[col[u]].lower_bound(u),rt=it;++rt;
            if(it==pos[col[u]].begin())
                rank::add(u,0);
            else{
                set&lt;int&gt;::iterator t=it;--t;
                rank::add(u,*t);
            }
            if(rt!=pos[col[u]].end()){
                int np;
                if(it==pos[col[u]].begin())np=0;
                else{
                    set&lt;int&gt;::iterator t=it;--t;
                    np=*t;
                }
                rank::del(*rt,np);
                rank::add(*rt,u);
            }
        }
    }
    rank::solve();
    lp(i,0,int(rank::as.size()-1))
        pf("%d\n",rank::as[i]);
    //ps;
    return 0;
} </pre><pre></pre><h2>Problem2132</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace isap{
	struct edge{
		edge(int a,int b):
			v(a),c(b){}
		int v,c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[10010];
	int vcnt,dis[10010],gap[10010];
	void add(int u,int v,int c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
				int t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	int run(){
		gap[0]=vcnt;
		int ret=0;
		while(dis[1]&lt;vcnt)ret+=dfs(1,~0u&gt;&gt;1);
		return ret;
	}
}
int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
int main(){
	static int n,m,nw,a[110][110],b[110][110],c[110][110],idst,id[110][110],idet;
	int ans=0;
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n)lp(j,1,m)sf("%d",&amp;a[i][j]),ans+=a[i][j];
	lp(i,1,n)lp(j,1,m)sf("%d",&amp;b[i][j]),ans+=b[i][j];
	lp(i,1,n)lp(j,1,m)sf("%d",&amp;c[i][j]);
	idst=++nw;
	lp(i,1,n)lp(j,1,m)id[i][j]=++nw;
	idet=++nw;
	isap::vcnt=nw;
	lp(i,1,n)lp(j,1,m){
		if((i+j)%2==1){
			isap::add(idst,id[i][j],a[i][j]);
			isap::add(id[i][j],idst,0);
			isap::add(id[i][j],idet,b[i][j]);
			isap::add(idet,id[i][j],0);
			lp(k,0,3){
				int ti=i+dir[k][0],tj=j+dir[k][1];
				if(ti&gt;0&amp;&amp;ti&lt;=n&amp;&amp;tj&gt;0&amp;&amp;tj&lt;=m){
					ans+=c[i][j]+c[ti][tj];
					isap::add(id[i][j],id[ti][tj],c[i][j]+c[ti][tj]);
					isap::add(id[ti][tj],id[i][j],c[i][j]+c[ti][tj]);
				}
			}
		}else{
			isap::add(idst,id[i][j],b[i][j]);
			isap::add(id[i][j],idst,0);
			isap::add(id[i][j],idet,a[i][j]);
			isap::add(idet,id[i][j],0);
		}
	}
	pf("%d\n",ans-isap::run());
	return 0;
}</pre><pre></pre><h2>Problem2154</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
∑[i=1-&gt;n]∑[j=1-&gt;m]lcm(i,j)
=∑[d=1-&gt;min(n,m)]f(n/d,m/d)*d
f(a,b,x)=∑[i=1-&gt;a]∑[j=1-&gt;b,(i,j)=x]ij
g(a,b,x)=∑[i=1-&gt;a/x]∑[j=1-&gt;b/x]ij*x*x=a/x(a/x+1)b/x(b/x+1)/4*x*x
g(a,b,x)=∑[x|y]f(a,b,y)
f(a,b,x)=∑[x|y]g(a,b,y)*u(y/x)
f(a,b,1)=∑[d=1-&gt;min(a,b)]g(a,b,d)*u(d)
*/
ll p=20101009;
namespace brute{
	ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
	ll solve(ll n,ll m){
		ll ret=0;
		lp(i,1,n)lp(j,1,m)ret=(ret+i*j/gcd(i,j))%p;
		return ret;
	}
}
namespace task{
	ll g(ll a,ll b,ll d){
		ll t1=a/d,t2=a/d+1,t3=b/d,t4=b/d+1;
		if(t1&amp;1)t2/=2;
		else t1/=2;
		if(t3&amp;1)t4/=2;
		else t3/=2;
		return t1*t2%p*t3%p*t4%p;
	}
	ll u[10000010];
	ll f(ll a,ll b){
		ll ret=0;
		for(ll i=1;i&lt;=min(a,b);++i){
			ll j=min(min(a,b),min(a/(a/i),b/(b/i)));
			ll gt=g(a,b,i);
			ret=(ret+(u[j]-u[i-1]+p)*gt)%p;
			i=j;
		}
		return ret;
	}
	ll solve(ll n,ll m){
		static ll isp[10000010],pri[10000010];
		u[1]=1;
		for(ll i=2;i&lt;=min(n,m);++i){
			if(!isp[i]){
				pri[++pri[0]]=i;
				u[i]=-1;
			}
			for(ll j=1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;=min(n,m);++j){
				isp[i*pri[j]]=1;
				if(i%pri[j]==0){
					break;
				}else{
					u[i*pri[j]]=-u[i];
				}
			}
		}
		lp(i,1,min(n,m))u[i]=(u[i]+p)*i%p*i%p;
		lp(i,1,min(n,m))u[i]=(u[i]+u[i-1])%p;
		//lp(i,1,50)pf("%d,%lld\n",i,u[i]);
		ll ret=0;
		for(ll i=1;i&lt;=min(n,m);++i){
			ll j=min(min(n,m),min(n/(n/i),m/(m/i)));
			ll ft=f(n/i,m/i);
			ret=(ret+(i+j)*(j-i+1)/2%p*ft)%p;
			i=j;
		}
		return ret;
	}
}
int main(){
	ll n,m;sf("%lld%lld",&amp;n,&amp;m);
	//pf("%lld\n",brute::solve(n,m));
	pf("%lld\n",task::solve(n,m));
	return 0;
}</pre><pre></pre><h2>Problem2179</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef complex&lt;double&gt; cpx;
double pi=acos(-1.0);
cpx im=cpx(0,1);
void print(cpx a){
    pf("{%.12lf,%.12lf}\n",real(a),imag(a));
}
void fft(cpx*a,int n,int s){
    for(int i=0;i&lt;n;++i){
        int j=0;for(int k=0;(1&lt;&lt;k)&lt;n;++k)j&lt;&lt;=1,j+=((i&gt;&gt;k)&amp;1);
        if(i&lt;j)swap(a[i],a[j]);
    }
    for(int i=1;(1&lt;&lt;i)&lt;=n;++i){
        int m=(1&lt;&lt;i);cpx wm=exp(double(s)*im*2.0*pi/double(m));
        for(int j=0;j&lt;n;j+=m){
            cpx w=1;
            for(int k=0;k&lt;(m&gt;&gt;1);++k){
                cpx u=a[j+k],v=w*a[j+k+(m&gt;&gt;1)];
                a[j+k]=u+v;
                a[j+k+(m&gt;&gt;1)]=u-v;
                w*=wm;
            }
        }
    }
}
cpx num[3][200010];
int len[2],ans[200010],alen;
char tmp[200010];
int main(){
    int ty;
    sf("%d",&amp;ty);
    lp(i,0,1){
        if(sf("%s",tmp)==EOF)return 0;
        len[i]=strlen(tmp);
        lp(j,0,len[i]-1)num[i][j]=cpx(tmp[len[i]-j-1]-'0',0);
    }
    int t=1;while(t&lt;len[0]||t&lt;len[1])t&lt;&lt;=1;t&lt;&lt;=1;
    lp(i,len[0],t-1)num[0][i]=0.0;
    lp(i,len[1],t-1)num[1][i]=0.0;
    fft(num[0],t,1);
    fft(num[1],t,1);
    lp(i,0,t-1)num[2][i]=num[0][i]*num[1][i];
    fft(num[2],t,-1);
    lp(i,0,t-1)ans[i]=int(real(num[2][i])/t+0.1);
    alen=0;//attention
    lp(i,0,t-1){
        ans[i+1]+=ans[i]/10;
        ans[i]%=10;
        if(ans[i])alen=i;
    }
    for(int i=alen;i&gt;=0;--i)pf("%d",ans[i]);pf("\n");
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=16){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=20){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=30){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=60){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=10){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=40){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            for(int i=0;i&lt;2*n;++i)r[l][i]=0;
            if(n&lt;=25){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                r[l][i+j]+=a[i]*b[j];return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][n+i]+=r[l-1][i],r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                r[l][(n&lt;&lt;1)+i]=a[(n&gt;&gt;1)+i]-a[i],
                r[l][(n&gt;&gt;1)*5+i]=b[i]-b[(n&gt;&gt;1)+i];
            kar(r[l]+(n&lt;&lt;1),r[l]+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)r[l][i+(n&gt;&gt;1)]+=r[l-1][i];
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=r[l][i];
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
vector&lt;int&gt;run2(vector&lt;int&gt;a,vector&lt;int&gt;b){
    vector&lt;int&gt;r(a.size()+b.size()-1);
    for(int i=0;i&lt;a.size();++i)
        for(int j=0;j&lt;b.size();++j)
            r[i+j]+=a[i]*b[j];
    return r;
} static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
3
485
413
*/</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            T*rl=r[l],*rll=r[l-1]; for(int i=0;i&lt;2*n;++i)*(rl+i)=0;
            if(n&lt;=25){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                *(rl+i+j)+=(*(a+i))*(*(b+j));return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+n)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                *(rl+(n&lt;&lt;1)+i)=(*(a+(n&gt;&gt;1)+i))-(*(a+i)),
                *(rl+i+(n&gt;&gt;1)*5)=(*(b+i))-(*(b+(n&gt;&gt;1)+i));
            kar(rl+(n&lt;&lt;1),rl+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+(n&gt;&gt;1))+=*(rll+i);
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=*(r[l]+i);
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
20
12345678901234567890
12345678901234567890
*/
</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            T*rl=r[l],*rll=r[l-1]; for(int i=0;i&lt;2*n;++i)*(rl+i)=0;
            if(n&lt;=25){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                *(rl+i+j)+=*(a+i)**(b+j);return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+n)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                *(rl+(n&lt;&lt;1)+i)=*(a+(n&gt;&gt;1)+i)-*(a+i),
                *(rl+i+(n&gt;&gt;1)*5)=*(b+i)-*(b+(n&gt;&gt;1)+i);
            kar(rl+(n&lt;&lt;1),rl+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+(n&gt;&gt;1))+=*(rll+i);
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=*(r[l]+i);
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
20
12345678901234567890
12345678901234567890
*/
</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            T*rl=r[l],*rll=r[l-1]; for(int i=0;i&lt;2*n;++i)*(rl+i)=0;
            if(n&lt;=20){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                *(rl+i+j)+=*(a+i)**(b+j);return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+n)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                *(rl+(n&lt;&lt;1)+i)=*(a+(n&gt;&gt;1)+i)-*(a+i),
                *(rl+i+(n&gt;&gt;1)*5)=*(b+i)-*(b+(n&gt;&gt;1)+i);
            kar(rl+(n&lt;&lt;1),rl+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+(n&gt;&gt;1))+=*(rll+i);
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=*(r[l]+i);
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
20
12345678901234567890
12345678901234567890
*/
</pre><pre></pre><h2>Problem2179</h2><pre>#ifndef KARATSUBA_ALGORITHM
#define KARATSUBA_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct KaratsubaAlgorithm{
        static void kar(T*a,T*b,int n,int l,T**r){
            T*rl=r[l],*rll=r[l-1]; for(int i=0;i&lt;2*n;++i)*(rl+i)=0;
            if(n&lt;=30){for(int i=0;i&lt;n;++i)for(int j=0;j&lt;n;++j)
                *(rl+i+j)+=*(a+i)**(b+j);return;}
            kar(a,b,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            kar(a+(n&gt;&gt;1),b+(n&gt;&gt;1),n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+n)+=*(rll+i),*(rl+i+(n&gt;&gt;1))+=*(rll+i);
            for(int i=0;i&lt;(n&gt;&gt;1);++i)
                *(rl+(n&lt;&lt;1)+i)=*(a+(n&gt;&gt;1)+i)-*(a+i),
                *(rl+i+(n&gt;&gt;1)*5)=*(b+i)-*(b+(n&gt;&gt;1)+i);
            kar(rl+(n&lt;&lt;1),rl+(n&gt;&gt;1)*5,n&gt;&gt;1,l-1,r);
            for(int i=0;i&lt;n;++i)*(rl+i+(n&gt;&gt;1))+=*(rll+i);
        }
        static vector&lt;T&gt;run(vector&lt;T&gt;a,vector&lt;T&gt;b){
            int l=ceil(log2(max(a.size(),b.size()))+1e-8);
            vector&lt;T&gt;rt(a.size()+b.size()-1);
            a.resize(1&lt;&lt;l);b.resize(1&lt;&lt;l);
            T**r=new T*[l+1];for(int i=0;i&lt;=l;++i)r[i]=new T[(1&lt;&lt;i)*3];
            kar(&amp;a[0],&amp;b[0],1&lt;&lt;l,l,r);
            for(int i=0;i&lt;rt.size();++i)rt[i]=*(r[l]+i);
            for(int i=0;i&lt;=l;++i)delete r[i];delete r;
            return rt;}};}
#endif
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
static char s[100010];
#include&lt;algorithm&gt;
int main(){int n;
    scanf("%d",&amp;n);
    vector&lt;int&gt;a(n),b(n);

    scanf("%s",s);
    for(int i=0;i&lt;n;++i)a[i]=s[i]-'0';
    scanf("%s",s);
    for(int i=0;i&lt;n;++i)b[i]=s[i]-'0';
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    vector&lt;int&gt;c=CTL::KaratsubaAlgorithm&lt;int&gt;::run(a,b);
    int up;
    for(int i=0;i&lt;c.size();++i){
        up=c[i]/10;
        c[i]%=10;
        if(i+1!=c.size())
            c[i+1]+=up;
    }
    if(up)c.push_back(up);
    for(int i=c.size()-1;i&gt;=0;--i)
        printf("%d",c[i]);printf("\n");
    return 0;
}
/*
20
12345678901234567890
12345678901234567890
*/
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;


#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
struct MM{
    int n;
    vector&lt;int&gt;res,nxt,mrk,vis,top;
    vector&lt;vector&lt;int&gt; &gt;to;
    queue&lt;int&gt;qu;
    vector&lt;int&gt;pr;
    int fd(int x){
        return x==pr[x]?x:pr[x]=fd(pr[x]);
    }
    void lk(int x,int y){
        pr[fd(x)]=y;
    }
    int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[fd(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    void unite(int x,int p){
        while(fd(x)!=fd(p)){
            int y=res[x],z=nxt[y];
            if(fd(z)!=fd(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[fd(z)];
            lk(x,y);
            lk(y,z);
            top[fd(z)]=t;
            x=z;
        }
    }
    void augment(int s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i,pr[i]=i;
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(fd(x)==fd(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(fd(x)!=fd(z))
                        nxt[x]=y;
                    if(fd(y)!=fd(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
    MM(int _n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),pr(n){
    }
    void add(int x,int y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    int run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
};
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    inline UnionFindSets(const int&amp;_vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    inline int Find(const int&amp;x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    inline void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
class MaximumMatching{
private:
    int n;
    std::vector&lt;int&gt;res,nxt,mrk,vis,top;
    std::vector&lt;vector&lt;int&gt; &gt;to;
    std::queue&lt;int&gt;qu;
    UnionFindSets ufs;
    inline int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    inline void unite(int x,const int&amp;p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    inline void augment(const int&amp;s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
public:
    inline MaximumMatching(const int&amp;_n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    inline void AddEdge(const int&amp;x,const int&amp;y){
        to[x].push_back(y);
        to[y].push_back(x);
    }
    inline int Run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
    inline const std::vector&lt;int&gt;&amp;Result(){
        return res;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MaximumMatching mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.AddEdge(u-1,v-1);
    }
    cout&lt;&lt;n-mm.Run()-1&lt;&lt;endl;}
    return 0;
}
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;
 
 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    inline UnionFindSets(const int&amp;_vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    inline int Find(const int&amp;x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    inline void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
class MM{
private:
    int n;
    std::vector&lt;int&gt;res,nxt,mrk,vis,top;
    std::vector&lt;vector&lt;int&gt; &gt;to;
    std::queue&lt;int&gt;qu;
    UnionFindSets ufs;
    inline int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    inline void unite(int x,const int&amp;p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    inline void augment(const int&amp;s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
public:
    inline MM(const int&amp;_n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    inline void AddEdge(const int&amp;x,const int&amp;y){
        to[x].push_back(y);
        to[y].push_back(x);
    }
    inline int Run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
    inline const std::vector&lt;int&gt;&amp;Result(){
        return res;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.AddEdge(u-1,v-1);
    }
    cout&lt;&lt;n-mm.Run()-1&lt;&lt;endl;}
    return 0;
}</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;
 
 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    inline UnionFindSets(const int&amp;_vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    inline int Find(const int&amp;x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    inline void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
class MM{
private:
    int n;
    std::vector&lt;int&gt;res,nxt,mrk,vis,top;
    std::vector&lt;vector&lt;int&gt; &gt;to;
    std::queue&lt;int&gt;qu;
    UnionFindSets ufs;
    inline int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    inline void unite(int x,const int&amp;p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    inline void augment(const int&amp;s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
public:
    inline MM(const int&amp;_n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    inline void add(const int&amp;x,const int&amp;y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    inline int Run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
    inline const std::vector&lt;int&gt;&amp;Result(){
        return res;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.add(u,v);
    }
    cout&lt;&lt;n-mm.Run()-1&lt;&lt;endl;}
    return 0;
}</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;


#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    inline UnionFindSets(int _vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    inline int Find(int x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    inline void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
class MM{
private:
    int n;
    std::vector&lt;int&gt;res,nxt,mrk,vis,top;
    std::vector&lt;vector&lt;int&gt; &gt;to;
    std::queue&lt;int&gt;qu;
    UnionFindSets ufs;
    inline int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    inline void unite(int x,int p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    inline void augment(int s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
public:
    inline MM(int _n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    inline void add(int x,int y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    inline int Run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.add(u,v);
    }
    cout&lt;&lt;n-mm.Run()-1&lt;&lt;endl;}
    return 0;
}
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;


#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    UnionFindSets(int _vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    int Find(int x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
class MM{
private:
    int n;
    std::vector&lt;int&gt;res,nxt,mrk,vis,top;
    std::vector&lt;vector&lt;int&gt; &gt;to;
    std::queue&lt;int&gt;qu;
    UnionFindSets ufs;
    int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    void unite(int x,int p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    void augment(int s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=std::queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
public:
    MM(int _n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    void add(int x,int y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    int run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.add(u,v);
    }
    cout&lt;&lt;n-mm.run()-1&lt;&lt;endl;}
    return 0;
}
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;


#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
class UnionFindSets{
private:
    int vcnt;
    std::vector&lt;int&gt;prt,rnk;
public:
    UnionFindSets(int _vcnt):
    vcnt(_vcnt),prt(_vcnt),rnk(_vcnt){
        for(int i=0;i&lt;vcnt;++i)
        prt[i]=i;
    }
    int Find(int x){
        return x==prt[x]?x:prt[x]=Find(prt[x]);
    }
    void Union(int x,int y){
        x=Find(x);
        y=Find(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
};
struct MM{
    int n;
    vector&lt;int&gt;res,nxt,mrk,vis,top;
    vector&lt;vector&lt;int&gt; &gt;to;
    queue&lt;int&gt;qu;
    UnionFindSets ufs;
    int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[ufs.Find(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    void unite(int x,int p){
        while(ufs.Find(x)!=ufs.Find(p)){
            int y=res[x],z=nxt[y];
            if(ufs.Find(z)!=ufs.Find(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[ufs.Find(z)];
            ufs.Union(x,y);
            ufs.Union(y,z);
            top[ufs.Find(z)]=t;
            x=z;
        }
    }
    void augment(int s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i;
        ufs=UnionFindSets(n);
        mrk[s]=1;
        qu=queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(ufs.Find(x)==ufs.Find(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(ufs.Find(x)!=ufs.Find(z))
                        nxt[x]=y;
                    if(ufs.Find(y)!=ufs.Find(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
    MM(int _n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),ufs(n){
    }
    void add(int x,int y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    int run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.add(u,v);
    }
    cout&lt;&lt;n-mm.run()-1&lt;&lt;endl;}
    return 0;
}
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;iostream&gt;


#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
struct MM{
    int n;
    vector&lt;int&gt;res,nxt,mrk,vis,top,prt,rnk;
    vector&lt;vector&lt;int&gt; &gt;to;
    queue&lt;int&gt;qu;
    int fd(int x){
        return x==prt[x]?x:prt[x]=fd(prt[x]);
    }
    void lk(int x,int y){
        x=fd(x);
        y=fd(y);
        if(rnk[x]&gt;rnk[y])
            prt[y]=x;
        else if(rnk[x]&lt;rnk[y])
            prt[x]=y;
        else{
            prt[x]=y;
            ++rnk[y];
        }
    }
    int lca(int x,int y){
        static int t;
        ++t;
        while(true){
            if(x!=-1){
                x=top[fd(x)];
                if(vis[x]==t)
                    return x;
                vis[x]=t;
                if(res[x]!=-1)
                    x=nxt[res[x]];
                else
                    x=-1;
            }
            swap(x,y);
        }
    }
    void unite(int x,int p){
        while(fd(x)!=fd(p)){
            int y=res[x],z=nxt[y];
            if(fd(z)!=fd(p))
                nxt[z]=y;
            if(mrk[y]==2){
                mrk[y]=1;
                qu.push(y);
            }
            if(mrk[z]==2){
                mrk[z]=1;
                qu.push(z);
            }
            int t=top[fd(z)];
            lk(x,y);
            lk(y,z);
            top[fd(z)]=t;
            x=z;
        }
    }
    void augment(int s){
        for(int i=0;i&lt;n;++i)
            nxt[i]=-1,mrk[i]=0,top[i]=i,prt[i]=i,rnk[i]=0;
        mrk[s]=1;
        qu=queue&lt;int&gt;();
        qu.push(s);
        while(!qu.empty()){
            int x=qu.front();
            qu.pop();
            for(int i=0;i&lt;to[x].size();++i){
                int y=to[x][i];
                if(res[x]==y)
                    continue;
                if(fd(x)==fd(y))
                    continue;
                if(mrk[y]==2)
                    continue;
                if(mrk[y]==1){
                    int z=lca(x,y);
                    if(fd(x)!=fd(z))
                        nxt[x]=y;
                    if(fd(y)!=fd(z))
                        nxt[y]=x;
                    unite(x,z);
                    unite(y,z);
                }else if(res[y]==-1){
                    nxt[y]=x;
                    while(y!=-1){
                        int z=nxt[y],mz=res[z];
                        res[z]=y;
                        res[y]=z;
                        y=mz;
                    }
                    return;
                }else{
                    nxt[y]=x;
                    mrk[res[y]]=1;
                    qu.push(res[y]);
                    mrk[y]=2;
                }
            }
        }
    }
    MM(int _n):
    n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),prt(n),rnk(n){
    }
    void add(int x,int y){
        to[x-1].push_back(y-1);
        to[y-1].push_back(x-1);
    }
    int run(){
        for(int i=0;i&lt;n;++i)
            if(res[i]==-1)
                augment(i);
        int r=0;
        for(int i=0;i&lt;n;++i)
            if(res[i]!=-1)
                ++r;
        return r/2;
    }
};
int main(){
    int n,m;
   while(cin&gt;&gt;n&gt;&gt;m){
    MM mm(n);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        mm.add(u,v);
    }
    cout&lt;&lt;n-mm.run()-1&lt;&lt;endl;}
    return 0;
}
</pre><pre></pre><h2>Problem2184</h2><pre>#ifndef BLOSSOM_ALGORITHM
#define BLOSSOM_ALGORITHM
#include&lt;queue&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    struct BlossomAlgorithm{
        int n;vector&lt;int&gt;res,nxt,mrk,vis,top,prt,rnk;
        vector&lt;vector&lt;int&gt; &gt;to;queue&lt;int&gt;qu;
        BlossomAlgorithm(int _n):
            n(_n),res(n,-1),nxt(n),mrk(n),vis(n),top(n),to(n),prt(n),rnk(n){}
        int fd(int x){return x==prt[x]?x:prt[x]=fd(prt[x]);}
        void lk(int x,int y){
            if(rnk[x=fd(x)]&gt;rnk[y=fd(y)])prt[y]=x;
            else if(rnk[x]&lt;rnk[y])prt[x]=y;
            else prt[x]=y,++rnk[y];}
        int lca(int x,int y){
            static int t;++t;
            for(;;swap(x,y))if(x!=-1){
                x=top[fd(x)];if(vis[x]==t)return x;vis[x]=t;
                if(res[x]!=-1)x=nxt[res[x]];else x=-1;}}
        void uni(int x,int p){
            for(;fd(x)!=fd(p);){
                int y=res[x],z=nxt[y];
                if(fd(z)!=fd(p))nxt[z]=y;
                if(mrk[y]==2)mrk[y]=1,qu.push(y);
                if(mrk[z]==2)mrk[z]=1,qu.push(z);
                int t=top[fd(z)];lk(x,y);lk(y,z);top[fd(z)]=t;x=z;}}
        void aug(int s){
            for(int i=0;i&lt;n;++i)nxt[i]=-1,mrk[i]=0,top[i]=i,prt[i]=i,rnk[i]=0;
            mrk[s]=1;qu=queue&lt;int&gt;();
            for(qu.push(s);!qu.empty();){
                int x=qu.front();qu.pop();
                for(int i=0;i&lt;to[x].size();++i){
                    int y=to[x][i];
                    if(res[x]==y||fd(x)==fd(y)||mrk[y]==2)continue;
                    if(mrk[y]==1){
                        int z=lca(x,y);
                        if(fd(x)!=fd(z))nxt[x]=y;
                        if(fd(y)!=fd(z))nxt[y]=x;
                        uni(x,z);uni(y,z);}
                    else if(res[y]==-1){
                        nxt[y]=x;while(y!=-1){
                            int z=nxt[y],mz=res[z];res[z]=y;res[y]=z;y=mz;}
                        return;}
                    else{nxt[y]=x;mrk[res[y]]=1;qu.push(res[y]);mrk[y]=2;}}}}
        void add(int x,int y){to[x-1].push_back(y-1);to[y-1].push_back(x-1);}
        int run(){
            for(int i=0;i&lt;n;++i)if(res[i]==-1)
                for(int j=0;j&lt;to[i].size();++j)
                    if(res[to[i][j]]==-1){res[to[i][j]]=i;res[i]=to[i][j];break;}
            for(int i=0;i&lt;n;++i)if(res[i]==-1)aug(i);
            int r=0;for(int i=0;i&lt;n;++i)if(res[i]!=-1)++r;
            return r/2;}};}
#endif
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;limits&gt;
#include&lt;iomanip&gt;
using namespace std;
    int main(){
        int n,m;
       while(cin&gt;&gt;n&gt;&gt;m){
        CTL::BlossomAlgorithm mm(n);
        for(int i=1;i&lt;=m;++i){
            int u,v;
            cin&gt;&gt;u&gt;&gt;v;
            mm.add(u,v);
        }
        cout&lt;&lt;n-mm.run()-1&lt;&lt;endl;}
        return 0;
    }
</pre><pre></pre><h2>Problem2184</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef double dbl;
typedef long double ldb;
typedef string str;
typedef pair&lt;int,int&gt; pii;




#ifndef MAXIMUM_MATCHING
#define MAXIMUM_MATCHING
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct MaximumMatching{
        int n;vector&lt;int&gt;res,nxt,mrk,vis,top,prt,rnk;
        vector&lt;vector&lt;int&gt; &gt;to;queue&lt;int&gt;qu;
        MaximumMatching(int _n):
            n(_n),res(n+1),nxt(n+1),mrk(n+1),
            vis(n+1),top(n+1),to(n+1),prt(n+1),rnk(n+1){}
        int fd(int x){return x==prt[x]?x:prt[x]=fd(prt[x]);}
        void lk(int x,int y){
            if(rnk[x=fd(x)]&gt;rnk[y=fd(y)])prt[y]=x;
            else if(rnk[x]&lt;rnk[y])prt[x]=y;
            else prt[x]=y,++rnk[y];}
        int lca(int x,int y){
            static int t;++t;
            for(;;swap(x,y))if(x){
                x=top[fd(x)];if(vis[x]==t)return x;vis[x]=t;
                if(res[x])x=nxt[res[x]];else x=0;}}
        void uni(int x,int p){
            for(;fd(x)!=fd(p);){
                int y=res[x],z=nxt[y];
                if(fd(z)!=fd(p))nxt[z]=y;
                if(mrk[y]==2)mrk[y]=1,qu.push(y);
                if(mrk[z]==2)mrk[z]=1,qu.push(z);
                int t=top[fd(z)];lk(x,y);lk(y,z);
                top[fd(z)]=t;x=z;}}
        void aug(int s){
            for(int i=1;i&lt;=n;++i)
                nxt[i]=0,mrk[i]=0,top[i]=i,prt[i]=i,rnk[i]=0;
            mrk[s]=1;qu=queue&lt;int&gt;();
            for(qu.push(s);!qu.empty();){
                int x=qu.front();qu.pop();
                for(int i=0;i&lt;to[x].size();++i){
                    int y=to[x][i];
                    if(res[x]==y||fd(x)==fd(y)||mrk[y]==2)
                        continue;
                    if(mrk[y]==1){
                        int z=lca(x,y);
                        if(fd(x)!=fd(z))nxt[x]=y;
                        if(fd(y)!=fd(z))nxt[y]=x;
                        uni(x,z);uni(y,z);}
                    else if(!res[y]){
                        for(nxt[y]=x;y;){
                            int z=nxt[y],mz=res[z];
                            res[z]=y;res[y]=z;y=mz;}
                        return;
                    }else{
                        nxt[y]=x;mrk[res[y]]=1;
                        qu.push(res[y]);mrk[y]=2;}}}}
        void add(int x,int y){
            to[x].push_back(y);to[y].push_back(x);}
        int run(){
            for(int i=1;i&lt;=n;++i)if(!res[i])
                for(int j=0;j&lt;to[i].size();++j)
                    if(!res[to[i][j]]){
                        res[to[i][j]]=i;res[i]=to[i][j];break;}
            for(int i=1;i&lt;=n;++i)if(!res[i])aug(i);
            int r=0;for(int i=1;i&lt;=n;++i)if(res[i])++r;
            return r/2;}};}
#endif


int main(){
        int n,m;
       while(cin&gt;&gt;n&gt;&gt;m){
        MaximumMatching mm(n);
        for(int i=1;i&lt;=m;++i){
            int u,v;
            cin&gt;&gt;u&gt;&gt;v;
            mm.add(u,v);
        }
        cout&lt;&lt;n-mm.run()-1&lt;&lt;endl;}
        return 0;
    }
</pre><pre></pre><h2>Problem2190</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int phi(int n){
    int r=n;
    for(int i=2;i*i&lt;=n;++i){
        if(n%i==0){
            r/=i;r*=i-1;
            while(n%i==0)n/=i;
        }
    }
    if(n!=1)r/=n,r*=n-1;
    return r;
} 
int main(){
    int n;sf("%d",&amp;n);
    long long ans=0;
    lp(i,2,n-1)ans+=phi(i);
    ans*=2;
    ans+=3;
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2200</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int T,R,P,S;
vector&lt;int&gt; E[2][25010],W[2][25010];
int Belong[25010],Calced[25010],Tot,Dis[25010];
int SetBg[25010],SetNxt[25010],SetNa[25010],SetTot;
void dfs(int x,int s){
    if(Belong[x]==0){
        Belong[x]=s;
        SetNa[++SetTot]=x;
        SetNxt[SetTot]=SetBg[s];
        SetBg[s]=SetTot;
        lp(i,0,int(E[0][x].size())-1)
            dfs(E[0][x][i],s);
    }
}
struct node{
    node(int x,int y):u(x),d(y){}
    int u,d;
};
bool operator&lt;(node a,node b){
    return a.d&gt;b.d;
}
void dijkstra(int s){
    priority_queue&lt;node&gt; q;
    for(int p=SetBg[s];p;p=SetNxt[p])
        if(Dis[SetNa[p]]!=1500000000)
            q.push(node(SetNa[p],Dis[SetNa[p]]));
    while(!q.empty()){
        node t=q.top();
        q.pop();
        if(t.d==Dis[t.u]){
            lp(i,0,int(E[0][t.u].size())-1){
                int v=E[0][t.u][i],w=W[0][t.u][i];
                if(Dis[t.u]+w&lt;Dis[v]){
                    Dis[v]=Dis[t.u]+w;
                    q.push(node(v,Dis[v]));
                }
            }
        }
    }
}
void calc(int s){
    if(!Calced[s]){
        Calced[s]=1;
        for(int p=SetBg[s];p;p=SetNxt[p])
            lp(j,0,int(E[1][SetNa[p]].size())-1){
                calc(Belong[E[1][SetNa[p]][j]]);
                if(Dis[E[1][SetNa[p]][j]]!=1500000000)
                    Dis[SetNa[p]]=min(Dis[SetNa[p]],Dis[E[1][SetNa[p]][j]]+W[1][SetNa[p]][j]);
            }
        dijkstra(s);
    }
}
int main(){
    sf("%d%d%d%d",&amp;T,&amp;R,&amp;P,&amp;S);
    lp(i,1,R){
        int a,b,c;
        sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        E[0][a].push_back(b);
        W[0][a].push_back(c);
        E[0][b].push_back(a);
        W[0][b].push_back(c);
    }
    lp(i,1,P){
        int a,b,c;
        sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        E[1][b].push_back(a);
        W[1][b].push_back(c);
    }
    lp(i,1,T)
        if(Belong[i]==0)
            dfs(i,++Tot);
    lp(i,1,T)
        Dis[i]=1500000000;
    Dis[S]=0;
    lp(i,1,Tot)
        calc(i);
    lp(i,1,T)
        if(Dis[i]==1500000000)
            pf("NO PATH\n");
        else
            pf("%d\n",Dis[i]);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2219</h2><pre>#include&lt;iostream&gt;


#ifndef MODULAR_NTH_ROOT
#define MODULAR_NTH_ROOT
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    namespace ModularNthRoot{
        typedef long long T;
        T pow(T a,T b,T c){T r=1;for(;b;b&amp;1?r=r*a%c:0,b&gt;&gt;=1,a=a*a%c);return r;}
        int chk(T a,int c=10){
            if(a==1)return 0;
            T u=a-1,t=0;for(;u%2==0;u/=2,++t);
            for(int i=0;i&lt;c;++i){
                T x=pow(rand()*1.0/RAND_MAX*(a-2)+1,u,a),y;
                for(int j=0;j&lt;t;++j){y=x,x=x*x%a;if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)return 0;}
                if(x!=1)return 0;}
            return 1;}
        T gcd(T a,T b){if(a&lt;0)a=-a;if(b&lt;0)b=-b;return b?gcd(b,a%b):a;}
        T rho(T a,T c){
            T x=double(rand())/RAND_MAX*(a-1),y=x;
            for(int i=1,k=2;;){
                x=(x*x%a+c)%a;T d=gcd(y-x,a);
                if(d!=1&amp;&amp;d!=a)return d;
                if(y==x)return a;
                if(++i==k)y=x,k=2*k;}}
        vector&lt;pair&lt;T,int&gt; &gt;fac(T a){
            if(a==1)return vector&lt;pair&lt;T,int&gt; &gt;();
            if(chk(a))return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
            T b=a;while((b=rho(b,double(rand())/RAND_MAX*(a-1)))==a);
            vector&lt;pair&lt;T,int&gt; &gt;u=fac(b),v=fac(a/b),r;
            for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
                if(pu==u.size())r.push_back(v[pv++]);
                else if(pv==v.size())r.push_back(u[pu++]);
                else if(u[pu].first==v[pv].first)
                    r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
                else if(u[pu].first&gt;v[pv].first)r.push_back(v[pv++]);
                else r.push_back(u[pu++]);}
            return r;}
        void dfs(vector&lt;pair&lt;T,int&gt; &gt;&amp;f,int i,T now,vector&lt;T&gt;&amp;r){
            if(i==f.size()){r.push_back(now);return;}
            for(int j=0;j&lt;=f[i].second;++j,now*=f[i].first){dfs(f,i+1,now,r);}}
        T prt(T a){
            T pa=a-1;vector&lt;pair&lt;T,int&gt; &gt;fpa=fac(pa);vector&lt;T&gt;fs;dfs(fpa,0,1,fs);
            for(T g=1,f=0;;++g,f=0){
                for(int i=0;i&lt;fs.size();++i)
                    if(fs[i]!=pa&amp;&amp;pow(g,fs[i],a)==1){f=1;break;}
                if(!f)return g;}}
        int ti[1&lt;&lt;16],va[1&lt;&lt;16],mp[1&lt;&lt;16],nx[1&lt;&lt;16],hd[1&lt;&lt;16],tm,nw;
        void ins(int x,int v){
            int y=x&amp;65535;if(ti[y]!=tm)ti[y]=tm,hd[y]=0;
            for(int i=hd[y];i;i=nx[i])if(va[i]==x){mp[i]=v;return;}
            va[++nw]=x;mp[nw]=v;nx[nw]=hd[y];hd[y]=nw;}
        int get(int x){
            int y=x&amp;65535;if(ti[y]!=tm)ti[y]=tm,hd[y]=0;
            for(int i=hd[y];i;i=nx[i])if(va[i]==x){return mp[i];}
            return -1;}
        void exg(T a,T b,T&amp;x,T&amp;y){if(!b)x=1,y=0;else exg(b,a%b,y,x),y-=a/b*x;}
        T inv(T a,T b){T x,y;exg(a,b,x,y);return x+b;}
        T bgs(T a,T b,T c){
            ++tm;nw=0;T m=sqrt(c);
            for(T i=m-1,u=pow(a,i,c),v=inv(a,c);i&gt;=0;--i,u=u*v%c)ins(u,i);
            for(T i=0,u=1,v=inv(pow(a,m,c),c);i*m&lt;=c;++i,u=u*v%c){
                T t=u*b%c,j;if((j=get(t))!=-1)return i*m+j;}
            return -1;}
        T pow(T a,T b){return b?pow(a,b-1)*a:1;}
        T spk(T a,T b,T p,T k){
            T pk=1;for(int i=1;i&lt;=k;++i)pk*=p;b%=pk;
            if(!b)return pow(p,k-1-(k-1)/a);
            T c0=0,b0=b;while(b0%p==0)b0/=p,++c0,pk/=p;
            if(c0%a)return 0;
            T g=prt(p),ib0=bgs(g,b0,pk),ppk=pk/p*(p-1),d=gcd(a,ppk);
            return ib0%d?0:d*pow(p,c0-c0/a);
        }
        T run(T a,T b,T c){
            b=(b%c+c)%c;if(c==1)return 1;
            if(a==0)return b==1?c:0;
            T r=1;vector&lt;pair&lt;T,int&gt; &gt;fa=fac(c);
            for(int i=0;i&lt;fa.size();++i)if(!(r*=spk(a,b,fa[i].first,fa[i].second)))return 0;
            return r;
        }
    }
}
#endif



#include&lt;iostream&gt;
#include&lt;cstdio&gt;
typedef long long ll;
using namespace std;
int main(){
    int a,b,c;
    int t;scanf("%d",&amp;t);
    while(t--){
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        printf("%d\n",(int)CTL::ModularNthRoot::run(a,b,2*c+1));
    }
    return 0;
}
</pre><pre></pre><h2>Problem2219</h2><pre>#include&lt;iostream&gt;


#ifndef MODULAR_NTH_ROOT
#define MODULAR_NTH_ROOT
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    namespace ModularNthRoot{
        typedef long long T;
        T pow(T a,T b,T c){T r=1;for(;b;b&amp;1?r=r*a%c:0,b&gt;&gt;=1,a=a*a%c);return r;}
        int chk(T a,int c=10){
            if(a==1)return 0;
            T u=a-1,t=0;for(;u%2==0;u/=2,++t);
            for(int i=0;i&lt;c;++i){
                T x=pow(rand()*1.0/RAND_MAX*(a-2)+1,u,a),y;
                for(int j=0;j&lt;t;++j){y=x,x=x*x%a;if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)return 0;}
                if(x!=1)return 0;}
            return 1;}
        T gcd(T a,T b){if(a&lt;0)a=-a;if(b&lt;0)b=-b;return b?gcd(b,a%b):a;}
        T rho(T a,T c){
            T x=double(rand())/RAND_MAX*(a-1),y=x;
            for(int i=1,k=2;;){
                x=(x*x%a+c)%a;T d=gcd(y-x,a);
                if(d!=1&amp;&amp;d!=a)return d;
                if(y==x)return a;
                if(++i==k)y=x,k=2*k;}}
        vector&lt;pair&lt;T,int&gt; &gt;fac(T a){
            if(a==1)return vector&lt;pair&lt;T,int&gt; &gt;();
            if(chk(a))return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
            T b=a;while((b=rho(b,double(rand())/RAND_MAX*(a-1)))==a);
            vector&lt;pair&lt;T,int&gt; &gt;u=fac(b),v=fac(a/b),r;
            for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
                if(pu==u.size())r.push_back(v[pv++]);
                else if(pv==v.size())r.push_back(u[pu++]);
                else if(u[pu].first==v[pv].first)
                    r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
                else if(u[pu].first&gt;v[pv].first)r.push_back(v[pv++]);
                else r.push_back(u[pu++]);}
            return r;}
        void dfs(vector&lt;pair&lt;T,int&gt; &gt;&amp;f,int i,T now,vector&lt;T&gt;&amp;r){
            if(i==f.size()){r.push_back(now);return;}
            for(int j=0;j&lt;=f[i].second;++j,now*=f[i].first){dfs(f,i+1,now,r);}}
        T prt(T a){
            T pa=a-1;vector&lt;pair&lt;T,int&gt; &gt;fpa=fac(pa);vector&lt;T&gt;fs;dfs(fpa,0,1,fs);
            for(T g=1,f=0;;++g,f=0){
                for(int i=0;i&lt;fs.size();++i)
                    if(fs[i]!=pa&amp;&amp;pow(g,fs[i],a)==1){f=1;break;}
                if(!f)return g;}}
        int ti[1&lt;&lt;16],va[1&lt;&lt;16],mp[1&lt;&lt;16],nx[1&lt;&lt;16],hd[1&lt;&lt;16],tm,nw;
        void ins(int x,int v){
            int y=x&amp;65535;if(ti[y]!=tm)ti[y]=tm,hd[y]=0;
            for(int i=hd[y];i;i=nx[i])if(va[i]==x){mp[i]=v;return;}
            va[++nw]=x;mp[nw]=v;nx[nw]=hd[y];hd[y]=nw;}
        int get(int x){
            int y=x&amp;65535;if(ti[y]!=tm)ti[y]=tm,hd[y]=0;
            for(int i=hd[y];i;i=nx[i])if(va[i]==x){return mp[i];}
            return -1;}
        void exg(T a,T b,T&amp;x,T&amp;y){if(!b)x=1,y=0;else exg(b,a%b,y,x),y-=a/b*x;}
        T inv(T a,T b){T x,y;exg(a,b,x,y);return x+b;}
        T bgs(T a,T b,T c){
            ++tm;nw=0;T m=sqrt(c);
            for(T i=m-1,u=pow(a,i,c),v=inv(a,c);i&gt;=0;--i,u=u*v%c)ins(u,i);
            for(T i=0,u=1,v=inv(pow(a,m,c),c);i*m&lt;=c;++i,u=u*v%c){
                T t=u*b%c,j;if((j=get(t))!=-1)return i*m+j;}
            return -1;}
        T pow(T a,T b){return b?pow(a,b-1)*a:1;}
        T spk(T a,T b,T p,T k){
            T pk=1;for(int i=1;i&lt;=k;++i)pk*=p;b%=pk;
            if(!b)return pow(p,k-1-(k-1)/a);
            T c0=0,b0=b;while(b0%p==0)b0/=p,++c0,pk/=p;
            if(c0%a)return 0;
            T g=prt(p),ib0=bgs(g,b0,pk),ppk=pk/p*(p-1),d=gcd(a,ppk);
            return ib0%d?0:d*pow(p,c0-c0/a);}
        T run(T a,T b,T c){
            b=(b%c+c)%c;if(c==1)return 1;
            if(a==0)return b==1?c:0;
            T r=1;vector&lt;pair&lt;T,int&gt; &gt;fa=fac(c);
            for(int i=0;i&lt;fa.size();++i)if(!(r*=spk(a,b,fa[i].first,fa[i].second)))return 0;
            return r;}}}
#endif



#include&lt;iostream&gt;
#include&lt;cstdio&gt;
typedef long long ll;
using namespace std;
int main(){
    int a,b,c;
    int t;scanf("%d",&amp;t);
    while(t--){
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        printf("%d\n",(int)CTL::ModularNthRoot::run(a,b,2*c+1));
    }
    return 0;
}
</pre><pre></pre><h2>Problem2226</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef unsigned long long ull;
const int lm=1000005;
ull a[lm+10],b[lm+10];
int main(){
    for(int i=1;i&lt;=lm;++i)a[i]=a[i-1]+i;
    for(int i=1;i&lt;=lm;++i)
        for(int j=2;j*i&lt;=lm;++j)
            a[j*i]-=a[i]*j;
    for(int i=1;i&lt;=lm;++i)
        for(int j=1;j*i&lt;=lm;++j)
            b[j*i]+=a[i];
    lp(i,1,lm)b[i]*=i;
    int test;sf("%d",&amp;test);
    lp(kase,1,test){
        int n;sf("%d",&amp;n);
        pf("%llu\n",b[n]);
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace lct{
    const int nmx=100000;
    int pr[nmx+10],ch[nmx+10][2];
    int cnt[nmx+10],col[nmx+10],lcol[nmx+10],rcol[nmx+10],tag[nmx+10];
    int tp(int u){return u!=ch[pr[u]][0];}
    void dw(int u){
        if(tag[u]!=-1){
            cnt[u]=1;col[u]=lcol[u]=rcol[u]=tag[u];
            tag[ch[u][0]]=tag[u];
            tag[ch[u][1]]=tag[u];tag[u]=-1;
        }
    }
    void up(int u){
        cnt[u]=1;lcol[u]=rcol[u]=col[u];
        if(ch[u][0]){
            dw(ch[u][0]);
            cnt[u]+=cnt[ch[u][0]]-(lcol[u]==rcol[ch[u][0]]);
            lcol[u]=lcol[ch[u][0]];
        }
        if(ch[u][1]){
            dw(ch[u][1]);
            cnt[u]+=cnt[ch[u][1]]-(rcol[u]==lcol[ch[u][1]]);
            rcol[u]=rcol[ch[u][1]];
        }
    }
    void prt(){
        lp(i,1,6)pf("[%d,%d,%d,%d,%d,%d]\n",i,pr[i],ch[i][0],ch[i][1],tag[i],cnt[i]);
    }
    void st(int u,int v,int d){
        ch[u][d]=v;pr[v]=u;up(u);
    }
    void rot(int u){
        int v=pr[u],w=pr[v],a=tp(u),b=tp(v);
        st(v,ch[u][!a],a);
        st(u,v,!a);
        if(w&gt;0)st(w,u,b);else pr[u]=w;
    }
    void dfs(int u){
        if(u&gt;0)dfs(pr[u]),dw(u);
    }
    void spl(int u){
        dfs(u);
        while(pr[u]&gt;0){
            if(pr[pr[u]]&lt;=0)rot(u);
            else if(tp(u)==tp(pr[u]))rot(pr[u]),rot(u);
            else rot(u),rot(u);
        }
    }
    int acc(int u){
        int v=0;
        while(u){
            spl(u);
            pr[ch[u][1]]=-u;
            st(u,v,1);
            v=u;u=-pr[u];
        }
        return v;
    }
    int ask(int u,int v){
        acc(u);int w=acc(v);
        spl(w);spl(u);
        int r=1;
        if(u!=w)r+=cnt[u]-(lcol[u]==col[w]);
        if(ch[w][1])r+=cnt[ch[w][1]]-(lcol[ch[w][1]]==col[w]);
        return r;
    }
    void mod(int u,int v,int c){
        acc(u);int w=acc(v);
        spl(w);spl(u);
        col[w]=lcol[w]=rcol[w]=c;
        if(u!=w)tag[u]=c;
        if(ch[w][1])tag[ch[w][1]]=c;
    }
}
vector&lt;int&gt;to[100010];
int in[100010];
void bfs(){
    queue&lt;int&gt;qu;qu.push(1);in[1]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,int(to[u].size()-1))
            if(!in[to[u][i]]){
                lct::pr[to[u][i]]=-u;
                in[to[u][i]]=1;
                qu.push(to[u][i]);
            }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;lct::col[i]);
        lct::cnt[i]=1;lct::tag[i]=-1;
        lct::lcol[i]=lct::rcol[i]=lct::col[i];
    }
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);
        to[v].push_back(u);
    }
    bfs();
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%d\n",lct::ask(a,b));
        }else{
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            lct::mod(a,b,c);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace lct{
    const int nmx=100000;
    int pr[nmx+10],ch[nmx+10][2];
    int cnt[nmx+10],col[nmx+10],lcol[nmx+10],rcol[nmx+10],tag[nmx+10];
    inline int tp(int u){return u!=ch[pr[u]][0];}
    inline void dw(int u){
        if(tag[u]!=-1){
            cnt[u]=1;col[u]=lcol[u]=rcol[u]=tag[u];
            tag[ch[u][0]]=tag[u];
            tag[ch[u][1]]=tag[u];tag[u]=-1;
        }
    }
   inline void up(int u){
        cnt[u]=1;lcol[u]=rcol[u]=col[u];
        if(ch[u][0]){
            dw(ch[u][0]);
            cnt[u]+=cnt[ch[u][0]]-(lcol[u]==rcol[ch[u][0]]);
            lcol[u]=lcol[ch[u][0]];
        }
        if(ch[u][1]){
            dw(ch[u][1]);
            cnt[u]+=cnt[ch[u][1]]-(rcol[u]==lcol[ch[u][1]]);
            rcol[u]=rcol[ch[u][1]];
        }
    }
    inline void prt(){
        lp(i,1,6)pf("[%d,%d,%d,%d,%d,%d]\n",i,pr[i],ch[i][0],ch[i][1],tag[i],cnt[i]);
    }
    inline void st(int u,int v,int d){
        ch[u][d]=v;pr[v]=u;up(u);
    }
   inline  void rot(int u){
        int v=pr[u],w=pr[v],a=tp(u),b=tp(v);
        st(v,ch[u][!a],a);
        st(u,v,!a);
        if(w&gt;0)st(w,u,b);else pr[u]=w;
    }
   inline  void dfs(int u){
        if(u&gt;0)dfs(pr[u]),dw(u);
    }
    inline void spl(int u){
        dfs(u);
        while(pr[u]&gt;0){
            if(pr[pr[u]]&lt;=0)rot(u);
            else if(tp(u)==tp(pr[u]))rot(pr[u]),rot(u);
            else rot(u),rot(u);
        }
    }
    inline int acc(int u){
        int v=0;
        while(u){
            spl(u);
            pr[ch[u][1]]=-u;
            st(u,v,1);
            v=u;u=-pr[u];
        }
        return v;
    }
   inline  int ask(int u,int v){
        acc(u);int w=acc(v);
        spl(w);spl(u);
        int r=1;
        if(u!=w)r+=cnt[u]-(lcol[u]==col[w]);
        if(ch[w][1])r+=cnt[ch[w][1]]-(lcol[ch[w][1]]==col[w]);
        return r;
    }
   inline  void mod(int u,int v,int c){
        acc(u);int w=acc(v);
        spl(w);spl(u);
        col[w]=lcol[w]=rcol[w]=c;
        if(u!=w)tag[u]=c;
        if(ch[w][1])tag[ch[w][1]]=c;
    }
}
vector&lt;int&gt;to[100010];
int in[100010];
inline void bfs(){
    queue&lt;int&gt;qu;qu.push(1);in[1]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,int(to[u].size()-1))
            if(!in[to[u][i]]){
                lct::pr[to[u][i]]=-u;
                in[to[u][i]]=1;
                qu.push(to[u][i]);
            }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;lct::col[i]);
        lct::cnt[i]=1;lct::tag[i]=-1;
        lct::lcol[i]=lct::rcol[i]=lct::col[i];
    }
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);
        to[v].push_back(u);
    }
    bfs();
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%d\n",lct::ask(a,b));
        }else{
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            lct::mod(a,b,c);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
using namespace std;
namespace sam{
    const int N=100000,L=2;
    int pr[N*2+10],ln[N*2+10],tr[N*2+10][L+10],nw;
    int ct[N*2+10],ps[N*2+10];
    int make(){++nw;return nw;}
    void init(){nw=0;make();}
    int add(int c,int p){
        if(tr[p][c]){
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)return q;
            else{
                int np=make();ln[np]=ln[p]+1;pr[np]=pr[q];
                copy(tr[q],tr[q]+L,tr[np]);pr[q]=np;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=np;
                return np;
            }
        }else{
            int np=make();ln[np]=ln[p]+1;
            for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
            if(!p)pr[np]=1;
            else{
                int q=tr[p][c];
                if(ln[q]==ln[p]+1)pr[np]=q;
                else{
                    int nq=make();ln[nq]=ln[p]+1;pr[nq]=pr[q];
                    copy(tr[q],tr[q]+L,tr[nq]);pr[q]=pr[np]=nq;
                    for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
                }
            }
            return np;
        }
    }
    bool cmp(int x,int y){return ln[x]&gt;ln[y];}
    int ch[10010][2];
    void dfs(int u){
        for(int i=0;i&lt;2;++i){
            if(ch[u][i]&amp;&amp;ct[ch[u][i]]&gt;1){
                for(int j=1;j&lt;=ln[ch[u][i]]-ln[u];++j)
                    printf("%d\n",ct[ch[u][i]]);
                dfs(ch[u][i]);
            }
        }
    }
    void run(){
        int len;static char str[3010];
        scanf("%d%s",&amp;len,str+1);
        reverse(str+1,str+len+1);
        init();int myu=1;int couter=1;
        for(char*p=str+1;*p;++p)
            myu=add(*p-'0',myu),ct[myu]=1,ps[myu]=couter++;
        static int buff[10010];
        for(int i=1;i&lt;=nw;++i)buff[i]=i;
        sort(buff+1,buff+nw+1,cmp);
        for(int i=1;i&lt;=nw;++i){
            int u=buff[i];
            ct[pr[u]]+=ct[u];
            ps[pr[u]]=ps[u];
            char c=str[ps[u]-ln[pr[u]]]-'0';
            ch[pr[u]][c]=u;
        }
        dfs(1);
    }
}
int main(){
    sam::run();
    //for(;;);
    return 0;
} 
</pre><pre></pre><h2>Problem2286</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
using namespace std;
const int N=250000,L=18;
struct VT{
    vector&lt;int&gt;we[N+1];int mi[N+1][L+1];
    vector&lt;int&gt;vwe[N+1];
     
    vector&lt;int&gt;to[N+1],vto[N+1],lst;
    int up[N+1][L+1],dp[N+1],dfn[N+1],edf[N+1],imp[N+1],n;
    VT(int _n):
        n(_n){
        fill(imp+1,imp+n+1,0);
    }
    void add(int u,int v,int w){
        to[u].push_back(v);
        to[v].push_back(u);
        we[u].push_back(w);
        we[v].push_back(w);
    }
    void vadd(int u,int v,int w){
        vto[u].push_back(v);
        
        vwe[u].push_back(w);
       
         
         
       //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
    }
    int lca(int u,int v){
        if(dp[u]&lt;dp[v])
            swap(u,v);
        for(int i=0;i&lt;=L;++i)
            if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)
                u=up[u][i];
        if(u==v)
            return u;
        for(int i=L;i&gt;=0;--i)
            if(up[u][i]!=up[v][i])
                u=up[u][i],v=up[v][i];
        return up[u][0];
    }
    int mlca(int u,int v){
        int ans=~0u&gt;&gt;1;
        if(dp[u]&lt;dp[v])
            swap(u,v);
        for(int i=0;i&lt;=L;++i)
            if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)
                ans=min(ans,mi[u][i]),u=up[u][i];
        if(u==v)
            return ans;
        for(int i=L;i&gt;=0;--i)
            if(up[u][i]!=up[v][i])
                ans=min(ans,mi[u][i]),ans=min(ans,mi[v][i]),u=up[u][i],v=up[v][i];
        return ans;
    }
    void dfs(int u){
        dfn[u]=++dfn[0];
        for(int i=1;i&lt;=L;++i){
            up[u][i]=up[up[u][i-1]][i-1];
            mi[u][i]=min(mi[u][i-1],mi[up[u][i-1]][i-1]);
        }
             
        for(int i=0;i&lt;to[u].size();++i){
            int v=to[u][i];
            if(v!=up[u][0]){
                up[v][0]=u;
                mi[v][0]=we[u][i];
                dp[v]=dp[u]+1;
                dfs(v);
            }
        }
        edf[u]=dfn[0];
    }
    void build(){
        fill(up[0],up[0]+L+1,0);
        fill(mi[0],mi[0]+L+1,~0u&gt;&gt;1);
        up[1][0]=0;
        mi[1][0]=~0u&gt;&gt;1;
        dp[1]=0;
        dfn[0]=0;
        dfs(1);
    }
    void run(int*a,int m){
        for(int i=0;i&lt;lst.size();++i){
            imp[lst[i]]=0;
            vto[lst[i]].clear();
            vwe[lst[i]].clear();
        }
        lst.clear();
        static pair&lt;int,int&gt;b[N+1];
        for(int i=1;i&lt;=m;++i){
            imp[a[i]]=1;
            b[i]=make_pair(dfn[a[i]],a[i]);
        }
        sort(b+1,b+m+1);
        vector&lt;int&gt;st;
        st.push_back(1);
        lst.push_back(1);
        for(int i=1;i&lt;=m;++i){
            int u=b[i].second,v=st.back();
            if(u==1)
                continue;
            if(dfn[u]&lt;=edf[v])
                st.push_back(u);
            else{
                int w=lca(u,v);
            //  cout&lt;&lt;w&lt;&lt;endl;
                while(st.size()&gt;=2&amp;&amp;dp[st[st.size()-2]]&gt;=dp[w]){
                    vadd(st[st.size()-2],*st.rbegin(),mlca(*st.rbegin(),st[st.size()-2]));
                    lst.push_back(*st.rbegin());
                    st.pop_back();
                }
                if(st.size()&gt;=2&amp;&amp;w!=st[st.size()-1]){
                    vadd(w,*st.rbegin(),mlca(w,*st.rbegin()));
                    lst.push_back(*st.rbegin());
                    st.pop_back();
                    st.push_back(w);
                }
                st.push_back(u);
            }
            //cout&lt;&lt;"stack:";
            //for(int j=0;j&lt;st.size();++j)
            //  cout&lt;&lt;st[j]&lt;&lt;" ";
            //  cout&lt;&lt;endl;
        }
        while(st.size()&gt;=2){
            vadd(st[st.size()-2],*st.rbegin(),mlca(*st.rbegin(),st[st.size()-2]));
            lst.push_back(*st.rbegin());
            st.pop_back();
        }
    }
};
VT*vt;
long long treedp(int u){
    long long ans=0;
    for(int i=0;i&lt;vt-&gt;vto[u].size();++i){
        int v=vt-&gt;vto[u][i];
        int w=vt-&gt;vwe[u][i];
    //  cout&lt;&lt;"("&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;")"&lt;&lt;endl;
        if(vt-&gt;imp[v]){
            ans+=vt-&gt;vwe[u][i];
        }else{
            ans+=min((long long)vt-&gt;vwe[u][i],treedp(v));
        }
    }
    return ans;
}
int main(){
    int n;scanf("%d",&amp;n);
    vt=new VT(n);
    for(int i=1;i&lt;=n-1;++i){
        int u,v,w;
        scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        vt-&gt;add(u,v,w);
    }
    vt-&gt;build();
    int m;scanf("%d",&amp;m);
    static int a[250010];
    for(int i=1;i&lt;=m;++i){
        int k;scanf("%d",&amp;k);
        for(int j=1;j&lt;=k;++j)
            scanf("%d",&amp;a[j]);
        vt-&gt;run(a,k);
    //  for(int j=0;j&lt;vt-&gt;lst.size();++j)
        //  cout&lt;&lt;vt-&gt;lst[j]&lt;&lt;endl;
    //  printf("-----------\n");
        printf("%lld\n",treedp(1));
    }
    //cout&lt;&lt;vt-&gt;lca(10,6)&lt;&lt;endl;
    return  0;
}
/*
10
1 5 13
1 9 6
2 1 19
2 4 8
2 3 91
5 6 8
7 5 4
7 8 31
10 7 9
3
2 10 6
4 5 7 8 3
3 9 4 6
 
*/</pre><pre></pre><h2>Problem2286</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
 const int N=250000,L=18;
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct VirtualTree{
    vector&lt;int&gt;we[N+1];int mi[N+1][L+1];
    vector&lt;int&gt;vwe[N+1];



    int n,l;vector&lt;vector&lt;int&gt; &gt;to,vto,up;
    vector&lt;int&gt;lst,dp,dfn,edf,imp;
    VirtualTree(int _n):
        n(_n),l(ceil(log2(n)+1e-8)),to(n+1),vto(n+1),
        up(n+1,vector&lt;int&gt;(l+1)),dp(n+1),dfn(n+1),edf(n+1),imp(n+1){}
    void add(int u,int v,int w){
        to[u].push_back(v);
        to[v].push_back(u);
        we[u].push_back(w);
        we[v].push_back(w);
    }
    void vadd(int u,int v,int w){
        vto[u].push_back(v);

        vwe[u].push_back(w);



       //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
    }
    int lca(int u,int v){
        if(dp[u]&lt;dp[v])
            swap(u,v);
        for(int i=0;i&lt;=l;++i)
            if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)
                u=up[u][i];
        if(u==v)
            return u;
        for(int i=l;i&gt;=0;--i)
            if(up[u][i]!=up[v][i])
                u=up[u][i],v=up[v][i];
        return up[u][0];
    }
    int mlca(int u,int v){
        int ans=~0u&gt;&gt;1;
        if(dp[u]&lt;dp[v])
            swap(u,v);
        for(int i=0;i&lt;=l;++i)
            if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)
                ans=min(ans,mi[u][i]),u=up[u][i];
        if(u==v)
            return ans;
        for(int i=l;i&gt;=0;--i)
            if(up[u][i]!=up[v][i])
                ans=min(ans,mi[u][i]),ans=min(ans,mi[v][i]),u=up[u][i],v=up[v][i];
        return ans;
    }
    void dfs(int u){
        dfn[u]=++dfn[0];
        for(int i=1;i&lt;=l;++i){
            up[u][i]=up[up[u][i-1]][i-1];
            mi[u][i]=min(mi[u][i-1],mi[up[u][i-1]][i-1]);
        }

        for(int i=0;i&lt;to[u].size();++i){
            int v=to[u][i];
            if(v!=up[u][0]){
                up[v][0]=u;
                mi[v][0]=we[u][i];
                dp[v]=dp[u]+1;
                dfs(v);
            }
        }
        edf[u]=dfn[0];
    }
    void build(){
        fill(mi[0],mi[0]+l+1,~0u&gt;&gt;1);
        mi[1][0]=~0u&gt;&gt;1;
        dfs(1);
    }
    void run(int*a,int m){
        for(int i=0;i&lt;lst.size();++i){
            imp[lst[i]]=0;
            vto[lst[i]].clear();
            vwe[lst[i]].clear();
        }
        lst.clear();
        static pair&lt;int,int&gt;b[N+1];
        for(int i=1;i&lt;=m;++i){
            imp[a[i]]=1;
            b[i]=make_pair(dfn[a[i]],a[i]);
        }
        sort(b+1,b+m+1);
        vector&lt;int&gt;st;
        st.push_back(1);
        lst.push_back(1);
        for(int i=1;i&lt;=m;++i){
            int u=b[i].second,v=st.back();
            if(u==1)
                continue;
            if(dfn[u]&lt;=edf[v])
                st.push_back(u);
            else{
                int w=lca(u,v);
            //  cout&lt;&lt;w&lt;&lt;endl;
                while(st.size()&gt;=2&amp;&amp;dp[st[st.size()-2]]&gt;=dp[w]){
                    vadd(st[st.size()-2],*st.rbegin(),mlca(*st.rbegin(),st[st.size()-2]));
                    lst.push_back(*st.rbegin());
                    st.pop_back();
                }
                if(st.size()&gt;=2&amp;&amp;w!=st[st.size()-1]){
                    vadd(w,*st.rbegin(),mlca(w,*st.rbegin()));
                    lst.push_back(*st.rbegin());
                    st.pop_back();
                    st.push_back(w);
                }
                st.push_back(u);
            }
            //cout&lt;&lt;"stack:";
            //for(int j=0;j&lt;st.size();++j)
            //  cout&lt;&lt;st[j]&lt;&lt;" ";
            //  cout&lt;&lt;endl;
        }
        while(st.size()&gt;=2){
            vadd(st[st.size()-2],*st.rbegin(),mlca(*st.rbegin(),st[st.size()-2]));
            lst.push_back(*st.rbegin());
            st.pop_back();
        }
    }
};
VirtualTree*vt;
long long treedp(int u){
    long long ans=0;
    for(int i=0;i&lt;vt-&gt;vto[u].size();++i){
        int v=vt-&gt;vto[u][i];
        int w=vt-&gt;vwe[u][i];
    //  cout&lt;&lt;"("&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;")"&lt;&lt;endl;
        if(vt-&gt;imp[v]){
            ans+=vt-&gt;vwe[u][i];
        }else{
            ans+=min((long long)vt-&gt;vwe[u][i],treedp(v));
        }
    }
    return ans;
}
int main(){
    int n;scanf("%d",&amp;n);
    vt=new VirtualTree(n);
    for(int i=1;i&lt;=n-1;++i){
        int u,v,w;
        scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        vt-&gt;add(u,v,w);
    }
    vt-&gt;build();
    int m;scanf("%d",&amp;m);
    static int a[250010];
    for(int i=1;i&lt;=m;++i){
        int k;scanf("%d",&amp;k);
        for(int j=1;j&lt;=k;++j)
            scanf("%d",&amp;a[j]);
        vt-&gt;run(a,k);
    //  for(int j=0;j&lt;vt-&gt;lst.size();++j)
        //  cout&lt;&lt;vt-&gt;lst[j]&lt;&lt;endl;
    //  printf("-----------\n");
        printf("%lld\n",treedp(1));
    }
    //cout&lt;&lt;vt-&gt;lca(10,6)&lt;&lt;endl;
    return  0;
}
/*
10
1 5 13
1 9 6
2 1 19
2 4 8
2 3 91
5 6 8
7 5 4
7 8 31
10 7 9
3
2 10 6
4 5 7 8 3
3 9 4 6
*/
</pre><pre></pre><h2>Problem2292</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[100010],we[100010];int n,m;
struct node{
    node(int a,int b):
        d(a),u(b){}
    int d,u;
};
bool operator&lt;(node a,node b){
    return a.d&gt;b.d;
}
int dis[100010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        to[u].push_back(v);
        we[u].push_back(w);
    }
    lp(i,2,n)dis[i]=~0u&gt;&gt;1;
    priority_queue&lt;node&gt;qu;qu.push(node(0,1));
    while(!qu.empty()){
        int u=qu.top().u,d=qu.top().d;qu.pop();
        if(d==dis[u]){
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(dis[u]+we[u][i]&lt;dis[v]){
                    dis[v]=dis[u]+we[u][i];
                    qu.push(node(dis[v],v));
                }
            }
        }
    }
    pf("%d\n",dis[n]);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2292</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
	struct node{
		inline node(){}
		inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
		ll val;int url;node*ch,*br,*pr;
	}pool[1000010];int posz;
	inline node*make(int u,ll v){
		node*t=&amp;pool[posz++];*t=node(u,v);return t;
	}
	inline node*merge(node*x,node*y){
		if(!x)return y;
		if(!y)return x;
		if(x-&gt;val&gt;y-&gt;val)swap(x,y);
		y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
		y-&gt;pr=x;x-&gt;ch=y;
		return x;
	}
	inline node*decrease(node*x,node*y,ll v){
		y-&gt;val=v;
		if(x!=y){
			if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
			else y-&gt;pr-&gt;br=y-&gt;br;
			if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
			y-&gt;pr=y-&gt;br=0;
			x=merge(x,y);
		}
		return x;
	}
	inline node*pop(node*x){
		static node*ns[1000010];int nz=0;
		for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
		lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
		for(int i=1;i+1&lt;=nz;i+=2)ns[i]=merge(ns[i],ns[i+1]);
		x=0;for(int i=nz-(1-(nz&amp;1));i&gt;=1;i-=2)x=merge(x,ns[i]);
		return x;
	}
}
namespace frontstar{
	struct node{
		inline node(){}
		inline node(int a,int b,node*c):
			v(a),w(b),nxt(c){}
		int v,w;node*nxt;
	}pool[1000010];int posz;
	node*bg[1000010];
	inline void add(int u,int v,int w){
		node*t=&amp;pool[posz++];*t=node(v,w,bg[u]);bg[u]=t;
	}
}
int main(){
	int n,m;sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		frontstar::add(u,v,w);
	}
	static ll dis[1000010];static pairingheap::node*pm[1000010];
	pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
	lp(i,2,n){
		int u=rt-&gt;url;
		if(u==n)break;
		rt=pairingheap::pop(rt);
		for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
			if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
				dis[e-&gt;v]=dis[u]+e-&gt;w;
				if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
				else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
			}
		}
	}
	pf("%lld\n",dis[n]);
	return 0;
}
/*
6 8
1 2 1
1 3 3
2 4 1
4 3 2
4 5 1
4 6 10
3 5 4
5 6 1
*/</pre><pre></pre><h2>Problem2292</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
    struct node{
        inline node(){}
        inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
        ll val;int url;node*ch,*br,*pr;
    }pool[1000010];int posz;
    inline node*make(int u,ll v){
        node*t=&amp;pool[posz++];*t=node(u,v);return t;
    }
    inline node*merge(node*x,node*y){
        if(!x)return y;
        if(!y)return x;
        if(x-&gt;val&gt;y-&gt;val)swap(x,y);
        y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
        y-&gt;pr=x;x-&gt;ch=y;
        return x;
    }
    inline node*decrease(node*x,node*y,ll v){
        y-&gt;val=v;
        if(x!=y){
            if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
            else y-&gt;pr-&gt;br=y-&gt;br;
            if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
            y-&gt;pr=y-&gt;br=0;
            x=merge(x,y);
        }
        return x;
    }
    inline node*pop(node*x){
        static node*ns[1000010];int nz=0;
        for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
        lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
        for(int i=1;i+1&lt;=nz;i+=2)ns[i]=merge(ns[i],ns[i+1]);
        x=0;for(int i=1;i&lt;=nz;i+=2)x=merge(x,ns[i]);
        return x;
    }
}
namespace frontstar{
    struct node{
        inline node(){}
        inline node(int a,int b,node*c):
            v(a),w(b),nxt(c){}
        int v,w;node*nxt;
    }pool[1000010];int posz;
    node*bg[1000010];
    inline void add(int u,int v,int w){
        node*t=&amp;pool[posz++];*t=node(v,w,bg[u]);bg[u]=t;
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        frontstar::add(u,v,w);
    }
    static ll dis[1000010];static pairingheap::node*pm[1000010];
    pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
    lp(i,2,n){
        int u=rt-&gt;url;
        if(u==n)break;
        rt=pairingheap::pop(rt);
        for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
            if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
                dis[e-&gt;v]=dis[u]+e-&gt;w;
                if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
                else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
            }
        }
    }
    pf("%lld\n",dis[n]);
    return 0;
}</pre><pre></pre><h2>Problem2301</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll sum[50010],mui[50010],pri[50010],isp[50010];
ll solve(ll a,ll b){
    if(a==0||b==0)return 0;
    ll r=0;
    for(ll i=1;i&lt;=min(a,b);++i){
        ll t1=(a/i),t2=(b/i);
        ll j=min(a/t1,b/t2);
        r+=(sum[j]-sum[i-1])*t1*t2;
        i=j;
    }
    return r;
}
int main(){
    mui[1]=1;
    lp(i,2,50005){
        if(!isp[i]){
            pri[++pri[0]]=i;
            mui[i]=-1;
        }
        for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=50005;++j){
            if(i%pri[j]==0){
                isp[i*pri[j]]=1;
                mui[i*pri[j]]=0;
            }else{
                isp[i*pri[j]]=1;
                mui[i*pri[j]]=-mui[i];
            }
        }
    }
    lp(i,1,50005)sum[i]=sum[i-1]+mui[i];
    int n;sf("%d",&amp;n);
    lp(i,1,n){
        ll a,b,c,d,k;
        sf("%lld%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);
        a=(a-1)/k;
        b/=k;
        c=(c-1)/k;
        d/=k;
        pf("%lld\n",solve(b,d)-solve(a,d)-solve(b,c)+solve(a,c));
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2324</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
namespace mcmf{
    const int N=1010;
    struct edge{
        edge(int _v,int _c,ll _w):
            v(_v),c(_c),w(_w){}
        int v,c;
        ll w;
    };
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;to[N];
    ll dis[N];int in[N],vcnt;
    void add(int u,int v,int c,ll w){
        to[u].pb(eg.size());
        eg.pb(edge(v,c,w));
        to[v].pb(eg.size());
        eg.pb(edge(u,0,-w));
        //pf("[%d,%d,%d,%lld]\n",u,v,c,w);
    }
    bool spfa(){
        lp(i,1,vcnt)dis[i]=10000000000000000ll;
        dis[1]=0;priority_queue&lt;pair&lt;ll,int&gt; &gt;qu;
        qu.push(mp(-0,1));
        while(!qu.empty()){
            int u=qu.top().second;ll d=-qu.top().first;qu.pop();
            if(dis[u]!=d)continue;
            vp(i,to[u]){
                edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    qu.push(mp(-dis[e.v],e.v));
                }
            }
        }
        return dis[vcnt]!=10000000000000000ll;
    }
    ll cst;int flw;
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;in[u]=1;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t;ev.c+=t;g-=t;cst+=e.w*t;
                if(!g)return f;
            }
        }
        return f-g;
    }
    void run(){
        while(spfa()){
            int t;
            do{
                lp(i,1,vcnt)in[i]=0;
                t=dfs(1,~0u&gt;&gt;1);
                flw+=t;
            }while(0);
        }
    }
}
int n,m,k;
int idst,idet,idx[210][2],nw;
int dp[210][210];
int main(){
	sf("%d%d%d",&amp;n,&amp;m,&amp;k);
	idst=++nw;
	idx[0][0]=++nw;
	lp(i,1,n)idx[i][1]=++nw,idx[i][0]=++nw;
	idet=++nw;
	mcmf::vcnt=nw;
	lp(i,0,n)lp(j,0,n)dp[i][j]=~0u&gt;&gt;1;
	lp(i,1,m){
		int u,v,c;sf("%d%d%d",&amp;u,&amp;v,&amp;c);
		dp[u][v]=min(dp[u][v],c);
		dp[v][u]=min(dp[v][u],c);
	}
	lp(l,0,n){
		lp(i,0,n)lp(j,0,n){
			if(dp[i][l]!=~0u&gt;&gt;1&amp;&amp;dp[l][j]!=~0u&gt;&gt;1&amp;&amp;dp[i][l]+dp[l][j]&lt;dp[i][j])
				dp[i][j]=dp[i][l]+dp[l][j];
		}
		lp(i,0,l-1)if(dp[i][l]!=~0u&gt;&gt;1)mcmf::add(idx[i][0],idx[l][1],1,dp[i][l]);
	}
	lp(i,1,n)mcmf::add(idx[i][1],idx[i][0],1,-ll(~0u&gt;&gt;1));
	mcmf::add(idst,idx[0][0],k,0);
	lp(i,1,n)mcmf::add(idx[i][0],idet,1,0);
	mcmf::add(idx[0][0],idet,k,0);
	mcmf::run();
	ll tmp=~0u&gt;&gt;1;
	//pf("%lld\n",mcmf::cst);
	pf("%lld\n",(mcmf::cst%tmp+tmp)%tmp);
	return 0;
}</pre><pre></pre><h2>Problem2330</h2><pre>#include&lt;cstdio&gt;

#include&lt;cstring&gt;

#include&lt;queue&gt;

#include&lt;algorithm&gt;

#include&lt;iostream&gt;

using namespace std;

typedef long long LL;

int n, m, used;

int ST[100010], c[100010];

bool b[100010], flag = true;

LL dist[100010];

struct node

{

    int x, y, z;

    node(){}

    node(int _x, int _y, int _z) : x(_x), y(_y), z(_z){}

}a[300010];

bool cmp(node a1, node a2){return a1.x &lt; a2.x;}

  

void spfa()

{

    int i, st = a[1].x;

    queue &lt;int&gt; q;

    for(i = 1; i &lt;= n; i++) {b[i] = c[i] = dist[i] = 1; q.push(i);}

    while(!q.empty()) 

    {

        int u = q.front(); q.pop(); b[u] = 0;

        for(int i = ST[u]; a[i].x == u; i++)

        {

            if(dist[a[i].x] + (LL)a[i].z &gt; dist[a[i].y])

            {

                if(++c[a[i].y] &gt; n) {flag = false; return;}

                dist[a[i].y] = dist[a[i].x] + (LL)a[i].z;

                if(!b[a[i].y]) {q.push(a[i].y); b[a[i].y] = 1; ++c[a[i].y];}

            }

        }

    }

  

}

  

int main()

{

    int i, no = 0;

    cin&gt;&gt;n&gt;&gt;m;

    memset(ST, 0, sizeof(ST)); memset(b, 0, sizeof(b));

    for(i = 1; i &lt;= m; i++)

    {

        int k, x, y; cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;

        if(k == 1) {a[++used] = node(x, y, 0); a[++used] = node(y, x, 0);}

        else if(k == 2) 

        {

            if(x == y) {cout&lt;&lt;"-1"; return 0;}

            a[++used] = node(x, y, 1);

        }

        else if(k == 3) {a[++used] = node(y, x, 0);}

        else if(k == 4) 

        {

            if(x == y) {cout&lt;&lt;"-1"; return 0;}

            a[++used] = node(y, x, 1);

        }

        else if(k == 5) {a[++used] = node(x, y, 0);}

    }

    sort(a + 1, a + 1 + used, cmp);

    for(i = used; i &gt;= 1; i--) ST[a[i].x] = i;

    spfa();

    if(flag)

    {

        LL ans = 0;

        for(i = 1; i &lt;= n; i++) ans += dist[i];

        ans += no;

        cout&lt;&lt;ans;

    }

    else cout&lt;&lt;"-1";

return 0;

}</pre><pre></pre><h2>Problem2330</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[100010],we[100010];int n,m;
int in[100010],dis[100010],cnt[100010];
void add(int u,int v,int w){
    to[u].push_back(v);
    we[u].push_back(w);
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int x,a,b;sf("%d%d%d",&amp;x,&amp;a,&amp;b);
        if(x==1){
            add(a,b,0);add(b,a,0); 
        }else if(x==2){
            add(a,b,1);
        }else if(x==3){
            add(b,a,0);
        }else if(x==4){
            add(b,a,1);
        }else{
            add(a,b,0);
        }
    }
    lp(i,1,n)add(n+1,i,1);
    lp(i,1,n+1)reverse(to[i].begin(),to[i].end()),
        reverse(we[i].begin(),we[i].end());
    deque&lt;int&gt;qu;qu.push_back(n+1);in[n+1]=1;
    int f=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop_front();in[u]=0;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i],w=we[u][i];
            if(dis[v]&lt;dis[u]+w){
                dis[v]=dis[u]+w;
                if(!in[v]){
                    if(++cnt[v]&gt;=n+1){f=0;goto ok;}
                    in[v]=1;
                    if (qu.empty() || dis[v] &lt; dis[qu.front()]) qu.push_back(v);
                    else qu.push_front(v);
                }
            }
        }
    }
    ok:
    long long ans=0;lp(i,1,n)ans+=dis[i];
    pf("%lld\n",f?ans:(long long)(-1));
    return 0;
}
</pre><pre></pre><h2>Problem2384</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int MXN=1000010;
int A[MXN],N,Pr[MXN],Nx[MXN],Fa[MXN];
int B[MXN],M;
int Ans[MXN];
void init(){
    sf("%d%d",&amp;N,&amp;M);
    lp(i,1,N)sf("%d",&amp;A[i]);
    lp(i,1,M)sf("%d",&amp;B[i]);
}
void trans(){
    static int tmp[MXN];
    lp(i,1,N)tmp[A[i]]=i;
    lp(i,1,N)A[i]=tmp[i];
    //lp(i,1,N)pf("[%d]",A[i]);pf("\n");
}
void make(){
    static int lft[MXN],rht[MXN],pos[MXN];
    lp(i,1,N)lft[i]=i-1,rht[i]=(i==N?0:i+1),pos[A[i]]=i;
    for(int i=N;i;--i){
        Pr[i]=pos[lft[A[i]]];Nx[i]=pos[rht[A[i]]];
        rht[lft[A[i]]]=rht[A[i]];
        lft[rht[A[i]]]=lft[A[i]];
    }
    //lp(i,1,N)pf("[%d,%d]",Pr[i],Nx[i]);pf("\n");
}
bool cmp1(int a,int b){
    if(Pr[a]&amp;&amp;A[b-(a-Pr[a])]&gt;A[b])return false;
    if(Nx[a]&amp;&amp;A[b-(a-Nx[a])]&lt;A[b])return false;
    return true;
}
void build(){
    Fa[1]=0;
    for(int i=2,j=0;i&lt;=N;++i){
        while(j&amp;&amp;!cmp1(j+1,i))j=Fa[j];
        if(cmp1(j+1,i))++j;
        Fa[i]=j;
    }
    //lp(i,1,N)pf("[%d]",Fa[i]);
}
bool cmp2(int a,int b){
    if(Pr[a]&amp;&amp;B[b-(a-Pr[a])]&gt;B[b])return false;
    if(Nx[a]&amp;&amp;B[b-(a-Nx[a])]&lt;B[b])return false;
    return true;
}
void match(){
    for(int i=1,j=0;i&lt;=M;++i){
        while(j&amp;&amp;!cmp2(j+1,i))j=Fa[j];
        if(cmp2(j+1,i))++j;
        if(j==N)j=Fa[j],Ans[++Ans[0]]=i-N+1;
    }
}
void print(){
    pf("%d\n",Ans[0]);
    if(!Ans[0])pf("\n");
    else lp(i,1,Ans[0])pf("%d%c",Ans[i],i==Ans[0]?'\n':' ');
}
int main(){
    init();
    trans();
    make();
    build();
    match();
    print();
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace mst{
    struct edge{
        edge(){sf("%d%d%d%d",&amp;u,&amp;v,&amp;x,&amp;y);
            ++u,++v;}
        int u,v,x,y;
    };
    int n,m;vector&lt;edge&gt;eg;
    void init(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,m)eg.push_back(edge());
    }
    struct cmp1{
        bool operator()(edge a,edge b){
            return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;
        }
    };
    struct cmp2{
        bool operator()(edge a,edge b){
            return a.y==b.y?a.x&lt;b.x:a.y&lt;b.y;
        }
    };
    struct cmp3{
        int x,y;
        cmp3(int a,int b):x(a),y(b){}
        bool operator()(edge a,edge b){
            return y*a.x-x*a.y&lt;y*b.x-x*b.y;
        }
    };
    int pr[210];
    int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
    template&lt;class T&gt;
    pair&lt;int,int&gt;work(T cmp){
        pair&lt;int,int&gt;r(0,0);
        lp(i,1,n)pr[i]=i;
        sort(eg.begin(),eg.end(),cmp);
        lp(i,0,int(eg.size()-1)){
            int u=eg[i].u,v=eg[i].v,x=eg[i].x,y=eg[i].y;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                r.first+=x;
                r.second+=y;
            }
        }
        return r;
    }
    pair&lt;int,int&gt;ans(-1,-1);
    void update(pair&lt;int,int&gt;p){
        if(ans.first==-1)ans=p;
        else if(ans.first*ans.second&gt;p.first*p.second)ans=p;
        else if(ans.first*ans.second==p.first*p.second&amp;&amp;ans.first&gt;p.first)ans=p;
    }
    void print(pair&lt;int,int&gt;x){
        pf("(%d,%d)",x.first,x.second);
    }
    pair&lt;int,int&gt;dfs(pair&lt;int,int&gt;p,pair&lt;int,int&gt;q){
        int x=p.first-q.first,y=p.second-q.second;
        pair&lt;int,int&gt;t=work(cmp3(x,y));
        if((t.first-q.first)*y-x*(t.second-q.second)!=0){
            update(t);
            dfs(p,t);
            dfs(t,q);
        }
    }
    void solve(){
        pair&lt;int,int&gt;p=work(cmp1()),q=work(cmp2());
        update(p);update(q);
        if(p!=q)dfs(p,q);
        pf("%d %d\n",ans.first,ans.second);
    }
}
int main(){
    mst::init();
    mst::solve();
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem2396</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;iostream&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll A[1010][1010],B[1010][1010],C[1010][1010],D[1010];
ll Ans1[1010],Ans2[1010],Ans3[1010],N;
int main(){
    while(sf("%lld",&amp;N)!=EOF){
        lp(i,1,N)lp(j,1,N)sf("%lld",&amp;A[i][j]);
        lp(i,1,N)lp(j,1,N)sf("%lld",&amp;B[i][j]);
        lp(i,1,N)lp(j,1,N)sf("%lld",&amp;C[i][j]);
        lp(i,1,N)D[i]=i;
        lp(i,1,N)lp(j,1,N)Ans1[i]+=B[i][j]*D[j];
        lp(i,1,N)lp(j,1,N)Ans2[i]+=A[i][j]*Ans1[j];
        lp(i,1,N)lp(j,1,N)Ans3[i]+=C[i][j]*D[j];
        int f=1;lp(i,1,N)if(Ans2[i]!=Ans3[i])f=0;
        pf("%s\n",f?"Yes":"No");
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2400</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace isap{
    struct edge{
        int v,c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[510];
    int dis[510],gap[510];int vcnt;
    void init(){
        eg.clear();
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v,int c){
        edge t;t.v=v;t.c=c;
        to[u].push_back(eg.size());eg.push_back(t);
    }
    void bfs(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;dis[1]=0;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,int(to[u].size()-1)){
                edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
                if(e.c&amp;&amp;dis[e.v]==~0u&gt;&gt;1){
                    dis[e.v]=dis[u]+1;
                    qu.push(e.v);
                }
            }
        }
        lp(i,0,vcnt)gap[i]=0;
        int t=dis[vcnt];
        lp(i,1,vcnt)dis[i]=t-dis[i];
        lp(i,1,vcnt)++gap[dis[i]]; 
    }
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    int solve(){
        int r=0;//bfs();
        lp(i,1,vcnt)gap[i]=0;gap[0]=vcnt;
        lp(i,1,vcnt)dis[i]=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
    void ddfs(int u){
        dis[u]=1;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;!dis[e.v]){
                ddfs(e.v);
            }
        }
    }
    int gtone(){
        lp(i,1,vcnt)dis[i]=0;
        ddfs(1);
        int r=0;
        lp(i,2,vcnt-1)r+=dis[i];
        return r;
    }
} 
int main(){
    static int n,m,v[510];
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;v[i]);
    vector&lt;pair&lt;int,int&gt; &gt;eg;
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        eg.push_back(make_pair(a,b));
    }
    ll ans1=0,ans2=0;
    lp(i,0,30){
        isap::vcnt=n+2;
        isap::init();
        lp(j,0,int(eg.size()-1))
            isap::add(eg[j].first+1,eg[j].second+1,1),
            isap::add(eg[j].second+1,eg[j].first+1,1);
        lp(j,1,n)if(v[j]&gt;=0){
            if((v[j]&gt;&gt;i)&amp;1)
                isap::add(1,j+1,~0u&gt;&gt;1),
                isap::add(j+1,1,0);
            else
                isap::add(n+2,j+1,0),
                isap::add(j+1,n+2,~0u&gt;&gt;1);
        }
        int t1=isap::solve(),t2=isap::gtone();
        ans1+=(1ll&lt;&lt;i)*t1;ans2+=(1ll&lt;&lt;i)*t2;
    }
    pf("%lld\n%lld\n",ans1,ans2);
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem2400</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace isap{
    struct edge{
        int v,c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[510];
    int dis[510],gap[510];int vcnt;
    void init(){
        eg.clear();
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v,int c){
        edge t;t.v=v;t.c=c;
        to[u].push_back(eg.size());eg.push_back(t);
    }
    void bfs(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1;dis[1]=0;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,int(to[u].size()-1)){
                edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
                if(e.c&amp;&amp;dis[e.v]==~0u&gt;&gt;1){
                    dis[e.v]=dis[u]+1;
                    qu.push(e.v);
                }
            }
        }
        lp(i,0,vcnt)gap[i]=0;
        int t=dis[vcnt];
        lp(i,1,vcnt)dis[i]=t-dis[i];
        lp(i,1,vcnt)++gap[dis[i]];
    }
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;int mh=vcnt-1;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
            if(e.c)mh=min(mh,dis[e.v]);
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[dis[u]=mh+1];
        return f-g;
    }
    int solve(){
        int r=0;//bfs();
        lp(i,1,vcnt)gap[i]=0;gap[0]=vcnt;
        lp(i,1,vcnt)dis[i]=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
    void ddfs(int u){
        dis[u]=1;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;!dis[e.v]){
                ddfs(e.v);
            }
        }
    }
    int gtone(){
        lp(i,1,vcnt)dis[i]=0;
        ddfs(1);
        int r=0;
        lp(i,2,vcnt-1)r+=dis[i];
        return r;
    }
}
int main(){
    static int n,m,v[510];
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;v[i]);
    vector&lt;pair&lt;int,int&gt; &gt;eg;
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        eg.push_back(make_pair(a,b));
    }
    ll ans1=0,ans2=0;
    lp(i,0,30){
        isap::vcnt=n+2;
        isap::init();
        lp(j,0,int(eg.size()-1))
            isap::add(eg[j].first+1,eg[j].second+1,1),
            isap::add(eg[j].second+1,eg[j].first+1,1);
        lp(j,1,n)if(v[j]&gt;=0){
            if((v[j]&gt;&gt;i)&amp;1)
                isap::add(1,j+1,~0u&gt;&gt;1),
                isap::add(j+1,1,0);
            else
                isap::add(n+2,j+1,0),
                isap::add(j+1,n+2,~0u&gt;&gt;1);
        }
        int t1=isap::solve(),t2=isap::gtone();
        ans1+=(1ll&lt;&lt;i)*t1;ans2+=(1ll&lt;&lt;i)*t2;
    }
    pf("%lld\n%lld\n",ans1,ans2);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2402</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;complex&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
struct point{
    point(double a=0,double b=0):
        x(a),y(b){}
    double x,y;
};
inline double operator*(const point&amp;a,const point&amp;b){
    return a.x*b.y-b.x*a.y;
}
inline point operator-(const point&amp;a,const point&amp;b){
    return point(a.x-b.x,a.y-b.y);
}
inline double myabs(double a){
    return a&lt;0?-a:a;
}
inline bool operator&lt;(const point&amp;a,const point&amp;b){
    return myabs(a.x-b.x)&lt;1e-8?a.y&lt;b.y:a.x&lt;b.x;
}
int n,q,dep[30010],siz[30010],prt[30010],chd[30010],dfn[30010],top[30010],nw;
vector&lt;int&gt;to[30010];point pot[30010][2],pts[30010][2];
inline void dfs1(int u){
    siz[u]=1;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            dep[v]=dep[u]+1;
            prt[v]=u;
            dfs1(v);
            siz[u]+=siz[v];
            if(siz[v]&gt;siz[chd[u]])
                chd[u]=v;
        }
    } 
}
inline void dfs2(int u,int w){
    dfn[u]=++nw;pts[nw][0]=pot[u][0];pts[nw][1]=pot[u][1];
    top[u]=w;
    if(chd[u])dfs2(chd[u],w);
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]&amp;&amp;v!=chd[u])
            dfs2(v,v);
    } 
}
vector&lt;point&gt;seg[30010*4][2];
inline void build(int x,int l,int r){
    if(l==r){
        lp(i,0,1)seg[x][i].push_back(pts[l][i]);
    }else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        lp(i,0,1){
            seg[x][i].resize(seg[x*2][i].size()+seg[x*2+1][i].size());
            merge(seg[x*2][i].begin(),seg[x*2][i].end(),seg[x*2+1][i].begin(),seg[x*2+1][i].end(),seg[x][i].begin());
            vector&lt;point&gt;tmp;
            lp(j,0,int(seg[x][i].size()-1)){
                point t=seg[x][i][j];
                while(tmp.size()&gt;1){
                    point t1=tmp[tmp.size()-2],t2=tmp[tmp.size()-1];
                    if((t-t1)*(t2-t1)&lt;1e-8)
                        tmp.pop_back();
                    else
                        break;
                }
                tmp.pb(t);
            }
            seg[x][i]=tmp;
        }
    }
    /*pf("[%d,%d,%d]\n",x,l,r);
    lp(i,0,1){
        lp(j,0,int(seg[x][i].size()-1)){
            pf("(%.2lf,%.2lf)",seg[x][i][j].x,seg[x][i][j].y);
        }
        pf("\n"); 
    }*/
}
inline pair&lt;double,double&gt;ask(int x,int l,int r,int b,int e,double k){
    if(b&lt;=l&amp;&amp;e&gt;=r){
        double ret[2]={-1e100,-1e100};
        lp(i,0,1){
            int left=0,right=int(seg[x][i].size()-1);
            while(right-left&gt;=3){
                int del=(right-left)/3;
                int mid1=left+del,mid2=mid1+del;
                if(seg[x][i][mid1].y-seg[x][i][mid1].x*k&gt;seg[x][i][mid2].y-seg[x][i][mid2].x*k)
                    right=mid2;
                else
                    left=mid1;
            }
            lp(j,left,right)ret[i]=max(ret[i],seg[x][i][j].y-seg[x][i][j].x*k);
        }
        return make_pair(ret[0],ret[1]);
    }else{
        pair&lt;double,double&gt;ret(-1e100,-1e100);
        int m=(l+r)/2;
        if(b&lt;=m){
            pair&lt;double,double&gt;t=ask(x*2,l,m,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        if(e&gt;m){
            pair&lt;double,double&gt;t=ask(x*2+1,m+1,r,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        return ret;
    }
}
void upda(pair&lt;double,double&gt;&amp;a,const pair&lt;double,double&gt;&amp;b){
    a.first=max(a.first,b.first);
    a.second=max(a.second,b.second);
}
double query(int u,int v,double k){
    pair&lt;double,double&gt;ret(-1e100,-1e100);
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
        upda(ret,ask(1,1,n,dfn[top[u]],dfn[u],k));
        u=prt[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    upda(ret,ask(1,1,n,dfn[v],dfn[u],k));
    return ret.first+ret.second;
} 
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].y);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].y);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);to[v].pb(u);
    }
    dfs1(1);
    dfs2(1,1);
    //lp(i,1,n)pf("[%d,%d,%d,%d,%d,%d]\n",dep[i],siz[i],prt[i],chd[i],dfn[i],top[i]);
    build(1,1,n);
    sf("%d",&amp;q);
    /*lp(i,1,q){
        int a,b;double c;sf("%d%d%lf",&amp;a,&amp;b,&amp;c);
        pf("[%lf,%lf]\n",ask(1,1,n,a,b,c).first, ask(1,1,n,a,b,c).second);
    }*/ 
    lp(i,1,q){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        double left=0,right=100000000;
        while(right-left&gt;1e-8){
            double mid=(left+right)/2;
            if(query(a,b,mid)&gt;-1e-8)
                left=mid;
            else
                right=mid;
        }
        pf("%.8lf\n",left);
    }
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem2402</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;complex&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
struct point{
    point(double a=0,double b=0):
        x(a),y(b){}
    double x,y;
};
double operator*(const point&amp;a,const point&amp;b){
    return a.x*b.y-b.x*a.y;
}
point operator-(const point&amp;a,const point&amp;b){
    return point(a.x-b.x,a.y-b.y);
}
double myabs(double a){
    return a&lt;0?-a:a;
}
bool operator&lt;(const point&amp;a,const point&amp;b){
    return myabs(a.x-b.x)&lt;1e-8?a.y&lt;b.y:a.x&lt;b.x;
}
int n,q,dep[30010],siz[30010],prt[30010],chd[30010],dfn[30010],top[30010],nw;
vector&lt;int&gt;to[30010];point pot[30010][2],pts[30010][2];
void dfs1(int u){
    siz[u]=1;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            dep[v]=dep[u]+1;
            prt[v]=u;
            dfs1(v);
            siz[u]+=siz[v];
            if(siz[v]&gt;siz[chd[u]])
                chd[u]=v;
        }
    } 
}
void dfs2(int u,int w){
    dfn[u]=++nw;pts[nw][0]=pot[u][0];pts[nw][1]=pot[u][1];
    top[u]=w;
    if(chd[u])dfs2(chd[u],w);
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]&amp;&amp;v!=chd[u])
            dfs2(v,v);
    } 
}
vector&lt;point&gt;seg[30010*4][2];
void build(int x,int l,int r){
    if(l==r){
        lp(i,0,1)seg[x][i].push_back(pts[l][i]);
    }else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        lp(i,0,1){
            seg[x][i].resize(seg[x*2][i].size()+seg[x*2+1][i].size());
            merge(seg[x*2][i].begin(),seg[x*2][i].end(),seg[x*2+1][i].begin(),seg[x*2+1][i].end(),seg[x][i].begin());
            vector&lt;point&gt;tmp;
            lp(j,0,int(seg[x][i].size()-1)){
                point t=seg[x][i][j];
                while(tmp.size()&gt;1){
                    point t1=tmp[tmp.size()-2],t2=tmp[tmp.size()-1];
                    if((t-t1)*(t2-t1)&lt;1e-8)
                        tmp.pop_back();
                    else
                        break;
                }
                tmp.pb(t);
            }
            seg[x][i]=tmp;
        }
    }
    /*pf("[%d,%d,%d]\n",x,l,r);
    lp(i,0,1){
        lp(j,0,int(seg[x][i].size()-1)){
            pf("(%.2lf,%.2lf)",seg[x][i][j].x,seg[x][i][j].y);
        }
        pf("\n"); 
    }*/
}
pair&lt;double,double&gt;ask(int x,int l,int r,int b,int e,double k){
    if(b&lt;=l&amp;&amp;e&gt;=r){
        double ret[2]={-1e100,-1e100};
        lp(i,0,1){
            int left=0,right=int(seg[x][i].size()-1);
            while(right-left&gt;=3){
                int del=(right-left)/3;
                int mid1=left+del,mid2=mid1+del;
                if(seg[x][i][mid1].y-seg[x][i][mid1].x*k&gt;seg[x][i][mid2].y-seg[x][i][mid2].x*k)
                    right=mid2;
                else
                    left=mid1;
            }
            lp(j,left,right)ret[i]=max(ret[i],seg[x][i][j].y-seg[x][i][j].x*k);
        }
        return make_pair(ret[0],ret[1]);
    }else{
        pair&lt;double,double&gt;ret(-1e100,-1e100);
        int m=(l+r)/2;
        if(b&lt;=m){
            pair&lt;double,double&gt;t=ask(x*2,l,m,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        if(e&gt;m){
            pair&lt;double,double&gt;t=ask(x*2+1,m+1,r,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        return ret;
    }
}
void upda(pair&lt;double,double&gt;&amp;a,const pair&lt;double,double&gt;&amp;b){
    a.first=max(a.first,b.first);
    a.second=max(a.second,b.second);
}
double query(int u,int v,double k){
    pair&lt;double,double&gt;ret(-1e100,-1e100);
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
        upda(ret,ask(1,1,n,dfn[top[u]],dfn[u],k));
        u=prt[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    upda(ret,ask(1,1,n,dfn[v],dfn[u],k));
    return ret.first+ret.second;
} 
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].y);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].y);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);to[v].pb(u);
    }
    dfs1(1);
    dfs2(1,1);
    //lp(i,1,n)pf("[%d,%d,%d,%d,%d,%d]\n",dep[i],siz[i],prt[i],chd[i],dfn[i],top[i]);
    build(1,1,n);
    sf("%d",&amp;q);
    /*lp(i,1,q){
        int a,b;double c;sf("%d%d%lf",&amp;a,&amp;b,&amp;c);
        pf("[%lf,%lf]\n",ask(1,1,n,a,b,c).first, ask(1,1,n,a,b,c).second);
    }*/ 
    lp(i,1,q){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        double left=0,right=100000000;
        while(right-left&gt;1e-8){
            double mid=(left+right)/2;
            if(query(a,b,mid)&gt;-1e-8)
                left=mid;
            else
                right=mid;
        }
        pf("%.8lf\n",left);
    }
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem2402</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;complex&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
struct point{
    point(double a=0,double b=0):
        x(a),y(b){}
    double x,y;
};
inline double operator*(const point&amp;a,const point&amp;b){
    return a.x*b.y-b.x*a.y;
}
inline point operator-(const point&amp;a,const point&amp;b){
    return point(a.x-b.x,a.y-b.y);
}
inline double myabs(double a){
    return a&lt;0?-a:a;
}
inline bool operator&lt;(const point&amp;a,const point&amp;b){
    return myabs(a.x-b.x)&lt;1e-8?a.y&lt;b.y:a.x&lt;b.x;
}
int n,q,dep[30010],siz[30010],prt[30010],chd[30010],dfn[30010],top[30010],nw;
vector&lt;int&gt;to[30010];point pot[30010][2],pts[30010][2];
inline void dfs1(int u){
    siz[u]=1;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            dep[v]=dep[u]+1;
            prt[v]=u;
            dfs1(v);
            siz[u]+=siz[v];
            if(siz[v]&gt;siz[chd[u]])
                chd[u]=v;
        }
    }
}
inline void dfs2(int u,int w){
    dfn[u]=++nw;pts[nw][0]=pot[u][0];pts[nw][1]=pot[u][1];
    top[u]=w;
    if(chd[u])dfs2(chd[u],w);
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]&amp;&amp;v!=chd[u])
            dfs2(v,v);
    }
}
vector&lt;point&gt;seg[30010*4][2];
inline void build(int x,int l,int r){
    if(l==r){
        lp(i,0,1)seg[x][i].push_back(pts[l][i]);
    }else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        lp(i,0,1){
            seg[x][i].resize(seg[x*2][i].size()+seg[x*2+1][i].size());
            merge(seg[x*2][i].begin(),seg[x*2][i].end(),seg[x*2+1][i].begin(),seg[x*2+1][i].end(),seg[x][i].begin());
            vector&lt;point&gt;tmp;
            lp(j,0,int(seg[x][i].size()-1)){
                point t=seg[x][i][j];
                while(tmp.size()&gt;1){
                    point t1=tmp[tmp.size()-2],t2=tmp[tmp.size()-1];
                    if((t-t1)*(t2-t1)&lt;1e-8)
                        tmp.pop_back();
                    else
                        break;
                }
                tmp.pb(t);
            }
            seg[x][i]=tmp;
        }
    }
    /*pf("[%d,%d,%d]\n",x,l,r);
    lp(i,0,1){
        lp(j,0,int(seg[x][i].size()-1)){
            pf("(%.2lf,%.2lf)",seg[x][i][j].x,seg[x][i][j].y);
        }
        pf("\n");
    }*/
}
inline pair&lt;double,double&gt;ask(int x,int l,int r,int b,int e,double k){
    if(b&lt;=l&amp;&amp;e&gt;=r){
        double ret[2]={-1e100,-1e100};
        lp(i,0,1){
            int left=0,right=int(seg[x][i].size()-1);
            while(right-left&gt;=3){
                int del=(right-left)/3;
                int mid1=left+del,mid2=mid1+del;
                if(seg[x][i][mid1].y-seg[x][i][mid1].x*k&gt;seg[x][i][mid2].y-seg[x][i][mid2].x*k)
                    right=mid2;
                else
                    left=mid1;
            }
            lp(j,left,right)ret[i]=max(ret[i],seg[x][i][j].y-seg[x][i][j].x*k);
        }
        return make_pair(ret[0],ret[1]);
    }else{
        pair&lt;double,double&gt;ret(-1e100,-1e100);
        int m=(l+r)/2;
        if(b&lt;=m){
            pair&lt;double,double&gt;t=ask(x*2,l,m,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        if(e&gt;m){
            pair&lt;double,double&gt;t=ask(x*2+1,m+1,r,b,e,k);
            ret.first=max(ret.first,t.first);
            ret.second=max(ret.second,t.second);
        }
        return ret;
    }
}
inline void upda(pair&lt;double,double&gt;&amp;a,const pair&lt;double,double&gt;&amp;b){
    a.first=max(a.first,b.first);
    a.second=max(a.second,b.second);
}
inline double query(int u,int v,double k){
    pair&lt;double,double&gt;ret(-1e100,-1e100);
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
        upda(ret,ask(1,1,n,dfn[top[u]],dfn[u],k));
        u=prt[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    upda(ret,ask(1,1,n,dfn[v],dfn[u],k));
    return ret.first+ret.second;
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][0].y);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].x);
    lp(i,1,n)sf("%lf",&amp;pot[i][1].y);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);to[v].pb(u);
    }
    dfs1(1);
    dfs2(1,1);
    //lp(i,1,n)pf("[%d,%d,%d,%d,%d,%d]\n",dep[i],siz[i],prt[i],chd[i],dfn[i],top[i]);
    build(1,1,n);
    sf("%d",&amp;q);
    /*lp(i,1,q){
        int a,b;double c;sf("%d%d%lf",&amp;a,&amp;b,&amp;c);
        pf("[%lf,%lf]\n",ask(1,1,n,a,b,c).first, ask(1,1,n,a,b,c).second);
    }*/
    lp(i,1,q){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        double left=0,right=100000000;
        while(right-left&gt;1e-4){
            double mid=(left+right)/2;
            if(query(a,b,mid)&gt;-1e-8)
                left=mid;
            else
                right=mid;
        }
        pf("%.8lf\n",left);
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2424</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c,w;}edges[200010];int nw=1;
vector&lt;int&gt;to[1010];int vcnt;
void add(int u,int v,int c,int w){
    edge&amp;e=edges[++nw];
    e.v=v,e.c=c,e.w=w;
    to[u].push_back(nw);
}
int dis[1010],in[1010],cst;
int spfa(){
    dis[1]=0;lp(i,2,vcnt)dis[i]=~0u&gt;&gt;2;
    in[1]=1;lp(i,2,vcnt)in[i]=0;
    queue&lt;int&gt;qu;qu.push(1);
    while(!qu.empty()){
        int u=qu.front();qu.pop();in[u]=0;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=edges[to[u][i]];
            if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                dis[e.v]=dis[u]+e.w;
                if(!in[e.v]){
                    in[e.v]=1;
                    qu.push(e.v);
                }
            }
        }
    }
    return dis[vcnt]!=~0u&gt;&gt;2;
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    in[u]=1;
    int g=f;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=edges[to[u][i]];
        if(e.c&amp;&amp;!in[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t,edges[to[u][i]^1].c+=t,g-=t;
            cst+=t*e.w;
            if(!g)return f;
        }
    }
    return f-g;
}
void mcmf(){
    while(spfa()){do{lp(i,1,vcnt)in[i]=0;}while(dfs(1,~0u&gt;&gt;2));}
}
int n,m,s,uu[110],dd[110];
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;s);
    lp(i,1,n)sf("%d",&amp;uu[i]);
    lp(i,1,n)sf("%d",&amp;dd[i]);
    vcnt=2*n+2;
    lp(i,1,n)add(1,i*2,~0u&gt;&gt;2,dd[i]),add(i*2,1,0,-dd[i]);
    lp(i,1,n)add(i*2+1,2*n+2,uu[i],0),add(2*n+2,i*2+1,0,0);
    lp(i,1,n)add(i*2,i*2+1,~0u&gt;&gt;2,0),add(i*2+1,i*2,0,0);
    lp(i,1,n-1)add(i*2+1,(i+1)*2,s,m),add((i+1)*2,i*2+1,0,-m);
    mcmf();
    pf("%d\n",cst);//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2434</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; ftr[100010];
int tr[100010][26],pr[100010],fa[100010],nw=1;
void build(){
    queue&lt;int&gt; qu;
    lp(i,0,25)if(tr[1][i]){
        fa[tr[1][i]]=1,qu.push(tr[1][i]);
        ftr[1].push_back(tr[1][i]);
    }else tr[1][i]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,25)
            if(!tr[u][i])tr[u][i]=tr[fa[u]][i];
            else{
                fa[tr[u][i]]=tr[fa[u]][i],qu.push(tr[u][i]);
                ftr[tr[fa[u]][i]].push_back(tr[u][i]);
            }
    }
}
int mp[100010];
char op[100010];
int bg[100010],ed[100010],er=0;
int cnt[100010];
void dfs(int a){
    bg[a]=++er;
    lp(i,0,int(ftr[a].size())-1)
        dfs(ftr[a][i]);
    ed[a]=er;
}
int ans[100010];
vector&lt;int&gt; ques[100010],quesid[100010];
void add(int a,int d){
    for(int i=a;i&lt;=nw;i+=i&amp;-i)cnt[i]+=d;
}
int query(int a){
    int r=0;
    for(int i=a;i;i-=i&amp;-i)r+=cnt[i];
    return r;
}
int main(){
    sf("%s",op);
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')now=pr[now];
        else if(op[i]=='P')mp[++k]=now;
        else{
            if(!tr[now][op[i]-'a']){
                tr[now][op[i]-'a']=++nw;
                pr[nw]=now;
            }
            now=tr[now][op[i]-'a'];
        }
    }
    build();dfs(1);
    int m;sf("%d",&amp;m);
    lp(i,1,m){
        int x,y;sf("%d%d",&amp;x,&amp;y);
        ques[y].push_back(x);quesid[y].push_back(i);
    }
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')add(bg[now],-1),now=pr[now];
        else if(op[i]=='P'){
            ++k;
            lp(j,0,int(ques[k].size()-1)){
                int v=ques[k][j];
                ans[quesid[k][j]]=query(ed[mp[v]])-query(bg[mp[v]]-1);
            }
        }else{
            now=tr[now][op[i]-'a'];
            add(bg[now],1);
        }
    }
    lp(i,1,m)pf("%d\n",ans[i]);//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2434</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; ftr[100010];
int tr[100010][26],pr[100010],fa[100010],nw=1;
void build(){
    queue&lt;int&gt; qu;
    lp(i,0,25)if(tr[1][i]){
        fa[tr[1][i]]=1,qu.push(tr[1][i]);
        ftr[1].push_back(tr[1][i]);
    }else tr[1][i]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,25)
            if(!tr[u][i])tr[u][i]=tr[fa[u]][i];
            else{
                fa[tr[u][i]]=tr[fa[u]][i],qu.push(tr[u][i]);
                ftr[tr[fa[u]][i]].push_back(tr[u][i]);
            }
    }
}
int mp[100010];
char op[100010];
int bg[100010],ed[100010],er=0;
int cnt[100010];
void dfs(int a){
    bg[a]=++er;
    lp(i,0,int(ftr[a].size())-1)
        dfs(ftr[a][i]);
    ed[a]=er;
}
int ans[100010];
vector&lt;int&gt; ques[100010],quesid[100010];
void add(int a,int d){
    for(int i=a;i&lt;=nw;i+=i&amp;-i)cnt[i]+=d;
}
int query(int a){
    int r=0;
    for(int i=a;i;i-=i&amp;-i)r+=cnt[i];
    return r;
}
int main(){
    sf("%s",op);
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')now=pr[now];
        else if(op[i]=='P')mp[++k]=now;
        else{
            if(!tr[now][op[i]-'a']){
                tr[now][op[i]-'a']=++nw;
                pr[nw]=now;
            }
            now=tr[now][op[i]-'a'];
        }
    }
    build();dfs(1);
    int m;sf("%d",&amp;m);
    lp(i,1,m){
        int x,y;sf("%d%d",&amp;x,&amp;y);
        ques[y].push_back(x);quesid[y].push_back(i);
    }
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')add(bg[now],-1),now=pr[now];
        else if(op[i]=='P'){
            ++k;
            lp(j,0,int(ques[k].size()-1)){
                int v=ques[k][j];
                ans[quesid[k][j]]=query(ed[mp[v]])-query(bg[mp[v]]-1);
            }
        }else{
            now=tr[now][op[i]-'a'];
            add(bg[now],1);
        }
    }
    lp(i,1,m)pf("%d\n",ans[i]);//ps;
    return 0;
}</pre><pre></pre><h2>Problem2434</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
#ifndef FAST_READER_WRITER
#define FAST_READER_WRITER
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct FastReader{
        FILE*f;char*p,*e;vector&lt;char&gt;v;
        FastReader(FILE*_f):f(_f){red();}
        FastReader(string _f):f(fopen(_f.c_str(),"r")){red();}
        ~FastReader(){fclose(f);}
        void red(){
            for(int i=0,t;;++i){
                v.resize(v.size()+(1&lt;&lt;i));
                if((t=fread(&amp;v[0]+v.size()-(1&lt;&lt;i),1,1&lt;&lt;i,f))!=(1&lt;&lt;i)){
                    p=&amp;v[0],e=p+v.size()-(1&lt;&lt;i)+t;break;}}}
        void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
        int isc(){return p!=e&amp;&amp;!isspace(*p);}
        int isd(){return p!=e&amp;&amp;isdigit(*p);}
        FastReader&amp;operator&gt;&gt;(char&amp;a){ign(),a=*p++;return*this;}
        FastReader&amp;operator&gt;&gt;(char*a){
            for(ign();isc()?1:(*a=0);)*a++=*p++;return*this;}
        FastReader&amp;operator&gt;&gt;(int&amp;a){
            int n=1;if(ign(),a=0,*p=='-')n=-1,++p;
            for(;isd()?1:(a*=n,0);)a=a*10+*p++-'0';
            return*this;}
        FastReader&amp;operator&gt;&gt;(long long&amp;a){
            int n=1;if(ign(),a=0,*p=='-')n=-1,++p;
            for(;isd()?1:(a*=n,0);)a=a*10+*p++-'0';
            return*this;}
        char get(){return*p++;}};
    struct FastWriter{
        FILE*f;vector&lt;char&gt;p;
        FastWriter(FILE*_f):f(_f){}
        FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
        ~FastWriter(){(p.size()?fwrite(&amp;p[0],1,p.size(),f):0),fclose(f);}
        FastWriter&amp;operator&lt;&lt;(char a){p.push_back(a);return*this;}
        FastWriter&amp;operator&lt;&lt;(const char*a){
            while(*a)p.push_back(*a++);return*this;}
        FastWriter&amp;operator&lt;&lt;(int a){
            if(a&lt;0)p.push_back('-'),a=-a;
            static char t[10];char*q=t;
            do{int b=a/10;*q++=a-b*10+'0',a=b;}while(a);
            while(q&gt;t)p.push_back(*--q);
            return*this;}
        FastWriter&amp;operator&lt;&lt;(long long a){
            if(a&lt;0)p.push_back('-'),a=-a;
            static char t[19];char*q=t;
            do{long long b=a/10;*q++=a-b*10+'0',a=b;}while(a);
            while(q&gt;t)p.push_back(*--q);
            return*this;}};}
#endif
int ftrbg[1000010],ftrnx[1000010],fval[1000010],ftrnw;
//vector&lt;int&gt; ftr[100010];
inline void addftr(int u,int v){
    int x=++ftrnw;
    fval[x]=v;
    ftrnx[x]=ftrbg[u];
    ftrbg[u]=x;
}

int tr[100010][26],pr[100010],fa[100010],nw=1;
inline void build(){
    static int qu[1000010];int qf=1,qz=1;
    lp(i,0,25)if(tr[1][i]){
        fa[tr[1][i]]=1,qu[qz++]=tr[1][i];
        addftr(1,tr[1][i]);
       // ftr[1].push_back(tr[1][i]);
    }else tr[1][i]=1;
    while(qf!=qz){
        int u=qu[qf++];
        lp(i,0,25)
            if(!tr[u][i])tr[u][i]=tr[fa[u]][i];
            else{
                fa[tr[u][i]]=tr[fa[u]][i],qu[qz++]=tr[u][i];
                addftr(tr[fa[u]][i],tr[u][i]);
                //ftr[tr[fa[u]][i]].push_back(tr[u][i]);
            }
    }
}
int mp[100010];
char op[100010];
int bg[100010],ed[100010],er=0;
int cnt[100010];
void dfs(int a){
    bg[a]=++er;
    for(int x=ftrbg[a];x;x=ftrnx[x])
        dfs(fval[x]);
    ed[a]=er;
}
int ans[100010];
vector&lt;int&gt; ques[100010],quesid[100010];
void add(int a,int d){
    for(int i=a;i&lt;=nw;i+=i&amp;-i)cnt[i]+=d;
}
int query(int a){
    int r=0;
    for(int i=a;i;i-=i&amp;-i)r+=cnt[i];
    return r;
}
CTL::FastReader rd(stdin);
CTL::FastWriter wt(stdout);
int main(){
    rd&gt;&gt;op;
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')now=pr[now];
        else if(op[i]=='P')mp[++k]=now;
        else{
            if(!tr[now][op[i]-'a']){
                tr[now][op[i]-'a']=++nw;
                pr[nw]=now;
            }
            now=tr[now][op[i]-'a'];
        }
    }
    build();dfs(1);
    int m;rd&gt;&gt;m;
    lp(i,1,m){
        int x,y;rd&gt;&gt;x&gt;&gt;y;
        ques[y].push_back(x);quesid[y].push_back(i);
    }
    for(int k=0,i=0,now=1;op[i];++i){
        if(op[i]=='B')add(bg[now],-1),now=pr[now];
        else if(op[i]=='P'){
            ++k;
            lp(j,0,int(ques[k].size()-1)){
                int v=ques[k][j];
                ans[quesid[k][j]]=query(ed[mp[v]])-query(bg[mp[v]]-1);
            }
        }else{
            now=tr[now][op[i]-'a'];
            add(bg[now],1);
        }
    }
    lp(i,1,m)wt&lt;&lt;ans[i]&lt;&lt;'\n';
    return 0;
}
</pre><pre></pre><h2>Problem2435</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr(a,b,c) freopen(a,b,c)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int mx=2000000;
int to[mx+10],wei[mx+10],nx[mx+10],nw=1;
int bg[mx+10];int siz[mx+10];int n;
void add(int u,int v,int w){to[++nw]=v;wei[nw]=w;nx[nw]=bg[u];bg[u]=nw;}
int st[mx+10],tmp[mx+10],pr[mx+10],pw[mx+10];
int main(){
	//fr("data.in","r",stdin);
	//fr("hehe.out","w",stdout);
	sf("%d",&amp;n);
	lp(i,1,n-1){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
	}
	pr[1]=0;
	queue&lt;int&gt; qu;qu.push(1);st[1]=1;
	while(!qu.empty()){
		int u=qu.front();qu.pop();
		tmp[++tmp[0]]=u;
		for(int i=bg[u];i;i=nx[i])if(!st[to[i]])qu.push(to[i]),st[to[i]]=1,pr[to[i]]=u,pw[to[i]]=wei[i];
	}
	long long ans=0;
	lp(i,1,n)siz[i]=1;
	for(int i=tmp[0];i;--i){
		if(pr[tmp[i]]!=0){
			siz[pr[tmp[i]]]+=siz[tmp[i]];
			ans+=((long long)abs(siz[tmp[i]]-(n-siz[tmp[i]])))*pw[tmp[i]];
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2453</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace bit{
    int db[10010];
    void add(int i,int d){
        for(;i&lt;=10000;i+=i&amp;-i)db[i]+=d;
    }
    int ask(int i){
        int r=0;
        for(;i;i-=i&amp;-i)r+=db[i];
        return r;
    }
}
/*
用整体二分法离线解决区间值排名问题
*/
namespace rank{
    struct query{
        int t;//1:add 2:del 3:ask
        int i,v;
        int l,r,c,w;
    };
    vector&lt;int&gt;as;
    vector&lt;query&gt;qs;
    void add(int i,int v){
        //pf("[add %d,%d]\n",i,v);
        query t;t.t=1;t.i=i;t.v=v;
        qs.push_back(t);
    }
    void del(int i,int v){
        //pf("[del %d,%d]\n",i,v);
        query t;t.t=2;t.i=i;t.v=v;
        qs.push_back(t);
    }
    void ask(int l,int r,int v){
        //pf("[ask %d,%d,%d]\n",l,r,v);
        query t;t.t=3;t.l=l;t.r=r;
        t.c=0;t.v=v;t.w=as.size();
        as.push_back(0);
        qs.push_back(t);
    }
    void work(int ql,int qr,int vl,int vr){
        if(ql&lt;=qr){
            if(vl==vr){
                lp(i,ql,qr)
                    if(qs[i].t==3)
                        as[qs[i].w]=qs[i].c;
            }else{
                int vm=vl+(vr-vl)/2;
                lp(i,ql,qr)
                    if(qs[i].t==1&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,1);
                    else if(qs[i].t==2&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,-1);
                    else if(qs[i].t==3&amp;&amp;qs[i].v&gt;vm)
                        qs[i].c+=bit::ask(qs[i].r)-bit::ask(qs[i].l-1);
                lp(i,ql,qr)
                    if(qs[i].t==1&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,-1);
                    else if(qs[i].t==2&amp;&amp;qs[i].v&lt;=vm)
                        bit::add(qs[i].i,1);
                vector&lt;query&gt;lq,rq;//方便起见写成O(nlgu)的空间复杂度
                lp(i,ql,qr)
                    if(qs[i].v&lt;=vm)lq.push_back(qs[i]);
                    else rq.push_back(qs[i]);
                lp(i,0,int(lq.size()-1))
                    qs[ql+i]=lq[i];
                lp(i,0,int(rq.size()-1))
                    qs[ql+i+lq.size()]=rq[i];
                work(ql,ql+int(lq.size()-1),vl,vm);
                work(ql+lq.size(),qr,vm+1,vr);
            }
        }
    }
    void solve(){
        work(0,int(qs.size()-1),0,10000);
    }
}
set&lt;int&gt;pos[1000010];int n,m,col[10010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;col[i]);
    lp(i,1,n){
        int np;
        if(pos[col[i]].empty())np=0;
        else np=*(pos[col[i]].rbegin());
        rank::add(i,np);
        pos[col[i]].insert(i);
    }
    lp(i,1,m){
        char op[11];int u,v;
        sf("%s%d%d",op,&amp;u,&amp;v);
        if(op[0]=='Q'){
            rank::ask(u,v,u);
        }else{
            set&lt;int&gt;::iterator it=pos[col[u]].lower_bound(u),rt=it;++rt;
            if(it==pos[col[u]].begin())
                rank::del(u,0);
            else{
                set&lt;int&gt;::iterator t=it;--t;
                rank::del(u,*t);
            }
            if(rt!=pos[col[u]].end()){
                int np;
                if(it==pos[col[u]].begin())np=0;
                else{
                    set&lt;int&gt;::iterator t=it;--t;
                    np=*t;
                }
                rank::del(*rt,u);
                rank::add(*rt,np);
            }
            pos[col[u]].erase(u);
            col[u]=v;
            pos[col[u]].insert(u);
            it=pos[col[u]].lower_bound(u),rt=it;++rt;
            if(it==pos[col[u]].begin())
                rank::add(u,0);
            else{
                set&lt;int&gt;::iterator t=it;--t;
                rank::add(u,*t);
            }
            if(rt!=pos[col[u]].end()){
                int np;
                if(it==pos[col[u]].begin())np=0;
                else{
                    set&lt;int&gt;::iterator t=it;--t;
                    np=*t;
                }
                rank::del(*rt,np);
                rank::add(*rt,u);
            }
        }
    }
    rank::solve();
    lp(i,0,int(rank::as.size()-1))
        pf("%d\n",rank::as[i]);
    //ps;
    return 0;
} </pre><pre></pre><h2>Problem2456</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int main(){
    int u=-1,v=0,n;
    sf("%d",&amp;n);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        if(u==-1)u=t,v=1;
        else if(u==t)++v;
        else{--v;if(v==0)u=-1;}
    } 
    pf("%d\n",u);
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem2458</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cmath&gt;
struct point{
	int x,y;
}px[200010],py[200010];
int n;
double ans=1e100;
inline double sqr(double a){
	return a*a;
}
inline double operator*(point a,point b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
inline bool cmpx(point a,point b){
	return a.x&lt;b.x;
}
inline bool cmpy(point a,point b){
	return a.y&lt;b.y;
}
int tabs(int a){
	return a&gt;0?a:-a;
}
void solve(int l,int r){
	if(l!=r){
		int m=(l+r)/2;
		solve(l,m);
		solve(m+1,r);
		inplace_merge(py+l,py+m+1,py+r+1,cmpy);
		int tx=px[m].x;
		vector&lt;point&gt;tmp;
		lp(i,l,r)if(tabs(tx-py[i].x)&lt;ans/2)tmp.pb(py[i]);
		/*vp(i,tmp){
			pf("[%d,%d]",tmp[i].x,tmp[i].y);
		}
		pf("\n");*/
		vp(i,tmp){
			for(int j=i-1;j&gt;=0&amp;&amp;tabs(tmp[j].y-tmp[i].y)&lt;ans/2;--j){
				for(int k=i+1;k&lt;tmp.size()&amp;&amp;tabs(tmp[k].y-tmp[i].y)&lt;ans/2;++k){
					ans=min(ans,tmp[i]*tmp[j]+tmp[i]*tmp[k]+tmp[j]*tmp[k]);
					//pf("[%d,%d,%d,%.6lf]\n",i,j,k,ans);
				}
			}
		}
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d%d",&amp;px[i].x,&amp;px[i].y);
	sort(px+1,px+n+1,cmpx);
	lp(i,1,n)py[i]=px[i];
	solve(1,n);
	pf("%.6lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2460</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace gauss{
    const int nmx=1000;
    long long a[nmx+10];int n;
    void solve(){
        int k=0;
        rp(i,63,0){
            int j=k+1;
            while(j&lt;=n&amp;&amp;!((a[j]&gt;&gt;i)&amp;1))++j;
            if(j&lt;=n){
                swap(a[++k],a[j]);
                for(j=1;j&lt;=n;++j)
                    if(j!=k&amp;&amp;((a[j]&gt;&gt;i)&amp;1))
                        a[j]^=a[k];
            }
        }
    }
}
bool check(vector&lt;long long&gt;a){
    gauss::n=a.size();
    lp(i,0,int(a.size()-1))gauss::a[i+1]=a[i];
    gauss::solve();
    return gauss::a[gauss::n]!=0;
}
int main(){
    int n;sf("%d",&amp;n);int ans=0;
    vector&lt;pair&lt;int,long long&gt; &gt;tmp;
    lp(i,1,n){
        int v;long long u;sf("%lld%d",&amp;u,&amp;v);
        tmp.push_back(make_pair(v,u));
    }
    sort(tmp.begin(),tmp.end());
    vector&lt;long long&gt;a;
    rp(i,int(tmp.size()-1),0){
        a.push_back(tmp[i].second);
        if(check(a)){
            ans+=tmp[i].first;
        }else a.pop_back();
    }
    pf("%d\n",ans); 
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2462</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int main(){
	int m,n,a,b;
	sf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b);
	static char buff[1000010];
	lp(i,1,m)sf("%s",buff);
	int q;sf("%d",&amp;q);
	lp(i,1,q)pf("1\n");
	return 0;
}</pre><pre></pre><h2>Problem2463</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
int main(){
    int n;while(sf("%d",&amp;n),n)pf("%s\n",n%2?"Bob":"Alice");
    return 0;
}
</pre><pre></pre><h2>Problem2482</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
struct node{
	node(int a,int b):l(a),r(b),mx(0),emx(0),del(0),edel(0){ch[0]=ch[1]=0;}
	int l,r;ll mx,emx,del,edel;node*ch[2];
};
void down(node*x){
	x-&gt;emx=max(x-&gt;emx,x-&gt;mx+x-&gt;edel);
	x-&gt;mx+=x-&gt;del;
	lp(i,0,1)if(x-&gt;ch[i]){
		x-&gt;ch[i]-&gt;edel=max(x-&gt;ch[i]-&gt;edel,x-&gt;ch[i]-&gt;del+x-&gt;edel);
		x-&gt;ch[i]-&gt;del+=x-&gt;del;
	}
	x-&gt;del=0;
	x-&gt;edel=0;
}
void update(node*x){
	lp(i,0,1)down(x-&gt;ch[i]);
	x-&gt;mx=max(x-&gt;ch[0]-&gt;mx,x-&gt;ch[1]-&gt;mx);
	x-&gt;emx=max(x-&gt;ch[0]-&gt;emx,x-&gt;ch[1]-&gt;emx);
}
node*build(int l,int r){
	node*ret=new node(l,r);
	if(l!=r){
		int m=(l+r)/2;
		ret-&gt;ch[0]=build(l,m);
		ret-&gt;ch[1]=build(m+1,r);
	}
	return ret;
}
ll query(node*x,int l,int r){
	down(x);
	if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return x-&gt;emx;
	else{
		ll ret=0;
		if(l&lt;=x-&gt;ch[0]-&gt;r)ret=max(ret,query(x-&gt;ch[0],l,r));
		if(r&gt;x-&gt;ch[0]-&gt;r)ret=max(ret,query(x-&gt;ch[1],l,r));
		return ret;
	}
}
void modify(node*x,int l,int r,ll d){
	down(x);
	if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)x-&gt;del=d,x-&gt;edel=max(0ll,d);
	else{
		if(l&lt;=x-&gt;ch[0]-&gt;r)modify(x-&gt;ch[0],l,r,d);
		if(r&gt;x-&gt;ch[0]-&gt;r)modify(x-&gt;ch[1],l,r,d);
		update(x);
	}
}
int n,m,a[100010];ll ans[100010];
vector&lt;int&gt;lft[100010],idx[100010];
int main(){
	sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]);
	sf("%d",&amp;m);lp(i,1,m){int l,r;sf("%d%d",&amp;l,&amp;r);lft[r].pb(l);idx[r].pb(i);}
	map&lt;int,int&gt;pre;node*rt=build(1,n);
	lp(i,1,n){
		modify(rt,pre[a[i]]+1,i,a[i]);
		vp(j,lft[i]){
			ans[idx[i][j]]=query(rt,lft[i][j],i);
		}
		pre[a[i]]=i;
	}
	lp(i,1,m)pf("%lld\n",ans[i]);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem2482</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
struct node{
	node(int a,int b):l(a),r(b),mx(0),emx(0),del(0),edel(0){ch[0]=ch[1]=0;}
	int l,r;ll mx,emx,del,edel;node*ch[2];
};
inline void down(node*x){
	x-&gt;emx=max(x-&gt;emx,x-&gt;mx+x-&gt;edel);
	x-&gt;mx+=x-&gt;del;
	lp(i,0,1)if(x-&gt;ch[i]){
		x-&gt;ch[i]-&gt;edel=max(x-&gt;ch[i]-&gt;edel,x-&gt;ch[i]-&gt;del+x-&gt;edel);
		x-&gt;ch[i]-&gt;del+=x-&gt;del;
	}
	x-&gt;del=0;
	x-&gt;edel=0;
}
inline void update(node*x){
	lp(i,0,1)down(x-&gt;ch[i]);
	x-&gt;mx=max(x-&gt;ch[0]-&gt;mx,x-&gt;ch[1]-&gt;mx);
	x-&gt;emx=max(x-&gt;ch[0]-&gt;emx,x-&gt;ch[1]-&gt;emx);
}
inline node*build(int l,int r){
	node*ret=new node(l,r);
	if(l!=r){
		int m=(l+r)/2;
		ret-&gt;ch[0]=build(l,m);
		ret-&gt;ch[1]=build(m+1,r);
	}
	return ret;
}
inline ll query(node*x,int l,int r){
	down(x);
	if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return x-&gt;emx;
	else{
		ll ret=0;
		if(l&lt;=x-&gt;ch[0]-&gt;r)ret=max(ret,query(x-&gt;ch[0],l,r));
		if(r&gt;x-&gt;ch[0]-&gt;r)ret=max(ret,query(x-&gt;ch[1],l,r));
		return ret;
	}
}
inline void modify(node*x,int l,int r,ll d){
	down(x);
	if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)x-&gt;del=d,x-&gt;edel=max(0ll,d);
	else{
		if(l&lt;=x-&gt;ch[0]-&gt;r)modify(x-&gt;ch[0],l,r,d);
		if(r&gt;x-&gt;ch[0]-&gt;r)modify(x-&gt;ch[1],l,r,d);
		update(x);
	}
}
int n,m,a[100010];ll ans[100010];
vector&lt;int&gt;lft[100010],idx[100010];
int main(){
	sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]);
	sf("%d",&amp;m);lp(i,1,m){int l,r;sf("%d%d",&amp;l,&amp;r);lft[r].pb(l);idx[r].pb(i);}
	map&lt;int,int&gt;pre;node*rt=build(1,n);
	lp(i,1,n){
		modify(rt,pre[a[i]]+1,i,a[i]);
		vp(j,lft[i]){
			ans[idx[i][j]]=query(rt,lft[i][j],i);
		}
		pre[a[i]]=i;
	}
	lp(i,1,m)pf("%lld\n",ans[i]);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem2482</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
const int N=100010;
ll mx[N*4],emx[N*4],del[N*4],edel[N*4];
inline void down(int x,int l,int r){
	emx[x]=max(emx[x],mx[x]+edel[x]);
	mx[x]+=del[x];
	if(l!=r){
		edel[x*2]=max(edel[x*2],del[x*2]+edel[x]);
		del[x*2]+=del[x];
		edel[x*2+1]=max(edel[x*2+1],del[x*2+1]+edel[x]);
		del[x*2+1]+=del[x];
	}
	del[x]=edel[x]=0;
}
inline void update(int x,int l,int r){
	int m=(l+r)/2;
	down(x*2,l,m);down(x*2+1,m+1,r);
	mx[x]=max(mx[x*2],mx[x*2+1]);
	emx[x]=max(emx[x*2],emx[x*2+1]);
}
inline ll query(int x,int l,int r,int b,int e){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)return emx[x];
	else{
		ll ret=0;int m=(l+r)/2;
		if(b&lt;=m)ret=max(ret,query(x*2,l,m,b,e));
		if(e&gt;m)ret=max(ret,query(x*2+1,m+1,r,b,e));
		return ret;
	}
}
inline void modify(int x,int l,int r,int b,int e,ll d){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)del[x]=d,edel[x]=max(0ll,d);
	else{
		int m=(l+r)/2;
		if(b&lt;=m)modify(x*2,l,m,b,e,d);
		if(e&gt;m)modify(x*2+1,m+1,r,b,e,d);
		update(x,l,r);
	}
}
int n,m,a[100010];ll ans[100010];
vector&lt;int&gt;lft[100010],idx[100010];
int main(){
	sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]);
	sf("%d",&amp;m);lp(i,1,m){int l,r;sf("%d%d",&amp;l,&amp;r);lft[r].pb(l);idx[r].pb(i);}
	map&lt;int,int&gt;pre;
	lp(i,1,n){
		modify(1,1,n,pre[a[i]]+1,i,a[i]);
		vp(j,lft[i]){
			ans[idx[i][j]]=query(1,1,n,lft[i][j],i);
		}
		pre[a[i]]=i;
	}
	lp(i,1,m)pf("%lld\n",ans[i]);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem2482</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
#define N 400010
ll t0[N],emx[N],del[N],edel[N];
void down(int x,int l,int r){
	emx[x]=max(emx[x],t0[x]+edel[x]);
	t0[x]+=del[x];
	if(l!=r){
		edel[x*2]=max(edel[x*2],del[x*2]+edel[x]);
		del[x*2]+=del[x];
		edel[x*2+1]=max(edel[x*2+1],del[x*2+1]+edel[x]);
		del[x*2+1]+=del[x];
	}
	del[x]=edel[x]=0;
}
void update(int x,int l,int r){
	int m=(l+r)/2;
	down(x*2,l,m);down(x*2+1,m+1,r);
	t0[x]=max(t0[x*2],t0[x*2+1]);
	emx[x]=max(emx[x*2],emx[x*2+1]);
}
ll query(int x,int l,int r,int b,int e){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)return emx[x];
	else{
		ll ret=0;int m=(l+r)/2;
		if(b&lt;=m)ret=max(ret,query(x*2,l,m,b,e));
		if(e&gt;m)ret=max(ret,query(x*2+1,m+1,r,b,e));
		return ret;
	}
}
void modify(int x,int l,int r,int b,int e,ll d){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)del[x]=d,edel[x]=max(0ll,d);
	else{
		int m=(l+r)/2;
		if(b&lt;=m)modify(x*2,l,m,b,e,d);
		if(e&gt;m)modify(x*2+1,m+1,r,b,e,d);
		update(x,l,r);
	}
}
int n,m,a[100010];ll ans[100010];
vector&lt;int&gt;lft[100010],idx[100010];
int main(){
	sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]);
	sf("%d",&amp;m);lp(i,1,m){int l,r;sf("%d%d",&amp;l,&amp;r);lft[r].pb(l);idx[r].pb(i);}
	map&lt;int,int&gt;pre;
	lp(i,1,n){
		modify(1,1,n,pre[a[i]]+1,i,a[i]);
		vp(j,lft[i]){
			ans[idx[i][j]]=query(1,1,n,lft[i][j],i);
		}
		pre[a[i]]=i;
	}
	lp(i,1,m)pf("%lld\n",ans[i]);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem2482</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
#define N 400010
ll t0[N],t1[N],del[N],edel[N];
void down(int x,int l,int r){
	t1[x]=max(t1[x],t0[x]+edel[x]);
	t0[x]+=del[x];
	if(l!=r){
		edel[x*2]=max(edel[x*2],del[x*2]+edel[x]);
		del[x*2]+=del[x];
		edel[x*2+1]=max(edel[x*2+1],del[x*2+1]+edel[x]);
		del[x*2+1]+=del[x];
	}
	del[x]=edel[x]=0;
}
void update(int x,int l,int r){
	int m=(l+r)/2;
	down(x*2,l,m);down(x*2+1,m+1,r);
	t0[x]=max(t0[x*2],t0[x*2+1]);
	t1[x]=max(t1[x*2],t1[x*2+1]);
}
ll query(int x,int l,int r,int b,int e){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)return t1[x];
	else{
		ll ret=0;int m=(l+r)/2;
		if(b&lt;=m)ret=max(ret,query(x*2,l,m,b,e));
		if(e&gt;m)ret=max(ret,query(x*2+1,m+1,r,b,e));
		return ret;
	}
}
void modify(int x,int l,int r,int b,int e,ll d){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)del[x]=d,edel[x]=max(0ll,d);
	else{
		int m=(l+r)/2;
		if(b&lt;=m)modify(x*2,l,m,b,e,d);
		if(e&gt;m)modify(x*2+1,m+1,r,b,e,d);
		update(x,l,r);
	}
}
int n,m,a[N];ll ans[N];
vector&lt;int&gt;lft[N],idx[N];
int main(){
	sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]);
	sf("%d",&amp;m);lp(i,1,m){int l,r;sf("%d%d",&amp;l,&amp;r);lft[r].pb(l);idx[r].pb(i);}
	map&lt;int,int&gt;pre;
	lp(i,1,n){
		modify(1,1,n,pre[a[i]]+1,i,a[i]);
		vp(j,lft[i]){
			ans[idx[i][j]]=query(1,1,n,lft[i][j],i);
		}
		pre[a[i]]=i;
	}
	lp(i,1,m)pf("%lld\n",ans[i]);
	return 0;
}</pre><pre></pre><h2>Problem2521</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace isap{
    struct edge{
        int v,c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[50010];
    void add(int u,int v,int c){
        edge t;t.v=v;t.c=c;
        to[u].push_back(eg.size());eg.push_back(t);
        //pf("[%d,%d,%d]\n",u,v,c);
    }
    int dis[50010],vcnt,st,et;
    int dfs(int u,int f){
        if(u==et)return f;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(e.c,g));
                e.c-=t,ev.c+=t,g-=t;
                if(!g)return f; 
            }
        }
        ++dis[u];
        return f-g;
    }
    int isap(){
        int r=0;
        while(dis[st]&lt;vcnt)r+=dfs(st,~0u&gt;&gt;1);
        return r;
    }
}
struct edge2{
    int u,v,w;
};
vector&lt;edge2&gt;eg2;edge2 to;
int main(){
    int n,m,k;
    sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m){
        int u,v,w;
        sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        edge2 t;t.u=u;t.v=v;t.w=w;
        if(i==k)to=t;
        else eg2.push_back(t);
    }
    isap::vcnt=n;isap::st=to.u;isap::et=to.v;
    lp(i,0,int(eg2.size()-1)){
        int u=eg2[i].u,v=eg2[i].v,w=eg2[i].w;
        if(w&lt;=to.w)
            isap::add(u,v,to.w-w+1),
            isap::add(v,u,to.w-w+1);
    }
    pf("%d\n",isap::isap());
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
ll p1=1000000007,p2=1000000009;
ll pw1[100010],pw2[100010];
ll hs1[100010],hs2[100010];
pair&lt;ll,ll&gt; calc(ll i,ll j){
	ll t1=(hs1[j]-hs1[i-1]*pw1[j-i+1]%p1+p1)%p1;
	ll t2=(hs2[j]-hs2[i-1]*pw2[j-i+1]%p2+p2)%p2;
	return mp(t1,t2);
}
int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=(left+right)/2;
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=pw1[i-1]*27%p1;
	pw2[0]=1;
	lp(i,1,N*2)pw2[i]=pw2[i-1]*27%p2;
	lp(i,1,N*2)hs1[i]=(hs1[i-1]*27+S[i]-'a')%p1;
	lp(i,1,N*2)hs2[i]=(hs2[i-1]*27+S[i]-'a')%p2;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
ll p1=1000000007,p2=1000000009;
ll pw1[100010],pw2[100010];
ll hs1[100010],hs2[100010];
pair&lt;ll,ll&gt; calc(ll i,ll j){
	ll t1=(hs1[j]-hs1[i-1]*pw1[j-i+1]%p1+p1)%p1;
	return mp(t1,0);
}
int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=(left+right)/2;
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=pw1[i-1]*27%p1;
	pw2[0]=1;
	lp(i,1,N*2)pw2[i]=pw2[i-1]*27%p2;
	lp(i,1,N*2)hs1[i]=(hs1[i-1]*27+S[i]-'a')%p1;
	lp(i,1,N*2)hs2[i]=(hs2[i-1]*27+S[i]-'a')%p2;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
ll p1=1000000007,p2=1000000009;
ll pw1[100010],pw2[100010];
ll hs1[100010],hs2[100010];
pair&lt;ll,ll&gt; calc(ll i,ll j){
	ll t1=hs1[j]-hs1[i-1]*pw1[j-i+1]%p1+p1;
	if(t1&gt;=p1)t1-=p1;
	return mp(t1,0);
}
int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=(left+right)/2;
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=pw1[i-1]*27%p1;
	pw2[0]=1;
	lp(i,1,N*2)pw2[i]=pw2[i-1]*27%p2;
	lp(i,1,N*2)hs1[i]=(hs1[i-1]*27+S[i]-'a')%p1;
	lp(i,1,N*2)hs2[i]=(hs2[i-1]*27+S[i]-'a')%p2;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
int p1=1000000007,p2=1000000009;
int pw1[100010],pw2[100010];
int hs1[100010],hs2[100010];
pair&lt;int,int&gt; calc(int i,int j){
	int t1=hs1[j]-ll(hs1[i-1])*pw1[j-i+1]%p1+p1;
	if(t1&gt;=p1)t1-=p1;
	return mp(t1,0);
}
int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=(left+right)/2;
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=ll(pw1[i-1])*27%p1;
	pw2[0]=1;
	lp(i,1,N*2)pw2[i]=ll(pw2[i-1])*27%p2;
	lp(i,1,N*2)hs1[i]=(ll(hs1[i-1])*27+S[i]-'a')%p1;
	lp(i,1,N*2)hs2[i]=(ll(hs2[i-1])*27+S[i]-'a')%p2;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
int p1=1000000007,p2=1000000009;
int pw1[100010],pw2[100010];
int hs1[100010],hs2[100010];
inline int calc(int i,int j){
	int t1=hs1[j]-ll(hs1[i-1])*pw1[j-i+1]%p1+p1;
	if(t1&gt;=p1)t1-=p1;
	return t1;
}
inline int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=(left+right)/2;
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=ll(pw1[i-1])*27%p1;
	lp(i,1,N*2)hs1[i]=(ll(hs1[i-1])*27+S[i]-'a')%p1;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char S[100010];int N,L;
int p1=1000000007,p2=1000000009;
int pw1[100010],pw2[100010];
int hs1[100010],hs2[100010];
inline int calc(int i,int j){
	int t1=hs1[j]-ll(hs1[i-1])*pw1[j-i+1]%p1+p1;
	if(t1&gt;=p1)t1-=p1;
	return t1;
}
inline int lcp(int i,int j){
	if(i&gt;N*2||j&gt;N*2)return 0;
	int left=0,right=min(2*N-i,2*N-j);
	if(i&lt;=N&amp;&amp;j&lt;=N)right=min(N-i,N-j);
	if(calc(i,i+right)==calc(j,j+right))return right+1;
	if(calc(i,i+left)!=calc(j,j+left))return 0;
	while(left+1&lt;right){
		int mid=((left+right)&gt;&gt;1);
		if(calc(i,i+mid)==calc(j,j+mid))
			left=mid;
		else
			right=mid;
	}
	return left+1;
}
ll ans=0;
int main(){
	sf("%d",&amp;L);
	sf("%s",S+1);N=strlen(S+1);
	lp(i,1,N)S[N+i]=S[N-i+1];
	pw1[0]=1;
	lp(i,1,N*2)pw1[i]=ll(pw1[i-1])*27%p1;
	lp(i,1,N*2)hs1[i]=(ll(hs1[i-1])*27+S[i]-'a')%p1;
	lp(i,1,N){
		for(int j=1;j&lt;=N&amp;&amp;j+i+L&lt;=N;j+=i){
			int u=j,v=j+i+L;
			int t1=min(lcp(u,v),i);
			int t2=min(lcp(2*N-u+2,2*N-v+2),i-1);
			ans+=max(t1+t2-i+1,0);
		}
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int M,N,K,T;
int Qx[110],Qy[110],Bx[110],By[110],Tx,Ty;
int Tgx[110],Tgy[110],Tgr[110];
int Hei[110][110];
int Dp[110][110][110][3];//1Q2B
void init(){
    sf("%d%d%d%d",&amp;M,&amp;N,&amp;K,&amp;T);
    lp(i,1,K)sf("%d%d",&amp;Bx[i],&amp;By[i]);
    lp(i,1,K)sf("%d%d",&amp;Qx[i],&amp;Qy[i]);
    sf("%d%d",&amp;Tx,&amp;Ty);
    lp(i,1,T)sf("%d%d%d",&amp;Tgx[i],&amp;Tgy[i],&amp;Tgr[i]);
    lp(i,1,M)lp(j,1,N)sf("%d",&amp;Hei[i][j]);
}
struct node{
    node(int a,int b,int c):
        x(a),y(b),z(c){}
    int x,y,z;
};
bool operator&lt;(node a,node b){
    return a.z&lt;b.z;
}
int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
void mkdp(){
    lp(tg,1,T){
        priority_queue&lt;pair&lt;int,node&gt; &gt;qu;
        lp(i,1,M)lp(j,1,N)Dp[tg][i][j][1]=Dp[tg][i][j][2]=~0u&gt;&gt;1;
        Dp[tg][Tgx[tg]][Tgy[tg]][1]=Dp[tg][Tgx[tg]][Tgy[tg]][2]=0;
        qu.push(make_pair(-0,node(Tgx[tg],Tgy[tg],1)));
        qu.push(make_pair(-0,node(Tgx[tg],Tgy[tg],2)));
        while(!qu.empty()){
            int d=-qu.top().first;
            int x=qu.top().second.x;
            int y=qu.top().second.y;
            int z=qu.top().second.z;
            qu.pop();if(Dp[tg][x][y][z]!=d)continue;
            lp(i,0,3){
                int xt=x+dir[i][0],yt=y+dir[i][1];
                if(xt&gt;M||xt&lt;1||yt&gt;N||yt&lt;1)continue;
                if(z==1){
                    if(Hei[xt][yt]&gt;=Hei[x][y]&amp;&amp;Dp[tg][xt][yt][1]&gt;Dp[tg][x][y][1])
                        Dp[tg][xt][yt][1]=Dp[tg][x][y][1],
                        qu.push(make_pair(-Dp[tg][xt][yt][1],node(xt,yt,1)));
                    if(Hei[xt][yt]&gt;=Hei[x][y]&amp;&amp;Dp[tg][xt][yt][2]&gt;Dp[tg][x][y][1]+1)
                        Dp[tg][xt][yt][2]=Dp[tg][x][y][1]+1,
                        qu.push(make_pair(-Dp[tg][xt][yt][2],node(xt,yt,2)));
                }else{
                    if(Hei[xt][yt]&lt;=Hei[x][y]&amp;&amp;Dp[tg][xt][yt][2]&gt;Dp[tg][x][y][2])
                        Dp[tg][xt][yt][2]=Dp[tg][x][y][2],
                        qu.push(make_pair(-Dp[tg][xt][yt][2],node(xt,yt,2)));
                    if(Hei[xt][yt]&lt;=Hei[x][y]&amp;&amp;Dp[tg][xt][yt][1]&gt;Dp[tg][x][y][2]+1)
                        Dp[tg][xt][yt][1]=Dp[tg][x][y][2]+1,
                        qu.push(make_pair(-Dp[tg][xt][yt][1],node(xt,yt,1)));
                }
            } 
        }
        /*lp(i,1,8)pf("-");pf("\n");
        lp(i,1,M){
            lp(j,1,N)pf("[%d]",Dp[tg][i][j][1]);
            pf("\n");
        }
        pf("\n");
        lp(i,1,M){
            lp(j,1,N)pf("[%d]",Dp[tg][i][j][2]);
            pf("\n");
        }
        lp(i,1,8)pf("-");pf("\n");*/
    }
}
struct edge{
    edge(){}
    edge(int a,int b):
        v(a),c(b){}
    int v,c;
}edges[100010];//lazy....
vector&lt;int&gt;bg[1010];
int nw,vcnt;
void add(int u,int v,int c){
    edge&amp;e=edges[++nw];
    e.v=v;e.c=c;
    bg[u].push_back(nw);
}
//S 1
//Q 2~K+1  i+1
//B K+2,2*K+1 K+1+i
//Target 2*K+2,2*K+1+T 2*K+1+i
//T 2*K+T+2
int dis[1010];
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        edge&amp;ev=edges[bg[u][i]^1];
        if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,ev.c+=t;
            if(!g)return f;
        }
    }
    ++dis[u];
    return f-g;
}
int isap(){
    lp(i,1,vcnt)dis[i]=0;
    int r=0;
    while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
    return r;
}
bool check(int x){
    nw=1;vcnt=2+2*K+T;
    lp(i,1,vcnt)bg[i].clear();
    lp(i,1,K)add(1,i+1,1),add(i+1,1,0);
    lp(i,1,K)add(1,K+i+1,1),add(K+i+1,1,0);
    lp(i,1,T)add(2*K+1+i,2*K+T+2,Tgr[i]),
        add(2*K+T+2,2*K+1+i,0);
    lp(i,1,K)lp(j,1,T)if(Dp[j][Qx[i]][Qy[i]][1]&lt;=x)
        add(i+1,2*K+1+j,~0u&gt;&gt;1),
        add(2*K+1+j,i+1,0);//pf("[%d,%d,%d]",x,i,j);
    lp(i,1,K)lp(j,1,T)if(Dp[j][Bx[i]][By[i]][2]&lt;=x)
        add(K+1+i,2*K+1+j,~0u&gt;&gt;1),
        add(2*K+1+j,K+1+i,0);
    return isap()+x&gt;=2*K;
}
void solve(){
    int l=-1,r=2*K;
    while(l+1&lt;r){
        int m=(l+r)/2;
        if(check(m))r=m;
        else l=m; 
    } 
    pf("%d\n",r); 
}
int main(){
    init();
    mkdp();
    solve();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2555</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace sam{
    int pr[600010*2],tr[600010*2][26],ln[600010*2],cnt[600010*2],nw=1,lst=1;
    void add(int c){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];cnt[nq]=cnt[q];
                lp(i,0,25)tr[nq][i]=tr[q][i];
                pr[q]=pr[np]=nq;
                //pr[q]=pr[p]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq; 
            }
        }
        for(;np;np=pr[np])++cnt[np];
        //for(;p;p=pr[p])++cnt[p];
    }
}
char str[3000010];int len,msk=0;
void getstr(){sf("%s",str+1);len=strlen(str+1);} 
void demark(){
    int t=msk;
    lp(i,1,len){
        msk=(msk*131+i-1)%len;
        swap(str[i],str[msk+1]);
    }
    msk=t;
}
int main(){
    int q;sf("%d",&amp;q);
    getstr();lp(i,1,len)sam::add(str[i]-'A');
    lp(i,1,q){
        char op[110];sf("%s",op);getstr();demark();
        if(op[0]=='A'){
            lp(i,1,len)sam::add(str[i]-'A');
        }else{
            int s=1,f=1;
            lp(i,1,len){
                int c=str[i]-'A';
                //if(!sam::tr[s][c]){f=0;break;}
                if(!sam::tr[s][c]){f=0;break;}
                else s=sam::tr[s][c];
            }
            if(!f)pf("0\n");
            else pf("%d\n",sam::cnt[s]),msk^=sam::cnt[s]; 
        }
    } 
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2555</h2><pre>#ifndef SUFFIX_BALANCED_TREE
#define SUFFIX_BALANCED_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct SuffixBalancedTree{
        struct node{
            node*c[2],*p;int v,f,s;double t;
            node(node*_p,int _v):
                f(rand()*1.0/RAND_MAX*1e9),
                p(_p),v(_v),s(1),t(5e8){c[0]=c[1]=0;}}*root;
        SuffixBalancedTree():root(new node(0,-1)){}
        ~SuffixBalancedTree(){clear(root);}
        void update(node*x,double l,double r){
            x-&gt;s=1;if(x-&gt;c[0])
                x-&gt;c[0]-&gt;t=(l+x-&gt;t)/2,
                update(x-&gt;c[0],l,x-&gt;t),x-&gt;s+=x-&gt;c[0]-&gt;s;
            if(x-&gt;c[1])
                x-&gt;c[1]-&gt;t=(x-&gt;t+r)/2,
                update(x-&gt;c[1],x-&gt;t,r),x-&gt;s+=x-&gt;c[1]-&gt;s;}
        void rotate(node*&amp;x,int d){
            node*y=x-&gt;c[d];x-&gt;c[d]=y-&gt;c[!d];y-&gt;c[!d]=x;
            y-&gt;t=x-&gt;t;x=y;}
        static int check(node*x,node*p,int v){
            if(x-&gt;v!=v)return x-&gt;v&lt;v?1:0;
            double d=x-&gt;p-&gt;t-p-&gt;t;
            if(d&lt;-1e-8)return 1;return d&gt;1e-8?0:2;}
        node*insert(node*&amp;x,node*p,int v,double l,double r){
            int d=check(x,p,v);if(d==2)return x;
            node*y;if(!x-&gt;c[d]){
                y=x-&gt;c[d]=new node(p,v);
                if(d)y-&gt;t=(x-&gt;t+r)/2;
                else y-&gt;t=(l+x-&gt;t)/2;
            }else y=insert(x-&gt;c[d],p,v,d?x-&gt;t:l,d?r:x-&gt;t);
            if(x-&gt;c[d]-&gt;f&gt;x-&gt;f)rotate(x,d),update(x,l,r);
            else ++x-&gt;s;return y;}
        void erase(node*&amp;x,node*y){
            if(x==y){
                if(!x-&gt;c[0]){x=x-&gt;c[1];delete y;}
                else if(!x-&gt;c[1]){x=x-&gt;c[0];delete y;}
                else{
                    int d=x-&gt;c[0]-&gt;f&lt;x-&gt;c[1]-&gt;f;
                    rotate(x,d);erase(x-&gt;c[!d],y);--x-&gt;s;}
            }else erase(x-&gt;c[x-&gt;t&lt;y-&gt;t],y),--x-&gt;s;}
        int check(node*x,int*y){
            for(++y;x-&gt;v==*y&amp;&amp;*y!=-1;x=x-&gt;p,++y);
            if(x-&gt;v==*y)return 0;return x-&gt;v&lt;*y?-1:1;}
        int query(node*x,int*y){
            int r=0;while(x){
                if(check(x,y)&lt;0)
                    r+=(x-&gt;c[0]?x-&gt;c[0]-&gt;s:0)+1,x=x-&gt;c[1];
                else x=x-&gt;c[0];}
            return r;}
        void clear(node*x){
            if(!x)return;clear(x-&gt;c[0]);
            clear(x-&gt;c[1]);delete x;}
        void clear(){clear(root);root=new node(0,-1);}
        node*insert(node*p,int v){
            return insert(root,p,v,0,1e9);}
        void erase(node*y){erase(root,y);}
        int query(int*y){
            int*t=y;while(*(t+1)!=-1)++t;
            int r=-query(root,y);++*t;
            r+=query(root,y);--*t;return r;}};}
#endif

#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef double dbl;
typedef long double ldb;
typedef string str;
typedef pair&lt;int,int&gt; pii;

char st[3000010];int len,msk=0;
void getstr(){scf("%s",st+1);len=strlen(st+1);}
void demark(){
    //return;
    int t=msk;
    lop(i,1,len){
        msk=(msk*131+i-1)%len;
        swap(st[i],st[msk+1]);
    }
    msk=t;
}
int main(){
    int q;scf("%d",&amp;q);
    SuffixBalancedTree sbt;
    SuffixBalancedTree::node*p=sbt.root;
    getstr();lop(i,1,len)p=sbt.insert(p,st[i]);
    lop(i,1,q){
        char op[110];scf("%s",op);getstr();demark();
        if(op[0]=='A'){
            lop(i,1,len)p=sbt.insert(p,st[i]);
        }else{
            static int y[3000010];
            lop(i,1,len)y[len-i+1]=st[i];
            y[len+1]=-1;
            int ans=sbt.query(y);msk^=ans;
            ptf("%d\n",ans);
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2555</h2><pre>#ifndef SUFFIX_BALANCED_TREE
#define SUFFIX_BALANCED_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct SuffixBalancedTree{
        struct node{
            node*c[2],*p;int v,f,s;double t;
            node(node*_p,int _v):
                f(rand()*1.0/RAND_MAX*1e9),
                p(_p),v(_v),s(1),t(5e8){c[0]=c[1]=0;}}*root;
        SuffixBalancedTree():root(new node(0,-1)){}
        ~SuffixBalancedTree(){clear(root);}
        void relabel(node*x,double l,double r){
            if(x-&gt;c[0])x-&gt;c[0]-&gt;t=(l+x-&gt;t)/2,relabel(x-&gt;c[0],l,x-&gt;t);
            if(x-&gt;c[1])x-&gt;c[1]-&gt;t=(x-&gt;t+r)/2,relabel(x-&gt;c[1],x-&gt;t,r);}
        void update(node*x){
            x-&gt;s=1;for(int i=0;i&lt;2;++i)if(x-&gt;c[i])x-&gt;s+=x-&gt;c[i]-&gt;s;}
        void rotate(node*&amp;x,int d){
            node*y=x-&gt;c[d];x-&gt;c[d]=y-&gt;c[!d];y-&gt;c[!d]=x;
            y-&gt;t=x-&gt;t;y-&gt;s=x-&gt;s;update(x);x=y;}
        static int check(node*x,node*p,int v){
            if(x-&gt;v!=v)return x-&gt;v&lt;v?1:0;double d=x-&gt;p-&gt;t-p-&gt;t;
            if(d&lt;-1e-8)return 1;return d&gt;1e-8?0:2;}
        node*insert(node*&amp;x,node*p,int v,double l,double r){
            int d=check(x,p,v);if(d==2)return x;
            node*y;if(!x-&gt;c[d]){
                y=x-&gt;c[d]=new node(p,v);
                if(d)y-&gt;t=(x-&gt;t+r)/2;else y-&gt;t=(l+x-&gt;t)/2;
            }else y=insert(x-&gt;c[d],p,v,d?x-&gt;t:l,d?r:x-&gt;t);
            ++x-&gt;s;if(x-&gt;c[d]-&gt;f&gt;x-&gt;f)
                rotate(x,d),relabel(x,l,r);return y;}
        void erase(node*&amp;x,node*y){
            if(x==y){
                if(!x-&gt;c[0]){x=x-&gt;c[1];delete y;}
                else if(!x-&gt;c[1]){x=x-&gt;c[0];delete y;}
                else{
                    int d=x-&gt;c[0]-&gt;f&lt;x-&gt;c[1]-&gt;f;
                    rotate(x,d);erase(x-&gt;c[!d],y);--x-&gt;s;}
            }else erase(x-&gt;c[x-&gt;t&lt;y-&gt;t],y),--x-&gt;s;}
        int check(node*x,int*y){
            for(++y;x-&gt;v==*y&amp;&amp;*y!=-1;x=x-&gt;p,++y);
            if(x-&gt;v==*y)return 0;return x-&gt;v&lt;*y?-1:1;}
        int query(node*x,int*y){
            int r=0;while(x){
                if(check(x,y)&lt;0)
                    r+=(x-&gt;c[0]?x-&gt;c[0]-&gt;s:0)+1,x=x-&gt;c[1];
                else x=x-&gt;c[0];}
            return r;}
        void clear(node*x){
            if(!x)return;clear(x-&gt;c[0]);
            clear(x-&gt;c[1]);delete x;}
        void clear(){clear(root);root=new node(0,-1);}
        node*insert(node*p,int v){
            return insert(root,p,v,0,1e9);}
        void erase(node*y){erase(root,y);}
        int query(int*y){
            int*t=y;while(*(t+1)!=-1)++t;
            int r=-query(root,y);++*t;
            r+=query(root,y);--*t;return r;}};}
#endif

#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef double dbl;
typedef long double ldb;
typedef string str;
typedef pair&lt;int,int&gt; pii;

char st[3000010];int len,msk=0;
void getstr(){scf("%s",st+1);len=strlen(st+1);}
void demark(){
   // return;
    int t=msk;
    lop(i,1,len){
        msk=(msk*131+i-1)%len;
        swap(st[i],st[msk+1]);
    }
    msk=t;
}
int main(){
    int q;scf("%d",&amp;q);
    SuffixBalancedTree sbt;
    SuffixBalancedTree::node*p=sbt.root;
    getstr();lop(i,1,len)
            p=sbt.insert(p,st[i]);
    lop(i,1,q){
        char op[110];scf("%s",op);getstr();demark();
        if(op[0]=='A'){
            lop(i,1,len){
                SuffixBalancedTree::node*tmp=p;
                p=sbt.insert(p,st[i]);
               //sbt.erase(p);
              //  p=tmp;
             //   p=sbt.insert(p,st[i]);
            }
        }else{
            static int y[3000010];
            lop(i,1,len)y[len-i+1]=st[i];
            y[len+1]=-1;
            int ans=sbt.query(y);
            ptf("%d\n",ans);
            msk^=ans;
        }
    }
    //ps;
    return 0;
}
/*

1
abb
Q b

*/
</pre><pre></pre><h2>Problem2555</h2><pre>#ifndef SUFFIX_BALANCED_TREE
#define SUFFIX_BALANCED_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct SuffixBalancedTree{
        struct node{
            node*c[2],*p;int v,f,s;double t;
            node(node*_p,int _v):
                f(rand()*1.0/RAND_MAX*1e9),
                p(_p),v(_v),s(1),t(5e8){c[0]=c[1]=0;}}*root;
        SuffixBalancedTree():root(new node(0,-1)){}
        ~SuffixBalancedTree(){clear(root);}
        void relabel(node*x,double l,double r){
            x-&gt;t=(l+r)/2;if(x-&gt;c[0])relabel(x-&gt;c[0],l,x-&gt;t);
            if(x-&gt;c[1])relabel(x-&gt;c[1],x-&gt;t,r);}
        void update(node*x){
            x-&gt;s=1;for(int i=0;i&lt;2;++i)if(x-&gt;c[i])x-&gt;s+=x-&gt;c[i]-&gt;s;}
        void rotate(node*&amp;x,int d){
            node*y=x-&gt;c[d];x-&gt;c[d]=y-&gt;c[!d];y-&gt;c[!d]=x;
            y-&gt;s=x-&gt;s;update(x);x=y;}
        static int check(node*x,node*p,int v){
            if(x-&gt;v!=v)return x-&gt;v&lt;v?1:0;double d=x-&gt;p-&gt;t-p-&gt;t;
            if(d&lt;-1e-8)return 1;return d&gt;1e-8?0:2;}
        node*insert(node*&amp;x,node*p,int v,double l,double r){
            int d=check(x,p,v);if(d==2)return x;
            node*y;if(!x-&gt;c[d]){
                y=x-&gt;c[d]=new node(p,v);
                if(d)y-&gt;t=(x-&gt;t+r)/2;else y-&gt;t=(l+x-&gt;t)/2;
            }else y=insert(x-&gt;c[d],p,v,d?x-&gt;t:l,d?r:x-&gt;t);
            ++x-&gt;s;if(x-&gt;c[d]-&gt;f&gt;x-&gt;f)
                rotate(x,d),relabel(x,l,r);return y;}
        void erase(node*&amp;x,node*y){
            if(x==y){
                if(!x-&gt;c[0]){x=x-&gt;c[1];delete y;}
                else if(!x-&gt;c[1]){x=x-&gt;c[0];delete y;}
                else{
                    int d=x-&gt;c[0]-&gt;f&lt;x-&gt;c[1]-&gt;f;
                    rotate(x,d);erase(x-&gt;c[!d],y);--x-&gt;s;}
            }else erase(x-&gt;c[x-&gt;t&lt;y-&gt;t],y),--x-&gt;s;}
        int check(node*x,int*y){
            for(++y;x-&gt;v==*y&amp;&amp;*y!=-1;x=x-&gt;p,++y);
            if(x-&gt;v==*y)return 0;return x-&gt;v&lt;*y?-1:1;}
        int query(node*x,int*y){
            int r=0;while(x){
                if(check(x,y)&lt;0)
                    r+=(x-&gt;c[0]?x-&gt;c[0]-&gt;s:0)+1,x=x-&gt;c[1];
                else x=x-&gt;c[0];}
            return r;}
        void clear(node*x){
            if(!x)return;clear(x-&gt;c[0]);
            clear(x-&gt;c[1]);delete x;}
        void clear(){clear(root);root=new node(0,-1);}
        node*insert(node*p,int v){
            return insert(root,p,v,0,1e9);}
        void erase(node*y){erase(root,y);}
        int query(int*y){
            int*t=y;while(*(t+1)!=-1)++t;
            int r=-query(root,y);++*t;
            r+=query(root,y);--*t;return r;}};}
#endif

#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef double dbl;
typedef long double ldb;
typedef string str;
typedef pair&lt;int,int&gt; pii;

char st[3000010];int len,msk=0;
void getstr(){scf("%s",st+1);len=strlen(st+1);}
void demark(){
  // return;
    int t=msk;
    lop(i,1,len){
        msk=(msk*131+i-1)%len;
        swap(st[i],st[msk+1]);
    }
    msk=t;
}static int y[3000010];
int main(){
    int q;scf("%d",&amp;q);
    SuffixBalancedTree sbt;
    SuffixBalancedTree::node*p=sbt.root;
    getstr();lop(i,1,len)
            p=sbt.insert(p,st[i]);
    lop(i,1,q){
        char op[110];scf("%s",op);getstr();demark();
        if(op[0]=='A'){
            lop(i,1,len){

                p=sbt.insert(p,st[i]);

            }
        }else{

            lop(i,1,len)y[len-i+1]=st[i];
            y[len+1]=-1;
            int ans=sbt.query(y);
            ptf("%d\n",ans);
            msk^=ans;
        }
    }
    //ps;
    return 0;
}
/*

6
B
A B
A B
A B
A A
A B
Q B



*/
</pre><pre></pre><h2>Problem2555</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define mcs int css;cin&gt;&gt;css;lop(csn,1,css)
#define fio ios::sync_with_stdio(0)
#define all(a) a.begin(),a.end()
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define vec vector
#define scf scanf
#define ptf printf
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef double dbl;
typedef long double ldb;
typedef string str;
typedef pair&lt;int,int&gt; pii;



#ifndef SUFFIX_ARRAY
#define SUFFIX_ARRAY
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct SuffixArray{
        struct node{
            node*c[2],*p;T v;int f,s;double t;
            node(node*_p,T _v):
                f(rand()*1.0/RAND_MAX*1e9),
                p(_p),v(_v),s(1),t(5e8){c[0]=c[1]=0;}}*root;
        SuffixArray():root(new node(0,0)){}
        ~SuffixArray(){clear(root);}
        void relabel(node*x,double l,double r){
            x-&gt;t=(l+r)/2;if(x-&gt;c[0])relabel(x-&gt;c[0],l,x-&gt;t);
            if(x-&gt;c[1])relabel(x-&gt;c[1],x-&gt;t,r);}
        void update(node*x){
            x-&gt;s=1;for(int i=0;i&lt;2;++i)if(x-&gt;c[i])x-&gt;s+=x-&gt;c[i]-&gt;s;}
        void rotate(node*&amp;x,int d){
            node*y=x-&gt;c[d];x-&gt;c[d]=y-&gt;c[!d];y-&gt;c[!d]=x;
            y-&gt;s=x-&gt;s;update(x);x=y;}
        static int check(node*x,node*p,int v){
            if(x-&gt;v!=v)return x-&gt;v&lt;v?1:0;double d=x-&gt;p-&gt;t-p-&gt;t;
            if(d&lt;-1e-8)return 1;return d&gt;1e-8?0:2;}
        node*insert(node*&amp;x,node*p,int v,double l,double r){
            int d=check(x,p,v);if(d==2)return x;
            node*y;if(!x-&gt;c[d]){
                y=x-&gt;c[d]=new node(p,v);
                if(d)y-&gt;t=(x-&gt;t+r)/2;else y-&gt;t=(l+x-&gt;t)/2;
            }else y=insert(x-&gt;c[d],p,v,d?x-&gt;t:l,d?r:x-&gt;t);
            update(x);if(x-&gt;c[d]-&gt;f&gt;x-&gt;f)
                rotate(x,d),relabel(x,l,r);return y;}
        void erase(node*&amp;x,node*y){
            if(x==y){
                if(!x-&gt;c[0]){x=x-&gt;c[1];delete y;}
                else if(!x-&gt;c[1]){x=x-&gt;c[0];delete y;}
                else{
                    int d=x-&gt;c[0]-&gt;f&lt;x-&gt;c[1]-&gt;f;
                    rotate(x,d);erase(x-&gt;c[!d],y);--x-&gt;s;}
            }else erase(x-&gt;c[x-&gt;t&lt;y-&gt;t],y),--x-&gt;s;}
        bool check(node*x,T*y){
            for(++y;x-&gt;v==*y&amp;&amp;*y;x=x-&gt;p,++y);
            return x-&gt;v&lt;*y;}
        int count(node*x,T*y){
            int r=0;while(x){
                if(check(x,y))
                    r+=(x-&gt;c[0]?x-&gt;c[0]-&gt;s:0)+1,x=x-&gt;c[1];
                else x=x-&gt;c[0];}
            return r;}
        void clear(node*x){
            if(!x)return;clear(x-&gt;c[0]);
            clear(x-&gt;c[1]);delete x;}
        node*insert(node*p,int v){
            return insert(root,p,v,0,1e9);}
        void erase(node*y){erase(root,y);}
        int count(T*y){
            T*t=y;while(*(t+1))++t;
            int r=-count(root,y);++*t;
            r+=count(root,y);--*t;return r;}};}
#endif



char st[3000010];int len,msk=0;
void getstr(){scf("%s",st+1);len=strlen(st+1);}
void demark(){
  // return;
    int t=msk;
    lop(i,1,len){
        msk=(msk*131+i-1)%len;
        swap(st[i],st[msk+1]);
    }
    msk=t;
}
int main(){
    int q;scf("%d",&amp;q);
    SuffixArray&lt;char&gt; sbt;
    SuffixArray&lt;char&gt;::node*p=sbt.root;
    getstr();lop(i,1,len)
            p=sbt.insert(p,st[i]);
    lop(i,1,q){
        char op[110];scf("%s",op);getstr();demark();
        if(op[0]=='A'){
            lop(i,1,len){

                //SuffixArray&lt;char&gt;::node*tmp=p;
                             //  p=sbt.insert(p,st[i]);
                            //  sbt.erase(p);
                             //  p=tmp;
                               p=sbt.insert(p,st[i]);

            }
        }else{
            reverse(st+1,st+len+1);
            int ans=sbt.count(st);
            ptf("%d\n",ans);
            msk^=ans;
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2561</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace isap{
    int vcnt,nw,st,et;
    int gap[20010],dis[20010];
    vector&lt;int&gt;bg[20010];
    void init(){
        nw=1;lp(i,1,vcnt)bg[i].clear();
        lp(i,1,vcnt)dis[i]=0,gap[i]=0;gap[0]=vcnt;
    }
    struct edge{int v,c;}edges[200000*3];
    void add(int u,int v,int c){
        edge&amp;e=edges[++nw];
        e.v=v;e.c=c;bg[u].push_back(nw);
    }
    int dfs(int u,int f){
        if(u==et)return f;
        int g=f;
        lp(i,0,int(bg[u].size()-1)){
            edge&amp;e=edges[bg[u][i]],&amp;ev=edges[bg[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t;ev.c+=t;g-=t;
                if(!g||dis[st]==vcnt)return f-g;
            }
        }
        if((--gap[dis[u]])==0)dis[st]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    int solve(){
        int r=0;while(dis[st]&lt;vcnt)r+=dfs(st,~0u&gt;&gt;1);
        return r;
    }
} 
#define mp make_pair 
#define pb push_back
#define ft first 
#define sd second
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;egs;
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        egs.pb(mp(w,mp(u,v)));
    }
    int uu,vv,l;sf("%d%d%d",&amp;uu,&amp;vv,&amp;l);
    isap::vcnt=n;isap::st=uu;isap::et=vv;
    isap::init();
    lp(i,0,int(egs.size()-1)){
        if(egs[i].ft&gt;=l)continue;
        int u=egs[i].sd.ft,v=egs[i].sd.sd;
        isap::add(u,v,1),isap::add(v,u,1);
    } 
    int ans=isap::solve();
    isap::init();
    lp(i,0,int(egs.size()-1)){
        if(egs[i].ft&lt;=l)continue;
        int u=egs[i].sd.ft,v=egs[i].sd.sd;
        isap::add(u,v,1),isap::add(v,u,1);
    } 
    ans+=isap::solve();
    pf("%d\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2565</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
using namespace std;
const int N=100010,M=26;
struct PT{
    int n,m,nxt[N+2][M],fail[N+2],cnt[N+2],hei[N+2],len[N+2],str[N+1],strl,lst,nds;
    PT(int _n,int _m):
        n(_n),m(_m),strl(0),lst(0),nds(0){
        newnode(-1);
        fail[0]=1;
        newnode(0);
        fail[1]=0;
        str[0]=-1;
    }
    int newnode(int _l){
        fill(nxt[nds],nxt[nds]+M,1);
        cnt[nds]=0;
        hei[nds]=0;
        len[nds]=_l;
        return nds++;
    }
    int getfail(int x){
        while(str[strl-len[x]-1]!=str[strl])
            x=fail[x];
        return x;
    }
    void add(int c){
        str[++strl]=c;
        int p=getfail(lst);
        if(nxt[p][c]==1){
            int np=newnode(len[p]+2);
            fail[np]=nxt[getfail(fail[p])][c];
            nxt[p][c]=np;
            hei[np]=hei[fail[np]]+1;
        }
        ++cnt[lst=nxt[p][c]];
    }
    void count(){
        for(int i=nds-1;i&gt;=1;--i)
            cnt[fail[i]]+=cnt[i];
    }
};

int main(){
    static char s[100010];
    scanf("%s",s+1);
    int l=strlen(s+1);
    PT*pt=new PT(l,26),*rpt=new PT(l,26);
    static int dp[100010],rdp[100010];
    for(int i=1;i&lt;=l;++i)
        pt-&gt;add(s[i]-'a'),dp[i]=pt-&gt;len[pt-&gt;lst];
    for(int i=l;i&gt;=1;--i)
        rpt-&gt;add(s[i]-'a'),rdp[i]=rpt-&gt;len[rpt-&gt;lst];
    int ans=0;
    for(int i=1;i&lt;=l-1;++i)
        ans=max(ans,dp[i]+rdp[i+1]);
    printf("%d\n",ans);
    return 0;
}
</pre><pre></pre><h2>Problem2565</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
using namespace std;
const int N=100010,M=26;
struct PT{
    int n,m,nxt[N+3][M],fail[N+3],cnt[N+3],hei[N+3],len[N+3],str[N+1],strl,lst,nds;
    PT(int _n,int _m):
        n(_n),m(_m),strl(0),lst(1),nds(0){
        newnode(-2);
        fill(nxt[0],nxt[0]+M,2);
        newnode(-1);
        fail[1]=0;
        newnode(0);
        fail[2]=1;
        str[0]=-1;
    }
    int newnode(int _l){
        fill(nxt[nds],nxt[nds]+M,-1);
        cnt[nds]=0;
        hei[nds]=0;
        len[nds]=_l;
        return nds++;
    }
    int getfail(int x){
        while(x&amp;&amp;str[strl-len[x]-1]!=str[strl])
            x=fail[x];
        return x;
    }
    void add(int c){
        str[++strl]=c;
        int p=getfail(lst);
        if(nxt[p][c]==-1){
            int np=newnode(len[p]+2);
            fail[np]=nxt[getfail(fail[p])][c];
            nxt[p][c]=np;
            hei[np]=hei[fail[np]]+1;
        }
        ++cnt[lst=nxt[p][c]];
    }
    void count(){
        for(int i=nds-1;i&gt;=1;--i)
            cnt[fail[i]]+=cnt[i];
    }
};

int main(){
    static char s[100010];
    scanf("%s",s+1);
    int l=strlen(s+1);
    PT*pt=new PT(l,26),*rpt=new PT(l,26);
    static int dp[100010],rdp[100010];
    for(int i=1;i&lt;=l;++i)
        pt-&gt;add(s[i]-'a'),dp[i]=pt-&gt;len[pt-&gt;lst];
    for(int i=l;i&gt;=1;--i)
        rpt-&gt;add(s[i]-'a'),rdp[i]=rpt-&gt;len[rpt-&gt;lst];
    int ans=0;
    for(int i=1;i&lt;=l-1;++i)
        ans=max(ans,dp[i]+rdp[i+1]);
    printf("%d\n",ans);
    return 0;
}
</pre><pre></pre><h2>Problem2565</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(auto i=a;i&lt;=b;++i)
#define rlp(i,a,b) for(auto i=a;i&gt;=b;--i)
#define all(a) a.begin(),a.end()
#define sqr(a) ((a)*(a))
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define scf scanf
#define ptf printf
#define inf (~0u&gt;&gt;1)
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef string str;
typedef vector&lt;int&gt; vei;
typedef vector&lt;string&gt; ves;
typedef map&lt;int,int&gt; mii;
typedef map&lt;str,int&gt; msi;
typedef set&lt;int&gt; sti;
typedef set&lt;str&gt; sts;
typedef pair&lt;int,int&gt; pii;
typedef vector&lt;pii&gt; vii;
#ifndef PALINDROMIC_TREE
#define PALINDROMIC_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct PalindromicTree{
        struct node{
            node(int m,node*f,int l):nxt(m),fail(f),cnt(0),len(l){}
            vector&lt;node*&gt;nxt;node*fail;int cnt,len;}*lst;
        int m,strl;vector&lt;int&gt;str;vector&lt;node*&gt;nds;
        PalindromicTree(int _m):m(_m),strl(0),str(200010){
            node*n0=new node(m,0,-2),*n1=new node(m,n0,-1),*n2=new node(m,n1,0);
            fill(n0-&gt;nxt.begin(),n0-&gt;nxt.end(),n2);str[0]=-1;lst=n1;}
        node*getf(node*x){
            while(x-&gt;fail&amp;&amp;str[strl-x-&gt;len-1]!=str[strl])x=x-&gt;fail;return x;}
        node*add(int c){
              str[++strl]=c;node*p=getf(lst);
              if(!p-&gt;nxt[c]){
                  node*np=(p-&gt;nxt[c]=new node(m,getf(p-&gt;fail)-&gt;nxt[c],p-&gt;len+2));
                  nds.push_back(np);}
              ++(lst=p-&gt;nxt[c])-&gt;cnt;return lst;}
        void count(){for(int i=nds.size()-1;i&gt;=0;--i)nds[i]-&gt;fail-&gt;cnt+=nds[i]-&gt;cnt;}};}
#endif
        int main(){
            static char s[100010];
            scanf("%s",s+1);
            int l=strlen(s+1);
            PalindromicTree*pt=new PalindromicTree(26),*rpt=new PalindromicTree(26);
            static int dp[100010],rdp[100010];
            for(int i=1;i&lt;=l;++i)
                dp[i]=pt-&gt;add(s[i]-'a')-&gt;len;
            for(int i=l;i&gt;=1;--i)
                rdp[i]=rpt-&gt;add(s[i]-'a')-&gt;len;
            int ans=0;
            for(int i=1;i&lt;=l-1;++i)
                ans=max(ans,dp[i]+rdp[i+1]);
            printf("%d\n",ans);
            return 0;
        }</pre><pre></pre><h2>Problem2565</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(auto i=a;i&lt;=b;++i)
#define rlp(i,a,b) for(auto i=a;i&gt;=b;--i)
#define all(a) a.begin(),a.end()
#define sqr(a) ((a)*(a))
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define scf scanf
#define ptf printf
#define inf (~0u&gt;&gt;1)
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef string str;
typedef vector&lt;int&gt; vei;
typedef vector&lt;string&gt; ves;
typedef map&lt;int,int&gt; mii;
typedef map&lt;str,int&gt; msi;
typedef set&lt;int&gt; sti;
typedef set&lt;str&gt; sts;
typedef pair&lt;int,int&gt; pii;
typedef vector&lt;pii&gt; vii;
#ifndef PALINDROMIC_TREE
#define PALINDROMIC_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct PalindromicTree{
        struct node{
            node(int m,node*f,int l):nxt(m),fail(f),cnt(0),len(l){}
            vector&lt;node*&gt;nxt;node*fail;int cnt,len;}*lst;
        int m,strl;vector&lt;int&gt;str;vector&lt;node*&gt;nds;
        PalindromicTree(int _m):m(_m),strl(0){
            node*n0=new node(m,0,-2),*n1=new node(m,n0,-1),*n2=new node(m,n1,0);
            fill(n0-&gt;nxt.begin(),n0-&gt;nxt.end(),n2);str.push_back(-1);lst=n1;}
        node*getf(node*x){
            while(x-&gt;fail&amp;&amp;str[strl-x-&gt;len-1]!=str[strl])x=x-&gt;fail;return x;}
        node*add(int c){
            str.push_back(c);++strl;node*p=getf(lst);
            if(!p-&gt;nxt[c]){
                node*np=(p-&gt;nxt[c]=new node(m,getf(p-&gt;fail)-&gt;nxt[c],p-&gt;len+2));
                nds.push_back(np);}
            ++(lst=p-&gt;nxt[c])-&gt;cnt;return lst;}
        void count(){for(int i=nds.size()-1;i&gt;=0;--i)nds[i]-&gt;fail-&gt;cnt+=nds[i]-&gt;cnt;}};}
#endif
        int main(){
            static char s[100010];
            scanf("%s",s+1);
            int l=strlen(s+1);
            PalindromicTree*pt=new PalindromicTree(26),*rpt=new PalindromicTree(26);
            static int dp[100010],rdp[100010];
            for(int i=1;i&lt;=l;++i)
                dp[i]=pt-&gt;add(s[i]-'a')-&gt;len;
            for(int i=l;i&gt;=1;--i)
                rdp[i]=rpt-&gt;add(s[i]-'a')-&gt;len;
            int ans=0;
            for(int i=1;i&lt;=l-1;++i)
                ans=max(ans,dp[i]+rdp[i+1]);
            printf("%d\n",ans);
            return 0;
        }</pre><pre></pre><h2>Problem2588</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace seg{
    struct node{
        node(node*a,node*b,int c,int d,int e){
            ch[0]=a;ch[1]=b;l=c;r=d;cnt=e;
        }
        node*ch[2];int l,r,cnt;  
    };
    node*add(node*x,int p){
        if(x-&gt;l==x-&gt;r)
            return new node(0,0,x-&gt;l,x-&gt;r,x-&gt;cnt+1);
        else{
            int m=x-&gt;l+(x-&gt;r-x-&gt;l)/2;
            if(p&lt;=m){
                return new node(add(x-&gt;ch[0],p),x-&gt;ch[1],x-&gt;l,x-&gt;r,x-&gt;cnt+1);
            }else{
                return new node(x-&gt;ch[0],add(x-&gt;ch[1],p),x-&gt;l,x-&gt;r,x-&gt;cnt+1);
            }
        }
    }
    node*build(int l,int r){
        node*x=new node(0,0,l,r,0);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;ch[0]=build(l,m);
            x-&gt;ch[1]=build(m+1,r);
        }
        return x;
    }
    int ask(vector&lt;node*&gt;&amp;x,vector&lt;node*&gt;&amp;y,int l,int r,int k){
        if(l==r)return l;
        else{
            int t=0;
            lp(i,0,int(x.size()-1))
                    t+=x[i]-&gt;ch[0]-&gt;cnt;
            lp(i,0,int(y.size()-1))
                    t-=y[i]-&gt;ch[0]-&gt;cnt;
            int m=l+(r-l)/2;
            if(t&lt;=k-1){
                k-=t;
                lp(i,0,int(x.size()-1))
                        x[i]=x[i]-&gt;ch[1];
                lp(i,0,int(y.size()-1))
                        y[i]=y[i]-&gt;ch[1];
                return ask(x,y,m+1,r,k);
            }else{
                lp(i,0,int(x.size()-1))
                        x[i]=x[i]-&gt;ch[0];
                lp(i,0,int(y.size()-1))
                        y[i]=y[i]-&gt;ch[0];
                return ask(x,y,l,m,k);
            }
        }
    }
}
namespace tree{
    vector&lt;int&gt;to[100010];seg::node*sum[100010];
    int n,m,wei[100010];vector&lt;int&gt;tmp;
    void init(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,n)sf("%d",&amp;wei[i]);
        lp(i,1,n)tmp.push_back(wei[i]);
        sort(tmp.begin(),tmp.end());
        tmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());
        lp(i,1,n)wei[i]=lower_bound(tmp.begin(),tmp.end(),wei[i])-tmp.begin();
        lp(i,1,n-1){
            int x,y;sf("%d%d",&amp;x,&amp;y);
            to[x].push_back(y);
            to[y].push_back(x); 
        }
    }
    int up[100010][21],dp[100010];
        int lca(int x,int y){
        if(dp[x]&lt;dp[y])swap(x,y);
        lp(i,0,20)if(((dp[x]-dp[y])&gt;&gt;i)&amp;1)x=up[x][i];
        if(x==y)return x;
        rp(i,20,0)
            if(up[x][i]!=up[y][i])
                x=up[x][i],y=up[y][i];
        return up[x][0];
    }
    void bfs(){
        queue&lt;int&gt;qu;qu.push(1);sum[1]=seg::add(seg::build(0,n-1),wei[1]);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(v!=up[u][0]){
                    up[v][0]=u;
                    lp(j,1,20)up[v][j]=up[up[v][j-1]][j-1];
                    dp[v]=dp[u]+1;
                    sum[v]=seg::add(sum[u],wei[v]);
                    qu.push(v);
                }
            } 
        }
        //lp(i,1,n)pf("[%d,%d]\n",up[i][0],dp[i]);
        //lp(i,1,n)lp(j,1,n)pf("[%d,%d,%d]\n",i,j,lca(i,j));
    }
    int ask(int u,int v,int k){
        vector&lt;seg::node*&gt;x,y;
        x.push_back(sum[u]);x.push_back(sum[v]);
        int w=lca(u,v);
        y.push_back(sum[w]);
        if(up[w][0])y.push_back(sum[up[w][0]]);
        int tp=seg::ask(x,y,0,n-1,k);
        return tmp[tp];
    }
    void prec(){
        int last=0;
        lp(i,1,m){
            int u,v,k;
            sf("%d%d%d",&amp;u,&amp;v,&amp;k);
            u^=last;
            int ans=ask(u,v,k);
            last=ans;
            pf("%d",last); 
            if(i!=m)pf("\n");
        }
    }
}
int main(){
    tree::init();
    tree::bfs();
    tree::prec();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2590</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
建立费用流模型
用堆优化增广
*/
#include&lt;queue&gt;
int n,k;ll m,p[50010],c[50010];
int vis[50010];
struct item{
	item(int i,ll v):idx(i),val(v){}
	int idx;ll val;
};
bool operator&lt;(item a,item b){
	return a.val&gt;b.val;
}
int main(){
	sf("%d%d%lld",&amp;n,&amp;k,&amp;m);
	lp(i,1,n)sf("%lld%lld",&amp;p[i],&amp;c[i]);
	int ans=0;
	priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;ticket;
	lp(i,1,k)ticket.push(0);
	priority_queue&lt;item&gt;sml,big;
	lp(i,1,n)sml.push(item(i,c[i])),big.push(item(i,p[i]));
	while(true){
		while(!sml.empty()&amp;&amp;vis[sml.top().idx])sml.pop();
		while(!big.empty()&amp;&amp;vis[big.top().idx])big.pop();
		if(sml.empty())break;
		if(sml.top().val+ticket.top()&lt;big.top().val){
			ll t=sml.top().val+ticket.top();
			if(m&lt;t)break;
			m-=t;
			++ans;
			ticket.pop();
			vis[sml.top().idx]=1;
			ticket.push(p[sml.top().idx]-c[sml.top().idx]);
		}else{
			ll t=big.top().val;
			if(m&lt;t)break;
			m-=t;
			++ans;
			vis[big.top().idx]=1;
		}
	}
	pf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
struct edge{
    edge(int a,int b,edge*c):v(a),w(b),nxt(c){}
    int v,w;edge*nxt;
}*bg[200010];
void add(int u,int v,int w){
    bg[u]=new edge(v,w,bg[u]);
}
int n,k,ans=~0u&gt;&gt;1;
int siz[200010],mxs[200010],prt[200010],dis[200010],dep[200010];
int nds[200010],pos[200010],ns;
void dfs(int u){
    siz[u]=1;mxs[u]=0;nds[++ns]=u;
    for(edge*e=bg[u];e;e=e-&gt;nxt){
        if(e-&gt;v!=prt[u]){
            prt[e-&gt;v]=u;
            dis[e-&gt;v]=dis[u]+e-&gt;w;
            dep[e-&gt;v]=dep[u]+1;
            dfs(e-&gt;v);
            siz[u]+=siz[e-&gt;v];
            mxs[u]=max(mxs[u],siz[e-&gt;v]);
        }
    }
    pos[u]=ns;
}
bool cmp1(int u,int v){return dis[u]==dis[v]?dep[u]&lt;dep[v]:dis[u]&lt;dis[v];}
bool cmp2(int u,int v){return dis[u]&lt;dis[v];}
void treedc(int u){
    ns=0;prt[u]=dis[u]=dep[u]=0;dfs(u);
    if(siz[u]==1)return;
    if(siz[u]==2){if(bg[u]-&gt;w==k)ans=1;return;}
    lp(i,1,ns)mxs[nds[i]]=max(mxs[nds[i]],siz[u]-siz[nds[i]]);
    lp(i,1,ns)if(mxs[nds[i]]&lt;mxs[u])u=nds[i];
    ns=0;prt[u]=dis[u]=dep[u]=0;dfs(u);
    edge*mid=bg[u];int t=siz[bg[u]-&gt;v];
    while(t+siz[mid-&gt;nxt-&gt;v]&lt;siz[u]/2)t+=siz[mid-&gt;nxt-&gt;v],mid=mid-&gt;nxt;
    sort(nds+2,nds+pos[mid-&gt;v]+1,cmp1);
    lp(i,pos[mid-&gt;v]+1,ns){
        dis[0]=k-dis[nds[i]];int*j=lower_bound(nds+2,nds+pos[mid-&gt;v]+1,0,cmp2);
        if(j!=nds+pos[mid-&gt;v]+1&amp;&amp;dis[*j]+dis[nds[i]]==k)ans=min(ans,dep[*j]+dep[nds[i]]);
    }
    edge*te=mid-&gt;nxt;mid-&gt;nxt=0;treedc(u);
    bg[u]=te;treedc(u);
}
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,n-1){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        add(u+1,v+1,w);add(v+1,u+1,w);
    }
    treedc(1);
    pf("%d\n",ans==~0u&gt;&gt;1?-1:ans);
    return 0;
}
</pre><pre></pre><h2>Problem2599</h2><pre>#include&lt;iostream&gt;
 #include&lt;cstdio&gt;
 #include&lt;cmath&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 using namespace std;
 #define NMAX 200011
 struct node
 {
     int num,weight;
     node *next;
 };
 pair&lt;int,int&gt; d1[NMAX],d2[NMAX];
 node *graph[NMAX];
 node memo[2*NMAX];
 int size[NMAX],Q[NMAX],mark[NMAX];
 int n,m,ans=NMAX,top=0,root,sumsize,minsize,tot1,tot2;
 void add(int x,int y,int z)
 {
     node *p=&amp;memo[top++];
     p-&gt;num=y; p-&gt;weight=z; p-&gt;next=graph[x]; graph[x]=p;
     p=&amp;memo[top++];
     p-&gt;num=x; p-&gt;weight=z; p-&gt;next=graph[y]; graph[y]=p;
 }
 void get_root(int i,int fa)
 {
     int big=-1;
     size[i]=1;
     for(node *p=graph[i];p;p=p-&gt;next)
     if(p-&gt;num!=fa)
     {
         get_root(p-&gt;num,i);
         size[i]+=size[p-&gt;num];
         if(size[p-&gt;num]&gt;big) big=size[p-&gt;num];
     }
     if(sumsize-size[i]&gt;big) big=sumsize-size[i];
     if(big&lt;minsize) minsize=big,root=i;
 }
 void get_dis(int i,pair&lt;int,int&gt; d[], int &amp;tot)
 {
     int left,right,u;
     Q[left=right=1]=i;
     d[++tot].first=0; d[tot].second=0; mark[i]=tot;
     while(left&lt;=right)
     {
         u=Q[left++];
         for(node *p=graph[u];p;p=p-&gt;next)
         if(mark[p-&gt;num]==0)
         {
             d[++tot].first=d[mark[u]].first+p-&gt;weight; d[tot].second=d[mark[u]].second+1;
             mark[p-&gt;num]=tot;
             Q[++right]=p-&gt;num;
         }
     }
     for(i=1;i&lt;=right;i++) mark[Q[i]]=0;
 }
 
 void count(int x,node *mid)
 {
     node *mid_next=mid-&gt;next,*left=graph[x];
     tot2=tot1=0;
     mid-&gt;next=NULL; 
     get_dis(x,d1,tot1);
     sort(d1+2,d1+tot1+1);
     mid-&gt;next=mid_next; graph[x]=mid_next;
     get_dis(x,d2,tot2);
     sort(d2+2,d2+tot2+1);
     for(int i=1,j=tot2;i&lt;=tot1;i++)
     {
         while(d1[i].first+d2[j].first&gt;m&amp;&amp;j&gt;0) j--;
         while(d1[i].first+d2[j].first==m)
         {
             if(ans&gt;d1[i].second+d2[j].second) ans=d1[i].second+d2[j].second;
             if(j&gt;0&amp;&amp;d2[j-1].first==d2[j].first) j--;
             else break;
         }
     }
     graph[x]=left;
 }
 
 void dfs(int i,int size_i)
 {
     if(size_i&lt;=2) return ;
     sumsize=minsize=size_i;
     get_root(i,-1); i=root;
     get_root(i,-1);
     int sum=0;
     node *mid,*mid_next,*left=graph[i],*p;
     for(p=graph[i];p;p=p-&gt;next)
     {
         sum+=size[p-&gt;num];
         if(sum*2&gt;=size_i-1||p-&gt;next-&gt;next==NULL) break;
     }
     mid=p;
     count(i,mid);
     mid_next=mid-&gt;next; mid-&gt;next=NULL;
     dfs(i,sum+1);
     mid-&gt;next=mid_next; graph[i]=mid_next;
     dfs(i,size_i-sum);
     graph[i]=left;
 }
 
 int main()
 {
     int x,y,z;
     scanf("%d%d",&amp;n,&amp;m);
     memset(mark,0,sizeof(mark));
     memset(graph,0,sizeof(graph));
     int i;
     for(i=1;i&lt;n;i++)
     {
         scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
         add(x,y,z);
     }
     dfs(0,n);
     if(ans!=NMAX)
         printf("%d\n",ans);
     else
         printf("-1\n");
     return 0;
 }</pre><pre></pre><h2>Problem2620</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;ll a[100010],b[100010],s[100010];
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%lld%lld",a+i,b+i);
	lp(i,2,n)s[i]=s[i-1]+a[i-1]-b[i-1];
	sort(s+1,s+n+1);
	ll t=s[(n+1)/2];
	ll ans=0;
	lp(i,1,n)if(s[i]&gt;t)ans+=s[i]-t;else ans+=t-s[i];
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2626</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct point{int x,y,e;};
struct node{node*lc,*rc;int xi,xa,yi,ya;point p;};
point pts[100010];
int n,m;
bool cmpx(point a,point b){return a.x&lt;b.x;}
bool cmpy(point a,point b){return a.y&lt;b.y;}
node*build(int l,int r,int s){
    node*x=new node;int m=l+((r-l)&gt;&gt;1);
    sort(pts+l,pts+r+1,s?cmpy:cmpx);x-&gt;p=pts[m];
    x-&gt;xi=x-&gt;xa=x-&gt;p.x;x-&gt;yi=x-&gt;ya=x-&gt;p.y;
    if(l&lt;=m-1){
        x-&gt;lc=build(l,m-1,!s);
        x-&gt;xi=min(x-&gt;xi,x-&gt;lc-&gt;xi);
        x-&gt;xa=max(x-&gt;xa,x-&gt;lc-&gt;xa);
        x-&gt;yi=min(x-&gt;yi,x-&gt;lc-&gt;yi);
        x-&gt;ya=max(x-&gt;ya,x-&gt;lc-&gt;ya);
    }else x-&gt;lc=0;
    if(m+1&lt;=r){
        x-&gt;rc=build(m+1,r,!s);
        x-&gt;xi=min(x-&gt;xi,x-&gt;rc-&gt;xi);
        x-&gt;xa=max(x-&gt;xa,x-&gt;rc-&gt;xa);
        x-&gt;yi=min(x-&gt;yi,x-&gt;rc-&gt;yi);
        x-&gt;ya=max(x-&gt;ya,x-&gt;rc-&gt;ya);
    }else x-&gt;rc=0;
    return x;
}
typedef long long ll;
ll dis(point a,point b){return ll(a.x-b.x)*ll(a.x-b.x)+ll(a.y-b.y)*ll(a.y-b.y);}
int qk;point qp;pair&lt;ll,point&gt;ans[31];
bool cmp(pair&lt;ll,point&gt; a,pair&lt;ll,point&gt; b){
    if(a.first==b.first)return a.second.e&lt;b.second.e;
    else return a.first&gt;b.first;
}
void update(point p){
    pair&lt;ll,point&gt; t=make_pair(dis(p,qp),p);
    if(!cmp(t,ans[qk]))return;
    int i=qk;for(;i&amp;&amp;cmp(t,ans[i]);--i);++i;
    for(int j=qk;j&gt;i;--j)ans[j]=ans[j-1];
    ans[i]=t;
}
ll mab(ll a){return a&gt;0?a:-a;}
ll mdis(node*x){
    ll t1=max(mab(x-&gt;xi-qp.x),mab(x-&gt;xa-qp.x));
    ll t2=max(mab(x-&gt;yi-qp.y),mab(x-&gt;ya-qp.y));
    return t1*t1+t2*t2;
}
void query(node*x){
    update(x-&gt;p);
    ll t1=x-&gt;lc?mdis(x-&gt;lc):-2;
    ll t2=x-&gt;rc?mdis(x-&gt;rc):-2;
    if(t1&gt;t2){
        if(t1&gt;=ans[qk].first)query(x-&gt;lc);
        if(t2&gt;=ans[qk].first)query(x-&gt;rc);
    }else{
        if(t2&gt;=ans[qk].first)query(x-&gt;rc);
        if(t1&gt;=ans[qk].first)query(x-&gt;lc);
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){sf("%d%d",&amp;pts[i].x,&amp;pts[i].y);pts[i].e=i;}
    node*rt=build(1,n,0);
    sf("%d",&amp;m);
    lp(i,1,m){
        sf("%d%d%d",&amp;qp.x,&amp;qp.y,&amp;qk);
        lp(i,1,qk)ans[i]=make_pair(-1ll,point());
        query(rt);
        pf("%d\n",ans[qk].second.e);
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2631</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace lct{
    const int nmx=100000;
    int n,ch[nmx+10][2],pr[nmx+10],rv[nmx+10];
    unsigned sz[nmx+10],vl[nmx+10],sm[nmx+10],ta[nmx+10],tb[nmx+10];
    inline void dw(int x){
        if(rv[x]){
            swap(ch[x][0],ch[x][1]);
            if(ch[x][0])rv[ch[x][0]]^=1;
            if(ch[x][1])rv[ch[x][1]]^=1;
            rv[x]=0;
        }
        if(!(ta[x]==1&amp;&amp;tb[x]==0)){
            sm[x]=(sm[x]*ta[x]%51061+sz[x]*tb[x]%51061)%51061;
            vl[x]=(vl[x]*ta[x]+tb[x])%51061;
            if(ch[x][0]){
                ta[ch[x][0]]=ta[ch[x][0]]*ta[x]%51061;
                tb[ch[x][0]]=(tb[ch[x][0]]*ta[x]+tb[x])%51061;
            }
            if(ch[x][1]){
                ta[ch[x][1]]=ta[ch[x][1]]*ta[x]%51061;
                tb[ch[x][1]]=(tb[ch[x][1]]*ta[x]+tb[x])%51061;
            }
            ta[x]=1;tb[x]=0;
        }
    }
    inline void up(int x){
        sm[x]=vl[x];
        sz[x]=1;
        if(ch[x][0]){
            dw(ch[x][0]);
            sm[x]+=sm[ch[x][0]];sm[x]%=51061;
            sz[x]+=sz[ch[x][0]];
        }
        if(ch[x][1]){
            dw(ch[x][1]);
            sm[x]+=sm[ch[x][1]];sm[x]%=51061;
            sz[x]+=sz[ch[x][1]];
        }
    }
    inline int tp(int x){return x!=ch[pr[x]][0];}
    inline void st(int x,int y,int d){
        ch[x][d]=y;
        if(y)pr[y]=x;
        up(x);
    }
    inline void dfs(int x){
        if(x&gt;0){
            dfs(pr[x]);
            dw(x);
        }
    }
    inline void rot(int x){
        int y=pr[x],z=pr[y],d=tp(x),r;if(z&gt;0)r=tp(y);
        st(y,ch[x][!d],d);
        st(x,y,!d);
        if(z&gt;0)st(z,x,r);else pr[x]=z;
    }
    inline void spl(int x){
        dfs(x);
        while(pr[x]&gt;0){
            if(pr[pr[x]]&lt;=0)rot(x);
            else if(tp(x)==tp(pr[x]))rot(pr[x]),rot(x);
            else rot(x),rot(x);
        }
    }
    inline int acc(int x){
        int y=0;
        while(x){
            spl(x);
            if(ch[x][1])pr[ch[x][1]]=-x;
            st(x,y,1);
            y=x;x=-pr[x];
        }
        return y;
    }
    inline void evert(int x){
        acc(x);spl(x);rv[x]=1;
    }
    inline void print(){
        lp(x,1,n){
            pf("ch[%d,%d]",ch[x][0],ch[x][1]);
            pf("pr[%d]",pr[x]);
            pf("tg[%d,%d,%d]",rv[x],ta[x],tb[x]);
            pf("if[%d,%d]\n",sm[x],sz[x]);
        }
        pf("\n\n");
    }
}
int main(){
    int q;
    sf("%d%d",&amp;lct::n,&amp;q);
    static vector&lt;int&gt;to[100010];
    lp(i,1,lct::n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);
        to[v].push_back(u);
    }
    static int vi[100010];vi[1]=1;
    queue&lt;int&gt;qu;qu.push(1);
    lct::vl[1]=1;lct::ta[1]=1;lct::tb[1]=0;
    lct::sm[1]=1;lct::sz[1]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i];
            if(!vi[v]){
                vi[v]=1;
                lct::vl[v]=1;lct::ta[v]=1;lct::tb[v]=0;
                lct::pr[v]=-u;lct::sm[v]=1;lct::sz[v]=1;
                qu.push(v);
            }
        }
    }
    lp(i,1,q){
        char op[11];sf("%s",op);
        //lct::print();
        if(op[0]=='+'){
            int u,v,c;sf("%d%d%d",&amp;u,&amp;v,&amp;c);
            lct::evert(u);lct::acc(v);
            lct::spl(v);
            lct::tb[v]=c;
        }else if(op[0]=='-'){
            int u1,v1,u2,v2;
            sf("%d%d%d%d",&amp;u1,&amp;v1,&amp;u2,&amp;v2);
            lct::evert(u1);lct::acc(v1);lct::spl(u1);
            lct::pr[v1]=0;lct::ch[u1][1]=0;lct::up(u1);
            lct::evert(u2);lct::pr[u2]=-v2;
        }else if(op[0]=='*'){
            int u,v,c;sf("%d%d%d",&amp;u,&amp;v,&amp;c);
            lct::evert(u);lct::acc(v);
            lct::spl(v);
            lct::ta[v]=c;
        }else{
            int u,v;sf("%d%d",&amp;u,&amp;v);
            lct::evert(u);
            lct::acc(v);
            lct::spl(u);
            pf("%d\n",int(lct::sm[u]));
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2648</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct point{
	int x,y;
};
bool cmpx(point a,point b){
	return a.x&lt;b.x;
}
bool cmpy(point a,point b){
	return a.y&lt;b.y;
}
struct node{
	node(point _p){
		ch[0]=ch[1]=0;
		p=_p;
		xmi=xmx=p.x;
		ymi=ymx=p.y;
	}
	node*ch[2];
	point p;
	int xmi,xmx,ymi,ymx;
};
void update(node*x){
	lp(i,0,1)if(x-&gt;ch[i]){
		x-&gt;xmi=min(x-&gt;xmi,x-&gt;ch[i]-&gt;xmi);
		x-&gt;xmx=max(x-&gt;xmx,x-&gt;ch[i]-&gt;xmx);
		x-&gt;ymi=min(x-&gt;ymi,x-&gt;ch[i]-&gt;ymi);
		x-&gt;ymx=max(x-&gt;ymx,x-&gt;ch[i]-&gt;ymx);
	}
}
node*build(vector&lt;point&gt;&amp;a,int l,int r,int d){
	if(d==0)sort(a.begin()+l,a.begin()+r+1,cmpx);
	else sort(a.begin()+l,a.begin()+r+1,cmpy);
	int m=(l+r)/2;
	node*ret=new node(a[m]);
	if(l!=m)ret-&gt;ch[0]=build(a,l,m-1,d^1);
	if(m!=r)ret-&gt;ch[1]=build(a,m+1,r,d^1);
	update(ret);
	return ret;
}
void insert(node*&amp;x,point p,int d){
	if(!x)x=new node(p);
	else{
		int t=(d==0&amp;&amp;p.x&gt;x-&gt;p.x)||(d==1&amp;&amp;p.y&gt;x-&gt;p.y);
		insert(x-&gt;ch[t],p,d^1);
		update(x);
	}
}
int guess(node*x,point p){
	int r=0;
	if(p.x&lt;x-&gt;xmi)r+=x-&gt;xmi-p.x;
	if(p.x&gt;x-&gt;xmx)r+=p.x-x-&gt;xmx;
	if(p.y&lt;x-&gt;ymi)r+=x-&gt;ymi-p.y;
	if(p.y&gt;x-&gt;ymx)r+=p.y-x-&gt;ymx;
	return r;
	
}
int myabs(int x){
	return x&gt;0?x:-x;
}
int dist(point a,point b){
	return myabs(a.x-b.x)+myabs(a.y-b.y);
}
void query(node*x,int&amp;ans,point p){
	ans=min(ans,dist(p,x-&gt;p));
	int t1=x-&gt;ch[0]?guess(x-&gt;ch[0],p):~0u&gt;&gt;1;
	int t2=x-&gt;ch[1]?guess(x-&gt;ch[1],p):~0u&gt;&gt;1;
	if(t1&lt;t2){
		if(t1&lt;ans)query(x-&gt;ch[0],ans,p);
		if(t2&lt;ans)query(x-&gt;ch[1],ans,p);
	}else{
		if(t2&lt;ans)query(x-&gt;ch[1],ans,p);
		if(t1&lt;ans)query(x-&gt;ch[0],ans,p);
	}
}
int main(){
	int n,m;vector&lt;point&gt;pts;
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n){
		point t;sf("%d%d",&amp;t.x,&amp;t.y);
		pts.pb(t);
	}
	node*rt=build(pts,0,int(pts.size()-1),0);
	lp(i,1,m){
		int op;point t;sf("%d%d%d",&amp;op,&amp;t.x,&amp;t.y);
		if(op==1)insert(rt,t,0);
		else{
			int ans=~0u&gt;&gt;1;
			query(rt,ans,t);
			pf("%d\n",ans);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2653</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace input{
	int n,q,a[20010],t[25010][4];
	void run(){
		sf("%d",&amp;n);
		lp(i,1,n)sf("%d",&amp;a[i]);
		sf("%d",&amp;q);
		lp(i,1,q)lp(j,0,3)sf("%d",&amp;t[i][j]);
	}
}
namespace lisa{
	vector&lt;int&gt;data;
	void run(){
		lp(i,1,input::n)data.pb(input::a[i]);
		sort(data.begin(),data.end());
		data.erase(unique(data.begin(),data.end()),data.end());
	}
	int ask(int x){
		return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
	}
}
namespace segment{
	struct node{
		node(node*a,node*b,int c,int d,int e,int f,int g){
			ch[0]=a;ch[1]=b;l=c;r=d;lmx=e;rmx=f;sum=g;
		}
		node*ch[2];int l,r,lmx,rmx,sum;
	}*rts[20010];
	node*build(int l,int r){
		node*t=new node(0,0,l,r,r-l+1,r-l+1,r-l+1);
		if(l!=r){
			int m=(l+r)/2;
			t-&gt;ch[0]=build(l,m);
			t-&gt;ch[1]=build(m+1,r);
		}
		return t;
	}
	void update(node*x){
		x-&gt;sum=x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;sum;
		x-&gt;lmx=max(x-&gt;ch[0]-&gt;lmx,x-&gt;ch[0]-&gt;sum+x-&gt;ch[1]-&gt;lmx);
		x-&gt;rmx=max(x-&gt;ch[1]-&gt;rmx,x-&gt;ch[1]-&gt;sum+x-&gt;ch[0]-&gt;rmx);
	}
	node*edit(node*x,int p,int v){
		if(x-&gt;l==x-&gt;r)return new node(0,0,x-&gt;l,x-&gt;r,v,v,v);
		else{
			node*ret=new node(x-&gt;ch[0],x-&gt;ch[1],x-&gt;l,x-&gt;r,0,0,0);
			int m=(x-&gt;l+x-&gt;r)/2;
			if(p&lt;=m)ret-&gt;ch[0]=edit(x-&gt;ch[0],p,v);
			else ret-&gt;ch[1]=edit(x-&gt;ch[1],p,v);
			update(ret);
			return ret;
		}
	}
	node ask(node*x,int l,int r){
		if(x-&gt;l==l&amp;&amp;x-&gt;r==r)return*x;
		else{
			int m=(x-&gt;l+x-&gt;r)/2;
			if(r&lt;=m)return ask(x-&gt;ch[0],l,r);
			else if(l&gt;m)return ask(x-&gt;ch[1],l,r);
			else{
				node ret(0,0,l,r,0,0,0);
				node t1=ask(x-&gt;ch[0],l,m);
				node t2=ask(x-&gt;ch[1],m+1,r);
				ret.ch[0]=&amp;t1;
				ret.ch[1]=&amp;t2;
				update(&amp;ret);
				return ret;
			}
		}
	}
	int query(int a,int b,int c,int d,int v){
		if(b+1==c){
			node t1=ask(rts[v],a,b);
			node t2=ask(rts[v],c,d);
			return t1.rmx+t2.lmx;
		}else{
			node t1=ask(rts[v],a,b);
			node t2=ask(rts[v],c,d);
			node t3=ask(rts[v],b+1,c-1);
			return t1.rmx+t2.lmx+t3.sum;
		}
	}
	void run(){
		rts[0]=build(1,input::n);
		static vector&lt;int&gt;pos[20010];
		lp(i,1,input::n)pos[lisa::ask(input::a[i])].pb(i);
		lp(i,1,lisa::data.size()){
			rts[i]=rts[i-1];
			vp(j,pos[i-1])rts[i]=edit(rts[i],pos[i-1][j],-1);
		}
		ll lstans=0;
		lp(i,1,input::q){
			lp(j,0,3)input::t[i][j]=(input::t[i][j]+lstans)%input::n+1;
			sort(input::t[i],input::t[i]+4);
			int l=1,r=lisa::data.size()+1;
			while(l+1&lt;r){
				int m=(l+r)/2;
				if(query(input::t[i][0],input::t[i][1],input::t[i][2],input::t[i][3],m)&gt;=0)l=m;
				else r=m;
			}
			pf("%d\n",int(lstans=lisa::data[l-1]));
		}
	}
}
int main(){
	input::run();
	lisa::run();
	segment::run();
	return 0;
}
</pre><pre></pre><h2>Problem2654</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct edge{
	edge(){sf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c);++u;++v;d=0;}
	int u,v,w,c,d;
};
vector&lt;edge&gt;egs;int n,m,k;
bool operator&lt;(edge a,edge b){
	return a.w+a.d==b.w+b.d?a.c&lt;b.c:a.w+a.d&lt;b.w+b.d;
}
int pr[50010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
pair&lt;int,int&gt;mst(int x){
	vp(i,egs)if(egs[i].c==0)egs[i].d=x;
	sort(egs.begin(),egs.end());
	int r1=0,r2=0;
	lp(i,1,n)pr[i]=i;
	vp(i,egs){
		if(fd(egs[i].u)!=fd(egs[i].v)){
			pr[fd(egs[i].u)]=egs[i].v;
			r1+=egs[i].w+egs[i].d;
			r2+=1-egs[i].c;
		}
	}
	return mp(r1,r2);
}
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m)egs.pb(edge());
    int left=-100,right=100,ans;
    while(left&lt;=right){
        int mid=(left+right)/2;
        if(mst(mid).second&gt;=k){
            left=mid+1;
            ans=mid;
        }else{
            right=mid-1;
        }
    }
    pf("%d\n",mst(ans).first-k*ans);
    return 0;
}</pre><pre></pre><h2>Problem2654</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct edge{
    edge(){sf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c);++u;++v;d=0;}
    int u,v,w,c,d;
};
vector&lt;edge&gt;egs;int n,m,k;
bool operator&lt;(edge a,edge b){
    return a.w+a.d==b.w+b.d?a.c&lt;b.c:a.w+a.d&lt;b.w+b.d;
}
int pr[50010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
pair&lt;int,int&gt;mst(int x){
    vp(i,egs)if(egs[i].c==0)egs[i].d=x;
    sort(egs.begin(),egs.end());
    int r1=0,r2=0;
    lp(i,1,n)pr[i]=i;
    vp(i,egs){
        if(fd(egs[i].u)!=fd(egs[i].v)){
            pr[fd(egs[i].u)]=egs[i].v;
            r1+=egs[i].w+egs[i].d;
            r2+=1-egs[i].c;
        }
    }
    return mp(r1,r2);
}
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m)egs.pb(edge());
    int left=-200,right=200;
    while(left+1&lt;right){
        int mid=(left+right)/2;
        if(mst(mid).second&lt;k)right=mid;
        else left=mid;
    }
    pf("%d\n",mst(left).first-k*left);
    return 0;
}</pre><pre></pre><h2>Problem2656</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
void check(){
    static int a[81000];a[0]=0;a[1]=1;
    lp(i,2,80001)
        if(i%2)a[i]=a[(i-1)/2]+a[(i-1)/2+1];
        else a[i]=a[i/2];
    lp(i,1,100)pf("%d:%d\n",i,a[i]);pf("\n");
}
struct num{
    int d[310],l;
};
bool operator&lt;(num a,num b){
    if(a.l!=b.l)return a.l&lt;b.l;
    for(int i=a.l;i;--i)if(a.d[i]!=b.d[i])
        return a.d[i]&lt;b.d[i];
    return false;
}
num add1(num a){
    ++a.d[1];
    for(int i=1;i&lt;=a.l;++i){
        if(a.d[i]==10){
            if(i==a.l)++a.l,a.d[a.l]=0;
            a.d[i]=0,++a.d[i+1];
        }
    }
    return a;
}
num div2(num a){
    for(int i=a.l;i;--i){
        a.d[i-1]+=(a.d[i]%2)*10;
        a.d[i]/=2;
    }
    while(a.d[a.l]==0&amp;&amp;a.l&gt;1)--a.l;
    return a;
}
num operator+(num a,num b){
    num c;c.l=max(a.l,b.l);
    lp(i,1,min(a.l,b.l))c.d[i]=a.d[i]+b.d[i];
    lp(i,min(a.l,b.l)+1,a.l)c.d[i]=a.d[i];
    lp(i,min(a.l,b.l)+1,b.l)c.d[i]=b.d[i];
    for(int i=1;i&lt;=c.l;++i){
        if(c.d[i]&gt;9){
            if(i==c.l)++c.l,c.d[c.l]=0;
            c.d[i+1]+=c.d[i]/10;
            c.d[i]%=10;
        }
    }
    return c;
}
void print(num a){
    for(int i=a.l;i;--i)pf("%c",a.d[i]+'0');pf("\n");
}
map&lt;num,num&gt;mp;set&lt;num&gt;st;
num f(num x){
    if(st.count(x))return mp[x];
    else{
        st.insert(x);
        if(x.l==1&amp;&amp;x.d[1]==0){
            num t;t.l=1;t.d[1]=0;
            return mp[x]=t;
        }else if(x.l==1&amp;&amp;x.d[1]==1){
            num t;t.l=1;t.d[1]=1;
            return mp[x]=t;
        }else if(x.d[1]%2==0)return mp[x]=f(div2(x));
        else return mp[x]=f(div2(x))+f(add1(div2(x)));
    }
}
int main(){
    //check();
    int t;sf("%d",&amp;t);
    lp(i,1,t){
        char op[210];sf("%s",op+1);
        num n;n.l=strlen(op+1);
        lp(j,1,n.l)n.d[j]=op[n.l-j+1]-'0';
        print(f(n));
    }
    //ps;
    return 0;    
}

</pre><pre></pre><h2>Problem2683</h2><pre>#include&lt;iostream&gt;

#include&lt;cstdio&gt;



#include&lt;algorithm&gt;
using namespace std;
const int N=500000;
struct BIT{
    int n,a[N+1];
    BIT(int _n):
        n(_n){
        fill(a+1,a+n+1,0);
    }
    void add(int i,int d){
        for(;i&lt;=n;i+=i&amp;-i)
            a[i]+=d;
    }
    int ask(int i){
        int r=0;
        for(;i;i-=i&amp;-i)
            r+=a[i];
        return r;
    }
};
struct data{
    char typ;

    int x,y,delta;
        int id,t;

};
bool operator&lt;(data a,data b){
    return a.x&lt;b.x;
}

int n;
data ds[200000*4+10];
int dss;
int ans[200000+10];
int qid;
BIT*bit;
void work(int dsl,int dsr){
    if(dsl==dsr){
        return;
    }else{
        int dsm=(dsl+dsr)/2;
        work(dsl,dsm);
        work(dsm+1,dsr);
        static data op[200000*4+10];
        int ops=0;
        static data qu[200000*4+10];
        int qus=0;
        for(int i=dsl;i&lt;=dsm;++i)
            if(ds[i].typ=='A')
                op[++ops]=ds[i];
        for(int i=dsm+1;i&lt;=dsr;++i)
            if(ds[i].typ=='Q')
                qu[++qus]=ds[i];
        sort(op+1,op+ops+1);
        sort(qu+1,qu+qus+1);
        int ptr=1;
        for(int i=1;i&lt;=qus;++i){
            while(ptr&lt;=ops&amp;&amp;op[ptr].x&lt;=qu[i].x){
                bit-&gt;add(op[ptr].y,op[ptr].delta);
                ++ptr;
            }
            ans[qu[i].id]+=qu[i].t*bit-&gt;ask(qu[i].y);
        }
        ptr=1;
        for(int i=1;i&lt;=qus;++i){
            while(ptr&lt;=ops&amp;&amp;op[ptr].x&lt;=qu[i].x){
                bit-&gt;add(op[ptr].y,-op[ptr].delta);
                ++ptr;
            }
        }
    }
}

int main(){
    scanf("%d",&amp;n);
    bit=new BIT(n);
    for(int i=1;;++i){
        int t;scanf("%d",&amp;t);
        data tmp;
        if(t==1){
            int x,y,d;
            scanf("%d%d%d",&amp;x,&amp;y,&amp;d);
            tmp.typ='A';
            tmp.x=x;
            tmp.y=y;
            tmp.delta=d;
            ds[++dss]=tmp;
        }else if(t==2){
            ++qid;
            int x1,y1,x2,y2;
            scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            tmp.typ='Q';
            tmp.x=x2;
            tmp.y=y2;
            tmp.t=1;
            tmp.id=qid;
             ds[++dss]=tmp;

             if(x1!=1){
                 tmp.typ='Q';
                 tmp.x=x1-1;
                 tmp.y=y2;
                 tmp.t=-1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
             if(y1!=1){
                 tmp.typ='Q';
                 tmp.x=x2;
                 tmp.y=y1-1;
                 tmp.t=-1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
             if(x1!=1&amp;&amp;y1!=1){
                 tmp.typ='Q';
                 tmp.x=x1-1;
                 tmp.y=y1-1;
                 tmp.t=1;
                 tmp.id=qid;
                  ds[++dss]=tmp;
             }
        }else{
            break;
        }
    }
    work(1,dss);
    for(int i=1;i&lt;=qid;++i)
        printf("%d\n",ans[i]);
    return 0;
}
/*

16
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
1 2 3 3
2 1 1 3 3
1 2 2 2
2 2 2 3 4
*/
</pre><pre></pre><h2>Problem2697</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,k,c[310];
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,k)sf("%d",&amp;c[i]);
    sort(c+1,c+k+1);
    int ans=0;
    for(int i=k;i;--i){
        if(n&lt;2)break;
        ans+=(n-1)*c[i];
        n-=2;
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2705</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll phi(ll n){
    ll r=n;
    for(ll i=2;i*i&lt;=n;++i){
        if(n%i==0){
            r=r/i*(i-1);
            while(n%i==0)n/=i;
        }
    }
    if(n!=1)r=r/n*(n-1);
    return r;
}
int main(){
    //lp(i,1,10)pf("%d\n",phi(i));
    ll n;sf("%lld",&amp;n);ll ans=0;
    for(ll i=1;i*i&lt;=n;++i){
        if(n%i==0){
            ans+=phi(n/i)*i;
            if(i*i!=n)
                ans+=phi(i)*(n/i);
        }
    }
    pf("%lld\n",ans);//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2709</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
double L;int R,C;
char MAP[110][110];
pair&lt;int,int&gt;S,T;
struct node{
	node(pair&lt;int,int&gt;_p,double _d):
		p(_p),d(_d){}
	pair&lt;int,int&gt;p;double d;
};
bool operator&lt;(node a,node b){
	return a.d&gt;b.d;
}
double dijkstra(double v){
	static double dis[110][110];
	lp(i,1,R)lp(j,1,C)dis[i][j]=~0u&gt;&gt;1;
	dis[S.first][S.second]=0;
	priority_queue&lt;node&gt;qu;qu.push(node(S,0));
	while(true){
		node tmp=qu.top();qu.pop();
		if(dis[tmp.p.first][tmp.p.second]&lt;tmp.d-1e-8)continue;
		if(tmp.p==T)return tmp.d;
		int x=tmp.p.first,y=tmp.p.second;double d=tmp.d;
		//pf("(%d,%d):%lf\n",x,y,d);
		if(x!=1&amp;&amp;MAP[x-1][y]!='#'){
			if(d+v&lt;dis[x-1][y]-1e-8){
				dis[x-1][y]=d+v;
				qu.push(node(mp(x-1,y),d+v));
			}	
		}
		if(x!=R&amp;&amp;MAP[x+1][y]!='#'){
			if(d+v&lt;dis[x+1][y]-1e-8){
				dis[x+1][y]=d+v;
				qu.push(node(mp(x+1,y),d+v));
			}	
		}
		if(y!=1&amp;&amp;MAP[x][y-1]!='#'){
			if(d+1&lt;dis[x][y-1]-1e-8){
				dis[x][y-1]=d+1;
				qu.push(node(mp(x,y-1),d+1));
			}	
		}
		if(y!=C&amp;&amp;MAP[x][y+1]!='#'){
			if(d+1&lt;dis[x][y+1]-1e-8){
				dis[x][y+1]=d+1;
				qu.push(node(mp(x,y+1),d+1));
			}	
		}
	}
}
char reader(){
	char ret;
	for(ret=getchar();ret!='#'&amp;&amp;ret!=' '&amp;&amp;ret!='S'&amp;&amp;ret!='E';ret=getchar());
	return ret;
}
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		sf("%lf%d%d",&amp;L,&amp;R,&amp;C);while(getchar()!='\n');
		lp(i,1,R){
			lp(j,1,C){
				MAP[i][j]=reader();
				//pf("[%c]",MAP[i][j]);
			}
			if(i!=R)while(getchar()!='\n');
		}
		S=mp(-1,-1);
		T=mp(-1,-1);
		lp(i,1,R)lp(j,1,C){
			if(MAP[i][j]=='S')S=mp(i,j);
			else if(MAP[i][j]=='E')T=mp(i,j);
		}
		if(S.first&lt;0||T.first&lt;0)ps;
		//pf("[%d,%d][%d,%d]\n",S.first,S.second,T.first,T.second);
		double l=0,r=10;
		while(r-l&gt;1e-8){
			double m=(l+r)/2;
			if(dijkstra(m)&lt;L)l=m;
			else r=m;
		}
		pf("%.5lf\n",l);
	}
	return 0;
}
/*
2
2.5 4 5
#####
#S  #
#  E#
#####
21 13 12
############
#S##     #E#
# ##  #  # #
#   # #  # #
### # #  # #
#   # #  # #
#  ## #  # #
##  # #  # #
### # #  # #
##  # #  # #
#  ## #    #
#     #    #
############
*/</pre><pre></pre><h2>Problem2716</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct point{
	int x,y;
};
bool cmpx(point a,point b){
	return a.x&lt;b.x;
}
bool cmpy(point a,point b){
	return a.y&lt;b.y;
}
struct node{
	node(point _p){
		ch[0]=ch[1]=0;
		p=_p;
		xmi=xmx=p.x;
		ymi=ymx=p.y;
	}
	node*ch[2];
	point p;
	int xmi,xmx,ymi,ymx;
};
void update(node*x){
	lp(i,0,1)if(x-&gt;ch[i]){
		x-&gt;xmi=min(x-&gt;xmi,x-&gt;ch[i]-&gt;xmi);
		x-&gt;xmx=max(x-&gt;xmx,x-&gt;ch[i]-&gt;xmx);
		x-&gt;ymi=min(x-&gt;ymi,x-&gt;ch[i]-&gt;ymi);
		x-&gt;ymx=max(x-&gt;ymx,x-&gt;ch[i]-&gt;ymx);
	}
}
node*build(vector&lt;point&gt;&amp;a,int l,int r,int d){
	if(d==0)sort(a.begin()+l,a.begin()+r+1,cmpx);
	else sort(a.begin()+l,a.begin()+r+1,cmpy);
	int m=(l+r)/2;
	node*ret=new node(a[m]);
	if(l!=m)ret-&gt;ch[0]=build(a,l,m-1,d^1);
	if(m!=r)ret-&gt;ch[1]=build(a,m+1,r,d^1);
	update(ret);
	return ret;
}
void insert(node*&amp;x,point p,int d){
	if(!x)x=new node(p);
	else{
		int t=(d==0&amp;&amp;p.x&gt;x-&gt;p.x)||(d==1&amp;&amp;p.y&gt;x-&gt;p.y);
		insert(x-&gt;ch[t],p,d^1);
		update(x);
	}
}
int guess(node*x,point p){
	int r=0;
	if(p.x&lt;x-&gt;xmi)r+=x-&gt;xmi-p.x;
	if(p.x&gt;x-&gt;xmx)r+=p.x-x-&gt;xmx;
	if(p.y&lt;x-&gt;ymi)r+=x-&gt;ymi-p.y;
	if(p.y&gt;x-&gt;ymx)r+=p.y-x-&gt;ymx;
	return r;
	
}
int myabs(int x){
	return x&gt;0?x:-x;
}
int dist(point a,point b){
	return myabs(a.x-b.x)+myabs(a.y-b.y);
}
void query(node*x,int&amp;ans,point p){
	ans=min(ans,dist(p,x-&gt;p));
	int t1=x-&gt;ch[0]?guess(x-&gt;ch[0],p):~0u&gt;&gt;1;
	int t2=x-&gt;ch[1]?guess(x-&gt;ch[1],p):~0u&gt;&gt;1;
	if(t1&lt;t2){
		if(t1&lt;ans)query(x-&gt;ch[0],ans,p);
		if(t2&lt;ans)query(x-&gt;ch[1],ans,p);
	}else{
		if(t2&lt;ans)query(x-&gt;ch[1],ans,p);
		if(t1&lt;ans)query(x-&gt;ch[0],ans,p);
	}
}
int main(){
	int n,m;vector&lt;point&gt;pts;
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n){
		point t;sf("%d%d",&amp;t.x,&amp;t.y);
		pts.pb(t);
	}
	node*rt=build(pts,0,int(pts.size()-1),0);
	lp(i,1,m){
		int op;point t;sf("%d%d%d",&amp;op,&amp;t.x,&amp;t.y);
		if(op==1)insert(rt,t,0);
		else{
			int ans=~0u&gt;&gt;1;
			query(rt,ans,t);
			pf("%d\n",ans);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2718</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace hug{
	int cx,cy;vector&lt;int&gt;to[210];int lk[210],vi[210];
	int dfs(int u){
		vp(i,to[u]){
			int v=to[u][i];
			if(!vi[v]){
				vi[v]=1;
				if(!lk[v]||dfs(lk[v])){
					lk[v]=u;
					return 1;
				}
			}
		}
		return 0;
	}
	int solve(){
		int r=0;
		lp(i,1,cx){
			fill(vi+1,vi+cy+1,0);
			r+=dfs(i);
		}
		return r;
	}
}
int fld[210][210],n,m;
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,m){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		fld[a][b]=1;
	}
	lp(k,1,n)lp(i,1,n)lp(j,1,n)if(fld[i][k]&amp;&amp;fld[k][j])fld[i][j]=1;
	hug::cx=hug::cy=n;
	lp(i,1,n)lp(j,1,n)if(fld[i][j])hug::to[i].pb(j);
	pf("%d\n",n-hug::solve());
	return 0;
}</pre><pre></pre><h2>Problem2721</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
1/x+1/y=1/z的正整数解个数为z^2的约数个数
*/
ll pri[1000010],isp[1000010],n,p=1000000007;
ll fac(ll x,ll y){
	ll r=0;
	while(x){
		r+=x/y;
		x/=y;
	}
	return r;
}
ll ans[1000010];
int main(){
	sf("%lld",&amp;n);
	lp(i,2,n){
		if(!isp[i])pri[++pri[0]]=i;
		for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=n;++j){
			isp[pri[j]*i]=1;
			if(i%pri[j]==0)break;
		}
	}
	lp(i,1,pri[0])ans[i]=fac(n,pri[i])*2;
	ll t1=1;
	lp(i,1,pri[0])t1=t1*(ans[i]+1)%p;
	pf("%lld\n",t1);
	return 0;
}
</pre><pre></pre><h2>Problem2724</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr feopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int a[40010],n,org[40010],m;
void init(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;a[i]);
}
void lisa(){//checked
    static int b[40010];
    lp(i,1,n)b[i]=a[i],org[i]=a[i];
    sort(b+1,b+n+1);
    int c=unique(b+1,b+n+1)-b-1;
    lp(i,1,n)a[i]=lower_bound(b+1,b+c+1,a[i])-b;
    //lp(i,1,n)pf("[%d]",a[i]);
}
struct block{
    int c[40010],k,k_bac;
    block(){fill(c+1,c+n+1,0);k=-1;}
    void save(){k_bac=k;}
    void load(){k=k_bac;}
    void add(int x){
        ++c[a[x]];
        if(k==-1||c[a[x]]&gt;c[a[k]]||(c[a[x]]==c[a[k]]&amp;&amp;a[x]&lt;a[k]))k=x;
    }
    void del(int x){
        --c[a[x]];
    }
}bks[41][41],tmp;
int bg[2010],ed[2010],bs;
int bel[40010];
void make(){//checked
    int siz=max(1,int(pow(double(n),2.0/3.0)));
    int re=0;
    lp(i,1,n){
        if(!re){
            ++bs,re=siz;
            bg[bs]=i;
        }else --re;
        bel[i]=bs;
        ed[bs]=i;
    }
    lp(i,1,bs)lp(j,i,bs){
        lp(k,bg[i],ed[j]){
            bks[i][j].add(k);
        }
        //pf("[%d]",org[bks[i][j].k]);
    }
    //lp(i,1,bs)pf("[%d,%d]",bg[i],ed[i]);pf("\n");
    //lp(i,1,n)pf("[%d]",bel[i]);
}
int query(int l,int r){
    if(bel[l]==bel[r]){
        tmp.save();
        lp(i,l,r)tmp.add(i);
        int t=org[tmp.k];
        lp(i,l,r)tmp.del(i);
        tmp.load();
        return t;
    }else{
        int ll=l,rr=r;
        while(bel[ll-1]==bel[ll])++ll;
        while(bel[rr+1]==bel[rr])--rr;
        int uu=bel[ll],ww=bel[rr];
        //pf("[%d,%d]",l,r);
        block&amp;bk=uu&gt;ww?tmp:bks[uu][ww];
        bk.save();
        lp(i,l,ll-1)bk.add(i);
        lp(i,rr+1,r)bk.add(i);
        int t=org[bk.k];
        lp(i,l,ll-1)bk.del(i);
        lp(i,rr+1,r)bk.del(i);
        bk.load();
        return t;
    }
}
void answ(){
    int lst=0;
    lp(i,1,m){
        int l,r;sf("%d%d",&amp;l,&amp;r);
        l=(l+lst-1)%n+1,r=(r+lst-1)%n+1;
        if(l&gt;r)swap(l,r);
        pf("%d\n",lst=query(l,r));
    }
}
int main(){
    init();
    lisa();
    make();
    answ();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2729</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
 bigint()
 bigint(long long)
 bigint(bigint)
 bigint(char*)
 bigint(string)
 +, +=, ++
 -, -=, --
 *, *=
 /, /=
 &lt;&lt;, &lt;&lt;=
 ==, !=
 &lt;, &lt;=
 &gt;, &gt;=
 -
 !
 abs(bigint), bigint.abs()
 pow(bigint, unsigned), bigint.pow(unsigned)
 root(bigint, unsigned), bigint.root(unsigned)
 sqrt(bigint), bigint.sqrt()
 bigint.read(default = stdin)
 bigint.write(default = stdout)
 istream&gt;&gt;bigint
 ostream&lt;&lt;bigint
 enoughMemory() : optimize division and modulo
*/
#include &lt;iostream&gt;
 
#ifndef BIGINT
#define BIGINT 1
 
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;
 
static const unsigned base = 10000, length = 4;
static bool __enoughMemory = false;
 
typedef vector&lt;int&gt; vi;
typedef vector&lt;int&gt;::iterator viit;
typedef vector&lt;int&gt;::const_iterator vicit;
typedef vector&lt;int&gt;::reverse_iterator virit;
typedef vector&lt;int&gt;::const_reverse_iterator vicrit;
typedef complex&lt;double&gt; comp;
typedef vector&lt;comp&gt; vc;
typedef vector&lt;comp&gt;::iterator vcit;
 
class Bigint {
public :
    Bigint();
    template&lt;typename _Tp&gt; Bigint(_Tp);
    Bigint(const Bigint&amp;);
    Bigint(const char*);
    Bigint(const string&amp;);
     
    bool&amp; neg();
    const bool&amp; neg() const;
    vi&amp; num();
    const vi&amp; num() const;
     
    bool operator==(const Bigint&amp;) const;
    bool operator!=(const Bigint&amp;) const;
    bool operator&lt;(const Bigint&amp;) const;
    bool operator&lt;=(const Bigint&amp;) const;
    bool operator&gt;(const Bigint&amp;) const;
    bool operator&gt;=(const Bigint&amp;) const;
     
    Bigint&amp; operator+=(const Bigint&amp;);
    Bigint&amp; operator-=(const Bigint&amp;);
    Bigint&amp; operator*=(const Bigint&amp;);
    Bigint&amp; operator/=(const Bigint&amp;);
    Bigint&amp; operator%=(const Bigint&amp;);
    Bigint&amp; operator&lt;&lt;=(const unsigned&amp;);
    Bigint&amp; operator&gt;&gt;=(const unsigned&amp;);
     
    Bigint&amp; operator++();
    Bigint&amp; operator--();
    Bigint operator-() const;
    bool operator!() const;
     
    int compare(const Bigint&amp;) const;
    bool equal(const Bigint&amp;) const;
    bool less(const Bigint&amp;) const;
    bool lessOrEqual(const Bigint&amp;) const;
    bool greater(const Bigint&amp;) const;
    bool greaterOrEqual(const Bigint&amp;) const;
     
    Bigint&amp; abs();
    Bigint&amp; pow(unsigned);
    Bigint&amp; root(const unsigned&amp;);
    Bigint&amp; sqrt();
    void multiply10(const unsigned&amp;);
    void divide2();
     
    void add(const Bigint&amp;);
    void subtract(const Bigint&amp;);
    void multiply(const Bigint&amp;);
    void multiplySlow(const Bigint&amp;);
    void multiplyFast(const Bigint&amp;, const int&amp;, const int&amp;);
    pair&lt;vi, vi&gt; divide(const Bigint&amp;);
     
    Bigint&amp; read(FILE*);
    const Bigint&amp; write(FILE*) const;
     
private :
    bool _m_neg;
    vi _m_num;
     
    void adjust();
    comp exp(const double&amp;);
    void bitrev(const vcit&amp;, const int&amp;, const int&amp;, const int&amp;, const int&amp;);
    void fft(vc&amp;, const int&amp;, const int&amp;, const bool&amp;);
     
    void divideByZero();
    void imaginaryNumberUnsupported();
    void error(const string&amp;);
};
 
//pre-declaration
Bigint abs(const Bigint&amp;);
Bigint pow(const Bigint&amp;, const unsigned&amp;);
Bigint root(const Bigint&amp;, const unsigned&amp;);
Bigint sqrt(const Bigint&amp;);
istream&amp; operator&gt;&gt;(istream&amp;, Bigint&amp;);
ostream&amp; operator&lt;&lt;(ostream&amp;, const Bigint&amp;);
void enoughMemory();
 
//operator
inline Bigint operator+(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) += __y;
}
inline Bigint operator-(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) -= __y;
}
inline Bigint operator*(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) *= __y;
}
inline Bigint operator/(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) /= __y;
}
inline Bigint operator%(const Bigint&amp; __x, const Bigint&amp; __y) {
    return Bigint(__x) %= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&lt;&lt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &lt;&lt;= __y;
}
template&lt;typename _Tp&gt; inline Bigint operator&gt;&gt;(const Bigint&amp; __x, const _Tp&amp; __y) {
    return Bigint(__x) &gt;&gt;= __y;
}
 
//public
 
//constructor
inline Bigint::Bigint() {
    neg() = false;
    num().clear();
    num().push_back(0);
}
template&lt;typename _Tp&gt; inline Bigint::Bigint(_Tp __t) {
    if (__t &lt; 0) neg() = true, __t = -__t;
    else neg() = false;
    num().clear();
    while (__t &gt;= base) {
        num().push_back(__t % base);
        __t /= base;
    }
    num().push_back(__t);
}
inline Bigint::Bigint(const Bigint&amp; __t) {
    *this = __t;
}
inline Bigint::Bigint(const char* __c) {
    while (*__c) {
        if (*__c == '-' || *__c == '+' || '0' &lt;= *__c &amp;&amp; *__c &lt;= '9')
            break;
        ++__c;
    }
    if (*__c == '-') ++__c, neg() = true;
    else {
        neg() = false;
        if (*__c == '+') ++__c;
    }
    int __n = strlen(__c);
    num().clear();
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    const char* __t = __c + __n;
    while (__c + 1 != __t &amp;&amp; *__c == '0') ++__c;
    int __x = 0, __y = 1, __z = 0;
    while (__t-- != __c) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*__t - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
inline Bigint::Bigint(const string&amp; __s) {
    string::const_iterator i = __s.begin();
    string::const_iterator j = __s.end();
    while (i != j) {
        if (*i == '-' || *i == '+' || '0' &lt;= *i &amp;&amp; *i &lt;= '9')
            break;
        ++i;
    }
    if (i != j) {
        if (*i == '-') ++i, neg() = true;
        else {
            neg() = false;
            if (*i == '+') ++i;
        }
    }
    int __n = j - i;
    if (__n == 0) {
        neg() = false;
        num().push_back(0);
        return ;
    }
    while (i + 1 != j &amp;&amp; *i == '0') ++i;
    int __x = 0, __y = 1, __z = 0;
    while (j-- != i) {
        if (__z == 4) {
            num().push_back(__x);
            __x = 0, __y = 1, __z = 0;
        }
        __x += (*j - '0') * __y;
        __y = (__y &lt;&lt; 3) + (__y &lt;&lt; 1);
        ++__z;
    }
    num().push_back(__x);
}
 
inline bool&amp; Bigint::neg() {
    return _m_neg;
}
inline const bool&amp; Bigint::neg() const {
    return _m_neg;
}
inline vi&amp; Bigint::num() {
    return _m_num;
}
inline const vi&amp; Bigint::num() const {
    return _m_num;
}
 
//logical operator
inline bool Bigint::operator==(const Bigint&amp; __t) const {
    return neg() == __t.neg() &amp;&amp; equal(__t);
}
inline bool Bigint::operator!=(const Bigint&amp; __t) const {
    return neg() != __t.neg() || !equal(__t);
}
inline bool Bigint::operator&lt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greater(__t);
    return less(__t);
}
inline bool Bigint::operator&lt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return neg();
    if (neg()) return greaterOrEqual(__t);
    return lessOrEqual(__t);
}
inline bool Bigint::operator&gt;(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return less(__t);
    return greater(__t);
}
inline bool Bigint::operator&gt;=(const Bigint&amp; __t) const {
    if (neg() != __t.neg()) return __t.neg();
    if (neg()) return lessOrEqual(__t);
    return greaterOrEqual(__t);
}
 
//arithmetic operators
inline Bigint&amp; Bigint::operator+=(const Bigint&amp; __t) {
    if (neg() == __t.neg()) add(__t);
    else {
        int __x = compare(__t);
        if (__x == 0) *this = Bigint();
        else if (__x == -1) {
            Bigint __y = *this;
            *this = __t;
            subtract(__y);
        }
        else subtract(__t);
    }
    return *this;
}
inline Bigint&amp; Bigint::operator-=(const Bigint&amp; __t) {
    return *this += (-__t);
}
inline Bigint&amp; Bigint::operator*=(const Bigint&amp; __t) {
    if (*this != 0 &amp;&amp; __t != 0) {
        neg() = neg() != __t.neg();
        multiply(__t);
    }
    else *this = Bigint();
    return *this;
}
inline Bigint&amp; Bigint::operator/=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    if (less(__t)) *this = Bigint();
    else {
        neg() = neg() != __t.neg();
        num() = divide(__t).first;
        adjust();
    }
    return *this;
}
inline Bigint&amp; Bigint::operator%=(const Bigint&amp; __t) {
    if (__t == 0) divideByZero();
    num() = divide(__t).second;
    adjust();
    if (num().size() == 1 &amp;&amp; !*num().rbegin()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::operator&lt;&lt;=(const unsigned&amp; __y) {
    return *this *= Bigint(2).pow(__y);
}
inline Bigint&amp; Bigint::operator&gt;&gt;=(const unsigned&amp; __y) {
    for (unsigned i = 0 ; i &lt; __y ; ++i) divide2();
    return *this;
}
 
//self operator
inline Bigint&amp; Bigint::operator++() {
    return *this += 1;
}
inline Bigint&amp; Bigint::operator--() {
    return *this -= 1;
}
inline Bigint Bigint::operator-() const {
    Bigint __t = *this;
    if (__t != 0) __t.neg() ^= true;
    return __t;
}
inline bool Bigint::operator!() const {
    return *this == 0;
}
 
//comparator
inline int Bigint::compare(const Bigint&amp; __t) const {
    if (num().size() &lt; __t.num().size()) return -1;
    else if (num().size() &gt; __t.num().size()) return 1;
    vicrit i = num().rbegin();
    vicrit j = __t.num().rbegin();
    while (i != num().rend()) {
        if (*i &lt; *j) return -1;
        else if (*i &gt; *j) return 1;
        ++i, ++j;
    }
    return 0;
}
inline bool Bigint::equal(const Bigint&amp; __t) const {
    return compare(__t) == 0;
}
inline bool Bigint::less(const Bigint&amp; __t) const {
    return compare(__t) == -1;
}
inline bool Bigint::lessOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == -1 || __r == 0;
}
inline bool Bigint::greater(const Bigint&amp; __t) const {
    return compare(__t) == 1;
}
inline bool Bigint::greaterOrEqual(const Bigint&amp; __t) const {
    int __r = compare(__t);
    return __r == 1 || __r == 0;
}
 
//math
inline Bigint&amp; Bigint::abs() {
    if (neg()) neg() = false;
    return *this;
}
inline Bigint&amp; Bigint::pow(unsigned __y) {
    Bigint __x = *this;
    *this = 1;
    while (__y) {
        if (__y &amp; 1) *this *= __x;
        __x *= __x;
        __y &gt;&gt;= 1;
    }
    return *this;
}
inline Bigint&amp; Bigint::root(const unsigned&amp; __y = 2) {
    if (!__y) divideByZero();
    if (*this == 0 || __y == 1) return *this;
    bool __n = neg();
    if (__n)
        if (__y &amp; 1) neg() = false;
        else imaginaryNumberUnsupported();
    const double log2_10 = 3.3219280948873623478703194294893901758648313930245806;
    size_t __s = num().size();
    if (double(__s &lt;&lt; 2) * log2_10 &lt; __y) return *this = 1;
    __s = __s / __y + (__s % __y ? 1 : 0);
    int __l, __r, __m;
    Bigint __a = *this, __b, __c;
    num().clear();
    for (int i = __s - 1 ; i &gt;= 0 ; --i) {
        __l = 1, __r = base - 1;
        while (__l &lt;= __r) {
            __m = __l + __r &gt;&gt; 1;
            __b = *this;
            __b.num().insert(__b.num().begin(), __m);
            __b.pow(__y);
            __b.multiply10(i * __y &lt;&lt; 2);
            if (__b &lt;= __a) __l = __m + 1;
            else __r = __m - 1;
        }
        num().insert(num().begin(), __r);
    }
    neg() = __n;
    return *this;
}
inline Bigint&amp; Bigint::sqrt() {
    root();
    return *this;
}
inline void Bigint::multiply10(const unsigned&amp; __t) {
    if (!__t) return ;
    size_t __s = num().size();
    size_t __r = (__t &gt;&gt; 2) + (__t &amp; 3 ? 1 : 0);
    int __x = 0, __y, __z, __a, __b;
    if ((__t &amp; 3) == 0) __a = 1, __b = 10000;
    else if ((__t &amp; 3) == 1) __a = 1000, __b = 10;
    else if ((__t &amp; 3) == 2) __a = 100, __b = 100;
    else if ((__t &amp; 3) == 3) __a = 10, __b = 1000;
    num().resize(__s + __r);
    virit i = num().rbegin();
    virit j = i + __r;
    while (i != num().rbegin() + __s) {
        __y = *j++;
        __z = __y / __a;
        __x += __z;
        *i++ = __x;
        __x = (__y - __z * __a) * __b;
    }
    *i++ = __x;
    fill(i, num().rend(), 0);
    adjust();
}
inline void Bigint::divide2() {
    int __t = 0;
    for (virit i = num().rbegin() ; i != num().rend() ; ++i) {
        __t = (__t &amp; 1 ? base : 0) + *i;
        *i = __t &gt;&gt; 1;
    }
    adjust();
}
 
//+, -, *, /
inline void Bigint::add(const Bigint&amp; __t) {
    if (num().size() &lt; __t.num().size())
        num().resize(__t.num().size());
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (i != num().end() &amp;&amp; j != __t.num().end())
        *i++ += *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &gt;= base) {
            *i -= base;
            ++*(i + 1);
        }
    if (*i &gt;= base) {
        *i -= base;
        num().push_back(1);
    }
}
inline void Bigint::subtract(const Bigint&amp; __t) {
    viit i = num().begin();
    vicit j = __t.num().begin();
    while (j != __t.num().end())
        *i++ -= *j++;
    for (i = num().begin() ; i + 1 != num().end() ; ++i)
        if (*i &lt; 0) {
            *i += base;
            --*(i + 1);
        }
    adjust();
}
inline void Bigint::multiply(const Bigint&amp; __t) {
    int __n = max(num().size(), __t.num().size());
    int __l = 0;
    while ((1 &lt;&lt; __l) &lt; __n) ++__l;
    __n = 1 &lt;&lt; ++__l;
    if ((long long)num().size() * __t.num().size() &lt;= (long long)__n * __l * 20)
        multiplySlow(__t);
    else
        multiplyFast(__t, __n, __l);
    adjust();
}
inline void Bigint::multiplySlow(const Bigint&amp; __t) {
    int __n = num().size() + __t.num().size(), i, j, k;
    vi __x, __y;
    if (__t.num().size() * 4 &lt; num().size())
        __x = __t.num(), __y = num();
    else
        __x = num(), __y = __t.num();
    num().clear();
    num().resize(__n);
    for (i = 0 ; i &lt; __x.size() ; ++i) {
        k = __x[i];
        for (j = 0 ; j &lt; __y.size() ; ++j)
            num()[i + j] += k * __y[j];
        k = i + 1 + __y.size();
        for (j = 0 ; j &lt; k ; ++j) {
            num()[j + 1] += num()[j] / base;
            num()[j] %= base;
        }
    }
}
inline void Bigint::multiplyFast(const Bigint&amp; __t, const int&amp; __n, const int&amp; __l) {
    vc a, b;
    a.reserve(__n);
    b.reserve(__n);
    for (viit i = num().begin() ; i != num().end() ; ++i)
        a.push_back(comp(*i, 0));
    for (vicit i = __t.num().begin() ; i != __t.num().end() ; ++i)
        b.push_back(comp(*i, 0));
    a.resize(__n);
    b.resize(__n);
    fft(a, __l, __n, true);
    fft(b, __l, __n, true);
    vcit i = a.begin(), j = b.begin();
    while (i != a.end()) *i++ *= *j++;
    fft(a, __l, __n, false);
    long long __x = 0;
    num().resize(__n);
    i = a.begin();
    viit k = num().begin();
    while (i != a.end()) {
        __x = (long long)(i++ -&gt;real() / __n + 0.5) + __x / base;
        *k++ = __x % base;
    }
}
inline pair&lt;vi, vi&gt; Bigint::divide(const Bigint&amp; __t) {
    int __l, __r, __m, __n = num().size() - __t.num().size() + 1;
    Bigint __x = *this, __y = __t, __z;
    vi __v;
    __v.resize(__n);
    if (__enoughMemory) {
        Bigint __p[10];
        for (__m = 0 ; __m &lt; 10 ; ++__m) __p[__m] = __m * __y;
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            int k = 0;
            for (int j = 3 + (i &lt;&lt; 2) ; j &gt;= (i &lt;&lt; 2) ; --j) {
                __l = 1, __r = 9;
                while (__l &lt;= __r) {
                    __m = __l + __r &gt;&gt; 1;
                    __z = __p[__m];
                    __z.multiply10(j);
                    if (__z.greater(__x)) __r = __m - 1;
                    else __l = __m + 1;
                }
                k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + __r;
                __z = __p[__r];
                __z.multiply10(j);
                __x.subtract(__z);
            }
            __v[i] = k;
        }
    }
    else {
        for (int i = __n - 1 ; i &gt;= 0 ; --i) {
            __l = 1, __r = base - 1;
            while (__l &lt;= __r) {
                __m = __l + __r &gt;&gt; 1;
                __z = __m * __y;
                __z.multiply10(i &lt;&lt; 2);
                if (__z.greater(__x)) __r = __m - 1;
                else __l = __m + 1;
            }
            __v[i] = __r;
            __z = __r * __y;
            __z.multiply10(i &lt;&lt; 2);
            __x.subtract(__z);
        }
    }
    return make_pair(__v, __x.num());
}
 
//io
inline Bigint&amp; Bigint::read(FILE *in = stdin) {
    string __s = "";
    char __c = fgetc(in);
    while (true) {
        if (__c == '-' || __c == '+' || '0' &lt;= __c &amp;&amp; __c &lt;= '9' || __c == EOF)
            break;
        __c = fgetc(in);
    }
    while (true) {
        __s += __c;
        __c = fgetc(in);
        if (__c &lt; '0' || __c &gt; '9') break;
    }
    return *this = Bigint(__s.c_str());
}
inline const Bigint&amp; Bigint::write(FILE *out = stdout) const {
    vicrit i = num().rbegin();
    if (neg()) fprintf(out, "-");
    fprintf(out, "%d", *i++);
    while (i != num().rend()) fprintf(out, "%04d", *i++);
    return *this;
}
 
//private
 
//other
inline void Bigint::adjust() {
    virit i = num().rbegin();
    while (i + 1 != num().rend()) {
        if (*i) break;
        ++i;
    }
    num().erase(i.base(), num().end());
}
inline comp Bigint::exp(const double&amp; u) {
    return comp(cos(u), sin(u));
}
inline void Bigint::bitrev(const vcit&amp; i, const int&amp; __l, const int&amp; __p, const int&amp; __x, const int&amp; __y) {
    if (__p == 0) {
        if (__x &lt; __y) swap(*(i + __x), *(i + __y));
        return ;
    }
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1, __y);
    bitrev(i, __l, __p - 1, __x &lt;&lt; 1 | 1, __y | (1 &lt;&lt; __l - __p));
}
inline void Bigint::fft(vc&amp; __a, const int&amp; __l, const int&amp; __n, const bool&amp; __r) {
    const double __p = 3.141592653589793238462643383279;
    bitrev(__a.begin(), __l, __l, 0, 0);
    for (int i = 1 ; i &lt;= __l ; ++i) {
        int __m = 1 &lt;&lt; i;
        comp wm = exp((__r ? -2 : 2) * __p / __m);
        for (int k = 0 ; k &lt; __n ; k += __m) {
            comp w = 1;
            for (int j = 0 ; j &lt; __m / 2 ; ++j) {
                comp t = w * __a[k + j + __m / 2];
                comp u = __a[k + j];
                __a[k + j] = u + t;
                __a[k + j + __m / 2] = u - t;
                w *= wm;
            }
        }
    }
}
 
//error
inline void Bigint::divideByZero() {
    error("divide by zero");
}
inline void Bigint::imaginaryNumberUnsupported() {
    error("imaginary number unsupported");
}
inline void Bigint::error(const string&amp; __s) {
    fprintf(stderr, "%s\n", __s.c_str());
    cerr &lt;&lt; __s &lt;&lt; endl;
    abort();
}
 
//math
inline Bigint abs(const Bigint&amp; __x) {
    return Bigint(__x).abs();
}
inline Bigint pow(const Bigint&amp; __x, const unsigned&amp; __y) {
    return Bigint(__x).pow(__y);
}
inline Bigint root(const Bigint&amp; __x, const unsigned&amp; __y = 2) {
    return Bigint(__x).root(__y);
}
inline Bigint sqrt(const Bigint&amp; __x) {
    return Bigint(__x).sqrt();
}
 
//io
inline istream&amp; operator&gt;&gt;(istream&amp; __s, Bigint&amp; __t) {
    string __r;
    __s &gt;&gt; __r;
    __t = Bigint(__r);
    return __s;
}
inline ostream&amp; operator&lt;&lt;(ostream&amp; __s, const Bigint&amp; __t) {
    if (__t.neg()) __s &lt;&lt; '-';
    vicrit i = __t.num().rbegin();
    __s &lt;&lt; *i;
    while (++i != __t.num().rend()) {
        __s.width(length);
        __s.fill('0');
        __s &lt;&lt; *i;
    }
    return __s;
}
 
//optimization
inline void enoughMemory() {
    __enoughMemory = true;
}
 
#endif
/*
(n+2)!*P(n+3,m)-2(n+1)!*P(n+2,m)
*/
int n,m;
Bigint task1(){
	Bigint r=1;
	lp(i,1,n+2)r*=i;
	lp(i,n+3-m+1,n+3)r*=i;
	return r;
}
Bigint task2(){
	Bigint r=2;
	lp(i,1,n+1)r*=i;
	lp(i,n+2-m+1,n+2)r*=i;
	return r;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	cout&lt;&lt;task1()-task2()&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;complex&gt;
#include&lt;deque&gt;
typedef complex&lt;double&gt; point;
double eps=1e-16;
double dbs(double a){
	return a&gt;0?a:-a;
}
struct data{
	int x1,y1,y2;
}ds[100010];int n;
struct line{
	line(point a,point b):
		p(a),q(b),ar(arg(q-p)){}
	point p,q;double ar;
};
double det(point a,point b){
	return imag(conj(a)*b);
}
point operator*(line a,line b){
	point p1=a.p,q1=a.q,p2=b.p,q2=b.q;
	double a1=det(p2-q1,q2-p2);
	double a2=det(p1-q2,q2-p2);
	return (a1*p1+a2*q1)/(a1+a2);
}
bool operator&lt;(line a,line b){
	if(dbs(a.ar-b.ar)&lt;eps)return det(a.q-a.p,b.q-a.p)&lt;-eps;
	else return a.ar&lt;b.ar;
}
bool onleft(line a,line b,line c){
	point t=a*b;
	return det(t-c.p,c.q-c.p)&lt;-eps;
}
bool check(int lim){
	vector&lt;line&gt;lns;
	deque&lt;line&gt;ans;
	lp(i,1,lim){
		double x1=ds[i].x1,y1=ds[i].y1,y2=ds[i].y2;
		lns.pb(line(point(0.0,y1/x1),point(1.0,y1/x1-x1)));
		lns.pb(line(point(1.0,y2/x1-x1),point(0.0,y2/x1))); 
	}
	lns.pb(line(point(0.0,0.0),point(0.0,1e10)));
	lns.pb(line(point(0.0,1e10),point(-1e10,1e10)));
	lns.pb(line(point(-1e10,1e10),point(-1e10,0.0)));
	lns.pb(line(point(-1e10,0.0),point(0.0,0.0)));
	sort(lns.begin(),lns.end());
	vp(i,lns){
		while(ans.size()&gt;1&amp;&amp;!onleft(ans.back(),ans[ans.size()-2],lns[i]))
			ans.pop_back();
		while(ans.size()&gt;1&amp;&amp;!onleft(ans[0],ans[1],lns[i]))
			ans.pop_front();
		if(ans.empty()||dbs(ans.back().ar-lns[i].ar)&gt;eps)ans.pb(lns[i]);
	}
	while(ans.size()&gt;1&amp;&amp;!onleft(ans.back(),ans[ans.size()-2],ans.front()))
		ans.pop_back();
	return ans.size()&gt;2;
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d%d%d",&amp;ds[i].x1,&amp;ds[i].y1,&amp;ds[i].y2);
	int l=1,r=n;
	if(check(r))pf("%d\n",r);
	else{
		while(l+1&lt;r){
			int m=(l+r)/2;
			if(check(m))l=m;
			else r=m;
		}
		pf("%d\n",l);
	}
	return 0;
}</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct node{node():lc(0),rc(0),s(0){}node*lc,*rc;int s;};
void up(node*x){
    x-&gt;s=0;
    if(x-&gt;lc)x-&gt;s+=x-&gt;lc-&gt;s;
    if(x-&gt;rc)x-&gt;s+=x-&gt;rc-&gt;s;
}
void add(node*x,int l,int r,int t){
    if(l==r)++x-&gt;s;
    else{
        int m=(l+r)/2;
        if(t&lt;=m)add(x-&gt;lc?x-&gt;lc:(x-&gt;lc=new node()),l,m,t);
        else add(x-&gt;rc?x-&gt;rc:(x-&gt;rc=new node()),m+1,r,t);
        up(x);
    }
}
void merge(node*x,node*y,int l,int r){
    if(l==r)x-&gt;s+=y-&gt;s;
    else{
        int m=(l+r)/2;
        if(!x-&gt;lc)x-&gt;lc=y-&gt;lc;
        else if(y-&gt;lc)merge(x-&gt;lc,y-&gt;lc,l,m);
        if(!x-&gt;rc)x-&gt;rc=y-&gt;rc;
        else if(y-&gt;rc)merge(x-&gt;rc,y-&gt;rc,m+1,r);
        up(x);
    }
}
int query(node*x,int l,int r,int t){
    if(t&gt;x-&gt;s||t&lt;1)return 0;
    if(l==r)return l;
    else{
        int m=(l+r)/2;
        if(!x-&gt;lc||x-&gt;lc-&gt;s&lt;t)return query(x-&gt;rc,m+1,r,t-(x-&gt;lc?x-&gt;lc-&gt;s:0));
        else return query(x-&gt;lc,l,m,t);
    }
}
void print(node*x,int l,int r){
    pf("[%d,%d,%d]",l,r,x-&gt;s);
    if(l==r)return;
    else{
        int m=(l+r)/2;
        if(x-&gt;lc)print(x-&gt;lc,l,m);
        if(x-&gt;rc)print(x-&gt;rc,m+1,r);
    }
}
int n,m,w[100010],v[100010],q;
int pr[100010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
node*sg[100010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;w[i]);
        v[w[i]]=i;
        sg[i]=new node();
        add(sg[i],1,n,w[i]);
        pr[i]=i;
    }
    v[0]=-1;
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        if(fd(a)!=fd(b)){
            int t1=fd(a),t2=fd(b);
            merge(sg[t1],sg[t2],1,n);
            pr[fd(t2)]=t1;
        }
    }
    sf("%d",&amp;q);
    lp(i,1,q){
        char op[11];int a,b;
        sf("%s%d%d",op,&amp;a,&amp;b);
        if(op[0]=='Q')pf("%d\n",v[query(sg[fd(a)],1,n,b)]);
        else{
            if(fd(a)!=fd(b)){
                int t1=fd(a),t2=fd(b);
                merge(sg[t1],sg[t2],1,n);
                pr[fd(t2)]=t1;
            }
        }
        //lp(i,1,n)print(sg[i],1,n),pf("\n");
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct node{node():lc(0),rc(0),s(0){}node*lc,*rc;int s;}buff[7000000];int nw;
void up(node*x){
    x-&gt;s=0;
    if(x-&gt;lc)x-&gt;s+=x-&gt;lc-&gt;s;
    if(x-&gt;rc)x-&gt;s+=x-&gt;rc-&gt;s;
}
void add(node*x,int l,int r,int t){
    if(l==r)++x-&gt;s;
    else{
        int m=(l+r)/2;
        if(t&lt;=m)add(x-&gt;lc?x-&gt;lc:(x-&gt;lc=&amp;buff[++nw]),l,m,t);
        else add(x-&gt;rc?x-&gt;rc:(x-&gt;rc=&amp;buff[++nw]),m+1,r,t);
        up(x);
    }
}
void merge(node*x,node*y,int l,int r){
    if(l==r)x-&gt;s+=y-&gt;s;
    else{
        int m=(l+r)/2;
        if(!x-&gt;lc)x-&gt;lc=y-&gt;lc;
        else if(y-&gt;lc)merge(x-&gt;lc,y-&gt;lc,l,m);
        if(!x-&gt;rc)x-&gt;rc=y-&gt;rc;
        else if(y-&gt;rc)merge(x-&gt;rc,y-&gt;rc,m+1,r);
        up(x);
    }
}
int query(node*x,int l,int r,int t){
    if(t&gt;x-&gt;s||t&lt;1)return 0;
    if(l==r)return l;
    else{
        int m=(l+r)/2;
        if(!x-&gt;lc||x-&gt;lc-&gt;s&lt;t)return query(x-&gt;rc,m+1,r,t-(x-&gt;lc?x-&gt;lc-&gt;s:0));
        else return query(x-&gt;lc,l,m,t);
    }
}
void print(node*x,int l,int r){
    pf("[%d,%d,%d]",l,r,x-&gt;s);
    if(l==r)return;
    else{
        int m=(l+r)/2;
        if(x-&gt;lc)print(x-&gt;lc,l,m);
        if(x-&gt;rc)print(x-&gt;rc,m+1,r);
    }
}
int n,m,w[100010],v[100010],q;
int pr[100010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
node*sg[100010];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        sf("%d",&amp;w[i]);
        v[w[i]]=i;
        sg[i]=&amp;buff[++nw];
        add(sg[i],1,n,w[i]);
        pr[i]=i;
    }
    v[0]=-1;
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        if(fd(a)!=fd(b)){
            int t1=fd(a),t2=fd(b);
            merge(sg[t1],sg[t2],1,n);
            pr[fd(t2)]=t1;
        }
    }
    sf("%d",&amp;q);
    lp(i,1,q){
        char op[11];int a,b;
        sf("%s%d%d",op,&amp;a,&amp;b);
        if(op[0]=='Q')pf("%d\n",v[query(sg[fd(a)],1,n,b)]);
        else{
            if(fd(a)!=fd(b)){
                int t1=fd(a),t2=fd(b);
                merge(sg[t1],sg[t2],1,n);
                pr[fd(t2)]=t1;
            }
        }
        //lp(i,1,n)print(sg[i],1,n),pf("\n");
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int u=100010;
struct treap{
	int l,r,dat,val,siz;
	#define l(x) t[x].l
	#define r(x) t[x].r
	#define dat(x) t[x].dat
	#define val(x) t[x].val
	#define siz(x) t[x].siz
}t[u];
int ver[2*u],next[2*u],head[u],fa[u],f[u],cnt[u],v[u],n,m,q,i,x,y,tot,num;
char str[2];

void add(int x,int y)
{
	ver[++tot]=y,next[tot]=head[x],head[x]=tot;
}

int get(int x)
{
	if(x==fa[x]) return x;
	return fa[x]=get(fa[x]);
}

inline void update(int x)
{
	siz(x)=siz(l(x))+siz(r(x))+1; 
}

inline void zig(int &amp;x)
{
	int y=l(x); l(x)=r(y); r(y)=x;
	update(x),update(y),x=y;
}

inline void zag(int &amp;x)
{
	int y=r(x); r(x)=l(y); l(y)=x;;
	update(x),update(y),x=y;
}

void insert(int &amp;p,int x)
{
	if(dat(x)&lt;dat(p))
	{
		if(l(p)) insert(l(p),x); else l(p)=x;
		update(p); if(val(l(p))&lt;val(p)) zig(p);
	}
	else{
		if(r(p)) insert(r(p),x); else r(p)=x;
		update(p); if(val(r(p))&lt;val(p)) zag(p);
	}
}

void bfs(int x,int &amp;p)
{
	queue&lt;int&gt; q;
	q.push(x); v[x]=++num;
	while(q.size())
	{
		x=q.front(); q.pop();
		siz(x)=1,l(x)=r(x)=0;
		insert(p,x);
		for(int i=head[x];i;i=next[i])
			if(v[ver[i]]!=num) q.push(ver[i]),v[ver[i]]=num;
	}
}

void connect(int x,int y)
{
	x=get(x),y=get(y);
	if(x==y) return;
	if(cnt[x]&lt;cnt[y]) swap(x,y);
	bfs(y,f[x]);
	fa[y]=x,cnt[x]+=cnt[y];
	add(x,y),add(y,x);
}

int ask(int x,int y)
{
	if(y&gt;siz(x)) return -1;
	if(y==siz(l(x))+1) return x;
	if(y&lt;=siz(l(x))) return ask(l(x),y);
	return ask(r(x),y-siz(l(x))-1);
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(i=1;i&lt;=n;i++) scanf("%d",&amp;dat(i));
	for(i=1;i&lt;=n;i++) fa[i]=f[i]=i,cnt[i]=siz(i)=1,val(i)=rand()%32768;
	for(i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		connect(x,y);
	}
	cin&gt;&gt;q;
	for(i=1;i&lt;=q;i++)
	{
		scanf("%s%d%d",str,&amp;x,&amp;y);
		if(str[0]=='B') connect(x,y);
		else printf("%d\n",ask(f[get(x)],y));
	}
	return 0;
}
</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace ufs{
    const int nmx=100000;
    int p[nmx+10];
    int fd(int u){return u==p[u]?u:p[u]=fd(p[u]);}
    int lk(int u,int v){p[fd(u)]=v;}
}
namespace seg{
    struct node{
        node(int a,int b):
            lc(0),rc(0),ct(0),lt(a),rt(b){}
        node*lc,*rc;int ct,lt,rt;
    };
    node*merge(node*u,node*v){
        if(!u)return v;
        if(!v)return u;
        u-&gt;ct+=v-&gt;ct;
        if(u-&gt;lt!=u-&gt;rt)
            u-&gt;lc=merge(u-&gt;lc,v-&gt;lc),
            u-&gt;rc=merge(u-&gt;rc,v-&gt;rc);
        delete v;return u;
    }
    node*insert(node*u,int a){
        if(u-&gt;lt!=u-&gt;rt){
            int m=(u-&gt;lt+u-&gt;rt)/2;
            if(a&lt;=m){
                if(!u-&gt;lc)u-&gt;lc=new node(u-&gt;lt,m);
                insert(u-&gt;lc,a);
            }else{
                if(!u-&gt;rc)u-&gt;rc=new node(m+1,u-&gt;rt);
                insert(u-&gt;rc,a);
            }
        }
        ++u-&gt;ct;
    }
    int query(node*u,int k){
        if(u-&gt;ct&lt;k)return 0;
        if(u-&gt;lt==u-&gt;rt)return u-&gt;lt;
        else{
            int t=u-&gt;lc?u-&gt;lc-&gt;ct:0;
            if(k&lt;=t)
                return query(u-&gt;lc,k);
            else
                return query(u-&gt;rc,k-t);
        }
    }
    void print(node*u){
        if(u-&gt;lt==u-&gt;rt){
            if(u-&gt;ct)pf("[%d]",u-&gt;lt);
        }else{
            if(u-&gt;lc)print(u-&gt;lc);
            if(u-&gt;rc)print(u-&gt;rc);
        }
    }
}
seg::node*nd[100010];
int mp[100010];
int main(){
    mp[0]=-1;
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        nd[i]=new seg::node(1,n);
        seg::insert(nd[i],t);
        ufs::p[i]=i;
        mp[t]=i;
    }
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        if(ufs::fd(a)!=ufs::fd(b)){
            int d=ufs::fd(a),e=ufs::fd(b);
            nd[e]=seg::merge(nd[e],nd[d]);
            ufs::lk(d,e);
        }
    }
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[11];int a,b;
        sf("%s%d%d",op,&amp;a,&amp;b);
        if(op[0]=='Q')pf("%d\n",mp[seg::query(nd[ufs::fd(a)],b)]);
        else{
            if(ufs::fd(a)!=ufs::fd(b)){
                int d=ufs::fd(a),e=ufs::fd(b);
                nd[e]=seg::merge(nd[e],nd[d]);
                ufs::lk(d,e);
            }
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2733</h2><pre>#ifndef MERGABLE_SEGMENT_TREE
#define MERGABLE_SEGMENT_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct MergableSegmentTree{
        struct node{
            node(int a,int b):lc(0),rc(0),ct(0),lt(a),rt(b){}
            node*lc,*rc;int ct,lt,rt;}*root;
        MergableSegmentTree(int l,int r):root(new node(l,r)){}
        node*merge(node*u,node*v){
            if(!u)return v;if(!v)return u;u-&gt;ct+=v-&gt;ct;
            if(u-&gt;lt!=u-&gt;rt)u-&gt;lc=merge(u-&gt;lc,v-&gt;lc),u-&gt;rc=merge(u-&gt;rc,v-&gt;rc);
            delete v;return u;}
        void modify(int a,int d,node*u=0){
            if((u?0:(u=root)),u-&gt;lt!=u-&gt;rt){
                int m=(u-&gt;lt+u-&gt;rt)/2;
                if(a&lt;=m)modify(a,d,u-&gt;lc?u-&gt;lc:(u-&gt;lc=new node(u-&gt;lt,m)));
                else modify(a,d,u-&gt;rc?u-&gt;rc:( u-&gt;rc=new node(m+1,u-&gt;rt)));}
            u-&gt;ct+=d;}
        int query(int k,node*u=0){
            if((u?0:(u=root)),u-&gt;lt==u-&gt;rt)return u-&gt;lt;
            else if(k&lt;=(u-&gt;lc?u-&gt;lc-&gt;ct:0))return query(k,u-&gt;lc);
            else return query(k-(u-&gt;lc?u-&gt;lc-&gt;ct:0),u-&gt;rc);}
        int size(){return root-&gt;ct;}
        void merge(MergableSegmentTree&amp;a){
            root=merge(root,a.root);
            a.root=new node(root-&gt;lt,root-&gt;rt);}};}
#endif
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace ufs{
    const int nmx=100000;
    int p[nmx+10];
    int fd(int u){return u==p[u]?u:p[u]=fd(p[u]);}
    int lk(int u,int v){p[fd(u)]=v;}
}
using namespace CTL;
MergableSegmentTree* nd[100010];
int mp[100010];
int main(){
    mp[0]=-1;
    int n,m;sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        nd[i]=new MergableSegmentTree(1,n);
        nd[i]-&gt;modify(t,1);
        ufs::p[i]=i;
        mp[t]=i;
    }
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        if(ufs::fd(a)!=ufs::fd(b)){
            int d=ufs::fd(a),e=ufs::fd(b);
 nd[e]-&gt;merge(*nd[d]);
            ufs::lk(d,e);
        }
    }
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        char op[11];int a,b;
        sf("%s%d%d",op,&amp;a,&amp;b);
        if(op[0]=='Q'){
            int ans;
            if(b&gt;=1&amp;&amp;b&lt;=nd[ufs::fd(a)]-&gt;size())
                ans=nd[ufs::fd(a)]-&gt;query(b);
            else ans=0;
            pf("%d\n",mp[ans]);
        }
        else{
            if(ufs::fd(a)!=ufs::fd(b)){
                int d=ufs::fd(a),e=ufs::fd(b);
              nd[e]-&gt;merge(*nd[d]);
                ufs::lk(d,e);
            }
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2738</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct query{
    int tp;//1:add 2:ask
    int x,y,va;
    int x1,y1,x2,y2,k,now,idx;
}qs[400010];int qz;
int ans[100010],as;
int n,q;
int lisa[400010],lisas;
void init(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n)lp(j,1,n){
        ++qz;qs[qz].x=i;qs[qz].y=j;
        qs[qz].tp=1;
        sf("%d",&amp;qs[qz].va);
        lisa[++lisas]=qs[qz].va;
    }
    sort(lisa+1,lisa+lisas+1);
    lisas=unique(lisa+1,lisa+lisas+1)-lisa-1;
    lp(i,1,qz)qs[i].va=lower_bound(lisa+1,lisa+lisas+1,qs[i].va)-lisa;
    lp(i,1,q){
        ++qz;sf("%d%d%d%d%d",&amp;qs[qz].x1,&amp;qs[qz].y1,
            &amp;qs[qz].x2,&amp;qs[qz].y2,&amp;qs[qz].k);
        qs[qz].tp=2;
        qs[qz].now=0;qs[qz].idx=++as;
    }
}
void print(){
    lp(i,1,as)pf("%d\n",lisa[ans[i]]);
}
int db[510][510];
void add(int x,int y,int d){
    for(int i=x;i&lt;=n;i+=i&amp;-i)
        for(int j=y;j&lt;=n;j+=j&amp;-j)
            db[i][j]+=d;
}
int ask(int x,int y){
    int r=0;
    for(int i=x;i;i-=i&amp;-i)
        for(int j=y;j;j-=j&amp;-j)
            r+=db[i][j];
    return r;
}
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)ans[qs[i].idx]=vl;
    }else{
        static int dlt[400010];
        int vm=vl+(vr-vl)/2;
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].va&lt;=vm)add(qs[i].x,qs[i].y,1);
            else if(qs[i].tp==2)dlt[i]=ask(qs[i].x2,qs[i].y2)-ask(qs[i].x2,qs[i].y1-1)-
                ask(qs[i].x1-1,qs[i].y2)+ask(qs[i].x1-1,qs[i].y1-1);
        }
        lp(i,ql,qr){
            if(qs[i].tp==1&amp;&amp;qs[i].va&lt;=vm)add(qs[i].x,qs[i].y,-1);
        }
        static query lq[400010],rq[400010];int lqs=0,rqs=0;
        lp(i,ql,qr){
            if(qs[i].tp==1){
                if(qs[i].va&lt;=vm)lq[++lqs]=qs[i];
                else rq[++rqs]=qs[i];
            }else{
                if(qs[i].now+dlt[i]&lt;=qs[i].k-1){
                    qs[i].now+=dlt[i];
                    rq[++rqs]=qs[i];
                }else lq[++lqs]=qs[i];
            }
        }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,1,lisas);
    print();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2739</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef double ll;
using namespace std;
struct point{int x,y,e;};
struct node{node*lc,*rc;int xi,xa,yi,ya;point p;}nds[500010];int nww=0;
point pts[500010],pts2[500010];
int n,m;
inline bool cmpx(point a,point b){return a.x&lt;b.x;}
inline bool cmpy(point a,point b){return a.y&lt;b.y;}
inline node*build(int l,int r,int s){
    node*x=&amp;nds[nww++];int m=l+((r-l)&gt;&gt;1);
    nth_element(pts+l,pts+m,pts+r+1,s?cmpy:cmpx);x-&gt;p=pts[m];
    x-&gt;xi=x-&gt;xa=x-&gt;p.x;x-&gt;yi=x-&gt;ya=x-&gt;p.y;
    if(l&lt;=m-1){
        x-&gt;lc=build(l,m-1,!s);
        x-&gt;xi=min(x-&gt;xi,x-&gt;lc-&gt;xi);
        x-&gt;xa=max(x-&gt;xa,x-&gt;lc-&gt;xa);
        x-&gt;yi=min(x-&gt;yi,x-&gt;lc-&gt;yi);
        x-&gt;ya=max(x-&gt;ya,x-&gt;lc-&gt;ya);
    }else x-&gt;lc=0;
    if(m+1&lt;=r){
        x-&gt;rc=build(m+1,r,!s);
        x-&gt;xi=min(x-&gt;xi,x-&gt;rc-&gt;xi);
        x-&gt;xa=max(x-&gt;xa,x-&gt;rc-&gt;xa);
        x-&gt;yi=min(x-&gt;yi,x-&gt;rc-&gt;yi);
        x-&gt;ya=max(x-&gt;ya,x-&gt;rc-&gt;ya);
    }else x-&gt;rc=0;
    return x;
}
inline ll dis(point a,point b){return ll(a.x-b.x)*ll(a.x-b.x)+ll(a.y-b.y)*ll(a.y-b.y);}
int qk;point qp;pair&lt;ll,point&gt;ans;
inline bool cmp(pair&lt;ll,point&gt; a,pair&lt;ll,point&gt; b){
    if(a.first==b.first)return a.second.e&lt;b.second.e;
    else return a.first&gt;b.first;
}
inline void update(point p){
    pair&lt;ll,point&gt; t=make_pair(dis(p,qp),p);
    if(cmp(t,ans))ans=t;
}
inline ll mab(ll a){return a&gt;0?a:-a;}
inline ll mdis(node*x){
    ll t1=max(mab(x-&gt;xi-qp.x),mab(x-&gt;xa-qp.x));
    ll t2=max(mab(x-&gt;yi-qp.y),mab(x-&gt;ya-qp.y));
    return t1*t1+t2*t2;
}
inline void query(node*x){
    update(x-&gt;p);
    ll t1=x-&gt;lc?mdis(x-&gt;lc):-2;
    ll t2=x-&gt;rc?mdis(x-&gt;rc):-2;
    if(t1&gt;t2){
        if(t1&gt;=ans.first)query(x-&gt;lc);
        if(t2&gt;=ans.first)query(x-&gt;rc);
    }else{
        if(t2&gt;=ans.first)query(x-&gt;rc);
        if(t1&gt;=ans.first)query(x-&gt;lc);
    }
}
char bin[10000010],*pin=bin;
char bout[10000010],*pout=bout;
inline bool dig(char c){
    return (c&gt;='0'&amp;&amp;c&lt;='9')||(c=='-');
}
inline char gchr(){
    for(;!dig(*pin);++pin);
    return *pin++;
}
inline int gint(){
    int t=gchr(),flg=1;
    if(t=='-')flg=-1,t=0;
    else t-='0';
    for(;dig(*pin);++pin)t=t*10+*pin-'0';
    return t*flg;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)*pout++='0'+tmp[i];
    *pout++='\n';
}
int main(){
	fread(bin,1,10000000,stdin);
	int test=gint();
	lp(kase,1,test){
    	n=gint();nww=0;
    	lp(i,1,n){pts[i].x=gint();pts[i].y=gint();pts[i].e=i;pts2[i]=pts[i];}
    	node*rt=build(1,n,0);
    	m=n;
    	lp(i,1,m){
    		qp.x=pts2[i].x;qp.y=pts2[i].y;qk=1;
        	ans=make_pair(-1ll,point());
        	query(rt);
        	pint(ans.second.e);
    	}
    }
    fwrite(bout,1,pout-bout,stdout);
    return 0;
}</pre><pre></pre><h2>Problem2743</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;que[1000010][2];
int pr[1000010],bk[1000010],n,c,q,a[1000010],ans[1000010];
namespace bit{
    int dt[1000010];
    void init(){lp(i,1,n)dt[i]=0;}
    void add(int x,int d){for(;x&lt;=n;x+=x&amp;-x)dt[x]+=d;}
    int ask(int x){int r=0;for(;x;x-=x&amp;-x)r+=dt[x];return r;}
}
int main(){
    sf("%d%d%d",&amp;n,&amp;c,&amp;q);
    bit::init();
    lp(i,1,n)sf("%d",&amp;a[i]),pr[i]=bk[a[i]],bk[a[i]]=i;
    lp(i,1,q){
        int l,r;sf("%d%d",&amp;l,&amp;r);
        que[r][0].push_back(i);
        que[r][1].push_back(l);
    }
    lp(i,1,n){
        if(pr[i]){
            if(pr[pr[i]])bit::add(pr[pr[i]],-1);
            bit::add(pr[i],1);
        }
        lp(j,0,int(que[i][0].size()-1)){
            int idx=que[i][0][j],lt=que[i][1][j];
            ans[idx]=bit::ask(i)-bit::ask(lt-1);
        }
    }
    lp(i,1,n)bk[a[i]]=0;
    lp(i,1,q)pf("%d\n",ans[i]);//ps;
    return 0;
} 
</pre><pre></pre><h2>Problem2748</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int f[110][1010],n,bg,mx;
int main(){
    sf("%d%d%d",&amp;n,&amp;bg,&amp;mx);
    f[0][bg]=1;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        lp(j,0,mx)
            if(f[i-1][j]){
                if(j+t&lt;=mx)f[i][j+t]=1;
                if(j-t&gt;=0)f[i][j-t]=1;
            }
    }
    int ans=-1;
    lp(i,0,mx)if(f[n][i])ans=i;
    pf("%d\n",ans);//ps;
    return 0;
} 
</pre><pre></pre><h2>Problem2754</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
struct node{
	map&lt;int,node*&gt;tr;
	node*fa;int mrk,cnt,opt;
}nds[460010];int nw=1;
typedef map&lt;int,node*&gt;::iterator iter;
node*rt=nds;
int tmp[460010];int len;
node*insert(){
	node*x=rt;
	for(int i=1;i&lt;=len;++i){
		if(!x-&gt;tr.count(tmp[i]))
			x-&gt;tr[tmp[i]]=&amp;nds[nw++];
		x=x-&gt;tr[tmp[i]];
	}
	++x-&gt;opt;
	return x;
}
void build(){
	queue&lt;node*&gt;qu;
	for(iter i=rt-&gt;tr.begin();i!=rt-&gt;tr.end();++i){
		qu.push(i-&gt;second);
		i-&gt;second-&gt;fa=rt;
	}
	while(!qu.empty()){
		node*u=qu.front();qu.pop();
		for(iter i=u-&gt;tr.begin();i!=u-&gt;tr.end();++i){
			node*p=u-&gt;fa,*v=i-&gt;second;int w=i-&gt;first;
			while(p!=rt&amp;&amp;!p-&gt;tr.count(w))p=p-&gt;fa;
			if(p-&gt;tr.count(w))v-&gt;fa=p-&gt;tr[w];
			else v-&gt;fa=rt;
			qu.push(v);
		}
	}
}
vector&lt;int&gt;xi[200010][2];
void rrrd(vector&lt;int&gt;&amp;v){
	int t;sf("%d",&amp;t);
	lp(i,1,t){
		int t2;sf("%d",&amp;t2);
		v.pb(t2);
	}
}
int n,m;
int ans[200010];
node*rmm[200010];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n){
		rrrd(xi[i][0]);
		rrrd(xi[i][1]);
	}
	lp(i,1,m){
		sf("%d",&amp;len);
		lp(j,1,len)sf("%d",&amp;tmp[j]);
		rmm[i]=insert();
	}
	build();
	lp(i,1,n){
		lp(ppp,0,1){
			vector&lt;int&gt;&amp;a=xi[i][ppp];
			node*u=rt;
			vp(j,a){
				int c=a[j];
				while(u!=rt&amp;&amp;!u-&gt;tr.count(c))u=u-&gt;fa;
				if(u-&gt;tr.count(c))u=u-&gt;tr[c];
				node*v=u;
				while(v!=rt&amp;&amp;v-&gt;mrk!=i){
					v-&gt;mrk=i;
					++v-&gt;cnt;
					ans[i]+=v-&gt;opt;
					v=v-&gt;fa;
				}
			}
		}
	}
	lp(i,1,m)pf("%d\n",rmm[i]-&gt;cnt);
	lp(i,1,n)pf("%d%c",ans[i],i==n?'\n':' ');
	return 0;
}
</pre><pre></pre><h2>Problem2756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll big=10000000000000000ll;
namespace isap{
	struct edge{
		edge(int a,ll b):v(a),c(b){}
		int v;ll c;
	};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
	int dis[100010],gap[100010],vcnt;
	void clear(){
		lp(i,1,vcnt){
			to[i].clear();
			dis[i]=0;
			gap[i]=0;
		}
		eg.clear();
		gap[0]=vcnt;
	}
	void add(int u,int v,ll c){
		to[u].pb(eg.size());
		eg.pb(edge(v,c));
		to[v].pb(eg.size());
		eg.pb(edge(u,0));
	}
	ll dfs(int u,ll f){
		if(u==vcnt)return f;
		ll g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
				ll t=dfs(e.v,min(g,e.c));
				e.c-=t,ev.c+=t,g-=t;
				if(!g||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	ll solve(){
		ll r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,big);
		return r;
	}
}
ll n,m,a[110][110],idst,idet,idx[110][110];
bool check(ll mid){
	isap::clear();
	ll ret=0;
	lp(i,1,n)lp(j,1,m){
		if((i+j)&amp;1){
			isap::add(idst,idx[i][j],mid-a[i][j]);
			ret+=mid-a[i][j];
			if(i!=1)isap::add(idx[i][j],idx[i-1][j],big);
			if(i!=n)isap::add(idx[i][j],idx[i+1][j],big);
			if(j!=1)isap::add(idx[i][j],idx[i][j-1],big);
			if(j!=m)isap::add(idx[i][j],idx[i][j+1],big);
		}else{
			isap::add(idx[i][j],idet,mid-a[i][j]);
		}
	}
	return isap::solve()==ret;
}
int main(){
	ll test;sf("%lld",&amp;test);
	lp(kase,1,test){
		ll cj=0,co=0,sj=0,so=0;
		sf("%lld%lld",&amp;n,&amp;m);
		lp(i,1,n)lp(j,1,m){
			sf("%lld",&amp;a[i][j]);
			if((i+j)&amp;1)++cj,sj+=a[i][j];
			else ++co,so+=a[i][j];
		}
		ll nw=0;
		idst=++nw;lp(i,1,n)lp(j,1,m)idx[i][j]=++nw;idet=++nw;
		isap::vcnt=nw;
		if(cj==co){
			ll l=0,r=2000000000;
			lp(i,1,n)lp(j,1,m)l=max(l,a[i][j]);
			--l;
			if(!check(r))pf("-1\n");
			else{
				while(l+1&lt;r){
					ll mid=(l+r)/2;
					if(check(mid))r=mid;
					else l=mid;
				}
				//pf("[%lld]\n",r);
				pf("%lld\n",(n*m*r-(so+sj))/2);
			}
		}else{
			if(cj&gt;co)swap(cj,co),swap(sj,so);
			if(so&lt;sj)pf("-1\n");
			else if((so-sj)%(co-cj)!=0)pf("-1\n");
			else{
				ll t=(so-sj)/(co-cj),flg=0;
				lp(i,1,n)lp(j,1,m)if(a[i][j]&gt;t)flg=1;
				if(flg)pf("-1\n");
				else if(check(t))pf("%lld\n",(n*m*t-(so+sj))/2);
				else pf("-1\n");
			}
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll big=10000000000000000ll;
namespace isap{
    struct edge{
        edge(int a,ll b):v(a),c(b){}
        int v;ll c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],gap[100010],vcnt;
    void clear(){
        lp(i,1,vcnt){
            to[i].clear();
            dis[i]=0;
            gap[i]=0;
        }
        eg.clear();
        gap[0]=vcnt;
    }
    void add(int u,int v,ll c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        to[v].pb(eg.size());
        eg.pb(edge(u,0));
    }
    ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]==dis[e.v]+1){
                ll t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    ll solve(){
        ll r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
ll n,m,a[110][110],idst,idet,idx[110][110];
bool check(ll mid){
    isap::clear();
    ll ret=0;
    lp(i,1,n)lp(j,1,m){
        if((i+j)&amp;1){
            isap::add(idst,idx[i][j],mid-a[i][j]);
            ret+=mid-a[i][j];
            if(i!=1)isap::add(idx[i][j],idx[i-1][j],big);
            if(i!=n)isap::add(idx[i][j],idx[i+1][j],big);
            if(j!=1)isap::add(idx[i][j],idx[i][j-1],big);
            if(j!=m)isap::add(idx[i][j],idx[i][j+1],big);
        }else{
            isap::add(idx[i][j],idet,mid-a[i][j]);
        }
    }
    return isap::solve()==ret;
}
int main(){
    ll test;sf("%lld",&amp;test);
    lp(kase,1,test){
        ll cj=0,co=0,sj=0,so=0;
        sf("%lld%lld",&amp;n,&amp;m);
        lp(i,1,n)lp(j,1,m){
            sf("%lld",&amp;a[i][j]);
            if((i+j)&amp;1)++cj,sj+=a[i][j];
            else ++co,so+=a[i][j];
        }
        ll nw=0;
        idst=++nw;lp(i,1,n)lp(j,1,m)idx[i][j]=++nw;idet=++nw;
        isap::vcnt=nw;
        if(cj==co){
            ll l=0,r=2000000000;
            lp(i,1,n)lp(j,1,m)l=max(l,a[i][j]);
            --l;
            if(!check(r))pf("-1\n");
            else{
                while(l+1&lt;r){
                    ll mid=(l+r)/2;
                    if(check(mid))r=mid;
                    else l=mid;
                }
                //pf("[%lld]\n",r);
                pf("%lld\n",(n*m*r-(so+sj))/2);
            }
        }else{
            if(cj&gt;co)swap(cj,co),swap(sj,so);
            if(so&lt;sj)pf("-1\n");
            else if((so-sj)%(co-cj)!=0)pf("-1\n");
            else{
                ll t=(so-sj)/(co-cj),flg=0;
                lp(i,1,n)lp(j,1,m)if(a[i][j]&gt;t)flg=1;
                if(flg)pf("-1\n");
                else if(check(t))pf("%lld\n",(n*m*t-(so+sj))/2);
                else pf("-1\n");
            }
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem2761</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int main(){
    int t;sf("%d",&amp;t);
    lp(i,1,t){
        set&lt;int&gt;st;
        int n;sf("%d",&amp;n);
        bool f=0;
        lp(i,1,n){
            int k;sf("%d",&amp;k);
            if(!st.count(k)){
                st.insert(k);
                if(f)pf(" ");
                else f=1;
                pf("%d",k);
            }
        }
        pf("\n");
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2763</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
vector&lt;int&gt;to[10010],we[10010];
int n,s,t,m,k,f[10010][11],in[10010][11];
int main(){
    sf("%d%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;s,&amp;t);++s,++t;
    lp(i,1,m){
        int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
        ++a;++b;
        to[a].push_back(b);
        we[a].push_back(c);
        to[b].push_back(a);
        we[b].push_back(c);
    }
    lp(i,1,n)lp(j,0,k)f[i][j]=~0u&gt;&gt;1;
    f[s][0]=0;in[s][0]=1;queue&lt;pair&lt;int,int&gt; &gt;qu;qu.push(make_pair(s,0));
    while(!qu.empty()){
        int u=qu.front().first,d=qu.front().second;qu.pop();in[u][d]=0;
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i];
            if(f[u][d]+we[u][i]&lt;f[v][d]){
                f[v][d]=f[u][d]+we[u][i];
                if(!in[v][d]){
                    in[v][d]=1;
                    qu.push(make_pair(v,d));
                } 
            }
            if(d!=k&amp;&amp;f[u][d]&lt;f[v][d+1]){
                f[v][d+1]=f[u][d];
                if(!in[v][d+1]){
                    in[v][d+1]=1;
                    qu.push(make_pair(v,d+1));
                } 
            }
        }
    }
    int ans=~0u&gt;&gt;1;
    lp(i,0,k)ans=min(ans,f[t][i]);
    pf("%d\n",ans);
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem2768</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c;}edges[200010];int nw=1;
vector&lt;int&gt;bg[310];
void add(int u,int v,int c){edges[++nw].v=v;edges[nw].c=c;bg[u].push_back(nw);}
int di[310],vcnt;
int dfs(int u,int f){
    if(u==vcnt)return f;
    int g=f;
    lp(i,0,int(bg[u].size()-1)){
        edge&amp;e=edges[bg[u][i]];
        if(e.c&amp;&amp;di[u]==di[e.v]+1){
            int t=dfs(e.v,min(g,e.c));
            g-=t,e.c-=t,edges[bg[u][i]^1].c+=t;
            if(!g)return f-g;
        }
    }
    ++di[u];
    return f-g;
}
int isap(){int r=0;while(di[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;2);return r;}
int n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);vcnt=n+2;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        if(t)add(i+1,n+2,1),add(n+2,i+1,0);
        else add(i+1,1,0),add(1,i+1,1);
    }
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        add(a+1,b+1,1);
        add(b+1,a+1,1);
    }
    pf("%d\n",isap());//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2780</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
struct node{
	map&lt;int,node*&gt;tr;
	node*fa;int mrk,cnt;
}nds[460010];int nw=1;
typedef map&lt;int,node*&gt;::iterator iter;
node*rt=nds;
char tmp[460010];
node*insert(){
	node*x=rt;
	for(int i=0;tmp[i];++i){
		if(!x-&gt;tr.count(tmp[i]))
			x-&gt;tr[tmp[i]]=&amp;nds[nw++];
		x=x-&gt;tr[tmp[i]];
	}
	return x;
}
void build(){
	queue&lt;node*&gt;qu;
	for(iter i=rt-&gt;tr.begin();i!=rt-&gt;tr.end();++i){
		qu.push(i-&gt;second);
		i-&gt;second-&gt;fa=rt;
	}
	while(!qu.empty()){
		node*u=qu.front();qu.pop();
		for(iter i=u-&gt;tr.begin();i!=u-&gt;tr.end();++i){
			node*p=u-&gt;fa,*v=i-&gt;second;int w=i-&gt;first;
			while(p!=rt&amp;&amp;!p-&gt;tr.count(w))p=p-&gt;fa;
			if(p-&gt;tr.count(w))v-&gt;fa=p-&gt;tr[w];
			else v-&gt;fa=rt;
			qu.push(v);
		}
	}
}
vector&lt;int&gt;pos;
string inp[100010];
char tmp2[1000010];
node*ans[600010];
int main(){
	int n,q;sf("%d%d",&amp;n,&amp;q);
	lp(i,1,n){
		sf("%s",tmp2);
		for(int j=0;tmp2[j];++j)inp[i].pb(tmp2[j]);
	}
	lp(i,1,q){
		sf("%s",tmp);
		ans[i]=insert();
	}
	build();
	lp(i,1,n){
		node*u=rt;
		vp(j,inp[i]){
			int w=inp[i][j];
			while(u!=rt&amp;&amp;!u-&gt;tr.count(w))u=u-&gt;fa;
			if(u-&gt;tr.count(w))u=u-&gt;tr[w];
			node*v=u;
			while(v!=rt&amp;&amp;v-&gt;mrk!=i){
				v-&gt;mrk=i;
				++v-&gt;cnt;
				v=v-&gt;fa;
			}
		}
	}
	lp(i,1,q)pf("%d\n",ans[i]-&gt;cnt);
	return 0;
}
</pre><pre></pre><h2>Problem2789</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
vector&lt;int&gt;pos1[510],pos2[510];
char s1[1000010],s2[1000010];
int dt[1000010],n;
void add(int x){
	for(;x&lt;=n;x+=x&amp;-x)++dt[x];
}
int ask(int x){
	int r=0;
	for(;x;x-=x&amp;-x)r+=dt[x];
	return r;
}
int a[1000010];ll ans;
int main(){
	sf("%d%s%s",&amp;n,s1+1,s2+1);
	lp(i,1,n)pos1[s1[i]].pb(i),pos2[s2[i]].pb(i);
	lp(i,'A','Z')vp(j,pos1[i])a[pos1[i][j]]=pos2[i][j];
	lp(i,1,n){
		ans+=ask(n)-ask(a[i]);
		add(a[i]);
	}
	pf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2806</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace sam{
    int tr[1100010][3],pr[1100010],ln[1100010],nw=1,lst=1;
    void add(int c){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[p]+1==ln[q])pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                copy(tr[q],tr[q]+3,tr[nq]);
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
};
int n,m,len;
char tmp[1100010];
int f[1100010],d[1100010];
int check(int l){
    deque&lt;int&gt; qu;
    lp(i,1,len){
        if(i-l&gt;=0){
            while(!qu.empty()&amp;&amp;f[qu.back()]-qu.back()&lt;=f[i-l]-(i-l))qu.pop_back();
            qu.push_back(i-l);
        }
        while(!qu.empty()&amp;&amp;qu.front()&lt;i-d[i])qu.pop_front();
        f[i]=f[i-1];
        if(!qu.empty())f[i]=max(f[i],i+f[qu.front()]-qu.front());
    }
    return double(f[len])/len&gt;=0.9-1e-10;
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m){
        sf("%s",tmp);
        for(int j=0;tmp[j];++j)
            sam::add(tmp[j]-'0');
        sam::add(2);
    }
    lp(i,1,n){
        sf("%s",tmp+1);
        len=1;while(tmp[len+1])++len;
        int ty=0,now=1;
        lp(i,1,len){
            int c=tmp[i]-'0';
            if(!sam::tr[now][c]){
                while(now&amp;&amp;!sam::tr[now][c])now=sam::pr[now];
                if(!now)now=1,ty=0;
                else ty=sam::ln[now]+1,now=sam::tr[now][c];
            }else now=sam::tr[now][c],++ty;
            d[i]=ty;
        }
        if(!check(1))pf("0\n");
        else{
            int l=1,r=len+1;
            while(l+1&lt;r){
                int m=(l+r)/2;
                if(check(m))l=m;
                else r=m;
            }
            pf("%d\n",l);
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt; chd[100010];
int n,m,ci[100010],li[100010];
int lchd[100010],rchd[100010],val[100010],siz[100010],now,dist[100010]={-1};
long long sum[100010],ans;
int make(int v){
    int x=++now;
    val[x]=v;siz[x]=1;sum[x]=v;
    return x;
}
int link(int x,int y){
    if(!x)return y;
    if(!y)return x;
    if(val[x]&lt;val[y])swap(x,y);
    rchd[x]=link(rchd[x],y);
    if(dist[lchd[x]]&lt;dist[rchd[x]])swap(lchd[x],rchd[x]);
    siz[x]=siz[rchd[x]]+siz[lchd[x]]+1;
    sum[x]=sum[rchd[x]]+sum[lchd[x]]+val[x];
    dist[x]=dist[rchd[x]]+1;
    return x;
}
int calc(int u){
    int t=make(ci[u]);
    lp(i,0,int(chd[u].size())-1)
        t=link(t,calc(chd[u][i]));
    while(sum[t]&gt;m)t=link(lchd[t],rchd[t]);
    ans=max(ans,(long long)siz[t]*li[u]);
    return t;
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int b;sf("%d%d%d",&amp;b,&amp;ci[i],&amp;li[i]);
        chd[b].push_back(i);
    }
    calc(1);
    cout&lt;&lt;ans&lt;&lt;endl;
    //while(1);
    return 0;
}</pre><pre></pre><h2>Problem2812</h2><pre>int main(){}</pre><pre></pre><h2>Problem2815</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[100010],ch[100010];int n;
int vi[100010],iv[100010];
int up[100010][18],dep[100010],siz[100010];
int lca(int x,int y){
    if(dep[x]&lt;dep[y])swap(x,y);
    lp(i,0,17)if(((dep[x]-dep[y])&gt;&gt;i)&amp;1)x=up[x][i];
    if(x==y)return x;
    for(int i=17;i&gt;=0;--i)
        if(up[x][i]!=up[y][i])
            x=up[x][i],y=up[y][i];
    return up[x][0];
}
void calc(int u){
    vi[u]=1;siz[u]=1;
    lp(i,0,int(to[u].size()-1))
        if(!vi[to[u][i]])calc(to[u][i]);
    if(to[u].size()){
        int t=to[u][0];
        lp(i,1,int(to[u].size()-1))
            t=lca(t,to[u][i]);
        up[u][0]=t;dep[u]=dep[t]+1;
        ch[t].push_back(u);
        lp(j,1,17)up[u][j]=up[up[u][j-1]][j-1];
    }
}
void clac(int u){
    iv[u]=1;
    lp(i,0,int(ch[u].size()-1))
        if(!iv[ch[u][i]])clac(ch[u][i]);
    lp(i,0,int(ch[u].size()-1))
        siz[u]+=siz[ch[u][i]];
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        int k;
        while(sf("%d",&amp;k),k)to[i].push_back(k);
    }
    lp(i,1,n)if(!vi[i])calc(i);
    lp(i,1,n)if(!iv[i])clac(i);
    lp(i,1,n)pf("%d\n",siz[i]-1);//ps;
    return 0;
}
/*
5
0
1 0
1 0
2 3 0
2 0 
*/
</pre><pre></pre><h2>Problem2818</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
const int mx=10000000;
int np[mx+10],eu[mx+10],pr[mx+10];
long long seu[mx+10];
int main(){
    int n;sf("%d",&amp;n);
    eu[1]=1;
    lp(i,2,n){
        if(!np[i])pr[++pr[0]]=i,eu[i]=i-1;
        for(int j=1;j&lt;=pr[0]&amp;&amp;i*pr[j]&lt;=n;++j){
            np[i*pr[j]]=1;
            if(i%pr[j]==0){
                eu[i*pr[j]]=eu[i]*pr[j];
                break;
            }else{
                eu[i*pr[j]]=eu[i]*(pr[j]-1);
            }
        }
    }
    //lp(i,1,n)pf("%d\n",eu[i]);
    lp(i,1,n)seu[i]=seu[i-1]+eu[i];
    long long ans=0;
    lp(i,1,pr[0]){
        ans+=seu[n/pr[i]]*2-1;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2818</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll phi[10000010],pri[10000010];
bool isp[10000010];
int main(){
    ll n;sf("%lld",&amp;n);
    phi[1]=1;
    lp(i,2,n){
        if(!isp[i]){
            pri[++pri[0]]=i;
            phi[i]=i-1;
        }
        for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=n;++j){
            if(i%pri[j]==0){
                isp[i*pri[j]]=1;
                phi[i*pri[j]]=phi[i]*pri[j];
                break;
            }else{
                isp[i*pri[j]]=1;
                phi[i*pri[j]]=phi[i]*(pri[j]-1);
            }
        }
    }
    //lp(i,1,20)pf("%lld\n",phi[i]);
    lp(i,1,n)phi[i]+=phi[i-1];
    ll ans=0;
    lp(i,1,pri[0]){
        ans+=phi[n/pri[i]]*2-1;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2819</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
vector&lt;int&gt;to[500010];int n;
int bg[500010],ed[500010],tim;
int vis[500010],stk[500010*2];
int at[500010];
void init(){
    sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;at[i]);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].push_back(v);
        to[v].push_back(u);
    }
}
int up[500010][21],dep[500010];
void dfs(){
    stk[0]=2;stk[1]=1;stk[2]=1;vis[1]=1;
    while(stk[0]){
        int u=stk[stk[0]--],t=stk[stk[0]--];
        lp(i,1,20)up[u][i]=up[up[u][i-1]][i-1];
        if(t==1){
            //pf("[%d]",u);
            bg[u]=++tim;
            stk[++stk[0]]=2;stk[++stk[0]]=u;
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vis[v]){
                    vis[v]=1;up[v][0]=u;dep[v]=dep[u]+1;
                    stk[++stk[0]]=1;stk[++stk[0]]=v;
                }
            }
        }else{
            ed[u]=tim;
        }
    }
}
int lca(int x,int y){
    if(dep[x]&lt;dep[y])swap(x,y);
    for(int i=0;i&lt;=20;++i)if(((dep[x]-dep[y])&gt;&gt;i)&amp;1)x=up[x][i];
    if(x==y)return x;
    for(int i=20;i&gt;=0;--i)
        if(up[x][i]!=up[y][i])
            x=up[x][i],y=up[y][i];
    return up[x][0];
}
int bd[500010];
void add(int x,int d){for(;x&lt;=n;x+=x&amp;-x)bd[x]^=d;}
int qu(int x){
    int r=0;
    for(;x;x-=x&amp;-x)r^=bd[x];
    return r;
}
int qu2(int x){
    return qu(bg[x]);
}
void ans(){
    //pf("hi");
    lp(i,1,n)add(ed[i]+1,at[i]),add(bg[i],at[i]);
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        int u,v;
        char op[11];sf("%s%d%d",op,&amp;u,&amp;v);
        if(op[0]=='Q'){
            int z=lca(u,v);
            int t=(qu2(u)^qu2(v)^qu2(z));
            //pf("[%d,%d]",v,qu2(v));
            if(up[z][0]!=0)t^=qu2(up[z][0]);
            if(!t)pf("No\n");else pf("Yes\n");
        }else{
            add(ed[u]+1,at[u]),add(bg[u],at[u]);
            at[u]=v;
            add(ed[u]+1,at[u]),add(bg[u],at[u]);
        }
    }
}
int main(){
    init();
    dfs();
    //lp(i,1,n)pf("[%d,%d]",bg[i],ed[i]);
    //lp(i,1,n)lp(j,1,n)pf("[%d,%d,%d]\n",i,j,lca(i,j));
    ans();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2820</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int isp[10000010],pri[10000010],mui[10000010],ggg[10000010];
void precalc(){
    mui[1]=1;ggg[1]=0;
    for(int i=2;i&lt;=10000000;++i){
        if(!isp[i]){
            pri[++pri[0]]=i;
            mui[i]=-1;
            ggg[i]=1;
        }
        for(int j=1;j&lt;=pri[0]&amp;&amp;(long long)(pri[j])*i&lt;=10000000;++j){
            isp[i*pri[j]]=1;
            if(i%pri[j]==0){
                mui[i*pri[j]]=0;
                ggg[i*pri[j]]=mui[i];
                break;
            }else{
                mui[i*pri[j]]=-mui[i];
                ggg[i*pri[j]]=mui[i]-ggg[i];
            }
        }
    }
    for(int i=1;i&lt;=10000000;++i)
        ggg[i]+=ggg[i-1];
}
int main(){
    precalc();
    int T;scanf("%d",&amp;T);
    for(int i=1;i&lt;=T;++i){
        int n,m;scanf("%d%d",&amp;n,&amp;m);
        long long ans=0;
        if(n&gt;m)swap(n,m);
        for(int i=1;i&lt;=n;++i){
            int nxt=min(n/(n/i),m/(m/i));
            ans+=(long long)((n/i))*(m/i)*(ggg[nxt]-ggg[i-1]);
            i=nxt;
        }
        printf("%lld\n",ans);
    } 
    //for(;;);
    return 0;
} 
</pre><pre></pre><h2>Problem2844</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int a[100010],n,q;
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i]);
    int l=0;
    for(int i=30;i&gt;=0;--i){
        int j=l+1;while(j&lt;=n&amp;&amp;!((a[j]&gt;&gt;i)&amp;1))++j;
        if(j&lt;=n){
            swap(a[j],a[++l]);
            lp(k,1,n)if(k!=l&amp;&amp;((a[k]&gt;&gt;i)&amp;1))a[k]^=a[l];
        }
    }
    //lp(i,1,l)pf("[%d]",a[i]);ps;
    long long ans=0;
    sf("%d",&amp;q);
    lp(i,1,l){
        int j=30;while(!((a[i]&gt;&gt;j)&amp;1))--j;
        if((q&gt;&gt;j)&amp;1){
            q^=a[i];
            ans=(ans+(1ll&lt;&lt;(l-i)))%10086;
        }
    }
    lp(i,1,n-l)ans=ans*2%10086;
    //ans=ans*(1ll&lt;&lt;(n-l))%10086;//long long dead... 
    ans=(ans+1)%10086;
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2851</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int up[200010][21],dp[200010],n,q;
int lca(int u,int v){
    if(dp[u]&lt;dp[v])swap(u,v); 
    lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)u=up[u][i];
    if(u==v)return u;
    rp(i,20,0)if(up[u][i]!=up[v][i])u=up[u][i],v=up[v][i];
    return up[u][0]; 
}
vector&lt;int&gt;ch[200010];int rank[200010],nw;
void dfs(int u){rank[u]=nw++;vp(i,ch[u])dfs(ch[u][i]);}
bool cmp(int u,int v){return rank[u]&lt;rank[v];}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        int k;sf("%d",&amp;k);
        if(k)sf("%d",&amp;up[i][0]);
        lp(j,1,k-1){
            int v;sf("%d",&amp;v);
            up[i][0]=lca(v,up[i][0]);
        } 
        //pf("[%d,%d]\n",i,up[i][0]); 
        ch[up[i][0]].pb(i);dp[i]=dp[up[i][0]]+1;
        lp(j,1,20)up[i][j]=up[up[i][j-1]][j-1];
    }
    dfs(0);
    sf("%d",&amp;q);
    lp(i,1,q){
        vector&lt;int&gt;tmp;
        int k;sf("%d",&amp;k);
        lp(j,1,k){
            int v;sf("%d",&amp;v);
            tmp.pb(v);
        } 
        sort(tmp.begin(),tmp.end(),cmp);
        ll ans=0;
        vp(j,tmp)ans+=dp[tmp[j]];
        for(int j=0;j+1&lt;tmp.size();++j)ans-=dp[lca(tmp[j],tmp[j+1])];
        pf("%lld\n",ans);
    } 
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2851</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int up[200010][21],dp[200010],n,q;
int lca(int u,int v){
    if(dp[u]&lt;dp[v])swap(u,v); 
    lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)u=up[u][i];
    if(u==v)return u;
    rp(i,20,0)if(up[u][i]!=up[v][i])u=up[u][i],v=up[v][i];
    return up[u][0]; 
}
vector&lt;int&gt;ch[200010];int rank[200010],nw;
void dfs(int u){vp(i,ch[u])dfs(ch[u][i]);rank[u]=nw++;}
bool cmp(int u,int v){return rank[u]&lt;rank[v];}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        int k;sf("%d",&amp;k);
        if(k)sf("%d",&amp;up[i][0]);
        lp(j,1,k-1){
            int v;sf("%d",&amp;v);
            up[i][0]=lca(v,up[i][0]);
        } 
        //pf("[%d,%d]\n",i,up[i][0]); 
        ch[up[i][0]].pb(i);dp[i]=dp[up[i][0]]+1;
        lp(j,1,20)up[i][j]=up[up[i][j-1]][j-1];
    }
    dfs(0);
    sf("%d",&amp;q);
    lp(i,1,q){
        vector&lt;int&gt;tmp;
        int k;sf("%d",&amp;k);
        lp(j,1,k){
            int v;sf("%d",&amp;v);
            tmp.pb(v);
        } 
        sort(tmp.begin(),tmp.end(),cmp);
        ll ans=0;
        vp(j,tmp)ans+=dp[tmp[j]];
        for(int j=0;j+1&lt;tmp.size();++j)ans-=dp[lca(tmp[j],tmp[j+1])];
        pf("%lld\n",ans);
    } 
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2862</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m,k,s[20010],f[20010],g[20010];
void solve(int l,int r){
    if(l!=r){
        int m=(l+r)/2;
        solve(l,m);
        vector&lt;pair&lt;int,int&gt; &gt;t1,t2;
        lp(i,l,m)t1.push_back(make_pair(s[i],i));
        lp(i,m+1,r)t2.push_back(make_pair(s[i],i));
        sort(t1.begin(),t1.end());
        sort(t2.begin(),t2.end());
        vector&lt;int&gt;mi,mx;
        lp(i,0,int(t1.size()-1))mi.push_back(f[t1[i].second]);
        rp(i,int(mi.size()-2),0)mi[i]=min(mi[i],mi[i+1]);
        lp(i,0,int(t1.size()-1))mx.push_back(g[t1[i].second]);
        rp(i,int(mx.size()-2),0)mx[i]=max(mx[i],mx[i+1]);
        int j=0;
        lp(i,0,int(t2.size()-1)){
            while(j&lt;t1.size()&amp;&amp;t1[j].first&lt;t2[i].first-k)
                ++j;
            if(j!=t1.size()){
                f[t2[i].second]=min(f[t2[i].second],mi[j]+1);
                g[t2[i].second]=max(g[t2[i].second],mx[j]+1);
            } 
        }
        solve(m+1,r);
    }
}
bool check(){
    lp(i,1,n)f[i]=~0u&gt;&gt;1,g[i]=-(~0u&gt;&gt;1);
    solve(0,n);
    return m&gt;=f[n]&amp;&amp;m&lt;=g[n];
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;s[i]),s[i]+=s[i-1];
    int l=-1000000000,r=1000000000;
    while(l+1&lt;r){
        k=(l+r)/2;
        if(check())r=k;
        else l=k;
    }
    pf("%d\n",r);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2862</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m,k,s[20010],f[20010],g[20010];
vector&lt;pair&lt;int,int&gt; &gt;tree[20010*4];
void build(int x,int l,int r){
    if(l==r)tree[x].push_back(make_pair(s[l],l));
    else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        int pl=0,pr=0;
        tree[x].resize(r-l+1);
        merge(tree[x*2].begin(),tree[x*2].end(),
            tree[x*2+1].begin(),tree[x*2+1].end(),
                tree[x].begin());
    }
}
void solve(int x,int l,int r){
    if(l!=r){
        int m=(l+r)/2;
        solve(x*2,l,m);
        vector&lt;pair&lt;int,int&gt; &gt;t1=tree[x*2],t2=tree[x*2+1];
        vector&lt;int&gt;mi,mx;
        lp(i,0,int(t1.size()-1))mi.push_back(f[t1[i].second]);
        rp(i,int(mi.size()-2),0)mi[i]=min(mi[i],mi[i+1]);
        lp(i,0,int(t1.size()-1))mx.push_back(g[t1[i].second]);
        rp(i,int(mx.size()-2),0)mx[i]=max(mx[i],mx[i+1]);
        int j=0;
        lp(i,0,int(t2.size()-1)){
            while(j&lt;t1.size()&amp;&amp;t1[j].first&lt;t2[i].first-k)
                ++j;
            if(j!=t1.size()){
                f[t2[i].second]=min(f[t2[i].second],mi[j]+1);
                g[t2[i].second]=max(g[t2[i].second],mx[j]+1);
            } 
        }
        solve(x*2+1,m+1,r);
    }
}
bool check(){
    lp(i,1,n)f[i]=~0u&gt;&gt;1,g[i]=-(~0u&gt;&gt;1);
    solve(1,0,n);
    return m&gt;=f[n]&amp;&amp;m&lt;=g[n];
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;s[i]),s[i]+=s[i-1];
    build(1,0,n);
    int l=-1000000000,r=1000000000;
    while(l+1&lt;r){
        k=(l+r)/2;
        if(check())r=k;
        else l=k;
    }
    pf("%d\n",r);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2865</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
namespace sam{//124MB
    int*mem;
    #define tr(a,b) mem[(a-1)*26+b]
    int pr[500010*2],ln[500010*2],cnt[500010*2],pos[500010*2],nw=1,lst=1;
    void extend(int c,int idx){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;cnt[np]=1;pos[np]=idx;
        for(;p&amp;&amp;!tr(p,c);p=pr[p])tr(p,c)=np;
        if(!p)pr[np]=1;
        else{
            int q=tr(p,c);
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                lp(i,0,25)tr(nq,i)=tr(q,i);
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr(p,c)==q;p=pr[p])tr(p,c)=nq;
            }
        }
    }
    int tmp[500010*2];
    bool cmp(int a,int b){return ln[a]&lt;ln[b];}
    void count(){
        lp(i,1,nw)tmp[i]=i;sort(tmp+1,tmp+nw+1,cmp);
        for(int i=nw;i;--i)cnt[pr[tmp[i]]]+=cnt[tmp[i]],pos[pr[tmp[i]]]=pos[tmp[i]];
    }
    char str[500010];int len;
    void init(){
        sf("%s",str+1);len=strlen(str+1);
        mem=new int[(len*2+1)*26];lp(i,1,len*2+1)lp(j,0,25)tr(i,j)=0;
        lp(i,1,len)sam::extend(str[i]-'a',i);
        delete[] mem;
    }
}
namespace seg{//2*N*16=16MB
    struct node{
        node(node*a,node*b):
            lc(a),rc(b),t1(-1),t2(-1){}
        node*lc,*rc;int t1,t2;
    }*rt;
    node*build(int l,int r){
        node*x=new node(0,0);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;lc=build(l,m);
            x-&gt;rc=build(m+1,r);
        }
        return x;
    }
    void maket1(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t1==-1||x-&gt;t1&gt;t)
                x-&gt;t1=t;
        }else{
            int m=(xl+xr)/2;
            if(l&lt;=m)maket1(x-&gt;lc,xl,m,l,r,t);
            if(r&gt;=m+1)maket1(x-&gt;rc,m+1,xr,l,r,t);
        }
    }
    void maket2(node*x,int xl,int xr,int l,int r,int t){
        if(l&lt;=xl&amp;&amp;r&gt;=xr){
            if(x-&gt;t2==-1||x-&gt;t2&gt;t)
                x-&gt;t2=t;
        }else{
            int m=(xl+xr)/2;
            if(r&lt;=m)maket2(x-&gt;lc,xl,m,l,r,t);
            else if(l&gt;m)maket2(x-&gt;rc,m+1,xr,l,r,t);
            else{
                maket2(x-&gt;lc,xl,m,l,m,t+(r-(m+1)+1));
                maket2(x-&gt;rc,m+1,xr,m+1,r,t);
            }
        }
    }
    int query(node*x,int xl,int xr,int p){
        int r=~0u&gt;&gt;1;
        if(x-&gt;t1!=-1)r=min(r,x-&gt;t1);
        if(x-&gt;t2!=-1)r=min(r,x-&gt;t2+xr-p);
        if(xl!=xr){
            int m=(xl+xr)/2;
            if(p&lt;=m)r=min(r,query(x-&gt;lc,xl,m,p));
            else r=min(r,query(x-&gt;rc,m+1,xr,p));
        }
        return r;
    
    }
}
void work(){
    lp(i,1,sam::nw)if(sam::cnt[i]==1){
        int l1=sam::pos[i]-sam::ln[i]+1,l2=sam::pos[i]-sam::ln[sam::pr[i]],r=sam::pos[i];
        //pf("[%d,%d,%d]\n",l1,l2,r);
        if(l2+1&lt;=r)seg::maket1(seg::rt,1,sam::len,l2+1,r,r-l2+1);
        seg::maket2(seg::rt,1,sam::len,l1,l2,r-l2+1);
        //pf("[%d]\n",seg::query(seg::rt,4));
    }
    lp(i,1,sam::len)pf("%d\n",seg::query(seg::rt,1,sam::len,i));
}
int main(){
    sam::init();
    sam::count();
    seg::rt=seg::build(1,sam::len);
    work();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2870</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
vector&lt;int&gt;to[50010];int wei[50010],del[50010],n;long long ans;
bool cmp(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){
    if(a.first!=b.first)return a.first&lt;b.first;
    else return a.second&lt;a.second;
}
void solve(int rt){
    static int pr[50010],sz[50010];
    queue&lt;int&gt;qu;qu.push(rt);pr[rt]=0;
    vector&lt;int&gt;tmp;
    while(!qu.empty()){
        int u=qu.front();qu.pop();tmp.push_back(u);
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i];
            if(!del[v]&amp;&amp;v!=pr[u]){
                pr[v]=u;
                qu.push(v);
            }
        }
    }
    lp(i,0,int(tmp.size()-1))sz[tmp[i]]=1;
    rp(i,int(tmp.size()-1),0)sz[pr[tmp[i]]]+=sz[tmp[i]];
    if(sz[rt]==1){ans=max(ans,(long long)wei[rt]);return;}
    else if(sz[rt]==2){
        ans=max(ans,(long long)wei[tmp[0]]);
        ans=max(ans,(long long)wei[tmp[1]]);
        ans=max(ans,(long long)min(wei[tmp[0]],wei[tmp[1]])*2);
        return;
    }
    int ct=-1,cm=-1;
    lp(i,0,int(tmp.size()-1)){
        int u=tmp[i];
        int cu=0;
        lp(j,0,int(to[u].size()-1)){
            int v=to[u][j];
            if(!del[v]&amp;&amp;v!=pr[u]){
                cu=max(cu,sz[v]);
            }
        }
        cu=max(cu,sz[rt]-sz[u]);
        if(cm==-1||cu&lt;cm){
            ct=u;cm=cu;
        }
    }
    vector&lt;int&gt;dol,dor;
    int ty=0;
    lp(i,0,int(to[ct].size()-1)){
        int v=to[ct][i];
        if(!del[v]&amp;&amp;v!=pr[ct]){
            if(ty+sz[v]&lt;=sz[rt]/2){
                dol.push_back(v);
                ty+=sz[v];
            }else
                dor.push_back(v);
        }
    }
    dor.push_back(pr[ct]);
    lp(i,0,int(dol.size()-1)){
        del[dol[i]]=1;
    }
    solve(ct);
    lp(i,0,int(dol.size()-1)){
        del[dol[i]]=0;
    }
    lp(i,0,int(dor.size()-1)){
        del[dor[i]]=1;
    }
    solve(ct);
    lp(i,0,int(dor.size()-1)){
        del[dor[i]]=0;
    }
    qu=queue&lt;int&gt;();qu.push(ct);pr[ct]=0;
    static int len[50010],mii[50010],typ[50010];len[ct]=1;mii[ct]=wei[ct];
    lp(i,0,int(dol.size()-1))typ[dol[i]]=0;
    lp(i,0,int(dor.size()-1))typ[dor[i]]=1;
    while(!qu.empty()){
        int u=qu.front();qu.pop();
        lp(i,0,int(to[u].size()-1)){
            int v=to[u][i];
            if(!del[v]&amp;&amp;v!=pr[u]){
                pr[v]=u;
                len[v]=len[u]+1;
                mii[v]=min(mii[u],wei[v]);
                if(u!=ct)typ[v]=typ[u];
                qu.push(v);
            }
        }
    }
    vector&lt;pair&lt;int,int&gt; &gt;dp1,dp2,dq1,dq2;
    lp(i,0,int(tmp.size()-1)){
        int u=tmp[i];
        if(u!=ct){
            if(typ[u]==0)dp1.push_back(make_pair(mii[u],len[u]));
            else dp2.push_back(make_pair(mii[u],len[u]));
        }
    }
    sort(dp1.begin(),dp1.end(),cmp);
    sort(dp2.begin(),dp2.end(),cmp);
    lp(i,0,int(dp1.size()-1)){
        while(dq1.size()&gt;0&amp;&amp;dq1.back().second&lt;=dp1[i].second)
            dq1.pop_back();
        if(dq1.empty()||dq1.back()!=dp1[i])
            dq1.push_back(dp1[i]);
    }
    lp(i,0,int(dp2.size()-1)){
        while(dq2.size()&gt;0&amp;&amp;dq2.back().second&lt;=dp2[i].second)
            dq2.pop_back();
        if(dq2.empty()||dq2.back()!=dp2[i])
            dq2.push_back(dp2[i]);
    }
    //lp(i,0,int(tmp.size()-1))pf("[%d]",tmp[i]);pf("{%d}\n",ct); 
    //lp(i,0,int(dq1.size()-1))pf("[%d,%d]",dq1[i].first,dq1[i].second);pf("\n");
    //lp(i,0,int(dq2.size()-1))pf("[%d,%d]",dq2[i].first,dq2[i].second);pf("\n");pf("\n");
    int pll=0;
    int prr=-1;
    for(;pll&lt;dq1.size();++pll){
        while(prr+1&lt;dq2.size()&amp;&amp;dq2[prr+1].first&lt;dq1[pll].first)++prr;
        if(prr+1!=dq2.size()){
            ans=max(ans,((long long)dq1[pll].first)*(dq2[prr+1].second+dq1[pll].second-1));
        }
    }
    swap(dq1,dq2);
    pll=0;
    prr=-1;
    for(;pll&lt;dq1.size();++pll){
        while(prr+1&lt;dq2.size()&amp;&amp;dq2[prr+1].first&lt;dq1[pll].first)++prr;
        if(prr+1!=dq2.size()){
            ans=max(ans,((long long)dq1[pll].first)*(dq2[prr+1].second+dq1[pll].second-1));
        }
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;wei[i]);
    lp(i,1,n-1){
        int x,y;sf("%d%d",&amp;x,&amp;y);
        to[x].push_back(y);
        to[y].push_back(x);
    }
    solve(1);
    pf("%lld\n",ans);
    //ps;
    return 0;
}
/*
10
2 3 5 9 4 5 5 3 1 1
1 10
1 2
2 8
2 9
1 3
1 5
3 4
5 6
6 7
*/
</pre><pre></pre><h2>Problem2875</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll mul(ll a,ll b,ll c){
    ll r=0;
    while(b){
        if(b&amp;1)r=(r+a)%c;
        a=(a+a)%c;
        b&gt;&gt;=1;
    }
    return r;
}
struct mat{ll d[3][3];};
mat mul(mat a,mat b,ll c){
    mat r;
    lp(i,1,2)
        lp(j,1,2){
            r.d[i][j]=0;
            lp(k,1,2)
                r.d[i][j]=(r.d[i][j]+mul(a.d[i][k],b.d[k][j],c))%c;
        }
    return r;
}
mat pw(mat a,ll b,ll c){
    mat r;r.d[1][1]=r.d[2][2]=1;
    r.d[1][2]=r.d[2][1]=0;
    while(b){
        if(b&amp;1)r=mul(r,a,c);
        a=mul(a,a,c);
        b&gt;&gt;=1;
    }
    return r;
}
int main(){
    ll m,a,c,x0,n,g;
    sf("%lld%lld%lld%lld%lld%lld",&amp;m,&amp;a,&amp;c,&amp;x0,&amp;n,&amp;g);
    mat t;
    t.d[1][1]=a;
    t.d[1][2]=0;
    t.d[2][1]=1;
    t.d[2][2]=1;
    t=pw(t,n,m);
    ll ans=(mul(t.d[1][1],x0,m)+mul(t.d[2][1],c,m))%m;
    pf("%lld\n",ans%g);
    return 0;
} 
</pre><pre></pre><h2>Problem2875</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll mul(ll a,ll b,ll c){
    ll r=0;
    while(b){
        if(b&amp;1)r=(r+a)%c;
        a=(a+a)%c;
        b&gt;&gt;=1;
    }
    return r;
}
struct mat{ll d[3][3];};
mat mul(mat a,mat b,ll c){
    mat r;
    lp(i,1,2)
        lp(j,1,2){
            r.d[i][j]=0;
            lp(k,1,2)
                r.d[i][j]=(r.d[i][j]+mul(a.d[i][k],b.d[k][j],c))%c;
        }
    return r;
}
mat pw(mat a,ll b,ll c){
    mat r;r.d[1][1]=r.d[2][2]=1;
    r.d[1][2]=r.d[2][1]=0;
    while(b){
        if(b&amp;1)r=mul(r,a,c);
        a=mul(a,a,c);
        b&gt;&gt;=1;
    }
    return r;
}
int main(){
    ll m,a,c,x0,n,g;
    sf("%lld%lld%lld%lld%lld%lld",&amp;m,&amp;a,&amp;c,&amp;x0,&amp;n,&amp;g);
    mat t;
    t.d[1][1]=a;
    t.d[1][2]=0;
    t.d[2][1]=1;
    t.d[2][2]=1;
    t=pw(t,n,m);
    ll ans=(mul(t.d[1][1],x0,m)+mul(t.d[2][1],c,m))%m;
    pf("%lld\n",ans%g);
    return 0;
} </pre><pre></pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int N;
double E,S[10010],K[10010],Vw[10010];
double myabs(double a){
    return a&lt;0?-a:a;
} 
double calc(double phi,int f){
    double tmp=0;
    lp(i,1,N){
        double t=(max(Vw[i]/3.0*2,0.0)+1)*5,u;
        while(myabs(u=(2*phi*K[i]*t*t*t-2*phi*K[i]*Vw[i]*t*t-1))&gt;1e-12)
            t=t-u/(6*phi*K[i]*t*t-4*phi*K[i]*Vw[i]*t);
        if(f)tmp+=K[i]*(t-Vw[i])*(t-Vw[i])*S[i];
        else tmp+=S[i]/t;
    }
    return tmp;
}
int main(){
    sf("%d%lf",&amp;N,&amp;E);
    lp(i,1,N)sf("%lf%lf%lf",&amp;S[i],&amp;K[i],&amp;Vw[i]);
    double l=0,r=1;
    while(calc(r,1)&gt;E)l=r,r*=2;
    while(r-l&gt;1E-12){
        if(calc((l+r)/2,1)&gt;E)l=(l+r)/2;
        else r=(l+r)/2;
    }
    pf("%.12lf\n",calc(l,0));
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem2879</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct edge{int v,c,w;}edges[2000010];int nw=1;
vector&lt;int&gt;to[100010];int vcnt;
void add(int u,int v,int c,int w){
    edge&amp;e=edges[++nw];
    e.v=v,e.c=c,e.w=w;
    to[u].push_back(nw);
}
int tim[110][110],n,m;
int dis[100010],in[100010],cst;
int spfa(){
    dis[1]=0;lp(i,2,vcnt)dis[i]=~0u&gt;&gt;2;
    in[1]=1;lp(i,2,vcnt)in[i]=0;
    deque&lt;int&gt;qu;qu.push_back(1);
    while(!qu.empty()){
        int u=qu.front();qu.pop_front();in[u]=0;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=edges[to[u][i]];
            if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                dis[e.v]=dis[u]+e.w;
                if(!in[e.v]){
                    in[e.v]=1;
                    if(!qu.empty()&amp;&amp;dis[e.v]&lt;dis[qu.front()])
                        qu.push_front(e.v);
                    else
                        qu.push_back(e.v);
                }
            }
        }
    }
    return dis[vcnt]!=~0u&gt;&gt;2;
}
int dfs(int u,int f){
    if(u==vcnt)return f;
    in[u]=1;
    int g=f;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=edges[to[u][i]];
        if(e.c&amp;&amp;!in[e.v]&amp;&amp;dis[u]+e.w==dis[e.v]){
            int t=dfs(e.v,min(g,e.c));
            e.c-=t,edges[to[u][i]^1].c+=t,g-=t;
            cst+=t*e.w;
            if(!g)return f;
        }
    }
    return f-g;
}
int cnt[110]; int s=0;
int now[110],nowe[110];
void mcmf(){
    while(spfa()){
        do{lp(i,1,vcnt)in[i]=0;}while(dfs(1,~0u&gt;&gt;2));
        lp(j,1,m)if(!edges[nowe[j]].c){
            int k=++now[j];
            lp(i,1,n){
                add(i+1,n+1+(j-1)*s+k,1,k*tim[i][j]);
                add(n+1+(j-1)*s+k,i+1,0,-k*tim[i][j]);
            }
            add(n+1+(j-1)*s+k,s*m+n+2,1,0),now[j]=k,nowe[j]=nw,add(s*m+n+2,n+1+(j-1)*s+k,0,0);
        }
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;cnt[i]),s+=cnt[i];
    lp(i,1,n)lp(j,1,m)sf("%d",&amp;tim[i][j]);
    lp(i,1,n)lp(j,1,m)lp(k,1,1)
        add(i+1,n+1+(j-1)*s+k,1,k*tim[i][j]),
        add(n+1+(j-1)*s+k,i+1,0,-k*tim[i][j]);
    lp(i,1,n)add(1,i+1,cnt[i],0),add(i+1,1,0,0);
    lp(i,1,m)lp(j,1,1)add(n+1+(i-1)*s+j,s*m+n+2,1,0),now[i]=1,nowe[i]=nw,add(s*m+n+2,n+1+(i-1)*s+j,0,0);
    vcnt=s*m+n+2;
    mcmf();
    pf("%d\n",cst);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2883</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
/*namespace trp{
    struct node{
        node(){}
        node(int k,int v){
            key=k;val=v;fix=rand();sum=v;
            ch[0]=ch[1]=0;
        }
        node*ch[2];int fix;ll sum;int key,val;
    };
    node buff[3000010],*bfs=buff,*stk[3000010];int sts;
    inline node*newnode(int k,int v){
        node*t=sts?stk[sts--]:bfs++;
        *t=node(k,v);
        return t;
    }
    inline void deletenode(node*x){
        stk[++sts]=x;
    }
    inline void update(node*x){
        x-&gt;sum=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        y-&gt;sum=x-&gt;sum;
        update(x);
        x=y;
    }
    inline ll query(node*x,int k){
        if(!x)return 0;
        else if(x-&gt;key&lt;k)return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0)+x-&gt;val+query(x-&gt;ch[1],k);
        else return query(x-&gt;ch[0],k);
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(k,v);
        else if(k&lt;x-&gt;key||(k==x-&gt;key&amp;&amp;v&lt;x-&gt;val)){
            insert(x-&gt;ch[0],k,v);
            x-&gt;sum+=v;
            //if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;fix)rotate(x,0);
        }else{
            insert(x-&gt;ch[1],k,v);
            x-&gt;sum+=v;
            //if(x-&gt;ch[1]-&gt;fix&lt;x-&gt;fix)rotate(x,1);
        }
    }
    inline void remove(node*&amp;x,int k,int v){
        if(x-&gt;key==k&amp;&amp;x-&gt;val==v){
            if(!x-&gt;ch[0])deletenode(x),x=x-&gt;ch[1];
            else if(!x-&gt;ch[1])deletenode(x),x=x-&gt;ch[0];
            else if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;ch[1]-&gt;fix){
                rotate(x,0);
                remove(x-&gt;ch[1],k,v);
                x-&gt;sum-=v;
            }else{
                rotate(x,1);
                remove(x-&gt;ch[0],k,v);
                x-&gt;sum-=v;
            }
        }else if(k&lt;x-&gt;key||(k==x-&gt;key&amp;&amp;v&lt;x-&gt;val)){
            remove(x-&gt;ch[0],k,v);
            x-&gt;sum-=v;
        }else{
        	remove(x-&gt;ch[1],k,v);
            x-&gt;sum-=v;
        }
    }
}*/
namespace trp{
	struct node{
		node(){}
		node(int a,int b){l=a;r=b;sum=0;ch[0]=ch[1]=0;}
		int l,r;ll sum;
		node*ch[2];
	};
	node buff[4000010],*bfs=buff,*stk[4000010];int sts;
    inline node*newnode(int l,int r){
        node*t=sts?stk[sts--]:bfs++;
        *t=node(l,r);
        return t;
    }
    inline void deletenode(node*x){
        stk[++sts]=x;
    }
	inline ll query(node*x,int k){
		if(!x)return 0;
		int m=(x-&gt;l+x-&gt;r)/2;
		if(k&lt;=m)return query(x-&gt;ch[0],k);
		else return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0)+query(x-&gt;ch[1],k);
	}
	inline void insert(node*x,int k,int v){
		if(x-&gt;l==x-&gt;r)x-&gt;sum+=v;
		else{
			int m=(x-&gt;l+x-&gt;r)/2;
			if(k&lt;=m){
				if(!x-&gt;ch[0])x-&gt;ch[0]=newnode(x-&gt;l,m);
				insert(x-&gt;ch[0],k,v);
				x-&gt;sum+=v;
			}else{
				if(!x-&gt;ch[1])x-&gt;ch[1]=newnode(m+1,x-&gt;r);
				insert(x-&gt;ch[1],k,v);
				x-&gt;sum+=v;
			}
		}
	}
	inline void remove(node*x,int k,int v){
		if(x-&gt;l==x-&gt;r)x-&gt;sum-=v;
		else{
			int m=(x-&gt;l+x-&gt;r)/2;
			if(k&lt;=m){
				remove(x-&gt;ch[0],k,v);
				x-&gt;sum-=v;
			}else{
				remove(x-&gt;ch[1],k,v);
				x-&gt;sum-=v;
			}
		}
	}
}
namespace seg{
    struct node{
        node(int a,int b){ch[0]=ch[1]=0;l=a;r=b;tp=trp::newnode(0,99999);}
        node*ch[2];int l,r;trp::node*tp;
    };
    inline node*build(int l,int r){
        node*ret=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            ret-&gt;ch[0]=build(l,m);
            ret-&gt;ch[1]=build(m+1,r);
        }
        return ret;
    }
    inline void insert(node*x,int p,pair&lt;int,int&gt;v){
        trp::insert(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)insert(x-&gt;ch[0],p,v);
            else insert(x-&gt;ch[1],p,v);
        }
    }
    inline void remove(node*x,int p,pair&lt;int,int&gt;v){
        trp::remove(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)remove(x-&gt;ch[0],p,v);
            else remove(x-&gt;ch[1],p,v);
        }
    }
    inline ll query(node*x,int l,int r,int v){
        if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return trp::query(x-&gt;tp,v);
        else{
            ll ret=0;
            if(l&lt;=x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[0],l,r,v);
            if(r&gt;x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[1],l,r,v);
            return ret;
        }
    }
}
namespace lisa{
    vector&lt;int&gt;data;
    inline void insert(int x){
        data.pb(x);
    }
    inline void build(){
        sort(data.begin(),data.end());
        data.erase(unique(data.begin(),data.end()),data.end());
    }
    inline int convert(int x){
        return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
    }
}
int main(){
    static int a[100010],n,m;
    static set&lt;int&gt;p[200010];static char op1[100010];
    static int op2[100010],op3[100010];
    sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]),lisa::insert(a[i]);
    sf("%d",&amp;m);lp(i,1,m){
        char op[11];sf("%s%d%d",op,&amp;op2[i],&amp;op3[i]);
        op1[i]=op[0];if(op[0]=='U')lisa::insert(op3[i]);
    }
    lisa::build();
    seg::node*rt=seg::build(1,n);
    lp(i,1,n){
        int t=lisa::convert(a[i]);
        if(p[t].empty())seg::insert(rt,i,mp(0,a[i]));
        else seg::insert(rt,i,mp(*p[t].rbegin(),a[i]));
        p[t].insert(i);
    }
    lp(i,1,m){
        if(op1[i]=='Q'){
            pf("%lld\n",seg::query(rt,op2[i],op3[i],op2[i]));
        }else{
            int x=op2[i],y=a[x],z=op3[i];
            set&lt;int&gt;&amp;s1=p[lisa::convert(y)],&amp;s2=p[lisa::convert(z)];
            set&lt;int&gt;::iterator it,ti;int tp;
            it=s1.lower_bound(x);
            if(it==s1.begin())seg::remove(rt,x,mp(tp=0,y));
            else seg::remove(rt,x,mp(tp=*(--it),y)),++it;
            ++it;
            if(it!=s1.end()){
                seg::remove(rt,*it,mp(x,a[*it]));
                seg::insert(rt,*it,mp(tp,a[*it]));
            }
            s1.erase(x);
            it=ti=s2.lower_bound(x);
            if(it==s2.begin())seg::insert(rt,x,mp(tp=0,z));
            else seg::insert(rt,x,mp(tp=*(--it),z));
            it=ti;
            if(it!=s2.end()){
                seg::remove(rt,*it,mp(tp,a[*it]));
                seg::insert(rt,*it,mp(x,a[*it]));
            }
            s2.insert(x);
            a[x]=z;
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2883</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
/*namespace trp{
    struct node{
        node(){}
        node(int k,int v){
            key=k;val=v;fix=rand();sum=v;
            ch[0]=ch[1]=0;
        }
        node*ch[2];int fix;ll sum;int key,val;
    };
    node buff[3000010],*bfs=buff,*stk[3000010];int sts;
    inline node*newnode(int k,int v){
        node*t=sts?stk[sts--]:bfs++;
        *t=node(k,v);
        return t;
    }
    inline void deletenode(node*x){
        stk[++sts]=x;
    }
    inline void update(node*x){
        x-&gt;sum=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        y-&gt;sum=x-&gt;sum;
        update(x);
        x=y;
    }
    inline ll query(node*x,int k){
        if(!x)return 0;
        else if(x-&gt;key&lt;k)return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0)+x-&gt;val+query(x-&gt;ch[1],k);
        else return query(x-&gt;ch[0],k);
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(k,v);
        else if(k&lt;x-&gt;key||(k==x-&gt;key&amp;&amp;v&lt;x-&gt;val)){
            insert(x-&gt;ch[0],k,v);
            x-&gt;sum+=v;
            //if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;fix)rotate(x,0);
        }else{
            insert(x-&gt;ch[1],k,v);
            x-&gt;sum+=v;
            //if(x-&gt;ch[1]-&gt;fix&lt;x-&gt;fix)rotate(x,1);
        }
    }
    inline void remove(node*&amp;x,int k,int v){
        if(x-&gt;key==k&amp;&amp;x-&gt;val==v){
            if(!x-&gt;ch[0])deletenode(x),x=x-&gt;ch[1];
            else if(!x-&gt;ch[1])deletenode(x),x=x-&gt;ch[0];
            else if(x-&gt;ch[0]-&gt;fix&lt;x-&gt;ch[1]-&gt;fix){
                rotate(x,0);
                remove(x-&gt;ch[1],k,v);
                x-&gt;sum-=v;
            }else{
                rotate(x,1);
                remove(x-&gt;ch[0],k,v);
                x-&gt;sum-=v;
            }
        }else if(k&lt;x-&gt;key||(k==x-&gt;key&amp;&amp;v&lt;x-&gt;val)){
            remove(x-&gt;ch[0],k,v);
            x-&gt;sum-=v;
        }else{
        	remove(x-&gt;ch[1],k,v);
            x-&gt;sum-=v;
        }
    }
}*/
namespace trp{
	struct node{
		node(){}
		node(int a,int b){l=a;r=b;sum=0;ch[0]=ch[1]=0;}
		int l,r;ll sum;
		node*ch[2];
	};
	node buff[4000010],*bfs=buff,*stk[4000010];int sts;
    inline node*newnode(int l,int r){
        node*t=sts?stk[sts--]:bfs++;
        *t=node(l,r);
        return t;
    }
    inline void deletenode(node*x){
        stk[++sts]=x;
    }
	inline ll query(node*x,int k){
		if(!x)return 0;
		int m=(x-&gt;l+x-&gt;r)/2;
		if(k&lt;=m)return query(x-&gt;ch[0],k);
		else return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0)+query(x-&gt;ch[1],k);
	}
	inline void insert(node*x,int k,int v){
		if(x-&gt;l==x-&gt;r)x-&gt;sum+=v;
		else{
			int m=(x-&gt;l+x-&gt;r)/2;
			if(k&lt;=m){
				if(!x-&gt;ch[0])x-&gt;ch[0]=newnode(x-&gt;l,m);
				insert(x-&gt;ch[0],k,v);
				x-&gt;sum+=v;
			}else{
				if(!x-&gt;ch[1])x-&gt;ch[1]=newnode(m+1,x-&gt;r);
				insert(x-&gt;ch[1],k,v);
				x-&gt;sum+=v;
			}
		}
	}
	inline void remove(node*x,int k,int v){
		if(x-&gt;l==x-&gt;r)x-&gt;sum-=v;
		else{
			int m=(x-&gt;l+x-&gt;r)/2;
			if(k&lt;=m){
				remove(x-&gt;ch[0],k,v);
				if(x-&gt;ch[0]-&gt;sum==0)deletenode(x-&gt;ch[0]),x-&gt;ch[0]=0;
				x-&gt;sum-=v;
			}else{
				remove(x-&gt;ch[1],k,v);
				if(x-&gt;ch[1]-&gt;sum==0)deletenode(x-&gt;ch[1]),x-&gt;ch[1]=0;
				x-&gt;sum-=v;
			}
		}
	}
}
namespace seg{
    struct node{
        node(int a,int b){ch[0]=ch[1]=0;l=a;r=b;tp=trp::newnode(0,99999);}
        node*ch[2];int l,r;trp::node*tp;
    };
    inline node*build(int l,int r){
        node*ret=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            ret-&gt;ch[0]=build(l,m);
            ret-&gt;ch[1]=build(m+1,r);
        }
        return ret;
    }
    inline void insert(node*x,int p,pair&lt;int,int&gt;v){
        trp::insert(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)insert(x-&gt;ch[0],p,v);
            else insert(x-&gt;ch[1],p,v);
        }
    }
    inline void remove(node*x,int p,pair&lt;int,int&gt;v){
        trp::remove(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)remove(x-&gt;ch[0],p,v);
            else remove(x-&gt;ch[1],p,v);
        }
    }
    inline ll query(node*x,int l,int r,int v){
        if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return trp::query(x-&gt;tp,v);
        else{
            ll ret=0;
            if(l&lt;=x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[0],l,r,v);
            if(r&gt;x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[1],l,r,v);
            return ret;
        }
    }
}
namespace lisa{
    vector&lt;int&gt;data;
    inline void insert(int x){
        data.pb(x);
    }
    inline void build(){
        sort(data.begin(),data.end());
        data.erase(unique(data.begin(),data.end()),data.end());
    }
    inline int convert(int x){
        return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
    }
}
int main(){
    static int a[100010],n,m;
    static set&lt;int&gt;p[200010];static char op1[100010];
    static int op2[100010],op3[100010];
    sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]),lisa::insert(a[i]);
    sf("%d",&amp;m);lp(i,1,m){
        char op[11];sf("%s%d%d",op,&amp;op2[i],&amp;op3[i]);
        op1[i]=op[0];if(op[0]=='U')lisa::insert(op3[i]);
    }
    lisa::build();
    seg::node*rt=seg::build(1,n);
    lp(i,1,n){
        int t=lisa::convert(a[i]);
        if(p[t].empty())seg::insert(rt,i,mp(0,a[i]));
        else seg::insert(rt,i,mp(*p[t].rbegin(),a[i]));
        p[t].insert(i);
    }
    lp(i,1,m){
        if(op1[i]=='Q'){
            pf("%lld\n",seg::query(rt,op2[i],op3[i],op2[i]));
        }else{
            int x=op2[i],y=a[x],z=op3[i];
            set&lt;int&gt;&amp;s1=p[lisa::convert(y)],&amp;s2=p[lisa::convert(z)];
            set&lt;int&gt;::iterator it,ti;int tp;
            it=s1.lower_bound(x);
            if(it==s1.begin())seg::remove(rt,x,mp(tp=0,y));
            else seg::remove(rt,x,mp(tp=*(--it),y)),++it;
            ++it;
            if(it!=s1.end()){
                seg::remove(rt,*it,mp(x,a[*it]));
                seg::insert(rt,*it,mp(tp,a[*it]));
            }
            s1.erase(x);
            it=ti=s2.lower_bound(x);
            if(it==s2.begin())seg::insert(rt,x,mp(tp=0,z));
            else seg::insert(rt,x,mp(tp=*(--it),z));
            it=ti;
            if(it!=s2.end()){
                seg::remove(rt,*it,mp(tp,a[*it]));
                seg::insert(rt,*it,mp(x,a[*it]));
            }
            s2.insert(x);
            a[x]=z;
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2883</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trp{
    struct node{
        node(){}
        node(int a,int b){l=a;r=b;sum=0;ch[0]=ch[1]=0;}
        int l,r;ll sum;
        node*ch[2];
    };
    node buff[4000010],*bfs=buff;
    inline node*newnode(int l,int r){
        *bfs=node(l,r);
        return bfs++;
    }
    inline ll query(node*x,int k){
        if(!x)return 0;
        int m=(x-&gt;l+x-&gt;r)/2;
        if(k&lt;=m)return query(x-&gt;ch[0],k);
        else return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0)+query(x-&gt;ch[1],k);
    }
    inline void insert(node*x,int k,int v){
        if(x-&gt;l==x-&gt;r)x-&gt;sum+=v;
        else{
            int m=(x-&gt;l+x-&gt;r)/2;
            if(k&lt;=m){
                if(!x-&gt;ch[0])x-&gt;ch[0]=newnode(x-&gt;l,m);
                insert(x-&gt;ch[0],k,v);
                x-&gt;sum+=v;
            }else{
                if(!x-&gt;ch[1])x-&gt;ch[1]=newnode(m+1,x-&gt;r);
                insert(x-&gt;ch[1],k,v);
                x-&gt;sum+=v;
            }
        }
    }
    inline void remove(node*x,int k,int v){
        if(x-&gt;l==x-&gt;r)x-&gt;sum-=v;
        else{
            int m=(x-&gt;l+x-&gt;r)/2;
            if(k&lt;=m){
                remove(x-&gt;ch[0],k,v);
                x-&gt;sum-=v;
            }else{
                remove(x-&gt;ch[1],k,v);
                x-&gt;sum-=v;
            }
        }
    }
}
namespace seg{
    struct node{
        node(int a,int b){ch[0]=ch[1]=0;l=a;r=b;tp=trp::newnode(0,99999);}
        node*ch[2];int l,r;trp::node*tp;
    };
    inline node*build(int l,int r){
        node*ret=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            ret-&gt;ch[0]=build(l,m);
            ret-&gt;ch[1]=build(m+1,r);
        }
        return ret;
    }
    inline void insert(node*x,int p,pair&lt;int,int&gt;v){
        trp::insert(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)insert(x-&gt;ch[0],p,v);
            else insert(x-&gt;ch[1],p,v);
        }
    }
    inline void remove(node*x,int p,pair&lt;int,int&gt;v){
        trp::remove(x-&gt;tp,v.first,v.second);
        if(x-&gt;ch[0]){
            if(p&lt;=x-&gt;ch[0]-&gt;r)remove(x-&gt;ch[0],p,v);
            else remove(x-&gt;ch[1],p,v);
        }
    }
    inline ll query(node*x,int l,int r,int v){
        if(l&lt;=x-&gt;l&amp;&amp;r&gt;=x-&gt;r)return trp::query(x-&gt;tp,v);
        else{
            ll ret=0;
            if(l&lt;=x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[0],l,r,v);
            if(r&gt;x-&gt;ch[0]-&gt;r)ret+=query(x-&gt;ch[1],l,r,v);
            return ret;
        }
    }
}
namespace lisa{
    vector&lt;int&gt;data;
    inline void insert(int x){
        data.pb(x);
    }
    inline void build(){
        sort(data.begin(),data.end());
        data.erase(unique(data.begin(),data.end()),data.end());
    }
    inline int convert(int x){
        return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
    }
}
int main(){
    static int a[100010],n,m;
    static set&lt;int&gt;p[200010];static char op1[100010];
    static int op2[100010],op3[100010];
    sf("%d",&amp;n);lp(i,1,n)sf("%d",&amp;a[i]),lisa::insert(a[i]);
    sf("%d",&amp;m);lp(i,1,m){
        char op[11];sf("%s%d%d",op,&amp;op2[i],&amp;op3[i]);
        op1[i]=op[0];if(op[0]=='U')lisa::insert(op3[i]);
    }
    lisa::build();
    seg::node*rt=seg::build(1,n);
    lp(i,1,n){
        int t=lisa::convert(a[i]);
        if(p[t].empty())seg::insert(rt,i,mp(0,a[i]));
        else seg::insert(rt,i,mp(*p[t].rbegin(),a[i]));
        p[t].insert(i);
    }
    lp(i,1,m){
        if(op1[i]=='Q'){
            pf("%lld\n",seg::query(rt,op2[i],op3[i],op2[i]));
        }else{
            int x=op2[i],y=a[x],z=op3[i];
            set&lt;int&gt;&amp;s1=p[lisa::convert(y)],&amp;s2=p[lisa::convert(z)];
            set&lt;int&gt;::iterator it,ti;int tp;
            it=s1.lower_bound(x);
            if(it==s1.begin())seg::remove(rt,x,mp(tp=0,y));
            else seg::remove(rt,x,mp(tp=*(--it),y)),++it;
            ++it;
            if(it!=s1.end()){
                seg::remove(rt,*it,mp(x,a[*it]));
                seg::insert(rt,*it,mp(tp,a[*it]));
            }
            s1.erase(x);
            it=ti=s2.lower_bound(x);
            if(it==s2.begin())seg::insert(rt,x,mp(tp=0,z));
            else seg::insert(rt,x,mp(tp=*(--it),z));
            it=ti;
            if(it!=s2.end()){
                seg::remove(rt,*it,mp(tp,a[*it]));
                seg::insert(rt,*it,mp(x,a[*it]));
            }
            s2.insert(x);
            a[x]=z;
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2938</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace acm{
    int ch[30010][2],fa[30010],bc[30010],nw=1;
    char tmp[30010];
    void ins(){
        sf("%s",tmp+1);
        int len=strlen(tmp+1);int u=1;
        for(int i=1;i&lt;=len;++i){
            if(!ch[u][tmp[i]-'0'])
                ch[u][tmp[i]-'0']=++nw;
            u=ch[u][tmp[i]-'0'];
        }
        bc[u]=1;
    }
    void bud(){
        queue&lt;int&gt;qu;
        lp(i,0,1)if(!ch[1][i])ch[1][i]=1;
        else fa[ch[1][i]]=1,qu.push(ch[1][i]);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
             lp(i,0,1)if(!ch[u][i])ch[u][i]=ch[fa[u]][i];
            else{
                fa[ch[u][i]]=ch[fa[u]][i];
                if(bc[ch[fa[u]][i]])
                    bc[ch[u][i]]=1;
                qu.push(ch[u][i]);
            }
        }
    }
    int vis[30010],in[30010];
    bool dfs(int u){
        //pf("[%d]",u);
        vis[u]=1;in[u]=1;
        lp(i,0,1)if(!bc[ch[u][i]]){
            if(vis[ch[u][i]]){
                if(in[ch[u][i]])return true;
            }else if(dfs(ch[u][i]))return true;
        }
        in[u]=0;
        return false;
    }
}
int main(){
    int n;sf("%d",&amp;n);
    lp(i,1,n)acm::ins();
    acm::bud();
    //lp(i,1,acm::nw)pf("[%d,%d]",acm::ch[i][0],acm::ch[i][1]);
    if(acm::dfs(1))pf("TAK\n");
    else pf("NIE\n");
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem2946</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#define pf printf
#define sf scanf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int Mx=20050;
int Pr[Mx],Tr[Mx][26],Ln[Mx],Nw=4,Lst[5]={0,1,2,3,4};
void ext(int c,int k){
    int p=Lst[k],np=++Nw;Ln[np]=Ln[p]+1,Lst[k]=np;
    for(;p&amp;&amp;!Tr[p][c];p=Pr[p])Tr[p][c]=np;
    if(!p)Pr[np]=k;
    else{
        int q=Tr[p][c];
        if(Ln[p]+1==Ln[q])Pr[np]=q;
        else{
            int nq=++Nw;Ln[nq]=Ln[p]+1;
            copy(Tr[q],Tr[q]+26,Tr[nq]);
            Pr[nq]=Pr[q],Pr[np]=Pr[q]=nq;
            for(;p&amp;&amp;Tr[p][c]==q;p=Pr[p])Tr[p][c]=nq;
        }
    }
}
char Str[2010];
int F[2010][5],N;
int main(){
    //freopen("pow.in","r",stdin);
    //freopen("pow.out","w",stdout);
    sf("%d",&amp;N);
    lp(i,1,N-1){sf("%s",Str);for(int j=0;Str[j];++j)ext(Str[j]-'a',i);}
    sf("%s",Str+1);
    lp(j,1,N-1){
        int l=0,u=j;
        for(int i=1;Str[i];++i){
            if(Tr[u][Str[i]-'a'])++l,u=Tr[u][Str[i]-'a'];
            else{
                while(u&amp;&amp;!Tr[u][Str[i]-'a'])u=Pr[u];
                if(u==0)u=j,l=0;
                else l=Ln[u]+1,u=Tr[u][Str[i]-'a'];
            }
            F[i][j]=l;
        }
    }
    for(int i=1;Str[i];++i)lp(j,2,N-1)F[i][j]=min(F[i][j],F[i][j-1]);
    int ans=0;
    for(int i=1;Str[i];++i)ans=max(ans,F[i][N-1]);
    pf("%d\n",N==1?N:ans);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem2956</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*A
ΣΣ[i=1-&gt;n,j=1-&gt;m,i!=j](n%i)*(m%j)
=ΣΣ[i=1-&gt;n,j=1-&gt;m](n%i)*(m%j)-Σ[i=1-&gt;min(n,m)](n%i)*(m%i)
=ΣΣ[i=1-&gt;n,j=1-&gt;m](n-n/i*i)*(m-m/j*j)-Σ[i=1-&gt;min(n,m)](n-n/i*i)*(m-m/i*i)
=ΣΣ[i=1-&gt;n,j=1-&gt;m]nm-ΣΣ[i=1-&gt;n,j=1-&gt;m]n*m/j*j-ΣΣ[i=1-&gt;n,j=1-&gt;m]m*n/i*i+ΣΣ[i=1-&gt;n,j=1-&gt;m]i*j*n/i*m/j-Σ[i=1-&gt;min(n,m)](n-n/i*i)*(m-m/i*i)
=n^2*m^2-n^2*Σ[j=1-&gt;m]m/j*j-m^2*Σ[i=1-&gt;n]n/i*i+ΣΣ[i=1-&gt;n,j=1-&gt;m]i*j*n/i*m/j-Σ[i=1-&gt;min(n,m)](n-n/i*i)*(m-m/i*i)
=n^2*m^2-n^2*Σ[j=1-&gt;m]m/j*j-m^2*Σ[i=1-&gt;n]n/i*i+ΣΣ[i=1-&gt;n,j=1-&gt;m]i*j*n/i*m/j-min(n,m)*n*m+n*Σ[i=1-&gt;min(n,m)]m/i*i+m*Σ[i=1-&gt;min(n,m)]n/i*i-Σ[i=1-&gt;min(n,m)]i*i*n/i*m/i

subtask1:O(1)
n^2*m^2

subtask2:O(sqrt(m))
-n^2*Σ[j=1-&gt;m]m/j*j

subtask3:O(sqrt(n))
-m^2*Σ[i=1-&gt;n]n/i*i

subtask4:O(sqrt(n)+sqrt(m))
ΣΣ[i=1-&gt;n,j=1-&gt;m]i*j*n/i*m/j
=(Σ[i=1-&gt;n]i*n/i)*(Σ[j=1-&gt;m]j*m/j)

subtask5:O(1)
-min(n,m)*n*m

subtask6:O(sqrt(m))
n*Σ[i=1-&gt;min(n,m)]m/i*i

subtask7:O(sqrt(n))
m*Σ[i=1-&gt;min(n,m)]n/i*i

subtask8:O(sqrt(n)+sqrt(m))
-Σ[i=1-&gt;min(n,m)]i*i*n/i*m/i
*/
ll n,m,p=19940417;
ll subtask1(){
	ll r=n*n%p*m%p*m%p;
	return r;
}
ll subtask2(){
	ll r=0;
	for(ll j=1;j&lt;=m;++j){
		ll t=m/(m/j);
		r=(r+(m/j)*((j+t)*(t-j+1)/2%p)%p)%p;
		j=t;
	}
	r=n*n%p*r%p;
	r=(-r+p)%p;
	return r;
}
ll subtask3(){
	ll r=0;
	for(ll i=1;i&lt;=n;++i){
		ll t=n/(n/i);
		r=(r+(n/i)*((i+t)*(t-i+1)/2%p)%p)%p;
		i=t;
	}
	r=m*m%p*r%p;
	r=(-r+p)%p;
	return r;
}
ll subtask4(){
	ll r1=0;
	for(ll j=1;j&lt;=m;++j){
		ll t=m/(m/j);
		r1=(r1+(m/j)*((j+t)*(t-j+1)/2%p)%p)%p;
		j=t;
	}
	ll r2=0;
	for(ll i=1;i&lt;=n;++i){
		ll t=n/(n/i);
		r2=(r2+(n/i)*((i+t)*(t-i+1)/2%p)%p)%p;
		i=t;
	}
	return r1*r2%p;
}
ll subtask5(){
	ll r=min(n,m)*n%p*m%p;
	r=(-r+p)%p;
	return r;
}
ll subtask6(){
	ll r=0;
	for(ll j=1;j&lt;=min(n,m);++j){
		ll t=min(m/(m/j),min(n,m));
		r=(r+(m/j)*((j+t)*(t-j+1)/2%p)%p)%p;
		j=t;
	}
	r=r*n%p;
	return r;
}
ll subtask7(){
	ll r=0;
	for(ll i=1;i&lt;=min(n,m);++i){
		ll t=min(n/(n/i),min(n,m));
		r=(r+(n/i)*((i+t)*(t-i+1)/2%p)%p)%p;
		i=t;
	}
	r=r*m%p;
	return r;
}
ll subtask8calc(ll x){
	ll t1=x,t2=x+1,t3=2*x+1;
	if(t1%2==0)t1/=2;
	else t2/=2;
	if(t1%3==0)t1/=3;
	else if(t2%3==0)t2/=3;
	else t3/=3;
	return t1*t2%p*t3%p;
}
ll subtask8(){
	ll r=0;
	for(ll i=1;i&lt;=min(n,m);++i){
		ll t=min(min(n/(n/i),m/(m/i)),min(n,m));
		ll t1=subtask8calc(t);
		ll t2=subtask8calc(i-1);
		ll t3=(t1-t2+p)%p;
		r=(r+t3*(n/i)%p*(m/i)%p)%p;
		i=t;
	}
	r=(-r+p)%p;
	return r;
}
ll brute(){
	ll r=0;
	lp(i,1,n)lp(j,1,m)if(i!=j)r=(r+(n%i)*(m%j))%p;
	return r;
}
int main(){
	sf("%lld%lld",&amp;n,&amp;m);
	pf("%lld\n",(subtask1()+subtask2()+subtask3()+subtask4()
		+subtask5()+subtask6()+subtask7()+subtask8())%p);
	//pf("%lld\n",brute());
	return 0;
}</pre><pre></pre><h2>Problem2957</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
struct node{
    node*lc,*rc;int l,r;
    double m;int cnt;
}*rt;
int query(node*x,double v){
    if(x-&gt;l==x-&gt;r)return x-&gt;m&gt;v;
    else if(x-&gt;lc-&gt;m&lt;=v)return query(x-&gt;rc,v);
    else return x-&gt;cnt-x-&gt;lc-&gt;cnt+query(x-&gt;lc,v);
}
void update(node*x){
    x-&gt;m=max(x-&gt;lc-&gt;m,x-&gt;rc-&gt;m);
    x-&gt;cnt=x-&gt;lc-&gt;cnt+query(x-&gt;rc,x-&gt;lc-&gt;m);
}
node*build(int l,int r){
    node*t=new node;t-&gt;l=l;t-&gt;r=r;t-&gt;cnt=0;t-&gt;m=0;
    if(l!=r){
        int m=(l+r)/2;
        t-&gt;lc=build(l,m);
        t-&gt;rc=build(m+1,r);
    }
    return t;
}
void modify(node*x,int p,double v){
    if(x-&gt;l==x-&gt;r){
        x-&gt;m=v;x-&gt;cnt=(v&gt;0);
    }else{
        int m=(x-&gt;l+x-&gt;r)/2;
        if(p&lt;=m)modify(x-&gt;lc,p,v);
        else modify(x-&gt;rc,p,v);
        update(x);
    }
}
int n,m;
int main(){
    sf("%d%d",&amp;n,&amp;m);
    rt=build(1,n);
    lp(i,1,m){
        int x,y;sf("%d%d",&amp;x,&amp;y);
        modify(rt,x,double(y)/x);
        pf("%d\n",rt-&gt;cnt);
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2961</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr feopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int ans[500010],ac,n;double ep=1e-8;
struct point{
    point(){}
    point(double a,double b):
        x(a),y(b){}
    double x,y;
};
double fab(double a){
    return a&lt;0?-a:a;
}
point operator-(const point&amp;a,const point&amp;b){
    return point(a.x-b.x,a.y-b.y);
}
double operator*(const point&amp;a,const point&amp;b){
    return a.x*b.y-b.x*a.y;
}
bool operator&lt;(const point&amp;a,const point&amp;b){
    return fab(a.x-b.x)&lt;ep?(a.y&lt;b.y):(a.x&lt;b.x);
}
struct event{int k,u;point p;}es[500010];
point all[500010],up[500010],dw[500010];int als,ups,dws;
#define ru(t) ((-2*x)*(up[t].x)+(-2*y)*(up[t].y)+x*x+y*y)
#define rd(t) ((-2*x)*(dw[t].x)+(-2*y)*(dw[t].y)+x*x+y*y)
void solve(int l,int r){
    if(l!=r){
        int m=((l+r)&gt;&gt;1);
        solve(l,m);solve(m+1,r);
        ups=dws=als=0;
        lp(i,l,m)if(!es[i].k)all[++als]=es[i].p;
        sort(all+1,all+als+1);
        lp(i,1,als){
            while(ups&gt;1&amp;&amp;(up[ups]-up[ups-1])*(all[i]-up[ups])&gt;-ep)//at
                --ups;
            up[++ups]=all[i];
        }
        for(int i=als;i;--i){
            while(dws&gt;1&amp;&amp;(dw[dws]-dw[dws-1])*(all[i]-dw[dws])&gt;-ep){//at
                --dws;
            }
            dw[++dws]=all[i];
        }
        lp(i,m+1,r)if(es[i].k){
            double x=es[i].p.x,y=es[i].p.y;int u=es[i].u;
            if(y&lt;0&amp;&amp;ups){//at
                int b=1,e=ups;
                while(b+1&lt;e){//at
                    int m=(b+e)/2;
                    if(ru(m+1)&gt;ru(m))b=m;
                    else e=m;
                }
                if(ru(b)&gt;ep||ru(e)&gt;ep)ans[u]=0;
            }else if(dws){//at
                int b=1,e=dws;
                while(b+1&lt;e){//at
                    int m=(b+e)/2;
                    if(rd(m+1)&gt;rd(m))b=m;
                    else e=m;
                }
                if(rd(b)&gt;ep||rd(e)&gt;ep)ans[u]=0;
            }
        }
    }
}
int main(){
    sf("%d",&amp;n);int t=0;
    lp(i,1,n){
        sf("%d%lf%lf",&amp;es[i].k,
            &amp;es[i].p.x,&amp;es[i].p.y);
        if(!es[i].k)t=1;
        else{
            ans[++ac]=t;
            es[i].u=ac;
        }
    }
    solve(1,n);
    lp(i,1,ac)pf("%s\n",ans[i]?"Yes":"No");
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem2982</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
ll exgcd(ll a,ll b,ll&amp;x,ll&amp;y){
    if(!b){x=1,y=0;return a;}
    else{ll r=exgcd(b,a%b,y,x);y-=a/b*x;return r;}
}
ll fac[10010];
ll com(int n,int k,int p){
    if(n&lt;k)return 0;
    ll t1=fac[n],t2=fac[k]*fac[n-k]%p;
    ll x,y;
    exgcd(t2,p,x,y);
    return (t1*x%p+p)%p;
}
ll lucas(int n,int k,int p){
    if(!n&amp;&amp;!k)return 1;
    else return com(n%p,k%p,p)*lucas(n/p,k/p,p)%p;
}
int main(){
    fac[0]=1;
    lp(i,1,10010)fac[i]=fac[i-1]*i%10007;
    int T;sf("%d",&amp;T);
    lp(test,1,T){
        int n,k;sf("%d%d",&amp;n,&amp;k);
        pf("%lld\n",lucas(n,k,10007));
    }//ps;
    return 0;
}
</pre><pre></pre><h2>Problem2986</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size())-1;i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll pri[1000010],isp[1000010],mui[1000010];
ll count(ll x){
	ll r=0;
	for(ll i=2;i*i&lt;=x;++i)
		r-=(x/(i*i))*mui[i];
	return r;
}
int main(){
	mui[1]=1;
	for(ll i=2;i&lt;=1000000;++i){
		if(!isp[i]){
			pri[++pri[0]]=i;
			mui[i]=-1;
		}
		for(ll j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=1000000;++j){
			if(i%pri[j]==0){
				isp[i*pri[j]]=1;
				mui[i*pri[j]]=0;
				break;
			}else{
				isp[i*pri[j]]=1;
				mui[i*pri[j]]=-mui[i];
			}
		}
	}
	//lp(i,1,10)pf("[%d,%lld]\n",i,mui[i]);
	//lp(i,1,10)pf("[%d,%lld]\n",i,count(i));
	ll n;sf("%lld",&amp;n);
	ll left=0,right=1;
	while(count(right)&lt;n)right*=2;
	while(left+1&lt;right){
		ll mid=(left+right)/2;
		if(count(mid)&gt;=n)right=mid;
		else left=mid;
	}
	pf("%lld\n",right);
	return 0;
}</pre><pre></pre><h2>Problem3010</h2><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stdio.h&gt;

using namespace std;

void update_state(int&amp; cur_gang, int&amp; cur_cows, int cow_gang) {
  if(cur_cows == 0) {
    cur_gang = cow_gang;
  }
  if(cur_gang == cow_gang) {
    cur_cows++;
  } else {
    cur_cows--;
  }
}

/* Compute the number of cows from the first gang can be on the field at the
 * end. */
int max_cows(int cur_gang, int cur_cows, vector&lt;int&gt; G) {
  /* Keep trying to place the gang from the largest gang left. */
  sort(G.begin() + 1, G.end());
  while(G.back() &gt; 0) {
    for(int i = G.size() - 1; i &gt; 0; i--) {
      update_state(cur_gang, cur_cows, i);
      G[i]--;
      if(G[i - 1] &lt;= G[i]) {
        break;
      }
    }
  }
  /* Finish by placing all of Bessie's gang. */
  for(int i = 0; i &lt; G[0]; i++) {
    update_state(cur_gang, cur_cows, 0);
  }
  return cur_gang == 0 ? cur_cows : 0;
}

int main() {
  //freopen("gangs.in", "r", stdin);
  //freopen("gangs.out", "w", stdout);

  int N, M; cin &gt;&gt; N &gt;&gt; M;
  vector&lt;int&gt; G(M);
  for(int i = 0; i &lt; N; i++) {
    cin &gt;&gt; G[i];
  }

  int cur_gang = 0;
  int cur_cows = 0;
  int res = max_cows(cur_gang, cur_cows, G);
  if(res &gt; 0) {
    cout &lt;&lt; "YES\n" &lt;&lt; res &lt;&lt; "\n";
    for(int i = 0; i &lt; N; i++) {
      /* Find the smallest gang to place next. */
      int prev_cur_gang = cur_gang;
      int prev_cur_cows = cur_cows;
      for(int j = 0; ; j++) {
        if(G[j] == 0) {
          continue;
        }

        G[j]--;
        update_state(cur_gang, cur_cows, j);
        if(max_cows(cur_gang, cur_cows, G) == res) {
          cout &lt;&lt; j + 1 &lt;&lt; '\n';
          break;
        }

        /* Placing gang j next didn't work out.  Undo the changes. */
        G[j]++;
        cur_gang = prev_cur_gang;
        cur_cows = prev_cur_cows;
      }
    }
  } else {
    cout &lt;&lt; "NO" &lt;&lt; endl;
  }
  return 0;
}</pre><pre></pre><h2>Problem3010</h2><pre> 
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stdio.h&gt;
 
using namespace std;
 
void update_state(int&amp; cur_gang, int&amp; cur_cows, int cow_gang) {
  if(cur_cows == 0) {
    cur_gang = cow_gang;
  }
  if(cur_gang == cow_gang) {
    cur_cows++;
  } else {
    cur_cows--;
  }
}
 
/* Compute the number of cows from the first gang can be on the field at the
 * end. */
int max_cows(int cur_gang, int cur_cows, vector&lt;int&gt; G) {
  /* Keep trying to place the gang from the largest gang left. */
  sort(G.begin() + 1, G.end());
  while(G.back() &gt; 0) {
    for(int i = G.size() - 1; i &gt; 0; i--) {
      update_state(cur_gang, cur_cows, i);
      G[i]--;
      if(G[i - 1] &lt;= G[i]) {
        break;
      }
    }
  }
  /* Finish by placing all of Bessie's gang. */
  for(int i = 0; i &lt; G[0]; i++) {
    update_state(cur_gang, cur_cows, 0);
  }
  return cur_gang == 0 ? cur_cows : 0;
}
 
int main() {
  //freopen("gangs.in", "r", stdin);
  //freopen("gangs.out", "w", stdout);
 
  int N, M; cin &gt;&gt; N &gt;&gt; M;
  vector&lt;int&gt; G(M);
  for(int i = 0; i &lt; M; i++) {
    cin &gt;&gt; G[i];
  }
 
  int cur_gang = 0;
  int cur_cows = 0;
  int res = max_cows(cur_gang, cur_cows, G);
  if(res &gt; 0) {
    cout &lt;&lt; "YES\n" &lt;&lt; res &lt;&lt; "\n";
    for(int i = 0; i &lt; N; i++) {
      /* Find the smallest gang to place next. */
      int prev_cur_gang = cur_gang;
      int prev_cur_cows = cur_cows;
      for(int j = 0; ; j++) {
        if(G[j] == 0) {
          continue;
        }
 
        G[j]--;
        update_state(cur_gang, cur_cows, j);
        if(max_cows(cur_gang, cur_cows, G) == res) {
          cout &lt;&lt; j + 1 &lt;&lt; '\n';
          break;
        }
 
        /* Placing gang j next didn't work out.  Undo the changes. */
        G[j]++;
        cur_gang = prev_cur_gang;
        cur_cows = prev_cur_cows;
      }
    }
  } else {
    cout &lt;&lt; "NO" &lt;&lt; endl;
  }
  return 0;
}</pre><pre></pre><h2>Problem3010</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,m;vector&lt;int&gt;cnt(110);
void done(int&amp;curid,int&amp;curcnt,int idx){
	if(!curcnt)curid=idx,curcnt=1;
	else if(curid==idx)++curcnt;
	else --curcnt;
}
int calc(vector&lt;int&gt;cnt,int curid,int curcnt){
	sort(cnt.begin()+2,cnt.begin()+m+1);
	while(cnt[m]&gt;0){
		rp(i,m,2){
			done(curid,curcnt,i);
			--cnt[i];
			if(cnt[i-1]&lt;=cnt[i])break;
		}
	}
	lp(i,1,cnt[1])done(curid,curcnt,1);
	return curid==1?curcnt:0;
}
int main(){
	sf("%d%d",&amp;n,&amp;m);int curid=0,curcnt=0;
	lp(i,1,m)sf("%d",&amp;cnt[i]);int ret=calc(cnt,curid,curcnt);
	if(ret==0){
		pf("NO\n");
	}else{
		pf("YES\n%d\n",ret);
		lp(i,1,n){
			int saveid=curid,savecnt=curcnt;
			lp(j,1,m){
				if(cnt[j]==0)continue;
				--cnt[j];
				done(curid,curcnt,j);
				if(calc(cnt,curid,curcnt)==ret){
					pf("%d\n",j);break;
				}
				++cnt[j];
				curid=saveid;
				curcnt=savecnt;
			}
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3011</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;ll l;vector&lt;int&gt;ch[200010];vector&lt;ll&gt;we[200010];
int ans[200010];
struct node{
	node(ll v){val=v;del=0;cnt=1;ch[0]=ch[1]=0;}
	ll val,del;int cnt;
	node*ch[2];
};
void down(node*x){
	lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;del+=x-&gt;del;
	x-&gt;val+=x-&gt;del;
	x-&gt;del=0;
}
void update(node*x){
	x-&gt;cnt=1;
	lp(i,0,1)if(x-&gt;ch[i])x-&gt;cnt+=x-&gt;ch[i]-&gt;cnt;
}
node*merge(node*x,node*y){
	if(!x)return y;
	if(!y)return x;
	down(x);down(y);
	if(x-&gt;val&lt;y-&gt;val)swap(x,y);
	x-&gt;ch[1]=merge(x-&gt;ch[1],y);
	swap(x-&gt;ch[0],x-&gt;ch[1]);
	update(x);
	return x;
}
node*dfs(int u){
	node*t=0;
	vp(i,ch[u]){
		node*t2=dfs(ch[u][i]);t2-&gt;del+=we[u][i];
		t=merge(t,t2);
	}
	t=merge(t,new node(0));
	while(true){
		down(t);
		if(t-&gt;val&lt;=l)break;
		else t=merge(t-&gt;ch[0],t-&gt;ch[1]);
	}
	ans[u]=t-&gt;cnt;
	return t;
}
int main(){
	sf("%d%lld",&amp;n,&amp;l);
	lp(i,2,n){
		int p;ll d;sf("%d%lld",&amp;p,&amp;d);
		ch[p].pb(i);we[p].pb(d);
	}
	dfs(1);
	lp(i,1,n)pf("%d\n",ans[i]);
	return 0;
}</pre><pre></pre><h2>Problem3012</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;queue&gt;
int n;char tmp[300010];
vector&lt;char&gt;str[30010];
int can[30010];
struct node{
	node(){fill(ch,ch+26,(node*)0);id=0;}
	node*ch[26];int id;
}*rt=new node();
namespace graph{
	map&lt;int,int&gt;to[26];
	void add(int u,int v){
		++to[u][v];
	}
	void rem(int u,int v){
		if(!--to[u][v])to[u].erase(v);
	}
	bool chk(){
		queue&lt;int&gt;qu;
		static int ind[26];
		lp(i,0,25)ind[i]=0;
		lp(i,0,25)for(map&lt;int,int&gt;::iterator it=to[i].begin();it!=to[i].end();++it)
			++ind[it-&gt;first];
		lp(i,0,25)if(ind[i]==0)qu.push(i);
		int cnt=0;
		while(!qu.empty()){
			int u=qu.front();qu.pop();++cnt;
			for(map&lt;int,int&gt;::iterator it=to[u].begin();it!=to[u].end();++it)
				if(!--ind[it-&gt;first])qu.push(it-&gt;first);
		}
		return cnt==26;
	}
}
void dfs(node*x){
	if(x-&gt;id){can[x-&gt;id]=1;return;}
	lp(i,0,25)if(x-&gt;ch[i]){
		lp(j,0,25)if(j!=i&amp;&amp;x-&gt;ch[j])graph::add(j,i);
		if(graph::chk())dfs(x-&gt;ch[i]);
		lp(j,0,25)if(j!=i&amp;&amp;x-&gt;ch[j])graph::rem(j,i);
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n){
		sf("%s",tmp);
		for(int j=0;tmp[j];++j)
			str[i].pb(tmp[j]);
		node*t=rt;
		for(int j=0;tmp[j];++j){
			if(!t-&gt;ch[tmp[j]-'a'])t-&gt;ch[tmp[j]-'a']=new node();
			t=t-&gt;ch[tmp[j]-'a'];
		}
		t-&gt;id=i;
	}
	dfs(rt);
	int ans=0;
	lp(i,1,n)ans+=can[i];
	pf("%d\n",ans);
	lp(i,1,n)if(can[i]){
		vp(j,str[i])pf("%c",str[i][j]);pf("\n");
	}
	return 0;
}</pre><pre></pre><h2>Problem3012</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;queue&gt;
int n;char tmp[300010];
vector&lt;char&gt;str[30010];
int can[30010];
struct node{
	node(){fill(ch,ch+26,(node*)0);id=0;}
	node*ch[26];int id;
}*rt=new node();
namespace graph{
	map&lt;int,int&gt;to[26];
	void add(int u,int v){
		++to[u][v];
	}
	void rem(int u,int v){
		--to[u][v];
	}
	bool chk(){
		queue&lt;int&gt;qu;
		static int ind[26];
		lp(i,0,25)ind[i]=0;
		lp(i,0,25)for(map&lt;int,int&gt;::iterator it=to[i].begin();it!=to[i].end();++it)
			if(it-&gt;second)
				++ind[it-&gt;first];
		lp(i,0,25)if(ind[i]==0)qu.push(i);
		int cnt=0;
		while(!qu.empty()){
			int u=qu.front();qu.pop();++cnt;
			for(map&lt;int,int&gt;::iterator it=to[u].begin();it!=to[u].end();++it)
				if(it-&gt;second)
					if(!--ind[it-&gt;first])qu.push(it-&gt;first);
		}
		return cnt==26;
	}
}
void dfs(node*x){
	if(x-&gt;id){can[x-&gt;id]=1;return;}
	lp(i,0,25)if(x-&gt;ch[i]){
		lp(j,0,25)if(j!=i&amp;&amp;x-&gt;ch[j])graph::add(j,i);
		if(graph::chk())dfs(x-&gt;ch[i]);
		lp(j,0,25)if(j!=i&amp;&amp;x-&gt;ch[j])graph::rem(j,i);
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n){
		sf("%s",tmp);
		for(int j=0;tmp[j];++j)
			str[i].pb(tmp[j]);
		node*t=rt;
		for(int j=0;tmp[j];++j){
			if(!t-&gt;ch[tmp[j]-'a'])t-&gt;ch[tmp[j]-'a']=new node();
			t=t-&gt;ch[tmp[j]-'a'];
		}
		t-&gt;id=i;
	}
	dfs(rt);
	int ans=0;
	lp(i,1,n)ans+=can[i];
	pf("%d\n",ans);
	lp(i,1,n)if(can[i]){
		vp(j,str[i])pf("%c",str[i][j]);pf("\n");
	}
	return 0;
}</pre><pre></pre><h2>Problem3015</h2><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stdio.h&gt;

using namespace std;

int main() {
  //freopen("cbs.in", "r", stdin);
  //freopen("cbs.out", "w", stdout);

  int N, M; cin &gt;&gt; N &gt;&gt; M;
  vector&lt;string&gt; A(N);
  for(int i = 0; i &lt; N; i++) cin &gt;&gt; A[i];

  int res = 0;
  vector&lt;int&gt; L(N, M);
  vector&lt;vector&lt;int&gt; &gt; R(N, vector&lt;int&gt;(2 * M, M));
  map&lt;vector&lt;int&gt;, pair&lt;int, int&gt; &gt; mp;
  for(int i = 0; i &lt; N; i++) R[i][M] = 0;
  
  mp[L] = make_pair(0, 1);
  for(int i = 0; i &lt; M; i++) {
    int lft = 0;
    for(int j = 0; j &lt; N; j++) {
      if(A[j][i] == '(') {
        R[j][++L[j]] = i + 1;
      } else {
        --L[j];
        R[j][L[j]] = min(R[j][L[j]], i + 1);
      }
      lft = max(lft, R[j][L[j]]);
    }
    if(lft == M) continue;

    pair&lt;int, int&gt;&amp; dat = mp[L];
    if(dat.first == lft) {
      res += dat.second++;
    } else {
      dat = make_pair(lft, 1);
    }
  }
  cout &lt;&lt; res &lt;&lt; endl;
}</pre><pre></pre><h2>Problem3015</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;stack&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
int a[21][50010],l[21][50010],k,n,r,p[50010],g[50010]; 
int main(){
    sf("%d%d",&amp;k,&amp;n);
    lp(i,1,k){
        static char tmp[50010];
        sf("%s",tmp+1);stack&lt;int&gt;stk;
        lp(j,1,n){
            a[i][j]=a[i][j-1]+(tmp[j]=='('?1:-1);
            while(!stk.empty()&amp;&amp;a[i][stk.top()]&gt;=a[i][j])stk.pop();
            if(stk.empty())l[i][j]=-1;
            else l[i][j]=stk.top();
            stk.push(j);
        }
    }
    /*lp(i,1,k){
        lp(j,1,n)pf("%d ",a[i][j]);
        pf("\n"); 
    }
    lp(i,1,k){
        lp(j,1,n)pf("%d ",l[i][j]);
        pf("\n"); 
    }*/
    map&lt;vector&lt;int&gt;,int&gt;mp;mp[vector&lt;int&gt;(k,0)]=0;
    lp(i,1,n){
        vector&lt;int&gt;t;
        lp(j,1,k)t.pb(a[j][i]);
        if(mp.count(t)){
            int u=mp[t];
            int f=0;
            lp(j,1,k)if(l[j][i]&gt;u){f=1;break;}
            if(!f)p[u+1]=p[i]=i;
        }
        mp[t]=i; 
    }
    rp(i,n,1){
        if(p[i]!=0&amp;&amp;p[i]!=i){
            if(p[i]!=n&amp;&amp;p[p[i]+1]!=0&amp;&amp;p[p[i]+1]!=p[i]+1)
                g[i]=g[p[i]+1]+1;
            else
                g[i]=1;
            r+=g[i];
        }
    }
    pf("%d\n",r);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3029</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define ps for(;;)
using namespace std;
int N,L,K,A[201];
double P[201],F[201][201][402];
int main(){
  cin&gt;&gt;N&gt;&gt;L&gt;&gt;K;
  lp(i,1,N)cin&gt;&gt;P[i],P[i]/=100;
  lp(i,1,N)cin&gt;&gt;A[i];
  F[0][0][min(K,N)+201]=1;
  lp(i,0,N-1)
    lp(j,0,i)
      lp(k,-N,N)
        F[i+1][j][k+201]+=F[i][j][k+201]*(1-P[i+1]),
        F[i+1][j+1][min(k+A[i+1],N)+201]+=F[i][j][k+201]*P[i+1];
  double ans=0;
  lp(j,L,N)
    lp(k,0,N)
      ans+=F[N][j][k+201];
  cout&lt;&lt;setprecision(6)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;ans&lt;&lt;endl;
  return 0;
}</pre><pre></pre><h2>Problem3032</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace calc{
	int n;ll a[1000010],b[1000010],s[1000010];
	ll solve(){
		ll tsum=0;
    	lp(i,1,n)tsum+=a[i];
    	if(tsum%n!=0)return -1;
    	lp(i,1,n)b[i]=tsum/n;
		s[1]=0;
		lp(i,2,n)s[i]=s[i-1]+a[i-1]-b[i-1];
		sort(s+1,s+n+1);
		ll t=s[(n+1)/2];
		ll ans=0;
		lp(i,1,n)if(s[i]&gt;t)ans+=s[i]-t;else ans+=t-s[i];
		return ans;
	}
}
int main(){
	int n,m,t;vector&lt;pair&lt;int,int&gt; &gt;a;
	sf("%d%d%d",&amp;n,&amp;m,&amp;t);
	lp(i,1,t){
		int x,y;sf("%d%d",&amp;x,&amp;y);
		a.pb(mp(x,y));
	}
	int f0=0,f1=0;
	ll ans=0;
	calc::n=n;
	lp(i,1,n)calc::a[i]=0;
	vp(i,a)++calc::a[a[i].first];
	ll tt=calc::solve();
	if(tt==-1)f0=1;
	else ans+=tt;
	calc::n=m;
	lp(i,1,m)calc::a[i]=0;
	vp(i,a)++calc::a[a[i].second];
	tt=calc::solve();
	if(tt==-1)f1=1;
	else ans+=tt;
	if(f1&amp;&amp;f0)pf("impossible\n");
	else if(f1)pf("row %lld\n",ans);
	else if(f0)pf("column %lld\n",ans);
	else pf("both %lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3038</h2><pre>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#define sf scanf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
typedef long long ll;
ll A[100010],S[100010];int N,M,P[100010];
void ad(int i,ll d){for(;i&lt;=N;i+=i&amp;-i)S[i]+=d;}
ll qu(int i){ll r=0;for(;i;i-=i&amp;-i)r+=S[i];return r;}
int fd(int a){return P[a]-a?P[a]=fd(P[a]):a;}
int main(){
    sf("%d",&amp;N);lp(i,1,N)sf("%lld",&amp;A[i]),ad(i,A[i]),P[i]=i;
    P[N+1]=N+1;sf("%d",&amp;M);lp(i,1,M){int l,r,k;sf("%d%d%d",&amp;k,&amp;l,&amp;r);
    if(l&gt;r){int t=l;l=r,r=t;}if(!k){for(int i=fd(l);i&lt;=r;i=fd(i+1)){
    ll t=sqrt(A[i]);ad(i,-A[i]+t),A[i]=t,A[i]-1?0:++P[i];}}
    else printf("%lld\n",qu(r)-qu(l-1));}
    return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
	struct node{
		inline node(){}
		inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
		ll val;int url;node*ch,*br,*pr;
	}pool[1000010];int posz;
	inline node*make(int u,ll v){
		node*t=&amp;pool[posz++];*t=node(u,v);return t;
	}
	inline node*merge(node*x,node*y){
		if(!x)return y;
		if(!y)return x;
		if(x-&gt;val&gt;y-&gt;val)swap(x,y);
		y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
		y-&gt;pr=x;x-&gt;ch=y;
		return x;
	}
	inline node*decrease(node*x,node*y,ll v){
		y-&gt;val=v;
		if(x!=y){
			if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
			else y-&gt;pr-&gt;br=y-&gt;br;
			if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
			y-&gt;pr=y-&gt;br=0;
			x=merge(x,y);
		}
		return x;
	}
	inline node*pop(node*x){
		static node*ns[1000010];int nz=0;
		for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
		lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
		for(int i=1;i+1&lt;=nz;i+=2)ns[i]=merge(ns[i],ns[i+1]);
		x=0;for(int i=nz-(1-(nz&amp;1));i&gt;=1;i-=2)x=merge(x,ns[i]);
		return x;
	}
}
namespace frontstar{
	struct node{
		inline node(){}
		inline node(int a,int b,node*c):
			v(a),w(b),nxt(c){}
		int v,w;node*nxt;
	}pool[10000010];int posz;
	node*bg[1000010];
	inline void add(int u,int v,int w){
		node*t=&amp;pool[posz++];*t=node(v,w,bg[u]);bg[u]=t;
	}
}
int main(){
	int n,m;sf("%d%d",&amp;n,&amp;m);
	int t;ll rxa,rxc,rya,ryc,rpp;
	sf("%d%lld%lld%lld%lld%lld",&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rpp);
	ll x=0,y=0,z=0;
	lp(i,1,t){
		x=(x*rxa+rxc)%rpp;
		y=(y*rya+ryc)%rpp;
		int a=min(x%n+1,y%n+1);
		int b=max(y%n+1,y%n+1);
		frontstar::add(a,b,100000000-100*a);
	}
	lp(i,1,m-t){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		frontstar::add(u,v,w);
	}
	static ll dis[1000010];static pairingheap::node*pm[1000010];
	pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
	lp(i,2,n){
		int u=rt-&gt;url;
		if(u==n)break;
		rt=pairingheap::pop(rt);
		for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
			if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
				dis[e-&gt;v]=dis[u]+e-&gt;w;
				if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
				else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
			}
		}
	}
	pf("%lld\n",dis[n]);
	return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
	struct node{
		inline node(){}
		inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
		ll val;int url;node*ch,*br,*pr;
	}pool[1000010];node*posz=pool;
	inline node*make(int u,ll v){
		node*t=posz++;*t=node(u,v);return t;
	}
	inline node*merge(node*x,node*y){
		if(!x)return y;
		if(!y)return x;
		if(x-&gt;val&gt;y-&gt;val)swap(x,y);
		y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
		y-&gt;pr=x;x-&gt;ch=y;
		return x;
	}
	inline node*decrease(node*x,node*y,ll v){
		y-&gt;val=v;
		if(x!=y){
			if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
			else y-&gt;pr-&gt;br=y-&gt;br;
			if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
			y-&gt;pr=y-&gt;br=0;
			x=merge(x,y);
		}
		return x;
	}
	inline node*pop(node*x){
		static node*ns[1000010];int nz=0;
		for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
		lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
		for(int i=1;i+1&lt;=nz;i+=2)ns[i]=merge(ns[i],ns[i+1]);
		x=0;for(int i=nz-(1-(nz&amp;1));i&gt;=1;i-=2)x=merge(x,ns[i]);
		return x;
	}
}
namespace frontstar{
	struct node{
		inline node(){}
		inline node(int a,int b,node*c):
			v(a),w(b),nxt(c){}
		int v,w;node*nxt;
	}pool[10000010];node*posz=pool;
	node*bg[1000010];
	inline void add(int u,int v,int w){
		node*t=posz++;*t=node(v,w,bg[u]);bg[u]=t;
	}
}
int main(){
	int n,m;sf("%d%d",&amp;n,&amp;m);
	int t;ll rxa,rxc,rya,ryc,rpp;
	sf("%d%lld%lld%lld%lld%lld",&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rpp);
	ll x=0,y=0,z=0;
	lp(i,1,t){
		x=(x*rxa+rxc)%rpp;
		y=(y*rya+ryc)%rpp;
		int a=min(x%n+1,y%n+1);
		int b=max(y%n+1,y%n+1);
		frontstar::add(a,b,100000000-100*a);
	}
	lp(i,1,m-t){
		int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
		frontstar::add(u,v,w);
	}
	static ll dis[1000010];static pairingheap::node*pm[1000010];
	pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
	lp(i,2,n){
		int u=rt-&gt;url;
		if(u==n)break;
		rt=pairingheap::pop(rt);
		for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
			if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
				dis[e-&gt;v]=dis[u]+e-&gt;w;
				if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
				else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
			}
		}
	}
	pf("%lld\n",dis[n]);
	return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
    struct node{
        inline node(){}
        inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
        ll val;int url;node*ch,*br,*pr;
    }pool[1000010];node*posz=pool;
    inline node*make(int u,ll v){
        node*t=posz++;*t=node(u,v);return t;
    }
    inline node*merge(node*x,node*y){
        if(!x)return y;
        if(!y)return x;
        if(x-&gt;val&gt;y-&gt;val)swap(x,y);
        y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
        y-&gt;pr=x;x-&gt;ch=y;
        return x;
    }
    inline node*decrease(node*x,node*y,ll v){
        y-&gt;val=v;
        if(x!=y){
            if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
            else y-&gt;pr-&gt;br=y-&gt;br;
            if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
            y-&gt;pr=y-&gt;br=0;
            x=merge(x,y);
        }
        return x;
    }
    inline node*pop(node*x){
        static node*ns[1000010];int nz=0;
        for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
        lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
        for(int i=1;i+1&lt;=nz;i+=2)ns[i]=merge(ns[i],ns[i+1]);
        x=0;for(int i=1;i&lt;=nz;i+=2)x=merge(x,ns[i]);
        return x;
    }
}
namespace frontstar{
    struct node{
        inline node(){}
        inline node(int a,int b,node*c):
            v(a),w(b),nxt(c){}
        int v,w;node*nxt;
    }pool[10000010];node*posz=pool;
    node*bg[1000010];
    inline void add(int u,int v,int w){
        node*t=posz++;*t=node(v,w,bg[u]);bg[u]=t;
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    int t;ll rxa,rxc,rya,ryc,rpp;
    sf("%d%lld%lld%lld%lld%lld",&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rpp);
    ll x=0,y=0,z=0;
    lp(i,1,t){
        x=(x*rxa+rxc)%rpp;
        y=(y*rya+ryc)%rpp;
        int a=min(x%n+1,y%n+1);
        int b=max(y%n+1,y%n+1);
        frontstar::add(a,b,100000000-100*a);
    }
    lp(i,1,m-t){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        frontstar::add(u,v,w);
    }
    static ll dis[1000010];static pairingheap::node*pm[1000010];
    pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
    lp(i,2,n){
        int u=rt-&gt;url;
        if(u==n)break;
        rt=pairingheap::pop(rt);
        for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
            if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
                dis[e-&gt;v]=dis[u]+e-&gt;w;
                if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
                else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
            }
        }
    }
    pf("%lld\n",dis[n]);
    return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace pairingheap{
    struct node{
        inline node(){}
        inline node(int u,ll v){url=u;val=v;ch=br=pr=0;}
        ll val;int url;node*ch,*br,*pr;
    }pool[1000010];node*posz=pool;
    inline node*make(int u,ll v){
        node*t=posz++;*t=node(u,v);return t;
    }
    inline node*merge(node*x,node*y){
        if(!x)return y;
        if(!y)return x;
        if(x-&gt;val&gt;y-&gt;val)swap(x,y);
        y-&gt;br=x-&gt;ch;if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
        y-&gt;pr=x;x-&gt;ch=y;
        return x;
    }
    inline node*decrease(node*x,node*y,ll v){
        y-&gt;val=v;
        if(x!=y){
            if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;
            else y-&gt;pr-&gt;br=y-&gt;br;
            if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
            y-&gt;pr=y-&gt;br=0;
            x=merge(x,y);
        }
        return x;
    }
    inline node*pop(node*x){
        static node*ns[1000010];int nz=0;
        for(node*i=x-&gt;ch;i;i=i-&gt;br)ns[++nz]=i;
        lp(i,1,nz)ns[i]-&gt;pr=ns[i]-&gt;br=0;
        x=0;for(int i=1;i&lt;=nz;++i)x=merge(x,ns[i]);
        return x;
    }
}
namespace frontstar{
    struct node{
        inline node(){}
        inline node(int a,int b,node*c):
            v(a),w(b),nxt(c){}
        int v,w;node*nxt;
    }pool[10000010];node*posz=pool;
    node*bg[1000010];
    inline void add(int u,int v,int w){
        node*t=posz++;*t=node(v,w,bg[u]);bg[u]=t;
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    int t;ll rxa,rxc,rya,ryc,rpp;
    sf("%d%lld%lld%lld%lld%lld",&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rpp);
    ll x=0,y=0,z=0;
    lp(i,1,t){
        x=(x*rxa+rxc)%rpp;
        y=(y*rya+ryc)%rpp;
        int a=min(x%n+1,y%n+1);
        int b=max(y%n+1,y%n+1);
        frontstar::add(a,b,100000000-100*a);
    }
    lp(i,1,m-t){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        frontstar::add(u,v,w);
    }
    static ll dis[1000010];static pairingheap::node*pm[1000010];
    pairingheap::node*rt=pm[1]=pairingheap::make(1,0);
    lp(i,2,n){
        int u=rt-&gt;url;
        if(u==n)break;
        rt=pairingheap::pop(rt);
        for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
            if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
                dis[e-&gt;v]=dis[u]+e-&gt;w;
                if(!pm[e-&gt;v])rt=pairingheap::merge(rt,pm[e-&gt;v]=pairingheap::make(e-&gt;v,dis[e-&gt;v]));
                else rt=pairingheap::decrease(rt,pm[e-&gt;v],dis[e-&gt;v]);
            }
        }
    }
    pf("%lld\n",dis[n]);
    return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#ifndef PAIRING_HEAP
#define PAIRING_HEAP
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    template&lt;class T,class  C&gt;struct PairingHeap{
        PairingHeap():root(0),siz(0){}
        ~PairingHeap(){clear(root);}
        struct node{
            node(const T&amp;_val):val(_val),ch(0),br(0),pr(0){}
            T val;node*ch,*br,*pr;}*root;
        int siz;
        void merge(node*&amp;x,node*y){
            if(!x)x=y;
            else if(y){
                if(C()(y-&gt;val,x-&gt;val))swap(x,y);
                y-&gt;br=x-&gt;ch;
                if(x-&gt;ch)x-&gt;ch-&gt;pr=y;
                y-&gt;pr=x;x-&gt;ch=y;}}
        void cut(node*&amp;x,node*y){
            if(x==y)x=0;
            else{
                if(y==y-&gt;pr-&gt;ch)y-&gt;pr-&gt;ch=y-&gt;br;else y-&gt;pr-&gt;br=y-&gt;br;
                if(y-&gt;br)y-&gt;br-&gt;pr=y-&gt;pr;
                y-&gt;pr=y-&gt;br=0;}}
        node*split(node*x){
            vector&lt;node*&gt;t;
            for(node*i=x-&gt;ch;i;i=i-&gt;br)t.push_back(i);
            x-&gt;ch=0;node*r=0;
            for(int i=0;i&lt;t.size();++i)t[i]-&gt;pr=t[i]-&gt;br=0;
            for(int i=0;i+1&lt;t.size();i+=2)merge(t[i],t[i+1]);
            for(int i=0;i&lt;t.size();i+=2)merge(r,t[i]);
            return r;}
        void clear(node*x){
            if(x){clear(x-&gt;ch);clear(x-&gt;br);delete x;}}
        void clear(){clear(root);root=0;siz=0;}
        node*push(T a){node*r=new node(a);merge(root,r);++siz;return r;}
        void erase(node*x){cut(root,x);merge(root,split(x));--siz;}
        T top(){return root-&gt;val;}
        void pop(){erase(root);}
        void merge(PairingHeap&lt;T,C&gt;&amp;a){merge(root,a.root);a.root=0;siz+=a.siz;a.siz=0;}
        void modify(node*x,T v){
            if(C()(x-&gt;val,v))x-&gt;val=v,merge(root,split(x));
            else x-&gt;val=v,cut(root,x),merge(root,x);}
        int size(){return siz;}};}
#endif
using namespace CTL;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace frontstar{
    struct node{
        inline node(){}
        inline node(int a,int b,node*c):
            v(a),w(b),nxt(c){}
        int v,w;node*nxt;
    }pool[10000010];node*posz=pool;
    node*bg[1000010];
    inline void add(int u,int v,int w){
        node*t=posz++;*t=node(v,w,bg[u]);bg[u]=t;
    }
}
struct info{
    info(ll dd,int vv){
        d=dd,v=vv;
    }

    ll d;int v;
};
bool operator&lt;(info a,info b){
    return a.d&lt;b.d;
}

int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);
    int t;ll rxa,rxc,rya,ryc,rpp;
    sf("%d%lld%lld%lld%lld%lld",&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rpp);
    ll x=0,y=0,z=0;
    lp(i,1,t){
        x=(x*rxa+rxc)%rpp;
        y=(y*rya+ryc)%rpp;
        int a=min(x%n+1,y%n+1);
        int b=max(y%n+1,y%n+1);
        frontstar::add(a,b,100000000-100*a);
    }
    lp(i,1,m-t){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        frontstar::add(u,v,w);
    }
    static ll dis[1000010];static PairingHeap&lt;info,less&lt;info&gt; &gt;::node*pm[1000010];
    PairingHeap&lt;info,less&lt;info&gt; &gt;heap;
    pm[1]=heap.push(info(0,1));
    lp(i,2,n){
        int u=heap.top().v;
        if(u==n)break;
        heap.pop();
        for(frontstar::node*e=frontstar::bg[u];e;e=e-&gt;nxt){
            if(!pm[e-&gt;v]||dis[e-&gt;v]&gt;dis[u]+e-&gt;w){
                dis[e-&gt;v]=dis[u]+e-&gt;w;
                if(!pm[e-&gt;v])pm[e-&gt;v]=heap.push(info(dis[e-&gt;v],e-&gt;v));
                else heap.modify(pm[e-&gt;v],info(dis[e-&gt;v],e-&gt;v));
            }
        }
    }
    pf("%lld\n",dis[n]);
    return 0;
}
</pre><pre></pre><h2>Problem3048</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;set&gt;
int a[100010],n,k,ans;
map&lt;int,int&gt;cnt;
int main(){
    sf("%d%d",&amp;n,&amp;k);
    lp(i,1,n)sf("%d",&amp;a[i]);
    for(int i=1,j=0,u=0;i&lt;=n;++i){
        while(j+1&lt;=n&amp;&amp;(cnt[a[j+1]]||u&lt;=k)){
            if((++cnt[a[j+1]])==1)++u;
            ++j;
        }
        ans=max(ans,cnt[a[i]]);
        if((--cnt[a[i]])==0)--u;
    }
    pf("%d\n",ans);
    //ps;
    return 0;
}    </pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
typedef long long ll;
namespace planar{
    struct point{
        int x,y;
        point(){}
        point(int a,int b):
            x(a),y(b){}
        point operator-(const point&amp;a){
            return point(x-a.x,y-a.y);
        }
        ll operator*(const point&amp;a){
            return ll(x)*ll(a.y)-ll(a.x)*ll(y);
        }
        double angle(){
            return atan2(double(y),double(x));
        }
    };
    struct edge{
        edge(int a,int b,int c,double d):
            u(a),v(b),w(c),ang(d),bel(0){}
        int u,v,w,bel;
        edge*nxt,*rev;
        double ang;
    };
    bool cmp(edge*a,edge*b){
        return a-&gt;ang&lt;b-&gt;ang;
    }
    int n,m,pcnt,wside;
    point pos[100010];
    vector&lt;edge*&gt;eg[100010],all;
    void build(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,n){
            sf("%d%d",&amp;pos[i].x,&amp;pos[i].y);
            pos[i].x*=2,pos[i].y*=2;//乘2避免后面询问的小数 
        }
        lp(i,1,m){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            edge*a=new edge(u,v,w,(pos[v]-pos[u]).angle());
            edge*b=new edge(v,u,w,(pos[u]-pos[v]).angle());
            a-&gt;rev=b;b-&gt;rev=a;
            eg[u].push_back(a);all.push_back(a);
            eg[v].push_back(b);all.push_back(b);
        }
        lp(i,1,n){
            sort(eg[i].begin(),eg[i].end(),cmp);
            lp(j,0,int(eg[i].size()-1)){
                eg[i][j]-&gt;nxt=eg[i][(j+1)%eg[i].size()];
            }
        }
        lp(i,0,int(all.size()-1)){
            if(!all[i]-&gt;bel){
                ++pcnt;ll ar=0;edge*t=all[i];
                do{
                    t-&gt;bel=pcnt;
                    t=t-&gt;nxt-&gt;rev;
                    ar+=pos[t-&gt;u]*pos[t-&gt;v];
                }while(t!=all[i]);
                if(ar&lt;0)wside=pcnt;
            }
        }
        /*pf("[%d]\n",wside);
        lp(i,0,int(all.size()-1)){
            pf("[%d,%d,%d]\n",all[i]-&gt;u,all[i]-&gt;v,
                all[i]-&gt;bel);
        }*/
    }
}
namespace mst{
    struct edge{
        edge(int a,int b,int c):
            u(a),v(b),w(c){}
        int u,v,w;
    };
    bool operator&lt;(const edge&amp;a,const edge&amp;b){
        return a.w&lt;b.w;
    }
    int vcnt;
    vector&lt;edge&gt;all,ans;
    int prt[100010*3];
    int fd(int u){return u==prt[u]?u:prt[u]=fd(prt[u]);}
    void build(){
        vcnt=planar::pcnt;
        lp(i,1,vcnt)prt[i]=i;
        lp(i,0,int(planar::all.size()-1)){
            planar::edge*e=planar::all[i];
            all.push_back(edge(e-&gt;bel,e-&gt;rev-&gt;bel,e-&gt;w));
        }
        sort(all.begin(),all.end());
        lp(i,0,int(all.size()-1)){
            edge&amp;e=all[i];
            if(fd(e.u)!=fd(e.v)&amp;&amp;e.u!=planar::wside&amp;&amp;e.v!=planar::wside){
                ans.push_back(e);
                prt[fd(e.u)]=e.v;
            }
        }
        /*lp(i,0,int(ans.size()-1)){
            pf("[%d,%d]\n",ans[i].u,ans[i].v);
        }*/
    }
}
namespace lca{
    int vcnt;
    vector&lt;int&gt;to[100010*3],we[100010*3];
    int vi[100010*3],dp[100010*3],up[100010*3][21],mx[100010*3][21];
    int query(int u,int v){
        int r=0;
        if(dp[u]&lt;dp[v])swap(u,v);
        lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)r=max(r,mx[u][i]),u=up[u][i];
        if(u==v)return r;
        for(int i=20;i&gt;=0;--i){
            if(up[u][i]!=up[v][i]){
                r=max(r,mx[u][i]);
                r=max(r,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        }
        return max(max(mx[u][0],mx[v][0]),r);
    }
    void build(){
        vcnt=mst::vcnt;
        lp(i,0,int(mst::ans.size()-1)){
            mst::edge&amp;e=mst::ans[i];
            to[e.u].push_back(e.v);
            we[e.u].push_back(e.w);
            to[e.v].push_back(e.u);
            we[e.v].push_back(e.w);
        }
        queue&lt;int&gt;qu;qu.push(planar::wside==1?2:1);
        vi[planar::wside==1?2:1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,1,20){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=max(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vi[v]){
                    vi[v]=1;dp[v]=dp[u]+1;
                    up[v][0]=u;
                    mx[v][0]=we[u][i];
                    qu.push(v);
                }
            }
        }
        //lp(i,1,vcnt)pf("[%d]",vi[i]);
        //lp(i,1,vcnt)lp(j,i+1,vcnt)pf("[%d,%d,%d]\n",i,j,query(i,j));
    }
}
namespace questions{
    int x[100010*2],y[100010*2],q,loc[100010*2];
    void init(){
        sf("%d",&amp;q);
        lp(i,1,q){
            double a,b,c,d;
            sf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);
            x[2*i-1]=a*2+0.1;y[2*i-1]=b*2+0.1;//避免误差 
            x[2*i]=c*2+0.1;y[2*i]=d*2+0.1;
        }
    }
    void answer(){
        lp(i,1,q){
            int u=loc[2*i-1],v=loc[2*i];
            if(u==planar::wside||v==planar::wside)
                pf("-1\n");
            else
                pf("%d\n",lca::query(u,v));
        }
    }
}
namespace locate{
    struct event{
        event(int b,int c):
            typ(0),qi(b),x(c){}
        event(int a,planar::edge*b,int c):
            typ(a),e(b),x(c){}
        int typ;//0query1delete2insert
        planar::edge*e;
        int qi,x;
    };
    bool operator&lt;(const event&amp;a,const event&amp;b){
        return a.x==b.x?a.typ&lt;b.typ:a.x&lt;b.x;
    }
    vector&lt;event&gt;ev;
    struct node{
        node(int a,int b):typ(1),x(a),y(b){}
        node(planar::edge*a):typ(0),e(a){}
        int typ;//0seg1pot
        planar::edge*e;
        int x,y;
    };
    bool operator&lt;(const node&amp;a,const node&amp;b){
        if(a.typ==0&amp;&amp;b.typ==0){
            planar::point p1=planar::pos[a.e-&gt;u];
            planar::point p2=planar::pos[a.e-&gt;v];
            planar::point p3=planar::pos[b.e-&gt;u];
            planar::point p4=planar::pos[b.e-&gt;v];
            double x1=p1.x,y1=p1.y;
            double x2=p2.x,y2=p2.y;
            double x3=p3.x,y3=p3.y;
            double x4=p4.x,y4=p4.y;
            double l=max(x1,x3),r=min(x2,x4);
            double t=(l+r)/2;
            double t1=(y1-y2)/(x1-x2)*(t-x1)+y1;
            double t2=(y3-y4)/(x3-x4)*(t-x3)+y3;
            return t1-t2&lt;-1e-5;
            
        }else if(a.typ==0){
            planar::point p1=planar::pos[a.e-&gt;u];
            planar::point p2=planar::pos[a.e-&gt;v];
            return (p2-p1)*(planar::point(b.x,b.y)-p1)&gt;0;
        }else{
            planar::point p1=planar::pos[b.e-&gt;u];
            planar::point p2=planar::pos[b.e-&gt;v];
            return (p2-p1)*(planar::point(a.x,a.y)-p1)&lt;0;
        }
    }
    void solve(){
        lp(i,0,int(planar::all.size()-1)){
            planar::edge*e=planar::all[i];
            if(planar::pos[e-&gt;u].x&lt;planar::pos[e-&gt;v].x){
                ev.push_back(event(1,e,planar::pos[e-&gt;v].x));
                ev.push_back(event(2,e,planar::pos[e-&gt;u].x));
            }
        }
        lp(i,1,questions::q*2){
            ev.push_back(event(i,questions::x[i]));
        }
        sort(ev.begin(),ev.end());
        /*lp(i,0,int(ev.size()-1)){
            if(ev[i].typ==0)
                pf("qu %d %d\n",questions::x[ev[i].qi],
                    questions::y[ev[i].qi]);
            else if(ev[i].typ==1)
                pf("del %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
            else pf("ins %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
        }*/
        set&lt;node&gt;st;
        lp(i,0,int(ev.size()-1)){
            event&amp;e=ev[i];
            if(e.typ==0){
                node t(e.x,questions::y[e.qi]);
                set&lt;node&gt;::iterator it=st.lower_bound(t);
                if(it==st.end())questions::loc[e.qi]=planar::wside;
                else questions::loc[e.qi]=it-&gt;e-&gt;rev-&gt;bel;
            }else if(e.typ==1){
                node t(e.e);
                st.erase(t);
            }else{
                node t(e.e);
                st.insert(t);
            }
        }
        /*lp(i,1,questions::q*2){
            pf("[%d]\n",questions::loc[i]);
        }*/
    }
}
int main(){
    planar::build();
    mst::build();
    lca::build();
    questions::init();
    locate::solve();
    questions::answer(); 
    //ps;
    return 0;
}
/*
9 12
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
1 2 10
2 3 10
3 6 10
6 9 10
9 8 10
8 7 10
7 4 10
4 1 10
2 5 3
5 8 2
5 6 4
4 5 1
3
1.5 1.5 2.5 2.5
1.5 2.5 2.5 1.5
0.5 0.5 1.5 1.5
*/
/*
8 11
1 5
3 5
4 5
1 3
2 4
3 4
4 3
2 2
1 2 6
2 3 9
1 4 1
5 8 2
6 7 3
8 7 4
3 7 5
1 5 7
2 6 8
4 8 10
5 6 11
4
0 0 5 3
2 0 3 2
1.5 3 2.5 3
2.5 4.5 3.5 4.5
*/
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;complex&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
/*
二维点 
*/
namespace pot{
    typedef complex&lt;ll&gt; pot;
    ll&amp;x(pot&amp;p){
        return real(p);
    }
    ll&amp;y(pot&amp;p){
        return imag(p);
    }
    double a(pot p){
        return atan2(double(y(p)),double(x(p)));
    }
    pot operator-(pot p,pot q){
        return pot(x(p)-x(q),y(p)-y(q));
    }
    ll det(pot p,pot q){
        return x(p)*y(q)-x(q)*y(p);
    }
}
namespace planar{
    struct edge{
        edge(int a,int b,int c,double d):
            u(a),v(b),w(c),ang(d),bel(0){}
        int u,v,w,bel;
        edge*nxt,*rev;
        double ang;
    };
    bool cmp(edge*a,edge*b){
        return a-&gt;ang&lt;b-&gt;ang;
    }
    int n,m,pcnt,wside;
    pot::pot pos[100010];
    vector&lt;edge*&gt;eg[100010],all;
    void build(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,n){
            sf("%d%d",&amp;pot::x(pos[i]),&amp;pot::y(pos[i]));
            pot::x(pos[i])*=2,pot::y(pos[i])*=2;//乘2避免后面询问的小数
        }
        lp(i,1,m){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            edge*a=new edge(u,v,w,pot::a(pos[v]-pos[u]));
            edge*b=new edge(v,u,w,pot::a(pos[u]-pos[v]));
            a-&gt;rev=b;b-&gt;rev=a;
            eg[u].push_back(a);all.push_back(a);
            eg[v].push_back(b);all.push_back(b);
        }
        lp(i,1,n){
            sort(eg[i].begin(),eg[i].end(),cmp);
            lp(j,0,int(eg[i].size()-1)){
                eg[i][j]-&gt;nxt=eg[i][(j+1)%eg[i].size()];
            }
        }
        lp(i,0,int(all.size()-1)){
            if(!all[i]-&gt;bel){
                ++pcnt;ll ar=0;edge*t=all[i];
                do{
                    t-&gt;bel=pcnt;
                    t=t-&gt;nxt-&gt;rev;
                    ar+=pot::det(pos[t-&gt;u],pos[t-&gt;v]);
                }while(t!=all[i]);
                if(ar&lt;0)wside=pcnt;
            }
        }
        /*pf("[%d]\n",wside);
        lp(i,0,int(all.size()-1)){
            pf("[%d,%d,%d]\n",all[i]-&gt;u,all[i]-&gt;v,
                all[i]-&gt;bel);
        }*/
    }
}
namespace mst{
    struct edge{
        edge(int a,int b,int c):
            u(a),v(b),w(c){}
        int u,v,w;
    };
    bool operator&lt;(const edge&amp;a,const edge&amp;b){
        return a.w&lt;b.w;
    }
    int vcnt;
    vector&lt;edge&gt;all,ans;
    int prt[100010*3];
    int fd(int u){return u==prt[u]?u:prt[u]=fd(prt[u]);}
    void build(){
        vcnt=planar::pcnt;
        lp(i,1,vcnt)prt[i]=i;
        lp(i,0,int(planar::all.size()-1)){
            planar::edge*e=planar::all[i];
            all.push_back(edge(e-&gt;bel,e-&gt;rev-&gt;bel,e-&gt;w));
        }
        sort(all.begin(),all.end());
        lp(i,0,int(all.size()-1)){
            edge&amp;e=all[i];
            if(fd(e.u)!=fd(e.v)&amp;&amp;e.u!=planar::wside&amp;&amp;e.v!=planar::wside){
                ans.push_back(e);
                prt[fd(e.u)]=e.v;
            }
        }
        /*lp(i,0,int(ans.size()-1)){
            pf("[%d,%d]\n",ans[i].u,ans[i].v);
        }*/
    }
}
namespace lca{
    int vcnt;
    vector&lt;int&gt;to[100010*3],we[100010*3];
    int vi[100010*3],dp[100010*3],up[100010*3][21],mx[100010*3][21];
    int query(int u,int v){
        int r=0;
        if(dp[u]&lt;dp[v])swap(u,v);
        lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)r=max(r,mx[u][i]),u=up[u][i];
        if(u==v)return r;
        for(int i=20;i&gt;=0;--i){
            if(up[u][i]!=up[v][i]){
                r=max(r,mx[u][i]);
                r=max(r,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        }
        return max(max(mx[u][0],mx[v][0]),r);
    }
    void build(){
        vcnt=mst::vcnt;
        lp(i,0,int(mst::ans.size()-1)){
            mst::edge&amp;e=mst::ans[i];
            to[e.u].push_back(e.v);
            we[e.u].push_back(e.w);
            to[e.v].push_back(e.u);
            we[e.v].push_back(e.w);
        }
        queue&lt;int&gt;qu;qu.push(planar::wside==1?2:1);
        vi[planar::wside==1?2:1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,1,20){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=max(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vi[v]){
                    vi[v]=1;dp[v]=dp[u]+1;
                    up[v][0]=u;
                    mx[v][0]=we[u][i];
                    qu.push(v);
                }
            }
        }
        //lp(i,1,vcnt)pf("[%d]",vi[i]);
        //lp(i,1,vcnt)lp(j,i+1,vcnt)pf("[%d,%d,%d]\n",i,j,query(i,j));
    }
}
namespace questions{
    int x[100010*2],y[100010*2],q,loc[100010*2];
    void init(){
        sf("%d",&amp;q);
        lp(i,1,q){
            double a,b,c,d;
            sf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);
            x[2*i-1]=a*2+0.1;y[2*i-1]=b*2+0.1;//避免误差
            x[2*i]=c*2+0.1;y[2*i]=d*2+0.1;
        }
    }
    void answer(){
        lp(i,1,q){
            int u=loc[2*i-1],v=loc[2*i];
            if(u==planar::wside||v==planar::wside)
                pf("-1\n");
            else
                pf("%d\n",lca::query(u,v));
        }
    }
}
namespace locate{
    struct event{
        event(int b,int c):
            typ(0),qi(b),x(c){}
        event(int a,planar::edge*b,int c):
            typ(a),e(b),x(c){}
        int typ;//0query1delete2insert
        planar::edge*e;
        int qi,x;
    };
    bool operator&lt;(const event&amp;a,const event&amp;b){
        return a.x==b.x?a.typ&lt;b.typ:a.x&lt;b.x;
    }
    vector&lt;event&gt;ev;
    struct node{
        node(int a,int b):typ(1),x(a),y(b){}
        node(planar::edge*a):typ(0),e(a){}
        int typ;//0seg1pot
        planar::edge*e;
        int x,y;
    };
    bool operator&lt;(const node&amp;a,const node&amp;b){
        if(a.typ==0&amp;&amp;b.typ==0){
            pot::pot p1=planar::pos[a.e-&gt;u];
            pot::pot p2=planar::pos[a.e-&gt;v];
            pot::pot p3=planar::pos[b.e-&gt;u];
            pot::pot p4=planar::pos[b.e-&gt;v];
            double x1=pot::x(p1),y1=pot::y(p1);
            double x2=pot::x(p2),y2=pot::y(p2);
            double x3=pot::x(p3),y3=pot::y(p3);
            double x4=pot::x(p4),y4=pot::y(p4);
            double l=max(x1,x3),r=min(x2,x4);
            double t=(l+r)/2;
            double t1=(y1-y2)/(x1-x2)*(t-x1)+y1;
            double t2=(y3-y4)/(x3-x4)*(t-x3)+y3;
            return t1-t2&lt;-1e-5;
             
        }else if(a.typ==0){
            pot::pot p1=planar::pos[a.e-&gt;u];
            pot::pot p2=planar::pos[a.e-&gt;v];
            return pot::det(p2-p1,pot::pot(b.x,b.y)-p1)&gt;0;
        }else{
            pot::pot p1=planar::pos[b.e-&gt;u];
            pot::pot p2=planar::pos[b.e-&gt;v];
            return pot::det(p2-p1,pot::pot(a.x,a.y)-p1)&lt;0;
        }
    }
    void solve(){
        lp(i,0,int(planar::all.size()-1)){
            planar::edge*e=planar::all[i];
            if(pot::x(planar::pos[e-&gt;u])&lt;pot::x(planar::pos[e-&gt;v])){
                ev.push_back(event(1,e,pot::x(planar::pos[e-&gt;v])));
                ev.push_back(event(2,e,pot::x(planar::pos[e-&gt;u])));
            }
        }
        lp(i,1,questions::q*2){
            ev.push_back(event(i,questions::x[i]));
        }
        sort(ev.begin(),ev.end());
        /*lp(i,0,int(ev.size()-1)){
            if(ev[i].typ==0)
                pf("qu %d %d\n",questions::x[ev[i].qi],
                    questions::y[ev[i].qi]);
            else if(ev[i].typ==1)
                pf("del %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
            else pf("ins %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
        }*/
        set&lt;node&gt;st;
        lp(i,0,int(ev.size()-1)){
            event&amp;e=ev[i];
            if(e.typ==0){
                node t(e.x,questions::y[e.qi]);
                set&lt;node&gt;::iterator it=st.lower_bound(t);
                if(it==st.end())questions::loc[e.qi]=planar::wside;
                else questions::loc[e.qi]=it-&gt;e-&gt;rev-&gt;bel;
            }else if(e.typ==1){
                node t(e.e);
                st.erase(t);
            }else{
                node t(e.e);
                st.insert(t);
            }
        }
        /*lp(i,1,questions::q*2){
            pf("[%d]\n",questions::loc[i]);
        }*/
    }
}
int main(){
    planar::build();
    mst::build();
    lca::build();
    questions::init();
    locate::solve();
    questions::answer();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;complex&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
/*
二维点 
*/
namespace pot{
    typedef complex&lt;ll&gt; pot;
    ll&amp;x(pot&amp;p){
        return real(p);
    }
    ll&amp;y(pot&amp;p){
        return imag(p);
    }
    double a(pot p){
        return atan2(double(y(p)),double(x(p)));
    }
    pot operator-(pot p,pot q){
        return pot(x(p)-x(q),y(p)-y(q));
    }
    ll det(pot p,pot q){
        return x(p)*y(q)-x(q)*y(p);
    }
}
namespace plr{
    const int nmx=100000;
    struct edge{
        edge(int a,int b,int c,double d):
            u(a),v(b),w(c),ang(d),bel(0){}
        int u,v,w,bel;
        edge*nxt,*rev;
        double ang;
    };
    bool cmp(edge*a,edge*b){
        return a-&gt;ang&lt;b-&gt;ang;
    }
    int n,m,pcnt,wside;
    pot::pot pos[nmx+10];
    vector&lt;edge*&gt;eg[nmx+10],all;
    void build(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,n){
            sf("%d%d",&amp;pot::x(pos[i]),&amp;pot::y(pos[i]));
            pot::x(pos[i])*=2,pot::y(pos[i])*=2;//乘2避免后面询问的小数
        }
        lp(i,1,m){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            edge*a=new edge(u,v,w,pot::a(pos[v]-pos[u]));
            edge*b=new edge(v,u,w,pot::a(pos[u]-pos[v]));
            a-&gt;rev=b;b-&gt;rev=a;
            eg[u].push_back(a);all.push_back(a);
            eg[v].push_back(b);all.push_back(b);
        }
        lp(i,1,n){
            sort(eg[i].begin(),eg[i].end(),cmp);
            lp(j,0,int(eg[i].size()-1)){
                eg[i][j]-&gt;nxt=eg[i][(j+1)%eg[i].size()];
            }
        }
        lp(i,0,int(all.size()-1)){
            if(!all[i]-&gt;bel){
                ++pcnt;ll ar=0;edge*t=all[i];
                do{
                    t-&gt;bel=pcnt;
                    t=t-&gt;nxt-&gt;rev;
                    ar+=pot::det(pos[t-&gt;u],pos[t-&gt;v]);
                }while(t!=all[i]);
                if(ar&lt;0)wside=pcnt;
            }
        }
    }
}
namespace mst{
    struct edge{
        edge(int a,int b,int c):
            u(a),v(b),w(c){}
        int u,v,w;
    };
    bool operator&lt;(const edge&amp;a,const edge&amp;b){
        return a.w&lt;b.w;
    }
    int vcnt;
    vector&lt;edge&gt;all,ans;
    int prt[100010*3];
    int fd(int u){return u==prt[u]?u:prt[u]=fd(prt[u]);}
    void build(){
        vcnt=plr::pcnt;
        lp(i,1,vcnt)prt[i]=i;
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            all.push_back(edge(e-&gt;bel,e-&gt;rev-&gt;bel,e-&gt;w));
        }
        sort(all.begin(),all.end());
        lp(i,0,int(all.size()-1)){
            edge&amp;e=all[i];
            if(fd(e.u)!=fd(e.v)&amp;&amp;e.u!=plr::wside&amp;&amp;e.v!=plr::wside){
                ans.push_back(e);
                prt[fd(e.u)]=e.v;
            }
        }
        /*lp(i,0,int(ans.size()-1)){
            pf("[%d,%d]\n",ans[i].u,ans[i].v);
        }*/
    }
}
namespace lca{
    int vcnt;
    vector&lt;int&gt;to[100010*3],we[100010*3];
    int vi[100010*3],dp[100010*3],up[100010*3][21],mx[100010*3][21];
    int query(int u,int v){
        int r=0;
        if(dp[u]&lt;dp[v])swap(u,v);
        lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)r=max(r,mx[u][i]),u=up[u][i];
        if(u==v)return r;
        for(int i=20;i&gt;=0;--i){
            if(up[u][i]!=up[v][i]){
                r=max(r,mx[u][i]);
                r=max(r,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        }
        return max(max(mx[u][0],mx[v][0]),r);
    }
    void build(){
        vcnt=mst::vcnt;
        lp(i,0,int(mst::ans.size()-1)){
            mst::edge&amp;e=mst::ans[i];
            to[e.u].push_back(e.v);
            we[e.u].push_back(e.w);
            to[e.v].push_back(e.u);
            we[e.v].push_back(e.w);
        }
        queue&lt;int&gt;qu;qu.push(plr::wside==1?2:1);
        vi[plr::wside==1?2:1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,1,20){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=max(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vi[v]){
                    vi[v]=1;dp[v]=dp[u]+1;
                    up[v][0]=u;
                    mx[v][0]=we[u][i];
                    qu.push(v);
                }
            }
        }
        //lp(i,1,vcnt)pf("[%d]",vi[i]);
        //lp(i,1,vcnt)lp(j,i+1,vcnt)pf("[%d,%d,%d]\n",i,j,query(i,j));
    }
}
namespace questions{
    int x[100010*2],y[100010*2],q,loc[100010*2];
    void init(){
        sf("%d",&amp;q);
        lp(i,1,q){
            double a,b,c,d;
            sf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);
            x[2*i-1]=a*2+0.1;y[2*i-1]=b*2+0.1;//避免误差
            x[2*i]=c*2+0.1;y[2*i]=d*2+0.1;
        }
    }
    void answer(){
        lp(i,1,q){
            int u=loc[2*i-1],v=loc[2*i];
            if(u==plr::wside||v==plr::wside)
                pf("-1\n");
            else
                pf("%d\n",lca::query(u,v));
        }
    }
}
namespace locate{
    struct event{
        event(int b,int c):
            typ(0),qi(b),x(c){}
        event(int a,plr::edge*b,int c):
            typ(a),e(b),x(c){}
        int typ;//0query1delete2insert
        plr::edge*e;
        int qi,x;
    };
    bool operator&lt;(const event&amp;a,const event&amp;b){
        return a.x==b.x?a.typ&lt;b.typ:a.x&lt;b.x;
    }
    vector&lt;event&gt;ev;
    struct node{
        node(int a,int b):typ(1),x(a),y(b){}
        node(plr::edge*a):typ(0),e(a){}
        int typ;//0seg1pot
        plr::edge*e;
        int x,y;
    };
    bool operator&lt;(const node&amp;a,const node&amp;b){
        if(a.typ==0&amp;&amp;b.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            pot::pot p3=plr::pos[b.e-&gt;u];
            pot::pot p4=plr::pos[b.e-&gt;v];
            double x1=pot::x(p1),y1=pot::y(p1);
            double x2=pot::x(p2),y2=pot::y(p2);
            double x3=pot::x(p3),y3=pot::y(p3);
            double x4=pot::x(p4),y4=pot::y(p4);
            double l=max(x1,x3),r=min(x2,x4);
            double t=(l+r)/2;
            double t1=(y1-y2)/(x1-x2)*(t-x1)+y1;
            double t2=(y3-y4)/(x3-x4)*(t-x3)+y3;
            return t1-t2&lt;-1e-5;
             
        }else if(a.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            return pot::det(p2-p1,pot::pot(b.x,b.y)-p1)&gt;0;
        }else{
            pot::pot p1=plr::pos[b.e-&gt;u];
            pot::pot p2=plr::pos[b.e-&gt;v];
            return pot::det(p2-p1,pot::pot(a.x,a.y)-p1)&lt;0;
        }
    }
    void solve(){
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            if(pot::x(plr::pos[e-&gt;u])&lt;pot::x(plr::pos[e-&gt;v])){
                ev.push_back(event(1,e,pot::x(plr::pos[e-&gt;v])));
                ev.push_back(event(2,e,pot::x(plr::pos[e-&gt;u])));
            }
        }
        lp(i,1,questions::q*2){
            ev.push_back(event(i,questions::x[i]));
        }
        sort(ev.begin(),ev.end());
        /*lp(i,0,int(ev.size()-1)){
            if(ev[i].typ==0)
                pf("qu %d %d\n",questions::x[ev[i].qi],
                    questions::y[ev[i].qi]);
            else if(ev[i].typ==1)
                pf("del %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
            else pf("ins %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
        }*/
        set&lt;node&gt;st;
        lp(i,0,int(ev.size()-1)){
            event&amp;e=ev[i];
            if(e.typ==0){
                node t(e.x,questions::y[e.qi]);
                set&lt;node&gt;::iterator it=st.lower_bound(t);
                if(it==st.end())questions::loc[e.qi]=plr::wside;
                else questions::loc[e.qi]=it-&gt;e-&gt;rev-&gt;bel;
            }else if(e.typ==1){
                node t(e.e);
                st.erase(t);
            }else{
                node t(e.e);
                st.insert(t);
            }
        }
        /*lp(i,1,questions::q*2){
            pf("[%d]\n",questions::loc[i]);
        }*/
    }
}
int main(){
    plr::build();
    mst::build();
    lca::build();
    questions::init();
    locate::solve();
    questions::answer();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;complex&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
/*
二维点 
*/
namespace pot{
    typedef complex&lt;ll&gt; pot;
    ll&amp;x(pot&amp;p){
        return real(p);
    }
    ll&amp;y(pot&amp;p){
        return imag(p);
    }
    double a(pot p){
        return atan2(double(y(p)),double(x(p)));
    }
    pot operator-(pot p,pot q){
        return pot(x(p)-x(q),y(p)-y(q));
    }
    ll det(pot p,pot q){
        return x(p)*y(q)-x(q)*y(p);
    }
}
namespace plr{
    const int nmx=100000;
    struct edge{
        edge(int a,int b,int c,double d):
            u(a),v(b),w(c),ang(d),bel(0){}
        int u,v,w,bel;
        edge*nxt,*rev;
        double ang;
    };
    bool cmp(edge*a,edge*b){
        return a-&gt;ang&lt;b-&gt;ang;
    }
    int n,m,pc,ws;
    pot::pot pos[nmx+10];
    vector&lt;edge*&gt;eg[nmx+10],all;
    void build(){
        sf("%d%d",&amp;n,&amp;m);
        lp(i,1,n){
            sf("%d%d",&amp;pot::x(pos[i]),&amp;pot::y(pos[i]));
            pot::x(pos[i])*=2,pot::y(pos[i])*=2;//乘2避免后面询问的小数
        }
        lp(i,1,m){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            edge*a=new edge(u,v,w,pot::a(pos[v]-pos[u]));
            edge*b=new edge(v,u,w,pot::a(pos[u]-pos[v]));
            a-&gt;rev=b;b-&gt;rev=a;
            eg[u].push_back(a);all.push_back(a);
            eg[v].push_back(b);all.push_back(b);
        }
        lp(i,1,n){
            sort(eg[i].begin(),eg[i].end(),cmp);
            lp(j,0,int(eg[i].size()-1)){
                eg[i][j]-&gt;nxt=eg[i][(j+1)%eg[i].size()];
            }
        }
        lp(i,0,int(all.size()-1)){
            if(!all[i]-&gt;bel){
                ++pc;ll ar=0;edge*t=all[i];
                do{
                    t-&gt;bel=pc;
                    t=t-&gt;nxt-&gt;rev;
                    ar+=pot::det(pos[t-&gt;u],pos[t-&gt;v]);
                }while(t!=all[i]);
                if(ar&lt;0)ws=pc;
            }
        }
    }
}
namespace mst{
    struct edge{
        edge(int a,int b,int c):
            u(a),v(b),w(c){}
        int u,v,w;
    };
    bool operator&lt;(const edge&amp;a,const edge&amp;b){
        return a.w&lt;b.w;
    }
    int vcnt;
    vector&lt;edge&gt;all,ans;
    int prt[100010*3];
    int fd(int u){return u==prt[u]?u:prt[u]=fd(prt[u]);}
    void build(){
        vcnt=plr::pc;
        lp(i,1,vcnt)prt[i]=i;
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            all.push_back(edge(e-&gt;bel,e-&gt;rev-&gt;bel,e-&gt;w));
        }
        sort(all.begin(),all.end());
        lp(i,0,int(all.size()-1)){
            edge&amp;e=all[i];
            if(fd(e.u)!=fd(e.v)&amp;&amp;e.u!=plr::ws&amp;&amp;e.v!=plr::ws){
                ans.push_back(e);
                prt[fd(e.u)]=e.v;
            }
        }
        /*lp(i,0,int(ans.size()-1)){
            pf("[%d,%d]\n",ans[i].u,ans[i].v);
        }*/
    }
}
namespace lca{
    int vcnt;
    vector&lt;int&gt;to[100010*3],we[100010*3];
    int vi[100010*3],dp[100010*3],up[100010*3][21],mx[100010*3][21];
    int query(int u,int v){
        int r=0;
        if(dp[u]&lt;dp[v])swap(u,v);
        lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)r=max(r,mx[u][i]),u=up[u][i];
        if(u==v)return r;
        for(int i=20;i&gt;=0;--i){
            if(up[u][i]!=up[v][i]){
                r=max(r,mx[u][i]);
                r=max(r,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        }
        return max(max(mx[u][0],mx[v][0]),r);
    }
    void build(){
        vcnt=mst::vcnt;
        lp(i,0,int(mst::ans.size()-1)){
            mst::edge&amp;e=mst::ans[i];
            to[e.u].push_back(e.v);
            we[e.u].push_back(e.w);
            to[e.v].push_back(e.u);
            we[e.v].push_back(e.w);
        }
        queue&lt;int&gt;qu;qu.push(plr::ws==1?2:1);
        vi[plr::ws==1?2:1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,1,20){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=max(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vi[v]){
                    vi[v]=1;dp[v]=dp[u]+1;
                    up[v][0]=u;
                    mx[v][0]=we[u][i];
                    qu.push(v);
                }
            }
        }
        //lp(i,1,vcnt)pf("[%d]",vi[i]);
        //lp(i,1,vcnt)lp(j,i+1,vcnt)pf("[%d,%d,%d]\n",i,j,query(i,j));
    }
}
namespace questions{
    int x[100010*2],y[100010*2],q,loc[100010*2];
    void init(){
        sf("%d",&amp;q);
        lp(i,1,q){
            double a,b,c,d;
            sf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);
            x[2*i-1]=a*2+0.1;y[2*i-1]=b*2+0.1;//避免误差
            x[2*i]=c*2+0.1;y[2*i]=d*2+0.1;
        }
    }
    void answer(){
        lp(i,1,q){
            int u=loc[2*i-1],v=loc[2*i];
            if(u==plr::ws||v==plr::ws)
                pf("-1\n");
            else
                pf("%d\n",lca::query(u,v));
        }
    }
}
namespace locate{
    struct event{
        event(int b,int c):
            typ(0),qi(b),x(c){}
        event(int a,plr::edge*b,int c):
            typ(a),e(b),x(c){}
        int typ;//0query1delete2insert
        plr::edge*e;
        int qi,x;
    };
    bool operator&lt;(const event&amp;a,const event&amp;b){
        return a.x==b.x?a.typ&lt;b.typ:a.x&lt;b.x;
    }
    vector&lt;event&gt;ev;
    struct node{
        node(int a,int b):typ(1),x(a),y(b){}
        node(plr::edge*a):typ(0),e(a){}
        int typ;//0seg1pot
        plr::edge*e;
        int x,y;
    };
    bool operator&lt;(const node&amp;a,const node&amp;b){
        if(a.typ==0&amp;&amp;b.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            pot::pot p3=plr::pos[b.e-&gt;u];
            pot::pot p4=plr::pos[b.e-&gt;v];
            double x1=pot::x(p1),y1=pot::y(p1);
            double x2=pot::x(p2),y2=pot::y(p2);
            double x3=pot::x(p3),y3=pot::y(p3);
            double x4=pot::x(p4),y4=pot::y(p4);
            double l=max(x1,x3),r=min(x2,x4);
            double t=(l+r)/2;
            double t1=(y1-y2)/(x1-x2)*(t-x1)+y1;
            double t2=(y3-y4)/(x3-x4)*(t-x3)+y3;
            return t1-t2&lt;-1e-5;
             
        }else if(a.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            return pot::det(p2-p1,pot::pot(b.x,b.y)-p1)&gt;0;
        }else{
            pot::pot p1=plr::pos[b.e-&gt;u];
            pot::pot p2=plr::pos[b.e-&gt;v];
            return pot::det(p2-p1,pot::pot(a.x,a.y)-p1)&lt;0;
        }
    }
    void solve(){
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            if(pot::x(plr::pos[e-&gt;u])&lt;pot::x(plr::pos[e-&gt;v])){
                ev.push_back(event(1,e,pot::x(plr::pos[e-&gt;v])));
                ev.push_back(event(2,e,pot::x(plr::pos[e-&gt;u])));
            }
        }
        lp(i,1,questions::q*2){
            ev.push_back(event(i,questions::x[i]));
        }
        sort(ev.begin(),ev.end());
        /*lp(i,0,int(ev.size()-1)){
            if(ev[i].typ==0)
                pf("qu %d %d\n",questions::x[ev[i].qi],
                    questions::y[ev[i].qi]);
            else if(ev[i].typ==1)
                pf("del %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
            else pf("ins %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
        }*/
        set&lt;node&gt;st;
        lp(i,0,int(ev.size()-1)){
            event&amp;e=ev[i];
            if(e.typ==0){
                node t(e.x,questions::y[e.qi]);
                set&lt;node&gt;::iterator it=st.lower_bound(t);
                if(it==st.end())questions::loc[e.qi]=plr::ws;
                else questions::loc[e.qi]=it-&gt;e-&gt;rev-&gt;bel;
            }else if(e.typ==1){
                node t(e.e);
                st.erase(t);
            }else{
                node t(e.e);
                st.insert(t);
            }
        }
        /*lp(i,1,questions::q*2){
            pf("[%d]\n",questions::loc[i]);
        }*/
    }
}
int main(){
    plr::build();
    mst::build();
    lca::build();
    questions::init();
    locate::solve();
    questions::answer();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;complex&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
/*
二维点 
*/
namespace pot{
    typedef complex&lt;ll&gt; pot;
    ll&amp;x(pot&amp;p){
        return real(p);
    }
    ll&amp;y(pot&amp;p){
        return imag(p);
    }
    double a(pot p){
        return atan2(double(y(p)),double(x(p)));
    }
    pot operator-(pot p,pot q){
        return pot(x(p)-x(q),y(p)-y(q));
    }
    ll det(pot p,pot q){
        return x(p)*y(q)-x(q)*y(p);
    }
}
namespace plr{
    const int nmx=100000;
    struct edge{
        edge(int a,int b,int c,double d):
            u(a),v(b),w(c),ang(d),bel(0){}
        int u,v,w,bel;
        edge*nxt,*rev;
        double ang;
    };
    bool cmp(edge*a,edge*b){
        return a-&gt;ang&lt;b-&gt;ang;
    }
    int n,m,pc,ws;
    pot::pot pos[nmx+10];
    vector&lt;edge*&gt;eg[nmx+10],all;
    void add(int u,int v,int w){
        edge*a=new edge(u,v,w,pot::a(pos[v]-pos[u]));
        edge*b=new edge(v,u,w,pot::a(pos[u]-pos[v]));
        a-&gt;rev=b;b-&gt;rev=a;
        eg[u].push_back(a);all.push_back(a);
        eg[v].push_back(b);all.push_back(b);
    }
    void build(){
        lp(i,1,n){
            sort(eg[i].begin(),eg[i].end(),cmp);
            lp(j,0,int(eg[i].size()-1)){
                eg[i][j]-&gt;nxt=eg[i][(j+1)%eg[i].size()];
            }
        }
        lp(i,0,int(all.size()-1)){
            if(!all[i]-&gt;bel){
                ++pc;ll ar=0;edge*t=all[i];
                do{
                    t-&gt;bel=pc;
                    t=t-&gt;nxt-&gt;rev;
                    ar+=pot::det(pos[t-&gt;u],pos[t-&gt;v]);
                }while(t!=all[i]);
                if(ar&lt;0)ws=pc;
            }
        }
    }
}
namespace mst{
    struct edge{
        edge(int a,int b,int c):
            u(a),v(b),w(c){}
        int u,v,w;
    };
    bool operator&lt;(const edge&amp;a,const edge&amp;b){
        return a.w&lt;b.w;
    }
    int vcnt;
    vector&lt;edge&gt;all,ans;
    int prt[100010*3];
    int fd(int u){return u==prt[u]?u:prt[u]=fd(prt[u]);}
    void build(){
        vcnt=plr::pc;
        lp(i,1,vcnt)prt[i]=i;
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            all.push_back(edge(e-&gt;bel,e-&gt;rev-&gt;bel,e-&gt;w));
        }
        sort(all.begin(),all.end());
        lp(i,0,int(all.size()-1)){
            edge&amp;e=all[i];
            if(fd(e.u)!=fd(e.v)&amp;&amp;e.u!=plr::ws&amp;&amp;e.v!=plr::ws){
                ans.push_back(e);
                prt[fd(e.u)]=e.v;
            }
        }
        /*lp(i,0,int(ans.size()-1)){
            pf("[%d,%d]\n",ans[i].u,ans[i].v);
        }*/
    }
}
namespace lca{
    int vcnt;
    vector&lt;int&gt;to[100010*3],we[100010*3];
    int vi[100010*3],dp[100010*3],up[100010*3][21],mx[100010*3][21];
    int query(int u,int v){
        int r=0;
        if(dp[u]&lt;dp[v])swap(u,v);
        lp(i,0,20)if(((dp[u]-dp[v])&gt;&gt;i)&amp;1)r=max(r,mx[u][i]),u=up[u][i];
        if(u==v)return r;
        for(int i=20;i&gt;=0;--i){
            if(up[u][i]!=up[v][i]){
                r=max(r,mx[u][i]);
                r=max(r,mx[v][i]);
                u=up[u][i];
                v=up[v][i];
            }
        }
        return max(max(mx[u][0],mx[v][0]),r);
    }
    void build(){
        vcnt=mst::vcnt;
        lp(i,0,int(mst::ans.size()-1)){
            mst::edge&amp;e=mst::ans[i];
            to[e.u].push_back(e.v);
            we[e.u].push_back(e.w);
            to[e.v].push_back(e.u);
            we[e.v].push_back(e.w);
        }
        queue&lt;int&gt;qu;qu.push(plr::ws==1?2:1);
        vi[plr::ws==1?2:1]=1;
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            lp(i,1,20){
                up[u][i]=up[up[u][i-1]][i-1];
                mx[u][i]=max(mx[u][i-1],mx[up[u][i-1]][i-1]);
            }
            lp(i,0,int(to[u].size()-1)){
                int v=to[u][i];
                if(!vi[v]){
                    vi[v]=1;dp[v]=dp[u]+1;
                    up[v][0]=u;
                    mx[v][0]=we[u][i];
                    qu.push(v);
                }
            }
        }
        //lp(i,1,vcnt)pf("[%d]",vi[i]);
        //lp(i,1,vcnt)lp(j,i+1,vcnt)pf("[%d,%d,%d]\n",i,j,query(i,j));
    }
}
namespace questions{
    int x[100010*2],y[100010*2],q,loc[100010*2];
    void init(){
        sf("%d",&amp;q);
        lp(i,1,q){
            double a,b,c,d;
            sf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);
            x[2*i-1]=a*2+0.1;y[2*i-1]=b*2+0.1;//避免误差
            x[2*i]=c*2+0.1;y[2*i]=d*2+0.1;
        }
    }
    void answer(){
        lp(i,1,q){
            int u=loc[2*i-1],v=loc[2*i];
            if(u==plr::ws||v==plr::ws)
                pf("-1\n");
            else
                pf("%d\n",lca::query(u,v));
        }
    }
}
namespace locate{
    struct event{
        event(int b,int c):
            typ(0),qi(b),x(c){}
        event(int a,plr::edge*b,int c):
            typ(a),e(b),x(c){}
        int typ;//0query1delete2insert
        plr::edge*e;
        int qi,x;
    };
    bool operator&lt;(const event&amp;a,const event&amp;b){
        return a.x==b.x?a.typ&lt;b.typ:a.x&lt;b.x;
    }
    vector&lt;event&gt;ev;
    struct node{
        node(int a,int b):typ(1),x(a),y(b){}
        node(plr::edge*a):typ(0),e(a){}
        int typ;//0seg1pot
        plr::edge*e;
        int x,y;
    };
    bool operator&lt;(const node&amp;a,const node&amp;b){
        if(a.typ==0&amp;&amp;b.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            pot::pot p3=plr::pos[b.e-&gt;u];
            pot::pot p4=plr::pos[b.e-&gt;v];
            double x1=pot::x(p1),y1=pot::y(p1);
            double x2=pot::x(p2),y2=pot::y(p2);
            double x3=pot::x(p3),y3=pot::y(p3);
            double x4=pot::x(p4),y4=pot::y(p4);
            double l=max(x1,x3),r=min(x2,x4);
            double t=(l+r)/2;
            double t1=(y1-y2)/(x1-x2)*(t-x1)+y1;
            double t2=(y3-y4)/(x3-x4)*(t-x3)+y3;
            return t1-t2&lt;-1e-5;
             
        }else if(a.typ==0){
            pot::pot p1=plr::pos[a.e-&gt;u];
            pot::pot p2=plr::pos[a.e-&gt;v];
            return pot::det(p2-p1,pot::pot(b.x,b.y)-p1)&gt;0;
        }else{
            pot::pot p1=plr::pos[b.e-&gt;u];
            pot::pot p2=plr::pos[b.e-&gt;v];
            return pot::det(p2-p1,pot::pot(a.x,a.y)-p1)&lt;0;
        }
    }
    void solve(){
        lp(i,0,int(plr::all.size()-1)){
            plr::edge*e=plr::all[i];
            if(pot::x(plr::pos[e-&gt;u])&lt;pot::x(plr::pos[e-&gt;v])){
                ev.push_back(event(1,e,pot::x(plr::pos[e-&gt;v])));
                ev.push_back(event(2,e,pot::x(plr::pos[e-&gt;u])));
            }
        }
        lp(i,1,questions::q*2){
            ev.push_back(event(i,questions::x[i]));
        }
        sort(ev.begin(),ev.end());
        /*lp(i,0,int(ev.size()-1)){
            if(ev[i].typ==0)
                pf("qu %d %d\n",questions::x[ev[i].qi],
                    questions::y[ev[i].qi]);
            else if(ev[i].typ==1)
                pf("del %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
            else pf("ins %d %d\n",ev[i].e-&gt;u,ev[i].e-&gt;v);
        }*/
        set&lt;node&gt;st;
        lp(i,0,int(ev.size()-1)){
            event&amp;e=ev[i];
            if(e.typ==0){
                node t(e.x,questions::y[e.qi]);
                set&lt;node&gt;::iterator it=st.lower_bound(t);
                if(it==st.end())questions::loc[e.qi]=plr::ws;
                else questions::loc[e.qi]=it-&gt;e-&gt;rev-&gt;bel;
            }else if(e.typ==1){
                node t(e.e);
                st.erase(t);
            }else{
                node t(e.e);
                st.insert(t);
            }
        }
        /*lp(i,1,questions::q*2){
            pf("[%d]\n",questions::loc[i]);
        }*/
    }
}
int main(){
    int m;sf("%d%d",&amp;plr::n,&amp;m);
    lp(i,1,plr::n){
        sf("%d%d",&amp;pot::x(plr::pos[i]),&amp;pot::y(plr::pos[i]));
        pot::x(plr::pos[i])*=2,pot::y(plr::pos[i])*=2;//乘2避免后面询问的小数
    }
    lp(i,1,m){
        int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        plr::add(u,v,w);
    }
    plr::build();
    mst::build();
    lca::build();
    questions::init();
    locate::solve();
    questions::answer();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3053</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;set&gt;
vector&lt;int&gt;pos[50010];int n,k;
struct node{
	node(vector&lt;int&gt;_p){
		mx=mi=p=_p;
		ch[0]=ch[1]=0;
	}
	vector&lt;int&gt;p,mx,mi;
	node*ch[2];
};
void update(node*x){
	lp(i,0,1)if(x-&gt;ch[i]){
		lp(j,0,k-1){
			x-&gt;mx[j]=max(x-&gt;mx[j],x-&gt;ch[i]-&gt;mx[j]);
			x-&gt;mi[j]=min(x-&gt;mi[j],x-&gt;ch[i]-&gt;mi[j]);
		}
	}
}
struct cmp{
	cmp(int _d):d(_d){}
	int d;
	bool operator()(vector&lt;int&gt; x,vector&lt;int&gt; y){
		return x[d]&lt;y[d];
	}
};
node*build(int l,int r,int d){
	sort(pos+l,pos+r+1,cmp(d));
	int m=(l+r)/2;
	node*ret=new node(pos[m]);
	if(l!=m)ret-&gt;ch[0]=build(l,m-1,(d+1)%k);
	if(m!=r)ret-&gt;ch[1]=build(m+1,r,(d+1)%k);
	update(ret);
	return ret;
}
int sqr(int x){
	return x*x;
}
int guess(node*x,vector&lt;int&gt;&amp;p){
	int ret=0;
	lp(i,0,k-1){
		if(p[i]&lt;x-&gt;mi[i])ret+=sqr(x-&gt;mi[i]-p[i]);
		if(p[i]&gt;x-&gt;mx[i])ret+=sqr(p[i]-x-&gt;mx[i]);
	}
	return ret;
}
int dist(vector&lt;int&gt;&amp;p,vector&lt;int&gt;&amp;q){
	int ret=0;
	lp(i,0,k-1)ret+=sqr(p[i]-q[i]);
	return ret;
}
void query(set&lt;pair&lt;int,vector&lt;int&gt; &gt; &gt;&amp;ans,vector&lt;int&gt;&amp;p,node*x){
	ans.insert(mp(dist(x-&gt;p,p),x-&gt;p));
	set&lt;pair&lt;int,vector&lt;int&gt; &gt; &gt;::iterator uu=ans.end();--uu;
	ans.erase(uu);
	int t1=x-&gt;ch[0]?guess(x-&gt;ch[0],p):~0u&gt;&gt;1;
	int t2=x-&gt;ch[1]?guess(x-&gt;ch[1],p):~0u&gt;&gt;1;
	if(t1&lt;t2){
		if(t1&lt;ans.rbegin()-&gt;first)query(ans,p,x-&gt;ch[0]);
		if(t2&lt;ans.rbegin()-&gt;first)query(ans,p,x-&gt;ch[1]);
	}else{
		if(t2&lt;ans.rbegin()-&gt;first)query(ans,p,x-&gt;ch[1]);
		if(t1&lt;ans.rbegin()-&gt;first)query(ans,p,x-&gt;ch[0]);
	}
}
int main(){
	while(sf("%d%d",&amp;n,&amp;k)!=EOF){
		lp(i,1,n){
			pos[i].resize(k);
			lp(j,0,k-1)sf("%d",&amp;pos[i][j]);
		}
		node*rt=build(1,n,0);
		int q;sf("%d",&amp;q);
		lp(i,1,q){
			vector&lt;int&gt;tmp(k);
			lp(j,0,k-1)sf("%d",&amp;tmp[j]);
			int m;sf("%d",&amp;m);
			set&lt;pair&lt;int,vector&lt;int&gt; &gt; &gt;ans;
			lp(j,1,m)ans.insert(mp(~0u&gt;&gt;1,vector&lt;int&gt;(1,j)));
			query(ans,tmp,rt);
			pf("the closest %d points are:\n",m);
			lp(j,1,m){
				lp(u,0,k-1)pf("%d%c",ans.begin()-&gt;second[u],u==k-1?'\n':' ');
				ans.erase(ans.begin());
			}
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3060</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
等价于选最多边满足条件
必然存在一种方案，所有(u,v)u&gt;k,v&gt;k都选，调整法易证
*/
int pr[1000010];
int u[2000010],v[2000010],n,m,k;
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
int main(){
	sf("%d%d%d",&amp;n,&amp;m,&amp;k);
	lp(i,1,n)pr[i]=i;
	lp(i,1,m){
		sf("%d%d",&amp;u[i],&amp;v[i]);
		if(u[i]&gt;k&amp;&amp;v[i]&gt;k){
			if(fd(u[i])!=fd(v[i])){
				pr[fd(u[i])]=v[i];
			}
		}
	}
	int ans=0;
	lp(i,1,m){
		if(u[i]&lt;=k||v[i]&lt;=k){
			if(fd(u[i])!=fd(v[i])){
				pr[fd(u[i])]=v[i];
			}else ++ans;
		}
	}
	pf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace wtreap{
	struct node{
		node(int v){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();
			vl=v;
		}
		node*ch[2];
		int sz,fx,vl;
		double tl,tr;
	}*rt=0;
	void relabel(node*x){
		if(x-&gt;ch[0]){
			x-&gt;ch[0]-&gt;tl=x-&gt;tl;
			x-&gt;ch[0]-&gt;tr=(x-&gt;tl+x-&gt;tr)/2;
			relabel(x-&gt;ch[0]);
		}
		if(x-&gt;ch[1]){
			x-&gt;ch[1]-&gt;tl=(x-&gt;tl+x-&gt;tr)/2;
			x-&gt;ch[1]-&gt;tr=x-&gt;tr;
			relabel(x-&gt;ch[1]);
		}
	}
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		y-&gt;tl=x-&gt;tl;
		y-&gt;tr=x-&gt;tr;
		x=y;
		relabel(x);
	}
	void insert(node*&amp;x,node*y,int k,double l,double r){
		if(!x)x=y,x-&gt;tl=l,x-&gt;tr=r;
		else{
			int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
			if(t&gt;=k-1){
				insert(x-&gt;ch[0],y,k,x-&gt;tl,(x-&gt;tl+x-&gt;tr)/2);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y,k-(t+1),(x-&gt;tl+x-&gt;tr)/2,x-&gt;tr);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	node*select(node*x,int k){
		int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
		if(k&lt;=t)return select(x-&gt;ch[0],k);
		else if(t+1==k)return x;
		else return select(x-&gt;ch[1],k-(t+1));
	}
	void print(){
		lp(i,1,rt-&gt;sz)pf("[%lf,%lf]\n",select(rt,i)-&gt;tl,select(rt,i)-&gt;tr);
	}
}
namespace treap{
	struct node{
		node(wtreap::node*a){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();mp=a;
		}
		node*ch[2];
		int sz,fx;
		wtreap::node*mp;
	};
	void print(node*x,int d){
		if(x){
			print(x-&gt;ch[0],d+1);
			pf("[%lf,%lf,%d,%d]\n",x-&gt;mp-&gt;tl,x-&gt;mp-&gt;tr,x-&gt;sz,d);
			print(x-&gt;ch[1],d+1);
		}
	}
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		x=y;
	}
	void insert(node*&amp;x,node*y){
		if(!x)x=y;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y-&gt;mp-&gt;tl+y-&gt;mp-&gt;tr){
				insert(x-&gt;ch[0],y);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	void remove(node*&amp;x,double y){
		if(fabs(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y)&lt;1e-8){
			if(!x-&gt;ch[0]){node*t=x;x=x-&gt;ch[1];delete t;}
			else if(!x-&gt;ch[1]){node*t=x;x=x-&gt;ch[0];delete t;}
			else if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;ch[1]-&gt;fx){
				rotate(x,0);
				remove(x-&gt;ch[1],y);
				update(x);
			}else{
				rotate(x,1);
				remove(x-&gt;ch[0],y);
				update(x);
			}
		}else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y)remove(x-&gt;ch[0],y);
			else remove(x-&gt;ch[1],y);
			update(x);
		}
	}
	int less(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;-1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+less(x-&gt;ch[1],y);
			else
				return less(x-&gt;ch[0],y);
		}
	}
	int lesseq(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+lesseq(x-&gt;ch[1],y);
			else
				return lesseq(x-&gt;ch[0],y);
		}
	}
}
namespace seg{
	struct node{
		node(int a,int b){
			ch[0]=ch[1]=0;
			l=a;r=b;tp=0;
		}
		node*ch[2];
		int l,r;
		treap::node*tp;
	}*rt;
	node*build(int l,int r){
		node*x=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			x-&gt;ch[0]=build(l,m);
			x-&gt;ch[1]=build(m+1,r);
		}
		return x;
	}
	int ask(node*x,double l,double r,int k){
		if(x-&gt;l==x-&gt;r)return x-&gt;l;
		else{
			int t=treap::lesseq(x-&gt;ch[0]-&gt;tp,r)-treap::less(x-&gt;ch[0]-&gt;tp,l);
			if(t&lt;=k-1)return ask(x-&gt;ch[1],l,r,k-t);
			else return ask(x-&gt;ch[0],l,r,k);
		}
	}
	void insert(node*x,int w,wtreap::node*y){
		treap::insert(x-&gt;tp,new treap::node(y));
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)insert(x-&gt;ch[0],w,y);
			else insert(x-&gt;ch[1],w,y);
		}
	}
	void remove(node*x,int w,double y){
		treap::remove(x-&gt;tp,y);
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)remove(x-&gt;ch[0],w,y);
			else remove(x-&gt;ch[1],w,y);
		}
	}
	void print(node*x){
		pf("----[%d,%d]----\n",x-&gt;l,x-&gt;r);
		treap::print(x-&gt;tp,0);
		if(x-&gt;l!=x-&gt;r){
			print(x-&gt;ch[0]);
			print(x-&gt;ch[1]);
		}
	}
}
int main(){
	seg::rt=seg::build(0,70000);
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		wtreap::node*x=new wtreap::node(t);
		wtreap::insert(wtreap::rt,x,i+1,0,10000);
		seg::insert(seg::rt,t,x);
	}
	int la=0,q;
	sf("%d",&amp;q);
	lp(i,1,q){
		char op[11];sf("%s",op+1);
		if(op[1]=='M'){
			int p,v;sf("%d%d",&amp;p,&amp;v);
			p^=la;v^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,p);
			seg::remove(seg::rt,x-&gt;vl,x-&gt;tl+x-&gt;tr);x-&gt;vl=v;
			seg::insert(seg::rt,x-&gt;vl,x);
		}else if(op[1]=='I'){
			int p,v;sf("%d%d",&amp;p,&amp;v);
			p^=la;v^=la;
			wtreap::node*x=new wtreap::node(v);
			wtreap::insert(wtreap::rt,x,p,0,10000);
			seg::insert(seg::rt,v,x);
		}else{
			int pl,pr,k;sf("%d%d%d",&amp;pl,&amp;pr,&amp;k);
			pl^=la;pr^=la;k^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,pl);
			wtreap::node*y=wtreap::select(wtreap::rt,pr);
			la=seg::ask(seg::rt,x-&gt;tl+x-&gt;tr,y-&gt;tl+y-&gt;tr,k);
			pf("%d\n",la);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace wtreap{
	struct node{
		node(int v){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();
			vl=v;
		}
		node*ch[2];
		int sz,fx,vl;
		double tl,tr;
	}*rt=0;
	void relabel(node*x){
		if(x-&gt;ch[0]){
			x-&gt;ch[0]-&gt;tl=x-&gt;tl;
			x-&gt;ch[0]-&gt;tr=(x-&gt;tl+x-&gt;tr)/2;
			relabel(x-&gt;ch[0]);
		}
		if(x-&gt;ch[1]){
			x-&gt;ch[1]-&gt;tl=(x-&gt;tl+x-&gt;tr)/2;
			x-&gt;ch[1]-&gt;tr=x-&gt;tr;
			relabel(x-&gt;ch[1]);
		}
	}
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		y-&gt;tl=x-&gt;tl;
		y-&gt;tr=x-&gt;tr;
		x=y;
		relabel(x);
	}
	void insert(node*&amp;x,node*y,int k,double l,double r){
		if(!x)x=y,x-&gt;tl=l,x-&gt;tr=r;
		else{
			int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
			if(t&gt;=k-1){
				insert(x-&gt;ch[0],y,k,x-&gt;tl,(x-&gt;tl+x-&gt;tr)/2);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y,k-(t+1),(x-&gt;tl+x-&gt;tr)/2,x-&gt;tr);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	node*select(node*x,int k){
		int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
		if(k&lt;=t)return select(x-&gt;ch[0],k);
		else if(t+1==k)return x;
		else return select(x-&gt;ch[1],k-(t+1));
	}
	void print(){
		lp(i,1,rt-&gt;sz)pf("[%lf,%lf]\n",select(rt,i)-&gt;tl,select(rt,i)-&gt;tr);
	}
}
namespace treap{
	struct node{
		node(wtreap::node*a){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();mp=a;
		}
		node*ch[2];
		int sz,fx;
		wtreap::node*mp;
	};
	void print(node*x,int d){
		if(x){
			print(x-&gt;ch[0],d+1);
			pf("[%lf,%lf,%d,%d]\n",x-&gt;mp-&gt;tl,x-&gt;mp-&gt;tr,x-&gt;sz,d);
			print(x-&gt;ch[1],d+1);
		}
	}
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		x=y;
	}
	void insert(node*&amp;x,node*y){
		if(!x)x=y;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y-&gt;mp-&gt;tl+y-&gt;mp-&gt;tr){
				insert(x-&gt;ch[0],y);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	void remove(node*&amp;x,double y){
		if(fabs(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y)&lt;1e-8){
			if(!x-&gt;ch[0]){node*t=x;x=x-&gt;ch[1];delete t;}
			else if(!x-&gt;ch[1]){node*t=x;x=x-&gt;ch[0];delete t;}
			else if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;ch[1]-&gt;fx){
				rotate(x,0);
				remove(x-&gt;ch[1],y);
				update(x);
			}else{
				rotate(x,1);
				remove(x-&gt;ch[0],y);
				update(x);
			}
		}else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y)remove(x-&gt;ch[0],y);
			else remove(x-&gt;ch[1],y);
			update(x);
		}
	}
	int less(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;-1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+less(x-&gt;ch[1],y);
			else
				return less(x-&gt;ch[0],y);
		}
	}
	int lesseq(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+lesseq(x-&gt;ch[1],y);
			else
				return lesseq(x-&gt;ch[0],y);
		}
	}
}
namespace seg{
	struct node{
		node(int a,int b){
			ch[0]=ch[1]=0;
			l=a;r=b;tp=0;
		}
		node*ch[2];
		int l,r;
		treap::node*tp;
	}*rt;
	node*build(int l,int r){
		node*x=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			x-&gt;ch[0]=build(l,m);
			x-&gt;ch[1]=build(m+1,r);
		}
		return x;
	}
	int ask(node*x,double l,double r,int k){
		if(x-&gt;l==x-&gt;r)return x-&gt;l;
		else{
			int t=treap::lesseq(x-&gt;ch[0]-&gt;tp,r)-treap::less(x-&gt;ch[0]-&gt;tp,l);
			if(t&lt;=k-1)return ask(x-&gt;ch[1],l,r,k-t);
			else return ask(x-&gt;ch[0],l,r,k);
		}
	}
	void insert(node*x,int w,wtreap::node*y){
		treap::insert(x-&gt;tp,new treap::node(y));
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)insert(x-&gt;ch[0],w,y);
			else insert(x-&gt;ch[1],w,y);
		}
	}
	void remove(node*x,int w,double y){
		treap::remove(x-&gt;tp,y);
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)remove(x-&gt;ch[0],w,y);
			else remove(x-&gt;ch[1],w,y);
		}
	}
	void print(node*x){
		pf("----[%d,%d]----\n",x-&gt;l,x-&gt;r);
		treap::print(x-&gt;tp,0);
		if(x-&gt;l!=x-&gt;r){
			print(x-&gt;ch[0]);
			print(x-&gt;ch[1]);
		}
	}
}
int main(){
	seg::rt=seg::build(0,70000);
	int n;sf("%d",&amp;n);
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		wtreap::node*x=new wtreap::node(t);
		wtreap::insert(wtreap::rt,x,i+1,0,n);
		seg::insert(seg::rt,t,x);
	}
	int la=0,q;
	sf("%d",&amp;q);
	lp(i,1,q){
		char op[11];sf("%s",op+1);
		if(op[1]=='M'){
			int p,v;sf("%d%d",&amp;p,&amp;v);
			p^=la;v^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,p);
			seg::remove(seg::rt,x-&gt;vl,x-&gt;tl+x-&gt;tr);x-&gt;vl=v;
			seg::insert(seg::rt,x-&gt;vl,x);
		}else if(op[1]=='I'){
			int p,v;sf("%d%d",&amp;p,&amp;v);
			p^=la;v^=la;
			wtreap::node*x=new wtreap::node(v);
			wtreap::insert(wtreap::rt,x,p,0,n);
			seg::insert(seg::rt,v,x);
		}else{
			int pl,pr,k;sf("%d%d%d",&amp;pl,&amp;pr,&amp;k);
			pl^=la;pr^=la;k^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,pl);
			wtreap::node*y=wtreap::select(wtreap::rt,pr);
			la=seg::ask(seg::rt,x-&gt;tl+x-&gt;tr,y-&gt;tl+y-&gt;tr,k);
			pf("%d\n",la);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace wtreap{
	struct node{
		node(int v){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();
			vl=v;
		}
		node*ch[2];
		int sz,fx,vl;
		double tl,tr;
	}*rt=0;
	void relabel(node*x){
		if(x-&gt;ch[0]){
			x-&gt;ch[0]-&gt;tl=x-&gt;tl;
			x-&gt;ch[0]-&gt;tr=(x-&gt;tl+x-&gt;tr)/2;
			relabel(x-&gt;ch[0]);
		}
		if(x-&gt;ch[1]){
			x-&gt;ch[1]-&gt;tl=(x-&gt;tl+x-&gt;tr)/2;
			x-&gt;ch[1]-&gt;tr=x-&gt;tr;
			relabel(x-&gt;ch[1]);
		}
	}
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		y-&gt;tl=x-&gt;tl;
		y-&gt;tr=x-&gt;tr;
		x=y;
		relabel(x);
	}
	void insert(node*&amp;x,node*y,int k,double l,double r){
		if(!x)x=y,x-&gt;tl=l,x-&gt;tr=r;
		else{
			int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
			if(t&gt;=k-1){
				insert(x-&gt;ch[0],y,k,x-&gt;tl,(x-&gt;tl+x-&gt;tr)/2);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y,k-(t+1),(x-&gt;tl+x-&gt;tr)/2,x-&gt;tr);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	node*select(node*x,int k){
		int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0);
		if(k&lt;=t)return select(x-&gt;ch[0],k);
		else if(t+1==k)return x;
		else return select(x-&gt;ch[1],k-(t+1));
	}
}
namespace treap{
	struct node{
		node(wtreap::node*a){
			ch[0]=ch[1]=0;
			sz=1;fx=rand();mp=a;
		}
		node*ch[2];
		int sz,fx;
		wtreap::node*mp;
	};
	void update(node*x){
		x-&gt;sz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
	}
	void rotate(node*&amp;x,int d){
		node*y=x-&gt;ch[d];
		x-&gt;ch[d]=y-&gt;ch[!d];
		y-&gt;ch[!d]=x;
		update(x);
		update(y);
		x=y;
	}
	void insert(node*&amp;x,node*y){
		if(!x)x=y;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y-&gt;mp-&gt;tl+y-&gt;mp-&gt;tr){
				insert(x-&gt;ch[0],y);
				update(x);
				if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;fx)rotate(x,0);
			}else{
				insert(x-&gt;ch[1],y);
				update(x);
				if(x-&gt;ch[1]-&gt;fx&gt;x-&gt;fx)rotate(x,1);
			}
		}
	}
	void remove(node*&amp;x,double y){
		if(fabs(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y)&lt;1e-8){
			if(!x-&gt;ch[0]){node*t=x;x=x-&gt;ch[1];delete t;}
			else if(!x-&gt;ch[1]){node*t=x;x=x-&gt;ch[0];delete t;}
			else if(x-&gt;ch[0]-&gt;fx&gt;x-&gt;ch[1]-&gt;fx){
				rotate(x,0);
				remove(x-&gt;ch[1],y);
				update(x);
			}else{
				rotate(x,1);
				remove(x-&gt;ch[0],y);
				update(x);
			}
		}else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr&gt;y)remove(x-&gt;ch[0],y);
			else remove(x-&gt;ch[1],y);
			update(x);
		}
	}
	int less(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;-1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+less(x-&gt;ch[1],y);
			else
				return less(x-&gt;ch[0],y);
		}
	}
	int lesseq(node*x,double y){
		if(!x)return 0;
		else{
			if(x-&gt;mp-&gt;tl+x-&gt;mp-&gt;tr-y&lt;1e-8)
				return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+lesseq(x-&gt;ch[1],y);
			else
				return lesseq(x-&gt;ch[0],y);
		}
	}
}
namespace seg{
	struct node{
		node(int a,int b){
			ch[0]=ch[1]=0;
			l=a;r=b;tp=0;
		}
		node*ch[2];
		int l,r;
		treap::node*tp;
	}*rt;
	node*build(int l,int r){
		node*x=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			x-&gt;ch[0]=build(l,m);
			x-&gt;ch[1]=build(m+1,r);
		}
		return x;
	}
	int ask(node*x,double l,double r,int k){
		if(x-&gt;l==x-&gt;r)return x-&gt;l;
		else{
			int t=treap::lesseq(x-&gt;ch[0]-&gt;tp,r)-treap::less(x-&gt;ch[0]-&gt;tp,l);
			if(t&lt;=k-1)return ask(x-&gt;ch[1],l,r,k-t);
			else return ask(x-&gt;ch[0],l,r,k);
		}
	}
	void insert(node*x,int w,wtreap::node*y){
		treap::insert(x-&gt;tp,new treap::node(y));
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)insert(x-&gt;ch[0],w,y);
			else insert(x-&gt;ch[1],w,y);
		}
	}
	void remove(node*x,int w,double y){
		treap::remove(x-&gt;tp,y);
		if(x-&gt;l!=x-&gt;r){
			int m=(x-&gt;l+x-&gt;r)/2;
			if(w&lt;=m)remove(x-&gt;ch[0],w,y);
			else remove(x-&gt;ch[1],w,y);
		}
	}
}
char getchr(){
	char c;while(c=getchar(),c=='\n'||c==' ');
	return c;
}
int getint(){
   int r=getchr()-'0';char c;
   while(c=getchar(),'0'&lt;=c&amp;&amp;c&lt;='9')r=r*10+c-'0';
   return r;
}
int main(){
	seg::rt=seg::build(0,70000);
	int n=getint();
	lp(i,1,n){
		int t=getint();
		wtreap::node*x=new wtreap::node(t);
		wtreap::insert(wtreap::rt,x,i+1,0,n);
		seg::insert(seg::rt,t,x);
	}
	int la=0,q=getint();
	lp(i,1,q){
		char op=getchr();
		if(op=='M'){
			int p=getint(),v=getint();
			p^=la;v^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,p);
			seg::remove(seg::rt,x-&gt;vl,x-&gt;tl+x-&gt;tr);x-&gt;vl=v;
			seg::insert(seg::rt,x-&gt;vl,x);
		}else if(op=='I'){
			int p=getint(),v=getint();
			p^=la;v^=la;
			wtreap::node*x=new wtreap::node(v);
			wtreap::insert(wtreap::rt,x,p,0,n);
			seg::insert(seg::rt,v,x);
		}else{
			int pl=getint(),pr=getint(),k=getint();
			pl^=la;pr^=la;k^=la;
			wtreap::node*x=wtreap::select(wtreap::rt,pl);
			wtreap::node*y=wtreap::select(wtreap::rt,pr);
			la=seg::ask(seg::rt,x-&gt;tl+x-&gt;tr,y-&gt;tl+y-&gt;tr,k);
			pf("%d\n",la);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3068</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int mx=500010;
int n,wei[mx];vector&lt;int&gt;to[mx];
void build_tree(){
     sf("%d",&amp;n);
     lp(i,1,n-1){
        int a,b;
        sf("%d%d",&amp;a,&amp;b);
        to[a].push_back(b);
        to[b].push_back(a);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
}
int prt[mx];
void calc_prt(int u,int p){
    prt[u]=p;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=p){
            calc_prt(v,u);
        }
    }
}
long long sumd[mx],engd[mx];
void calc_sumd(int u){
    sumd[u]=wei[u];
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            calc_sumd(v);
            sumd[u]+=sumd[v];
        }
    }
}
void calc_engd(int u){
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            calc_engd(v);
            engd[u]+=engd[v]+sumd[v];
        }
    }
}
long long engu[mx],sumu[mx];
void calc_sumu(){
    long long t=0;lp(i,1,n)t+=wei[i];
    lp(i,1,n)sumu[i]=t-sumd[i];
}
void calc_engu(int u){
    if(prt[u]){
        lp(i,0,int(to[prt[u]].size()-1)){
            int w=to[prt[u]][i];
            if(w!=u&amp;&amp;w!=prt[prt[u]]){
                engu[u]+=engd[w]+sumd[w];
            }
        }
        engu[u]+=sumu[prt[u]]+engu[prt[u]];
    }
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u])calc_engu(v);
    }
}
int bg[mx],ed[mx],ti;
void calc_dfs(int u){
    bg[u]=++ti;
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u])calc_dfs(v);
    }
    ed[u]=ti;
}
long long ans=-1;
void calc_mov(int u,int x,long long ex,int dx,int y,long long ey,int dy){
    while(true){
        int flg=0;
        lp(i,0,int(to[x].size()-1)){
            int z=to[x][i],k=0;
            long long t=0;
            if(z==u)continue;
            if(z==prt[x]){
                if(bg[x]&lt;=bg[prt[u]]&amp;&amp;ed[x]&gt;=ed[prt[u]])k=dx+1;
                else k=dx-1;
            }else{
                if(bg[x]&lt;=bg[prt[u]]&amp;&amp;ed[x]&gt;=ed[prt[u]]){
                    if(bg[z]&lt;=bg[prt[u]]&amp;&amp;ed[z]&gt;=ed[prt[u]])k=dx-1;
                    else k=dx+1;
                }else k=dx+1;
            }
            t=engd[z]+engu[z]+sumu[z]-(engd[u]+(k+1)*sumd[u]);
            if(t&lt;ex){x=z,ex=t,dx=k,flg=1;break;}
        }
        if(!flg)break;
    }
    while(true){
        int flg=0;
        lp(i,0,int(to[y].size()-1)){
            int z=to[y][i],k=0;long long t;
            if(z==prt[u])continue;
            if(z==prt[y])k=dy-1;
            else k=dy+1;
            t=engd[z]+engu[z]+sumu[z]-(engu[u]+(k+1)*sumu[u]);
            if(t&lt;ey){y=z,ey=t,dy=k,flg=1;break;}
        }
        if(!flg)break;
    }
    if(ans==-1||ans&gt;ex+ey)ans=ex+ey; 
    lp(i,0,int(to[u].size()-1)){
        int v=to[u][i];
        if(v!=prt[u]){
            if(!(bg[v]&lt;=bg[y]&amp;&amp;ed[v]&gt;=ed[y]))
                calc_mov(v,x,ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1),dx+1,
                         v,engd[v],0);
            else
                calc_mov(v,x,ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1),dx+1,
                         y,ey-(engd[u]-(engd[v]+sumd[v]))-dy*(sumd[u]-sumd[v]),dy-1);
        }
    }
}
void calc_ans(){
    lp(i,0,int(to[1].size()-1)){
        int v=to[1][i];
        calc_mov(v,1,engd[1]-(engd[v]+sumd[v]),0,v,engd[v],0);
    }
}
int main(){
    build_tree();
    calc_prt(1,0);
    calc_sumd(1);
    calc_engd(1);
    calc_sumu();
    calc_engu(1);
    calc_dfs(1);
    calc_ans();
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3068</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int mx=500010;
int bg[mx*2],to[mx*2],nx[mx*2],nw;
int n,wei[mx];
void add(int u,int v){to[++nw]=v;nx[nw]=bg[u];bg[u]=nw;}
void build_tree(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        add(a,b),add(b,a);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
}
int prt[mx],stk[mx*2],que[mx];
void calc_prt(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int p=stk[stk[0]--],u=stk[stk[0]--];
        prt[u]=p;
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=p)stk[++stk[0]]=v,stk[++stk[0]]=u;
        }
    }
}
long long sumd[mx],engd[mx];
void calc_sumd(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            sumd[u]=wei[u];
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])sumd[u]+=sumd[v];
            }
        }
    }
}
void calc_engd(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])engd[u]+=engd[v]+sumd[v];
            }
        }
    }
}
long long engu[mx],sumu[mx];
void calc_sumu(){
    long long t=0;lp(i,1,n)t+=wei[i];
    lp(i,1,n)sumu[i]=t-sumd[i];
}
void calc_engu(){
    stk[0]=1;stk[1]=1;
    while(stk[0]){
        int u=stk[stk[0]--];
        if(prt[u]){
            for(int i=bg[prt[u]];i;i=nx[i]){
                int w=to[i];
                if(w!=u&amp;&amp;w!=prt[prt[u]]){
                    engu[u]+=engd[w]+sumd[w];
                }
            }
            engu[u]+=sumu[prt[u]]+engu[prt[u]];
        }
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=prt[u])stk[++stk[0]]=v;
        } 
    } 
}
int lt[mx],rt[mx],ti;
void calc_dfs(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            lt[u]=++ti;
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            rt[u]=ti;
        }
    }
}
long long ans=-1;
int stku[mx],stkx[mx],stky[mx],stkdx[mx],stkdy[mx],stktp;
long long stkex[mx],stkey[mx];
void calc_ans(){
    for(int i=bg[1];i;i=nx[i]){
        int v=to[i];
        ++stktp;
        stku[stktp]=v;
        stkx[stktp]=1;
        stkex[stktp]=engd[1]-(engd[v]+sumd[v]);
        stkdx[stktp]=0;
        stky[stktp]=v;
        stkey[stktp]=engd[v];
        stkdy[stktp]=0;
    }
    while(stktp){
        int u=stku[stktp];
        int x=stkx[stktp];
        long long ex=stkex[stktp];
        int dx=stkdx[stktp];
        int y=stky[stktp];
        long long ey=stkey[stktp];
        int dy=stkdy[stktp];
        --stktp;
        while(true){
            int flg=0;
            for(int i=bg[x];i;i=nx[i]){
                int z=to[i],k=0;
                long long t=0;
                if(z==u)continue;
                if(z==prt[x]){
                    if(lt[x]&lt;=lt[prt[u]]&amp;&amp;rt[x]&gt;=rt[prt[u]])k=dx+1;
                    else k=dx-1;
                }else{
                    if(lt[x]&lt;=lt[prt[u]]&amp;&amp;rt[x]&gt;=rt[prt[u]]){
                        if(lt[z]&lt;=lt[prt[u]]&amp;&amp;rt[z]&gt;=rt[prt[u]])k=dx-1;
                        else k=dx+1;
                    }else k=dx+1;
                }
                t=engd[z]+engu[z]+sumu[z]-(engd[u]+(k+1)*sumd[u]);
                if(t&lt;ex){x=z,ex=t,dx=k,flg=1;break;}
            }
            if(!flg)break;
        }
        while(true){
            int flg=0;
            for(int i=bg[y];i;i=nx[i]){
                int z=to[i],k=0;long long t;
                if(z==prt[u])continue;
                if(z==prt[y])k=dy-1;
                else k=dy+1;
                t=engd[z]+engu[z]+sumu[z]-(engu[u]+(k+1)*sumu[u]);
                if(t&lt;ey){y=z,ey=t,dy=k,flg=1;break;}
            }
            if(!flg)break;
        }
        if(ans==-1||ans&gt;ex+ey)ans=ex+ey;
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=prt[u]){
                if(!(lt[v]&lt;=lt[y]&amp;&amp;rt[v]&gt;=rt[y])){
                    ++stktp;
                    stku[stktp]=v;
                    stkx[stktp]=x;
                    stkex[stktp]=ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1);
                    stkdx[stktp]=dx+1;
                    stky[stktp]=v;
                    stkey[stktp]=engd[v];
                    stkdy[stktp]=0;
                }else{
                    ++stktp;
                    stku[stktp]=v;
                    stkx[stktp]=x;
                    stkex[stktp]=ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1);
                    stkdx[stktp]=dx+1;
                    stky[stktp]=y;
                    stkey[stktp]=ey-(engd[u]-(engd[v]+sumd[v]))-dy*(sumd[u]-sumd[v]);
                    stkdy[stktp]=dy-1;
                }
            }
        }
    }
}
int main(){
    build_tree();
    calc_prt();
    calc_sumd();
    calc_engd();
    calc_sumu();
    calc_engu();
    calc_dfs();
    calc_ans();
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
#include&lt;queue&gt;
#include&lt;stack&gt;
const int INF=~0u&gt;&gt;1;
vector&lt;int&gt;to[100010];int rt,n,q,we[100010];
int dp[100010],sz[100010],ch[100010],pr[100010];
int bg[100010],ed[100010],val[100010],nw,pos[100010],nw2;
int top[100010];vector&lt;int&gt;chd[100010];
inline void dfs1(int uu){
    stack&lt;int&gt;stk;stk.push(uu);
    vector&lt;int&gt;tmp;
    while(!stk.empty()){
        int u=stk.top();stk.pop();
        tmp.pb(u);
        vp(i,to[u]){
        int v=to[u][i];
        if(v!=pr[u]){
            dp[v]=dp[u]+1;
            pr[v]=u;chd[u].pb(v);
            stk.push(v);
        }
        }
    }
    wp(i,tmp){
        int u=tmp[i]; sz[u]=1;
        vp(j,chd[u]){
            int v=chd[u][j];
           
            sz[u]+=sz[v];
            if(sz[v]&gt;sz[ch[u]])ch[u]=v;
        }
    }
}
inline void dfs2(int uu,int aa){
    stack&lt;int&gt;st1,st2,st3;st1.push(uu);st2.push(aa);st3.push(0);
    while(!st1.empty()){
        int u=st1.top();st1.pop();
        int a=st2.top();st2.pop();
        int y=st3.top();st3.pop();
        if(y==0){
            st1.push(u);st2.push(a);st3.push(1);
            pos[u]=++nw2;val[nw2]=we[u];top[u]=a;
            bg[u]=++nw;
            vp(i,to[u]){
                    int v=to[u][i];
                    if(v!=pr[u]&amp;&amp;v!=ch[u]){
            st1.push(v);st2.push(v);st3.push(0);
                    }
                }
            if(ch[u]){
                st1.push(ch[u]);st2.push(a);st3.push(0);
            }
        }else ed[u]=nw;
        
    }
}
namespace seg{
    int sam[100010*4],mii[100010*4];
    inline void down(int x,int l,int r){
        if(sam[x]!=-INF){
            mii[x]=sam[x];
            if(l!=r){
                sam[x*2]=sam[x];
                sam[x*2+1]=sam[x];
            }
            sam[x]=-INF;
        }
    }
    inline void upda(int x,int l,int r){
        int m=(l+r)/2;
        down(x*2,l,m);down(x*2+1,m+1,r);
        mii[x]=min(mii[x*2],mii[x*2+1]);
    }
    inline void build(int x,int l,int r){
        sam[x]=-INF;
        if(l==r)mii[x]=val[l];
        else{
            int m=(l+r)/2;
            build(x*2,l,m);
            build(x*2+1,m+1,r);
            upda(x,l,r);
        }
    }
    inline void makesam(int x,int l,int r,int b,int e,int v){
        down(x,l,r);
        if(b&lt;=l&amp;&amp;e&gt;=r)sam[x]=v;
        else{
            int m=(l+r)/2;
            if(b&lt;=m)makesam(x*2,l,m,b,e,v);
            if(e&gt;m)makesam(x*2+1,m+1,r,b,e,v);
            upda(x,l,r);
        }
    }
    inline int ask(int x,int l,int r,int b,int e){
        down(x,l,r);
        if(b&lt;=l&amp;&amp;e&gt;=r)return mii[x];
        else{
            int m=(l+r)/2,ret=INF;
            if(b&lt;=m)ret=min(ret,ask(x*2,l,m,b,e));
            if(e&gt;m)ret=min(ret,ask(x*2+1,m+1,r,b,e));
            return ret;
        }
    }
}
void modify(int u,int v,int w){
    while(top[u]!=top[v]){
        if(dp[top[u]]&lt;dp[top[v]])swap(u,v);
        seg::makesam(1,1,n,pos[top[u]],pos[u],w);
        u=pr[top[u]];
    }
    if(dp[u]&lt;dp[v])swap(u,v);
    seg::makesam(1,1,n,pos[v],pos[u],w);
}
int askmin(int u){
    if(bg[rt]&lt;=bg[u]&amp;&amp;ed[rt]&gt;=ed[u]){
        if(bg[rt]!=bg[u]||ed[rt]!=ed[u])
            return seg::ask(1,1,n,bg[u],ed[u]);
        else return seg::ask(1,1,n,1,n);
    }else if(bg[rt]&gt;=bg[u]&amp;&amp;ed[rt]&lt;=ed[u]){
        int lft=0,rght=int(chd[u].size()-1);
        int v;
        if(pos[rt]&gt;=bg[chd[u].back()])v=chd[u].back();
        else{
            while(lft+1&lt;rght){
                int mid=(lft+rght)/2;
                if(pos[rt]&gt;=bg[chd[u][mid]])
                    lft=mid;
                else
                    rght=mid;
            }
            v=chd[u][lft];
        }
        int ret=INF;
        if(bg[v]!=1)ret=min(ret,seg::ask(1,1,n,1,bg[v]-1));
        if(ed[v]!=n)ret=min(ret,seg::ask(1,1,n,ed[v]+1,n));
        return ret;
    }else return seg::ask(1,1,n,bg[u],ed[u]);
}
bool cpm(int a,int b){
    return bg[a]&lt;bg[b];
}
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);to[v].pb(u);
    }
    lp(i,1,n)sf("%d",&amp;we[i]);sf("%d",&amp;rt);
    dfs1(1);
    dfs2(1,1);
    //lp(i,1,n)pf("[%d,%d,%d,%d]\n",bg[i],ed[i],sz[i],pr[i]);
    //lp(i,1,n)pf("[%d]\n",pos[i]);
    //lp(i,1,n)pf("[%d]\n",val[i]);
    //lp(i,1,n)pf("[%d,%d,%d]\n",pos[i],bg[i],ed[i]);
    //lp(i,1,n)pf("[%d] ",sz[i]);
    seg::build(1,1,n);
    lp(i,1,n)sort(chd[i].begin(),chd[i].end(),cpm);
    lp(i,1,q){
        int opt;sf("%d",&amp;opt);
        if(opt==1){
            sf("%d",&amp;rt);
        }else if(opt==2){
            int u,v,w;sf("%d%d%d",&amp;u,&amp;v,&amp;w);
            modify(u,v,w);
        }else{
            int x;sf("%d",&amp;x);
            pf("%d\n",askmin(x));
        }
    }
    //ps;
    return 0;
}
/*
4 3
2 1
3 2
4 1
2 2 3 1 
1
1 4
3 2
2 4 1
*/
</pre><pre></pre><h2>Problem3097</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int ans[400010];
int main(){
	int n=100000,l=10000;
	for(int i=1;i&lt;=n;i*=2){
		lp(j,1,i)ans[i+j]=(ans[j]^1);
	}
	pf("%d %d\n",n,l);
	lp(i,1,n)pf("%c",'a'+ans[i]);pf("\n");
	return 0;
}</pre><pre></pre><h2>Problem3098</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int main(){
	pf("100000 20\n");
	lp(i,1,100000)pf("%c",'a'+rand()%26);
	pf("\n");
	return 0;
}</pre><pre></pre><h2>Problem3100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
bool c[1000010];ll s[1000010];int n,ans;
void work(int l,int m,int r){
    int pr=m;while(pr+1&lt;=r&amp;&amp;!c[s[pr+1]-s[pr]])c[s[pr+1]-s[pr]]=1,++pr;
    int pl=m,px=m;
    for(;pl&gt;=l;--pl){
        while(c[s[pl]-s[pl-1]]&amp;&amp;pr&gt;=m)
            c[s[pr]-s[pr-1]]=0,--pr;
        c[s[pl]-s[pl-1]]=1;
        if(pr&lt;m)break;
        if(s[px]-s[px-1]&lt;s[pl]-s[pl-1])px=pl;
        if(pl+s[px]-s[px-1]-1&lt;=pr&amp;&amp;s[pl+s[px]-s[px-1]-1]-s[pl-1]==(s[px]-s[px-1])*(s[px]-s[px-1]+1)/2)
            ans=max(ans,int(s[px]-s[px-1]));
    }
    lp(i,l,r)c[s[i]-s[i-1]]=0;
}
void solve(){
    vector&lt;int&gt;p;
    lp(i,1,n)if(s[i]-s[i-1]==1)p.push_back(i);
    lp(i,0,int(p.size()-1))
        work((i==0?1:p[i-1]+1),p[i],(i+1==p.size()?n:p[i+1]-1));
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%lld",&amp;s[i]);
    lp(i,1,n)s[i]+=s[i-1];
    solve();
    rp(i,n,1)s[i]-=s[i-1];
    reverse(s+1,s+n+1);
    lp(i,1,n)s[i]+=s[i-1];
    solve();
    pf("%d\n",ans);
    //ps;
    return 0;
}
/*
5
3 4 6 1 2
*/
</pre><pre></pre><h2>Problem3101</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int main(){
    int n;sf("%d",&amp;n);
    if(n%6!=2&amp;&amp;n%6!=3){
        for(int i=2;i&lt;=n;i+=2)pf("%d\n",i);
        for(int i=1;i&lt;=n;i+=2)pf("%d\n",i);
    }else{
        int k=n/2;
        if(k%2==0&amp;&amp;n%2==0){
            for(int i=k;i&lt;=n;i+=2)pf("%d\n",i);
            for(int i=2;i&lt;=k-2;i+=2)pf("%d\n",i);
            for(int i=k+3;i&lt;=n-1;i+=2)pf("%d\n",i);
            for(int i=1;i&lt;=k+1;i+=2)pf("%d\n",i);
        }else if(k%2==0){
            for(int i=k;i&lt;=n-1;i+=2)pf("%d\n",i);
            for(int i=2;i&lt;=k-2;i+=2)pf("%d\n",i);
            for(int i=k+3;i&lt;=n-2;i+=2)pf("%d\n",i);
            for(int i=1;i&lt;=k+1;i+=2)pf("%d\n",i);
            pf("%d\n",n); 
        }else if(n%2==0){
            for(int i=k;i&lt;=n-1;i+=2)pf("%d\n",i);
            for(int i=1;i&lt;=k-2;i+=2)pf("%d\n",i);
            for(int i=k+3;i&lt;=n;i+=2)pf("%d\n",i);
            for(int i=2;i&lt;=k+1;i+=2)pf("%d\n",i);
        }else{
            for(int i=k;i&lt;=n-2;i+=2)pf("%d\n",i);
            for(int i=1;i&lt;=k-2;i+=2)pf("%d\n",i);
            for(int i=k+3;i&lt;=n-1;i+=2)pf("%d\n",i);
            for(int i=2;i&lt;=k+1;i+=2)pf("%d\n",i);
            pf("%d\n",n); 
        }
    }
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3105</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace gauss{
    const int nmx=100;
    int a[nmx+10],n;
    void solve(){
        int k=0;
        rp(i,31,0){
            int j=k+1;
            while(j&lt;=n&amp;&amp;!((a[j]&gt;&gt;i)&amp;1))++j;
            if(j&lt;=n){
                swap(a[++k],a[j]);
                for(j=1;j&lt;=n;++j)
                    if(j!=k&amp;&amp;((a[j]&gt;&gt;i)&amp;1))
                        a[j]^=a[k];
            }
        }
    }
}
bool check(vector&lt;int&gt;a){
    gauss::n=a.size();
    lp(i,0,int(a.size()-1))gauss::a[i+1]=a[i];
    gauss::solve();
    return gauss::a[gauss::n]!=0;
}
int main(){
    int n;sf("%d",&amp;n);
    vector&lt;int&gt;tmp,a;long long sum=0;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        tmp.push_back(t);
        sum+=t;
    }
    sort(tmp.begin(),tmp.end());
    rp(i,int(tmp.size()-1),0){
        a.push_back(tmp[i]);
        if(!check(a))a.pop_back();
        else sum-=tmp[i];
    }
    pf("%lld\n",sum);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3107</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
//
int f[31][31][31][31][2][2][2][2];
int g[31][31][31][31][2][2][2][2];
int dp(int lev,int a1,int b1,int c1,int al,int bl,int cl,int go){
	int&amp;fi=f[lev][a1][b1][c1][al][bl][cl][go],&amp;gi=g[lev][a1][b1][c1][al][bl][cl][go];
	if(gi)return fi;gi=1;fi=~0u&gt;&gt;1;
	if(lev==0){
		if(!go){
			if(al+bl==cl){
				fi=cl;
			}
		}else{
			if(al==1&amp;&amp;bl==1&amp;&amp;cl==0){
				fi=0;
			}
		}
	}else{
		if(!go){
			if(al+bl==cl){
				lp(i,0,1)lp(j,0,1)lp(k,0,1){
					if(a1-al&gt;=i&amp;&amp;b1-bl&gt;=j&amp;&amp;c1-cl&gt;=k){
						if(a1-al&lt;=lev-(1-i)&amp;&amp;b1-bl&lt;=lev-(1-j)&amp;&amp;c1-cl&lt;=lev-(1-k)){
							if(dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,0)!=~0u&gt;&gt;1)
								fi=min(fi,dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,0)+(cl&lt;&lt;lev));
						}
					}
				}
			}else if(!al&amp;&amp;!bl){
				lp(i,0,1)lp(j,0,1)lp(k,0,1){
					if(a1-al&gt;=i&amp;&amp;b1-bl&gt;=j&amp;&amp;c1-cl&gt;=k){
						if(a1-al&lt;=lev-(1-i)&amp;&amp;b1-bl&lt;=lev-(1-j)&amp;&amp;c1-cl&lt;=lev-(1-k)){
							if(dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,1)!=~0u&gt;&gt;1)
								fi=min(fi,dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,1)+(cl&lt;&lt;lev));
						}
					}
				}
			}
		}else{
			if(al==1&amp;&amp;bl==1){
				lp(i,0,1)lp(j,0,1)lp(k,0,1){
					if(a1-al&gt;=i&amp;&amp;b1-bl&gt;=j&amp;&amp;c1-cl&gt;=k){
						if(a1-al&lt;=lev-(1-i)&amp;&amp;b1-bl&lt;=lev-(1-j)&amp;&amp;c1-cl&lt;=lev-(1-k)){
							if(dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,cl)!=~0u&gt;&gt;1)
								fi=min(fi,dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,cl)+(cl&lt;&lt;lev));
						}
					}
				}
			}else if(al+bl==1&amp;&amp;cl==0){
				lp(i,0,1)lp(j,0,1)lp(k,0,1){
					if(a1-al&gt;=i&amp;&amp;b1-bl&gt;=j&amp;&amp;c1-cl&gt;=k){
						if(a1-al&lt;=lev-(1-i)&amp;&amp;b1-bl&lt;=lev-(1-j)&amp;&amp;c1-cl&lt;=lev-(1-k)){
							if(dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,1)!=~0u&gt;&gt;1)
								fi=min(fi,dp(lev-1,a1-al,b1-bl,c1-cl,i,j,k,1)+(cl&lt;&lt;lev));
						}
					}
				}
			}
		}
	}
	//pf("[%d,(%d,%d,%d),(%d,%d,%d),%d,{%d}]\n",lev,a1,b1,c1,al,bl,cl,go,fi);
	return fi;
}
int count(int x){int r=0;for(;x;x-=x&amp;-x)++r;return r;}
int main(){
	int a,b,c,a1,b1,c1;
	sf("%d%d%d",&amp;a,&amp;b,&amp;c);
	a1=count(a);b1=count(b);c1=count(c);
	int ans=~0u&gt;&gt;1,tlev=0;
	lp(i,0,30)if((a&gt;&gt;i)&amp;1)tlev=max(tlev,i);
	lp(i,0,30)if((b&gt;&gt;i)&amp;1)tlev=max(tlev,i);
	lp(i,0,30)if((c&gt;&gt;i)&amp;1)tlev=max(tlev,i);
	lp(i,0,1)lp(j,0,1)lp(k,0,1){
		if(a1&gt;=i&amp;&amp;b1&gt;=j&amp;&amp;c1&gt;=k){
			if(a1&lt;=tlev+1-(1-i)&amp;&amp;b1&lt;=tlev+1-(1-j)&amp;&amp;c1&lt;=tlev+1-(1-k)){
				ans=min(ans,dp(tlev,a1,b1,c1,i,j,k,0));
			}
		}
	}
	pf("%d\n",ans==~0u&gt;&gt;1?-1:ans);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem3107</h2><pre>#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;

using namespace std;

long max(long x, long y) {
	return x &gt; y ? x : y;
}
long min(long x, long y) {
	return x &lt; y ? x : y;
}
void Modify(long &amp;x, long y) {
	x = x == -1 ? y : min(x, y);
}

long get(long x){
	long s;
	for (s = 0; x; x &gt;&gt;= 1)
		if (1 &amp; x)
			++s;
	return s;
}

long f[2][31][31][31][2];

int main() {
	long x, y, z, n = 0;
	//freopen("aplusb.in", "r", stdin);
	//freopen("aplusb.out", "w", stdout);
	scanf("%ld%ld%ld", &amp;x, &amp;y, &amp;z);
	long a = get(x), b = get(y), c = get(z);
	x = max(x, max(y, z));
	for (; x; x &gt;&gt;= 1)
		++n;
	memset(f, -1, sizeof f);
	f[0][0][0][0][0] = 0;
	long cur = 0;
	for (long t = 0; t &lt; n; ++t, cur ^= 1) {
		long aa = min(t, a), bb = min(t, b), cc = min(t, c);
		for (long i = 0; i &lt;= aa; ++i)
			for (long j = 0; j &lt;= bb; ++j)
				for (long k = 0; k &lt;= cc; ++k) {
					if (f[cur][i][j][k][0] != -1) {
						long l = f[cur][i][j][k][0];
						Modify(f[cur ^ 1][i][j][k][0], l);
						if (i &lt; a &amp;&amp; k &lt; c)
							Modify(f[cur ^ 1][i + 1][j][k + 1][0], l + (1 &lt;&lt; t));
						if (i &lt; a &amp;&amp; j &lt; b)
							Modify(f[cur ^ 1][i + 1][j + 1][k][1], l);
						if (j &lt; b &amp;&amp; k &lt; c)
							Modify(f[cur ^ 1][i][j + 1][k + 1][0], l + (1 &lt;&lt; t));
					}
					if(f[cur][i][j][k][1] != -1) {
						long l = f[cur][i][j][k][1];
						Modify(f[cur ^ 1][i][j][k + 1][0], l + (1 &lt;&lt; t));
						if (i &lt; a)
							Modify(f[cur ^ 1][i + 1][j][k][1], l);
						if (j &lt; b)
							Modify(f[cur ^ 1][i][j + 1][k][1], l);
						if (i &lt; a &amp;&amp; j &lt; b &amp;&amp; k &lt; c)
							Modify(f[cur ^ 1][i + 1][j + 1][k + 1][1], l + (1 &lt;&lt; t));
                    }
				}
	}
	printf("%ld\n", f[cur][a][b][c][0]);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n;
int bit_data[2][50010];
void bit_add1(int*a,int i,int d){for(;i&lt;=n;i+=i&amp;-i)a[i]+=d;}
int bit_ask1(int*a,int i){int r=0;for(;i;i-=i&amp;-i)r+=a[i];return r;}
void bit_add2(int i,int d){
    bit_add1(bit_data[0],i+1,d*i);
    bit_add1(bit_data[1],1,d);
    bit_add1(bit_data[1],i+1,-d);
}
int bit_ask2(int i){
    return bit_ask1(bit_data[0],i)+bit_ask1(bit_data[1],i)*i;
}
void add(int l,int r,int d){
    bit_add2(r,d);if(l!=1)bit_add2(l-1,-d);
}
int ask(int l,int r){
    if(l!=1)return bit_ask2(r)-bit_ask2(l-1);
    else return bit_ask2(r);
}
int ans[50010],as,qz;
struct query{int tp,a,b,c,now,whe;}qs[50010];
void init(){
    sf("%d%d",&amp;n,&amp;qz);
    lp(i,1,qz){
        sf("%d%d%d%d",&amp;qs[i].tp,&amp;qs[i].a,&amp;qs[i].b,&amp;qs[i].c);
        if(qs[i].tp==2)qs[i].now=0,qs[i].whe=++as;
    }
}
typedef long long ll;
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==2)ans[qs[i].whe]=vl;
    }else{
        static int delt[50010];
        int vm=(ll(vl)+ll(vr))/2;
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,1);
            else if(qs[i].tp==2)delt[i]=ask(qs[i].a,qs[i].b);
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,-1);
        static query lq[50010],rq[50010];int lqs=0,rqs=0;
        lp(i,ql,qr)
            if(qs[i].tp==1){
                if(qs[i].c&lt;=vm)lq[++lqs]=qs[i];
                else rq[++rqs]=qs[i];
            }else{
                if(qs[i].now+delt[i]&lt;=qs[i].c-1){
                    qs[i].now+=delt[i];
                    lq[++lqs]=qs[i];
                }else rq[++rqs]=qs[i];
            }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,-(~0u&gt;&gt;1),~0u&gt;&gt;1);
    lp(i,1,as)pf("%d\n",ans[i]);
    //ps;
    return 0;
}
/*
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3
*/
</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,bd[2][50010];
void bit_add1(int*a,int i,int d){for(;i&lt;=n;i+=i&amp;-i)a[i]+=d;}
int bit_ask1(int*a,int i){int r=0;for(;i;i-=i&amp;-i)r+=a[i];return r;}
void bit_add2(int i,int d){
    bit_add1(bd[0],i+1,d*i);
    bit_add1(bd[1],1,d);
    bit_add1(bd[1],i+1,-d);
}
int bit_ask2(int i){
    return bit_ask1(bd[0],i)+bit_ask1(bd[1],i)*i;
}
void add(int l,int r,int d){
    bit_add2(r,d);if(l!=1)bit_add2(l-1,-d);
}
int ask(int l,int r){
    if(l!=1)return bit_ask2(r)-bit_ask2(l-1);
    else return bit_ask2(r);
}
int ans[50010],as,qz;
struct query{int tp,a,b,c,now,whe;}qs[50010];
void init(){
    sf("%d%d",&amp;n,&amp;qz);
    lp(i,1,qz){
        sf("%d%d%d%d",&amp;qs[i].tp,&amp;qs[i].a,&amp;qs[i].b,&amp;qs[i].c);
        if(qs[i].tp==2)qs[i].now=0,qs[i].whe=++as;
    }
}
typedef long long ll;
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==2)ans[qs[i].whe]=vl;
    }else{
        static int delt[50010];
        int vm=(ll(vl)+ll(vr))/2;
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,1);
            else if(qs[i].tp==2)delt[i]=ask(qs[i].a,qs[i].b);
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,-1);
        static query lq[50010],rq[50010];int lqs=0,rqs=0;
        lp(i,ql,qr)
            if(qs[i].tp==1){
                if(qs[i].c&lt;=vm)lq[++lqs]=qs[i];
                else rq[++rqs]=qs[i];
            }else{
                if(qs[i].now+delt[i]&lt;=qs[i].c-1){
                    qs[i].now+=delt[i];
                    lq[++lqs]=qs[i];
                }else rq[++rqs]=qs[i];
            }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,-(~0u&gt;&gt;1),~0u&gt;&gt;1);
    lp(i,1,as)pf("%d\n",ans[i]);
    return 0;
}
</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,bd[2][50010];
void ad1(int*a,int i,int d){for(;i&lt;=n;i+=i&amp;-i)a[i]+=d;}
int ak1(int*a,int i){int r=0;for(;i;i-=i&amp;-i)r+=a[i];return r;}
void bit_add2(int i,int d){
    ad1(bd[0],i+1,d*i);
    ad1(bd[1],1,d);
    ad1(bd[1],i+1,-d);
}
int bit_ask2(int i){
    return ak1(bd[0],i)+ak1(bd[1],i)*i;
}
void add(int l,int r,int d){
    bit_add2(r,d);if(l!=1)bit_add2(l-1,-d);
}
int ask(int l,int r){
    if(l!=1)return bit_ask2(r)-bit_ask2(l-1);
    else return bit_ask2(r);
}
int ans[50010],as,qz;
struct query{int tp,a,b,c,now,whe;}qs[50010];
void init(){
    sf("%d%d",&amp;n,&amp;qz);
    lp(i,1,qz){
        sf("%d%d%d%d",&amp;qs[i].tp,&amp;qs[i].a,&amp;qs[i].b,&amp;qs[i].c);
        if(qs[i].tp==2)qs[i].now=0,qs[i].whe=++as;
    }
}
typedef long long ll;
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==2)ans[qs[i].whe]=vl;
    }else{
        static int delt[50010];
        int vm=(ll(vl)+ll(vr))/2;
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,1);
            else if(qs[i].tp==2)delt[i]=ask(qs[i].a,qs[i].b);
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)add(qs[i].a,qs[i].b,-1);
        static query lq[50010],rq[50010];int lqs=0,rqs=0;
        lp(i,ql,qr)
            if(qs[i].tp==1){
                if(qs[i].c&lt;=vm)lq[++lqs]=qs[i];
                else rq[++rqs]=qs[i];
            }else{
                if(qs[i].now+delt[i]&lt;=qs[i].c-1){
                    qs[i].now+=delt[i];
                    lq[++lqs]=qs[i];
                }else rq[++rqs]=qs[i];
            }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,-(~0u&gt;&gt;1),~0u&gt;&gt;1);
    lp(i,1,as)pf("%d\n",ans[i]);
    return 0;
}
/*
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3
*/
</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#define sf scanf
#define pf printf
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,f0[2][50010];
void f1(int*a,int i,int d){for(;i&lt;=n;i+=i&amp;-i)a[i]+=d;}
int f2(int*a,int i){int r=0;for(;i;i-=i&amp;-i)r+=a[i];return r;}
void f3(int i,int d){f1(f0[0],i+1,d*i);f1(f0[1],1,d);f1(f0[1],i+1,-d);}
int f4(int i){return f2(f0[0],i)+f2(f0[1],i)*i;}
void f5(int l,int r,int d){f3(r,d);if(l-1)f3(l-1,-d);}
int f6(int l,int r){if(l-1)return f4(r)-f4(l-1);else return f4(r);}
int a0[50010],a1,qz;
struct query{int tp,a,b,c,now,whe;}qs[50010];
void init(){
    sf("%d%d",&amp;n,&amp;qz);
    lp(i,1,qz){
        sf("%d%d%d%d",&amp;qs[i].tp,&amp;qs[i].a,&amp;qs[i].b,&amp;qs[i].c);
        if(qs[i].tp==2)qs[i].now=0,qs[i].whe=++a1;
    }
}
typedef long long ll;
void solve(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(qs[i].tp==2)a0[qs[i].whe]=vl;
    }else{
        static int delt[50010];
        int vm=(ll(vl)+ll(vr))/2;
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)f5(qs[i].a,qs[i].b,1);
            else if(qs[i].tp==2)delt[i]=f6(qs[i].a,qs[i].b);
        lp(i,ql,qr)
            if(qs[i].tp==1&amp;&amp;qs[i].c&gt;vm)f5(qs[i].a,qs[i].b,-1);
        static query lq[50010],rq[50010];int lqs=0,rqs=0;
        lp(i,ql,qr)
            if(qs[i].tp==1){
                if(qs[i].c&lt;=vm)lq[++lqs]=qs[i];
                else rq[++rqs]=qs[i];
            }else{
                if(qs[i].now+delt[i]&lt;=qs[i].c-1){
                    qs[i].now+=delt[i];
                    lq[++lqs]=qs[i];
                }else rq[++rqs]=qs[i];
            }
        lp(i,1,lqs)qs[ql+i-1]=lq[i];
        lp(i,1,rqs)qs[ql+lqs+i-1]=rq[i];
        solve(ql,ql+lqs-1,vl,vm);
        solve(ql+lqs,qr,vm+1,vr);
    }
}
int main(){
    init();
    solve(1,qz,-(~0u&gt;&gt;1),~0u&gt;&gt;1);
    lp(i,1,a1)pf("%d\n",a0[i]);//for(;;);
    return 0;
}
/*
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3
*/
</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#define sf scanf
#define pf printf
#define mx 50010
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int n,f0[2][mx],a0[mx],a1,q2,d0[mx];
void f1(int*a,int i,int d){for(;i&lt;=n;i+=i&amp;-i)a[i]+=d;}
int f2(int*a,int i){int r=0;for(;i;i-=i&amp;-i)r+=a[i];return r;}
void f3(int i,int d){f1(f0[0],i+1,d*i);f1(f0[1],1,d);f1(f0[1],i+1,-d);}
int f4(int i){return f2(f0[0],i)+f2(f0[1],i)*i;}
void f5(int l,int r,int d){f3(r,d);if(l-1)f3(l-1,-d);}
int f6(int l,int r){if(l-1)return f4(r)-f4(l-1);else return f4(r);}
struct q0{int t,a,b,c,o,w;}q1[mx],lq[mx],rq[mx];
void s0(int ql,int qr,int vl,int vr){
    if(ql&gt;qr)return;
    if(vl==vr){
        lp(i,ql,qr)if(q1[i].t==2)a0[q1[i].w]=vl;
    }else{
        int vm=((long long)vl+vr)/2;
        lp(i,ql,qr)
            if(q1[i].t==1&amp;&amp;q1[i].c&gt;vm)f5(q1[i].a,q1[i].b,1);
            else if(q1[i].t==2)d0[i]=f6(q1[i].a,q1[i].b);
        lp(i,ql,qr)
            if(q1[i].t==1&amp;&amp;q1[i].c&gt;vm)f5(q1[i].a,q1[i].b,-1);
        int l0=0,l1=0;
        lp(i,ql,qr)
            if(q1[i].t==1){if(q1[i].c&lt;=vm)lq[++l0]=q1[i];else rq[++l1]=q1[i];
            }else{
                if(q1[i].o+d0[i]&lt;=q1[i].c-1) q1[i].o+=d0[i],lq[++l0]=q1[i];
                else rq[++l1]=q1[i];
            }
        lp(i,1,l0)q1[ql+i-1]=lq[i];
        lp(i,1,l1)q1[ql+l0+i-1]=rq[i];
        s0(ql,ql+l0-1,vl,vm);
        s0(ql+l0,qr,vm+1,vr);
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;q2);
    lp(i,1,q2){
        sf("%d%d%d%d",&amp;q1[i].t,&amp;q1[i].a,&amp;q1[i].b,&amp;q1[i].c);
        if(q1[i].t==2)q1[i].o=0,q1[i].w=++a1;
    }
    s0(1,q2,-(~0u&gt;&gt;1),~0u&gt;&gt;1);
    lp(i,1,a1)pf("%d\n",a0[i]);//for(;;);
    return 0;
}
</pre><pre></pre><h2>Problem3112</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace sim{
    const int nmx=1000,mmx=10000;
    const double eps=1e-6,inf=1e100;
    double mat[nmx+10][mmx+10];int n,m;
    int qu[mmx+10];
    void pivot(int l,int e){
        double t=-mat[l][e];mat[l][e]=-1;
        qu[0]=0;
        lp(i,0,m)
            if(fabs(mat[l][i]/=t)&gt;eps)
                qu[++qu[0]]=i;
        lp(i,0,n)if(i!=l&amp;&amp;fabs(mat[i][e])&gt;eps){
            t=mat[i][e];mat[i][e]=0;
            lp(j,1,qu[0])
                mat[i][qu[j]]+=mat[l][qu[j]]*t;
        }
    }
    int solve(){
        while(true){
            int l=-1,e=-1;double t=inf;
            lp(i,1,m)if(mat[0][i]&gt;eps){e=i;break;}
            if(e==-1)return 1;
            lp(i,1,n)if(mat[i][e]&lt;-eps&amp;&amp;-mat[i][0]/mat[i][e]&lt;t)
                t=-mat[i][0]/mat[i][e],l=i;
            if(l==-1)return 0;
            pivot(l,e);
        }
    }
}
int main(){
    //fr("zjoi13_defend.in","r",stdin);
    //fr("zjoi13_defend.out","w",stdout);
    int n,m;sf("%d%d",&amp;n,&amp;m);
    sim::n=n,sim::m=m;
    lp(i,1,n)sf("%lf",&amp;sim::mat[i][0]);
    lp(i,1,m){
        int l,r;sf("%d%d%lf",&amp;l,&amp;r,&amp;sim::mat[0][i]);
        lp(j,l,r)sim::mat[j][i]=-1;
    }
    sim::solve();
    pf("%d\n",int(sim::mat[0][0]+0.5));
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3118</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace simplex{
	double n,m,a[1010][30010],eps=1e-5,inf=1e100;
	double myabs(double a){return a&gt;0?a:-a;}
	void pivot(int l,int e){
		double t=-a[l][e];a[l][e]=-1;
		vector&lt;int&gt;qu;
		lp(i,0,m)if(myabs(a[l][i]/=t)&gt;eps)qu.pb(i);
		lp(i,0,n){
			if(i!=l&amp;&amp;myabs(a[i][e])&gt;eps){
				double t2=a[i][e];a[i][e]=0;
				vp(j,qu){
					a[i][qu[j]]+=a[l][qu[j]]*t2;
				}
			}
		}
	}
	double solve(){
		while(true){
			int e=-1;
			lp(i,1,m)if(a[0][i]&gt;eps){e=i;break;}
			if(e==-1)return a[0][0];
			int l=-1;double t=inf;
			lp(i,1,n)if(a[i][e]&lt;-eps&amp;&amp;a[i][0]/-a[i][e]&lt;t){
				t=a[i][0]/-a[i][e];
				l=i;
			}
			pivot(l,e);
		}
	}
}
namespace graph{
	int n,m,uu[1010],vv[1010],ww[1010],aa[1010],bb[1010],ff[1010];
	vector&lt;int&gt;to[310],idx[310];
	struct tri{
		int x,y,z;
	};
	vector&lt;tri&gt;ret;
	bool dfs(int u,int p,int v,int id){
		if(u==v)return true;
		vp(i,to[u]){
			if(to[u][i]!=p){
				if(dfs(to[u][i],u,v,id)){
					tri tmp;
					tmp.x=id;
					tmp.y=idx[u][i];
					if(ww[id]&lt;ww[idx[u][i]]){
						tmp.z=ww[idx[u][i]]-ww[id];
						ret.pb(tmp);
					}
					return true;
				}
			}
		}
		return false;
	}
	void run(){
		sf("%d%d",&amp;n,&amp;m);
		lp(i,1,m){
			sf("%d%d%d%d%d%d",&amp;uu[i],&amp;vv[i],&amp;ww[i],&amp;ff[i],&amp;aa[i],&amp;bb[i]);
			if(ff[i]==1){
				to[uu[i]].pb(vv[i]);
				idx[uu[i]].pb(i);
				to[vv[i]].pb(uu[i]);
				idx[vv[i]].pb(i);
			}
		}
		lp(i,1,m)if(ff[i]!=1)dfs(uu[i],0,vv[i],i);
		//vp(i,ret)pf("[%d,%d,%d]\n",ret[i].x,ret[i].y,ret[i].z);
		simplex::n=m;
		simplex::m=ret.size();
		lp(i,1,ret.size()){
			int u=ret[i-1].x,v=ret[i-1].y,w=ret[i-1].z;
			simplex::a[u][i]=-1;
			simplex::a[v][i]=-1;
			simplex::a[0][i]=w;
		}
		lp(i,1,m){
			if(ff[i]==1)simplex::a[i][0]=bb[i];
			else simplex::a[i][0]=aa[i];
		}
	}
	
}
int main(){
	graph::run();
	/*lp(i,0,simplex::n){
		lp(j,0,simplex::m){
			pf("%lf ",simplex::a[i][j]);
		}
		pf("\n");
	}*/
	pf("%d\n",int(simplex::solve()+0.5));
	return 0;
}</pre><pre></pre><h2>Problem3119</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll N,X,A,B,M,T[100010],Del[100010];
int main(){
	sf("%lld%lld%lld%lld%lld",&amp;N,&amp;X,&amp;A,&amp;B,&amp;M);
	T[1]=X;lp(i,2,N)T[i]=T[i-1]-B;
	ll sum=0;lp(i,1,N)sum+=T[i];
	ll t1=(M-sum)/(A+B);
	//pf("%lld\n",t1);
	rp(i,N-1,1){
		if(t1&gt;=i){
			t1-=i;
			Del[N-i+1]+=A+B;
		}
	}
	lp(i,1,N)Del[i]+=Del[i-1];
	lp(i,1,N)pf("%lld%c",T[i]+Del[i],i==N?'\n':' ');
	return 0;
}</pre><pre></pre><h2>Problem3122</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll qpow(ll x,ll y,ll z){
	ll r=1;
	while(y){
		if(y&amp;1)r=r*x%z;
		x=x*x%z;
		y&gt;&gt;=1;
	}
	return r;
}
ll bsgs(ll a,ll b,ll c){
	ll m=ll(sqrt(double(c-1))+0.5);
	map&lt;ll,ll&gt;pm;
	rp(i,m-1,0)pm[qpow(a,i,c)]=i;
	lp(i,0,(c-1)/m){
		ll t=qpow(qpow(a,i*m,c),c-2,c)*b%c;
		if(pm.count(t))return pm[t]+i*m;
	}
	return -1;
}
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		ll p,a,b,x1,t;
		sf("%lld%lld%lld%lld%lld",&amp;p,&amp;a,&amp;b,&amp;x1,&amp;t);
		if(a==0){
			if(t==x1)pf("1\n");
			else if(t==b)pf("2\n");
			else pf("-1\n");
		}else if(a==1){
			if(b==0){
				if(x1==t)pf("1\n");
				else pf("-1\n");
			}else{
				ll u=b,v=((t-x1+b)%p+p)%p;
				ll ans=v*qpow(u,p-2,p)%p;
				pf("%lld\n",ans==0?p:ans);
			}
		}else{
			ll u=((a*t-t+b)%p+p)%p;
			ll v=((a*x1-x1+b)%p+p)%p;
			if(v==0){
				if(u==0)pf("1\n");
				else pf("-1\n");
			}else{
				u=u*qpow(v,p-2,p)%p;
				ll ans=bsgs(a,u,p);
				pf("%lld\n",ans==-1?-1:ans+1);
			}
		}
	}
	return 0;
}
/*
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
*/</pre><pre></pre><h2>Problem3122</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll qpow(ll x,ll y,ll z){
	ll r=1;
	while(y){
		if(y&amp;1)r=r*x%z;
		x=x*x%z;
		y&gt;&gt;=1;
	}
	return r;
}
ll bsgs(ll a,ll b,ll c){
	ll m=ll(sqrt(double(c-1))+0.5);
	map&lt;ll,ll&gt;pm;
	lp(i,0,m-1)pm[qpow(a,i,c)]=i;
	lp(i,0,(c-1)/m){
		ll t=qpow(qpow(a,i*m,c),c-2,c)*b%c;
		if(pm.count(t))return pm[t]+i*m;
	}
	return -1;
}
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		ll p,a,b,x1,t;
		sf("%lld%lld%lld%lld%lld",&amp;p,&amp;a,&amp;b,&amp;x1,&amp;t);
		if(a==0){
			if(t==x1)pf("1\n");
			else if(t==b)pf("2\n");
			else pf("-1\n");
		}else if(a==1){
			if(b==0){
				if(x1==t)pf("1\n");
				else pf("-1\n");
			}else{
				ll u=b,v=((t-x1+b)%p+p)%p;
				ll ans=v*qpow(u,p-2,p)%p;
				pf("%lld\n",ans==0?p:ans);
			}
		}else{
			ll u=((a*t-t+b)%p+p)%p;
			ll v=((a*x1-x1+b)%p+p)%p;
			if(v==0){
				if(u==0)pf("1\n");
				else pf("-1\n");
			}else{
				u=u*qpow(v,p-2,p)%p;
				ll ans=bsgs(a,u,p);
				pf("%lld\n",ans==-1?-1:ans+1);
			}
		}
	}
	return 0;
}
/*
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
*/</pre><pre></pre><h2>Problem3126</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;deque&gt;
int n,m,f[200010];
int lft[200010],rgh[200010];
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,0,n+1)rgh[i]=n+1;
	lp(i,0,n)lft[i]=i+1;
	lp(i,1,m){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		rgh[a-1]=min(rgh[a-1],b);
		lft[a]=max(lft[a],b+1);
	}
	//lp(i,0,n)pf("[%d,%d]\n",lft[i],rgh[i]);
	rp(i,n-1,0)rgh[i]=min(rgh[i],rgh[i+1]);
	lp(i,1,n)lft[i]=max(lft[i],lft[i-1]);
	//lp(i,0,n)pf("[%d,%d]\n",lft[i],rgh[i]);
	f[n+1]=0;deque&lt;int&gt;qu;
	rp(i,n,0){
		rp(j,lft[i+1]-1,lft[i]){
			while(!qu.empty()&amp;&amp;f[qu.back()]&lt;=f[j])qu.pop_back();
			qu.pb(j);
		}
		while(!qu.empty()&amp;&amp;qu.front()&gt;rgh[i])qu.pop_front();
		if(lft[i]&lt;=rgh[i]){
			if(f[qu.front()]==-1)f[i]=-1;
			else f[i]=f[qu.front()]+1;
		}else{
			//if(lft[i]==n+1)f[i]=1;
			f[i]=-1;
		}
	}
	//lp(i,0,n)pf("[%d]",f[i]);pf("\n");
	pf("%d\n",f[0]==-1?-1:f[0]-1);
	return 0;
}</pre><pre></pre><h2>Problem3127</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct edge{
    edge(edge*a,int b,int c):
        nxt(a),v(b),w(c){}
    edge*nxt;int v,w;
}*bg[100010];
void add(int u,int v,int w){
    bg[u]=new edge(bg[u],v,w);
    bg[v]=new edge(bg[v],u,w);
}
int siz[100010],mxz[100010],nds[100010],edn[100010],ns;
void dfs(int u,int p){
    nds[++ns]=u;mxz[u]=0;siz[u]=1;
    for(edge*e=bg[u];e;e=e-&gt;nxt){
        if(e-&gt;v!=p){
            dfs(e-&gt;v,u);
            siz[u]+=siz[e-&gt;v];
            mxz[u]=max(mxz[u],siz[e-&gt;v]);
        }
    }
    edn[u]=ns;
}
int psum[100010];
ll calc1(int u,int p,int sum,int flag){
    ll ret=0;psum[u]=sum;
    if(flag&amp;&amp;!sum)++ret;
    for(edge*e=bg[u];e;e=e-&gt;nxt){
        if(e-&gt;v!=p){
            if(flag||(sum==0&amp;&amp;p!=0))
                ret+=calc1(e-&gt;v,u,sum+e-&gt;w,1);
            else
                ret+=calc1(e-&gt;v,u,sum+e-&gt;w,0);
        }
    }
    return ret;
}
ll table[200010];
int bad[200010];
void calcbad(int u,int p){
    if(table[100001+psum[u]])bad[u]=0;
    else bad[u]=1;
    ++table[100001+psum[u]];
    for(edge*e=bg[u];e;e=e-&gt;nxt){
        if(e-&gt;v!=p){
            calcbad(e-&gt;v,u);
        }
    }
    --table[100001+psum[u]];
}
ll treedc(int u){
    ll ret=0;ns=0;dfs(u,0);
    if(ns&lt;3)return 0;
    lp(i,1,ns)mxz[nds[i]]=max(mxz[nds[i]],ns-siz[nds[i]]);
    lp(i,1,ns)if(mxz[nds[i]]&lt;mxz[u])u=nds[i];
    ns=0;dfs(u,0);
    edge*mid=bg[u];
    for(int i=siz[mid-&gt;v];(i+=siz[mid-&gt;nxt-&gt;v])&lt;ns/2;mid=mid-&gt;nxt);
    int *pl=nds+2,*pm=nds+edn[mid-&gt;v],*pr=nds+ns;
    calc1(u,0,0,0);
    for(int*i=pl;i&lt;=pm;++i)++table[100001+psum[*i]];
    for(int*i=pm+1;i&lt;=pr;++i)ret+=table[100001-psum[*i]];
    for(int*i=pl;i&lt;=pm;++i)--table[100001+psum[*i]];
    calcbad(u,0);
    for(int*i=pl;i&lt;=pm;++i)if(bad[*i])++table[100001+psum[*i]];
    for(int*i=pm+1;i&lt;=pr;++i)if(bad[*i])ret-=table[100001-psum[*i]];
    for(int*i=pl;i&lt;=pm;++i)if(bad[*i])--table[100001+psum[*i]];
    edge*tmp=mid-&gt;nxt;mid-&gt;nxt=0;
    ret+=treedc(u);bg[u]=tmp;ret+=treedc(u);
    return ret;
}
int main(){
    int n;sf("%d",&amp;n);
    lp(i,2,n){
        int u,v,w;
        sf("%d%d%d",&amp;u,&amp;v,&amp;w);
        add(u,v,w*2-1);
    }
    pf("%lld\n",treedc(1));
    return 0;
}</pre><pre></pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace isap{
	struct edge{int v;double c;};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[1010];
	void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
	int vcnt,dis[1010],gap[1010];
	void clear(){lp(i,1,vcnt)dis[i]=gap[i]=0,to[i].clear();eg.clear();gap[0]=vcnt;}
	double dfs(int u,double f){
		if(u==vcnt)return f;
		double g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
				double t=dfs(e.v,min(g,e.c));
				g-=t,e.c-=t,ev.c+=t;
				if(g&lt;1e-6||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	double solve(){
		double r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
struct data{
	data(){sf("%d%d%d",&amp;u,&amp;v,&amp;c);}
	int u,v,c;
};
double tabs(double a){return a&gt;0?a:-a;}
int main(){
	int n,m,p;double mx;
	sf("%d%d%d",&amp;n,&amp;m,&amp;p);
	vector&lt;data&gt;v;
	lp(i,1,m)v.pb(data());
	isap::vcnt=n;
	isap::clear();
	vp(i,v)isap::add(v[i].u,v[i].v,v[i].c),isap::add(v[i].v,v[i].u,0);
	mx=isap::solve();
	double lft=0,rht=500000;
	while(rht-lft&gt;1e-6){
		double mid=(lft+rht)/2;
		isap::clear();
		vp(i,v)isap::add(v[i].u,v[i].v,min(double(v[i].c),mid)),isap::add(v[i].v,v[i].u,0);
		if(tabs(isap::solve()-mx)&lt;1e-6)rht=mid;
		else lft=mid;
	}
	pf("%.0lf\n%.4lf\n",mx,lft*p);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace isap{
	struct edge{int v;double c;};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[110];
	void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
	int vcnt,dis[110],gap[110];
	void clear(){lp(i,1,vcnt)dis[i]=gap[i]=0,to[i].clear();eg.clear();gap[0]=vcnt;}
	double dfs(int u,double f){
		if(u==vcnt)return f;
		double g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
				double t=dfs(e.v,min(g,e.c));
				g-=t,e.c-=t,ev.c+=t;
				if(g&lt;1e-6||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	double solve(){
		double r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
struct data{
	data(){sf("%d%d%d",&amp;u,&amp;v,&amp;c);}
	int u,v,c;
};
double tabs(double a){return a&gt;0?a:-a;}
int main(){
	int n,m,p;double mx;
	sf("%d%d%d",&amp;n,&amp;m,&amp;p);
	vector&lt;data&gt;v;
	lp(i,1,m)v.pb(data());
	isap::vcnt=n;
	isap::clear();
	vp(i,v)isap::add(v[i].u,v[i].v,v[i].c),isap::add(v[i].v,v[i].u,0);
	mx=isap::solve();
	double lft=0,rht=500000;
	while(rht-lft&gt;1e-6){
		double mid=(lft+rht)/2;
		isap::clear();
		vp(i,v)isap::add(v[i].u,v[i].v,min(double(v[i].c),mid)),isap::add(v[i].v,v[i].u,0);
		if(tabs(isap::solve()-mx)&lt;1e-6)rht=mid;
		else lft=mid;
	}
	pf("%.0lf\n%.4lf\n",mx,lft*p);
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;map&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace isap{
    struct edge{int v;double c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[110];
    void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
    int vcnt,dis[110],gap[110];
    void clear(){lp(i,1,vcnt)dis[i]=gap[i]=0,to[i].clear();eg.clear();gap[0]=vcnt;}
    double dfs(int u,double f){
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(g&lt;1e-6||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
}
struct data{
    data(){sf("%d%d%d",&amp;u,&amp;v,&amp;c);}
    int u,v,c;
};
double tabs(double a){return a&gt;0?a:-a;}
int main(){
    int n,m,p;double mx;
    sf("%d%d%d",&amp;n,&amp;m,&amp;p);
    vector&lt;data&gt;v;
    lp(i,1,m)v.pb(data());
    isap::vcnt=n;
    isap::clear();
    vp(i,v)isap::add(v[i].u,v[i].v,v[i].c),isap::add(v[i].v,v[i].u,0);
    mx=isap::solve();
    double lft=0,rht=500000;
    while(rht-lft&gt;1e-8){
        double mid=(lft+rht)/2;
        isap::clear();
        vp(i,v)isap::add(v[i].u,v[i].v,min(double(v[i].c),mid)),isap::add(v[i].v,v[i].u,0);
        if(tabs(isap::solve()-mx)&lt;1e-6)rht=mid;
        else lft=mid;
    }
    pf("%.0lf\n%.4lf\n",mx,lft*p);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;functional&gt;
#include&lt;queue&gt;
typedef long double ld;
map&lt;ll,ll&gt;cnt;
ll n,k,lgn;
ll val[10];
ll fac[21];
string strn;
void dfs(int lev,int rem){
    if(lev==10){
        if(rem!=lgn){
            ll res=1;
            lp(i,1,9)lp(j,1,val[i])res*=i;
            if(rem){
                ll t=fac[lgn-rem];
                lp(i,1,9)t/=fac[val[i]];
                cnt[res]+=t;
            }else{
                //if(val[1]==2)pf("[%d,%d,%lld]\n",lev,rem,res);
                lp(i,1,lgn){
                    static ll tval[10];
                    lp(j,1,9)tval[j]=val[j];
                    lp(j,1,i-1){
                        --tval[strn[j-1]];
                        if(tval[strn[j-1]]&lt;0)goto fail;
                    }
                    lp(j,1,strn[i-1]-1){
                        if(tval[j]){
                            //if(val[1]==2&amp;&amp;i==2)pf("[%lld]\n",cnt[1]);
                            --tval[j];
                            ll t=fac[lgn-i];
                            lp(k,1,9)t/=fac[tval[k]];
                            cnt[res]+=t;
                            ++tval[j];
                        }
                    }
                }
                fail:while(false);
            }
        }
    }else{
        lp(i,0,rem){
            val[lev]=i;
            dfs(lev+1,rem-i);
        }
    }
}
ll bfcnt(ll t){
	ll ret=0;
	lp(i,1,n){
		ll j=1;
		ll tmp=i;
		while(tmp){
			j*=tmp%10;
			tmp/=10;
		}
		if(j==t)++ret;
	}
	return ret;
}
vector&lt;pair&lt;ll,ll&gt; &gt;nums;
struct tri{
	tri(int x,int y):
		a(x),b(y){}
	int a,b;
};
bool operator&lt;(tri a,tri b){
	return ld(nums[a.a].first)*ld(nums[a.b].first)&lt;ld(nums[b.a].first)*ld(nums[b.b].first);
}
int main(){
	//cout&lt;&lt;setprecision(10)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;ld(12345678910ll)*ld(12345678910ll);
    sf("%lld%lld",&amp;n,&amp;k);
    stringstream ss;ss&lt;&lt;(n+1);ss&gt;&gt;strn;
    vp(i,strn)strn[i]-='0';
    for(ll i=n+1;i;i/=10)++lgn;
    fac[0]=1;lp(i,1,20)fac[i]=fac[i-1]*i;
    dfs(1,lgn);
    //lp(i,1,300)pf("[%d,%lld,%lld]\n",i,cnt[i],bfcnt(i));
    for(map&lt;ll,ll&gt;::iterator it=cnt.begin();it!=cnt.end();++it)
    	nums.pb(mp(it-&gt;second,it-&gt;first));
    sort(nums.begin(),nums.end(),greater&lt;pair&lt;ll,ll&gt; &gt;());
    //vp(i,nums)pf("[%lld,%lld]\n",nums[i].first,nums[i].second);
    //while((nums.size()-1)*(nums.size()-1)&gt;=k)nums.pop_back();
    //pf("[%d]\n",(int)nums.size());
    priority_queue&lt;tri&gt;qu;
    vp(i,nums)qu.push(tri(i,0));
    ll ans=0,p=1000000007;
    for(;!qu.empty()&amp;&amp;k&gt;0;--k){
    	tri tmp=qu.top();qu.pop();
    	if(tmp.b+1!=nums.size())qu.push(tri(tmp.a,tmp.b+1));
    	ll tmp2=(nums[tmp.a].first%p)*(nums[tmp.b].first%p)%p;
    	ans=(ans+tmp2)%p;
    }
    pf("%lld\n",ans);
    return 0;
}
</pre><pre></pre><h2>Problem3132</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m;
struct bit{
    int d[2049][2049];
    void add(int x,int y,int t){
        for(int i=x;i&lt;=n;i+=i&amp;-i)
            for(int j=y;j&lt;=m;j+=j&amp;-j)
                d[i][j]+=t;
    }
    int ask(int x,int y){
        int r=0;
        for(int i=x;i;i-=i&amp;-i)
            for(int j=y;j;j-=j&amp;-j)
                r+=d[i][j];
        return r;
    }
}b1,b2,b3,b4;
int sum(int x,int y){
    return b1.ask(x,y)*(x+1)*(y+1)-b2.ask(x,y)*(x+1)-b3.ask(x,y)*(y+1)+b4.ask(x,y);
}
int main(){
    char op[11];
    sf("%s%d%d",op,&amp;n,&amp;m);
    while(sf("%s",op)!=EOF){
        if(op[0]=='L'){
            int x1,y1,x2,y2,t;
            sf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;t);
            b1.add(x1,y1,t);b1.add(x2+1,y1,-t);b1.add(x1,y2+1,-t);b1.add(x2+1,y2+1,t);
            b2.add(x1,y1,t*y1);b2.add(x2+1,y1,-t*y1);b2.add(x1,y2+1,-t*(y2+1));b2.add(x2+1,y2+1,t*(y2+1));
            b3.add(x1,y1,t*x1);b3.add(x2+1,y1,-t*(x2+1));b3.add(x1,y2+1,-t*x1);b3.add(x2+1,y2+1,t*(x2+1));
            b4.add(x1,y1,t*x1*y1);b4.add(x2+1,y1,-t*(x2+1)*y1);b4.add(x1,y2+1,-t*x1*(y2+1));b4.add(x2+1,y2+1,t*(x2+1)*(y2+1));
        }else{
            int x1,y1,x2,y2;
            sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            pf("%d\n",sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1));
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3133</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;set&gt;
vector&lt;int&gt;ch[100010];int n,q,rt,mi[100010],we[100010],ew[100010],nw,up[100010][20],cnt[100010],dep[100010];
void dfs1(int u){
	dep[u]=dep[up[u][0]]+1;mi[u]=u;
	lp(i,1,19)up[u][i]=up[up[u][i-1]][i-1];
	vp(i,ch[u]){
		dfs1(ch[u][i]);
		mi[u]=min(mi[u],mi[ch[u][i]]);
	}
}
bool cmp(int a,int b){
	return mi[a]&lt;mi[b];
}
void dfs2(int u){
	sort(ch[u].begin(),ch[u].end(),cmp);
	vp(i,ch[u])dfs2(ch[u][i]);
	we[u]=++nw;ew[nw]=u;
}
int main(){
	sf("%d%d",&amp;n,&amp;q);
	lp(i,1,n){
		sf("%d",&amp;up[i][0]);
		ch[up[i][0]].pb(i);
		if(!up[i][0])rt=i;
	}
	dfs1(rt);
	dfs2(rt);
	set&lt;int&gt;st;
	lp(i,1,n)st.insert(i);
	lp(i,1,q){
		int op,u;sf("%d%d",&amp;op,&amp;u);
		if(op==1){
			int ans;
			lp(j,1,u){
				cnt[ew[*st.begin()]]=1;
				ans=ew[*st.begin()];
				st.erase(st.begin());
			}
			pf("%d\n",ans);
		}else{
			int t=u;
			rp(i,19,0)if(cnt[up[u][i]])u=up[u][i];
			cnt[u]=0;
			st.insert(we[u]);
			pf("%d\n",dep[t]-dep[u]);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3133</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;stack&gt;
namespace tree{
    int n,q,prt[100010],pos[100010],sop[100010],nw,rt;
    int mi[100010];
    vector&lt;int&gt;chd[100010];
    inline void dfs1(int u){
    	mi[u]=u;
    	vp(i,chd[u]){
        	dfs1(chd[u][i]);
        	mi[u]=min(mi[u],mi[chd[u][i]]);
    	}
    }
    inline bool cmp(int a,int b){
    	return mi[a]&lt;mi[b];
	}
	inline void dfs2(int u){
    	sort(chd[u].begin(),chd[u].end(),cmp);
    	vp(i,chd[u])dfs2(chd[u][i]);
    	pos[u]=++nw;sop[nw]=u;
	}
    inline void build(){
        sf("%d%d",&amp;n,&amp;q);
        lp(i,1,n){
            sf("%d",&amp;prt[i]);
            chd[prt[i]].pb(i);
            if(!prt[i])rt=i;
        }
        dfs1(rt);
        dfs2(rt);
    }
}
namespace seg{
    int sum[100010*4];
    inline int find(int x,int l,int r){
        if(l==r)return l;
        else{
            int m=(l+r)/2;
            if(sum[x*2]!=m-l+1)return find(x*2,l,m);
            else return find(x*2+1,m+1,r);
        }
    }
    inline void modify(int x,int l,int r,int p,int d){
        sum[x]+=d;
        if(l!=r){
            int m=(l+r)/2;
            if(p&lt;=m)modify(x*2,l,m,p,d);
            else modify(x*2+1,m+1,r,p,d);
        }
    }
}
namespace lct{
    struct node{
        node*ch[2],*pr;int val,sum;
    }ns[100010];
    inline int direct(node*x){
        if(!x-&gt;pr)return 2;
        else if(x==x-&gt;pr-&gt;ch[0])return 0;
        else if(x==x-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    inline void update(node*x){x-&gt;sum=x-&gt;val;lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;}
    inline void setchd(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;update(x);}
    inline void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;int d1=direct(x),d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);setchd(x,y,!d1);
        if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
    }
    inline void splay(node*x){
        while(direct(x)&lt;2){
            node*y=x-&gt;pr;
            if(direct(y)&gt;1)rotate(x);
            else if(direct(x)==direct(y))rotate(y),rotate(x);
            else rotate(x),rotate(x);
        }
    }
    inline void modify(node*x,int d){splay(x);x-&gt;sum+=d;x-&gt;val+=d;}
    node*access(node*x){node*y=0;while(x){splay(x);setchd(x,y,1);y=x;x=x-&gt;pr;}return y;}
    inline void build(){
        lp(i,1,tree::n)if(tree::prt[i])ns[i].pr=ns+tree::prt[i];
    }
    inline pair&lt;int,int&gt;query(node*x){
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0;
        if(t){
            pair&lt;int,int&gt;ret=query(x-&gt;ch[0]);
            return mp(ret.first,ret.second+1+(x-&gt;ch[1]?x-&gt;ch[1]-&gt;sum:0));
        }else if(x-&gt;val){
            return mp(x-ns,1+(x-&gt;ch[1]?x-&gt;ch[1]-&gt;sum:0));
        }else return query(x-&gt;ch[1]);
    }
}
int main(){
    tree::build();
    lct::build();
    lp(i,1,tree::q){
        int op;sf("%d",&amp;op);
        if(op==1){
            int k;sf("%d",&amp;k);int ans;
            lp(j,1,k){
                int tmp=tree::sop[seg::find(1,1,tree::n)];
                seg::modify(1,1,tree::n,tree::pos[tmp],1);
                lct::modify(lct::ns+tmp,1);
                ans=tmp;
            }
            pf("%d\n",ans);
        }else{
            int u;sf("%d",&amp;u);
            lct::access(lct::ns+u);
            lct::splay(lct::ns+u);
            pair&lt;int,int&gt;tmp=lct::query(lct::ns+u);
            lct::modify(lct::ns+tmp.first,-1);
            seg::modify(1,1,tree::n,tree::pos[tmp.first],-1);
            pf("%d\n",tmp.second-1);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3133</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;set&gt;
vector&lt;int&gt;ch[100010];int n,q,rt,mi[100010],we[100010],ew[100010],nw,up[100010][20],cnt[100010],dep[100010];
inline void dfs1(int u){
    dep[u]=dep[up[u][0]]+1;mi[u]=u;
    lp(i,1,19)up[u][i]=up[up[u][i-1]][i-1];
    vp(i,ch[u]){
        dfs1(ch[u][i]);
        mi[u]=min(mi[u],mi[ch[u][i]]);
    }
}
inline bool cmp(int a,int b){
    return mi[a]&lt;mi[b];
}
inline void dfs2(int u){
    sort(ch[u].begin(),ch[u].end(),cmp);
    vp(i,ch[u])dfs2(ch[u][i]);
    we[u]=++nw;ew[nw]=u;
}
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n){
        sf("%d",&amp;up[i][0]);
        ch[up[i][0]].pb(i);
        if(!up[i][0])rt=i;
    }
    dfs1(rt);
    dfs2(rt);
    set&lt;int&gt;st;
    lp(i,1,n)st.insert(i);
    lp(i,1,q){
        int op,u;sf("%d%d",&amp;op,&amp;u);
        if(op==1){
            int ans;
            lp(j,1,u){
                cnt[ew[*st.begin()]]=1;
                ans=ew[*st.begin()];
                st.erase(st.begin());
            }
            pf("%d\n",ans);
        }else{
            int t=u;
            rp(i,19,0)if(cnt[up[u][i]])u=up[u][i];
            cnt[u]=0;
            st.insert(we[u]);
            pf("%d\n",dep[t]-dep[u]);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3133</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;stack&gt;
namespace tree{
    int n,q,prt[100010],pos[100010],sop[100010],nw,rt;
    int mi[100010];
    vector&lt;int&gt;chd[100010];
    void dfs1(int u){
        mi[u]=u;
        vp(i,chd[u]){
            dfs1(chd[u][i]);
            mi[u]=min(mi[u],mi[chd[u][i]]);
        }
    }
   bool cmp(int a,int b){
        return mi[a]&lt;mi[b];
    }
    void dfs2(int u){
        sort(chd[u].begin(),chd[u].end(),cmp);
        vp(i,chd[u])dfs2(chd[u][i]);
        pos[u]=++nw;sop[nw]=u;
    }
   void build(){
        sf("%d%d",&amp;n,&amp;q);
        lp(i,1,n){
            sf("%d",&amp;prt[i]);
            chd[prt[i]].pb(i);
            if(!prt[i])rt=i;
        }
        dfs1(rt);
        dfs2(rt);
    }
}
namespace seg{
    int sum[100010*4];
    int find(int x,int l,int r){
        if(l==r)return l;
        else{
            int m=(l+r)/2;
            if(sum[x*2]!=m-l+1)return find(x*2,l,m);
            else return find(x*2+1,m+1,r);
        }
    }
    void modify(int x,int l,int r,int p,int d){
        sum[x]+=d;
        if(l!=r){
            int m=(l+r)/2;
            if(p&lt;=m)modify(x*2,l,m,p,d);
            else modify(x*2+1,m+1,r,p,d);
        }
    }
}
namespace lct{
    struct node{
        node*ch[2],*pr;int val,sum;
    }ns[100010];
   int direct(node*x){
        if(!x-&gt;pr)return 2;
        else if(x==x-&gt;pr-&gt;ch[0])return 0;
        else if(x==x-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    void update(node*x){x-&gt;sum=x-&gt;val;lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;}
     void setchd(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;update(x);}
    void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;int d1=direct(x),d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);setchd(x,y,!d1);
        if(d2&lt;2)setchd(z,x,d2);else x-&gt;pr=z;
    }
    void splay(node*x){
        while(direct(x)&lt;2){
            node*y=x-&gt;pr;
            if(direct(y)&gt;1)rotate(x);
            else if(direct(x)==direct(y))rotate(y),rotate(x);
            else rotate(x),rotate(x);
        }
    }
    void modify(node*x,int d){splay(x);x-&gt;sum+=d;x-&gt;val+=d;}
    node*access(node*x){node*y=0;while(x){splay(x);setchd(x,y,1);y=x;x=x-&gt;pr;}return y;}
    void build(){
        lp(i,1,tree::n)if(tree::prt[i])ns[i].pr=ns+tree::prt[i];
    }
     pair&lt;int,int&gt;query(node*x){
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;sum:0;
        if(t){
            pair&lt;int,int&gt;ret=query(x-&gt;ch[0]);
            return mp(ret.first,ret.second+1+(x-&gt;ch[1]?x-&gt;ch[1]-&gt;sum:0));
        }else if(x-&gt;val){
            return mp(x-ns,1+(x-&gt;ch[1]?x-&gt;ch[1]-&gt;sum:0));
        }else return query(x-&gt;ch[1]);
    }
}
int main(){
    tree::build();
    lct::build();
    lp(i,1,tree::q){
        int op;sf("%d",&amp;op);
        if(op==1){
            int k;sf("%d",&amp;k);int ans;
            lp(j,1,k){
                int tmp=tree::sop[seg::find(1,1,tree::n)];
                seg::modify(1,1,tree::n,tree::pos[tmp],1);
                lct::modify(lct::ns+tmp,1);
                ans=tmp;
            }
            pf("%d\n",ans);
        }else{
            int u;sf("%d",&amp;u);
            lct::access(lct::ns+u);
            lct::splay(lct::ns+u);
            pair&lt;int,int&gt;tmp=lct::query(lct::ns+u);
            lct::modify(lct::ns+tmp.first,-1);
            seg::modify(1,1,tree::n,tree::pos[tmp.first],-1);
            pf("%d\n",tmp.second-1);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3134</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;string&gt;
#include&lt;sstream&gt;
ll dp(int fir,int sec,int len){
	static ll dt[10][10][20];static int vi[10][10][20];
	ll&amp;f=dt[fir][sec][len];
	int&amp;g=vi[fir][sec][len];
	if(!g){
		g=1;
		if(len==2)f=1;
		else{
			lp(i,0,9)if(i!=fir&amp;&amp;i!=sec)
				f+=dp(sec,i,len-1);
		}
	}
	return f;
}
ll calc(ll tn){
	string n;stringstream ss;ss&lt;&lt;tn;ss&gt;&gt;n;
	ll ret=0;vp(i,n)n[i]-='0';
	if(n.size()==1)ret=n[0];//1位
	else{
		lp(i,1,n[0]-1)lp(j,0,9)if(i!=j)ret+=dp(i,j,n.size());//第1位不同，且不为0
		for(int i=1;i+1&lt;n.size();++i){//考虑前导0的情况，枚举哪位开始不为0
			lp(j,1,9)lp(k,0,9)if(j!=k)ret+=dp(j,k,n.size()-i);
		}
		//没考虑的0到9
		ret+=10;
		for(int i=1;i&lt;n.size();++i){//枚举到哪位不同
			int flg=1;
			lp(j,0,i-2)if(n[j]==n[j+1])flg=0;
			lp(j,0,i-3)if(n[j]==n[j+2])flg=0;
			if(!flg)break;
			lp(j,0,n[i]-1)
				if(j!=n[i-1]&amp;&amp;(i==1||j!=n[i-2]))
					ret+=dp(n[i-1],j,n.size()-i+1);
		}
	}
	return ret;
}
int main(){
	//lp(i,1,1000)pf("%d,%lld\n",i,calc(i));return 0;
	ll a,b;sf("%lld%lld",&amp;a,&amp;b);
	pf("%lld\n",calc(b+1)-calc(a));
	return 0;
}</pre><pre></pre><h2>Problem3135</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct edge{
	edge(int a,int b,edge*c):
		v(a),id(b),nxt(c){}
	int v,id;edge*nxt;
}*bg[100010];
void add(int u,int v,int i){
	bg[u]=new edge(v,i,bg[u]);
}
ll val[100010],ans[100010];int n,m;
namespace tree{
	int vis[100010];
	ll tval[100010];
	bool dfs(int u,int p){
		vis[u]=1;
		for(edge*e=bg[u];e;e=e-&gt;nxt){
			if(e-&gt;v!=p){
				if(vis[e-&gt;v])return false;
				if(!dfs(e-&gt;v,u))return false;
				tval[u]+=ans[e-&gt;id];
			}
		}
		for(edge*e=bg[u];e;e=e-&gt;nxt){
			if(e-&gt;v==p){
				ans[e-&gt;id]=val[u]-tval[u];
			}
		}
		return true;
	}
	bool run(){
		return dfs(1,0);
	}
}
namespace circle{
	vector&lt;int&gt;cir;
	int incir[100010];
	int vis[100010],nw;
	ll tval[100010];
	int prt[100010];
	bool dfs(int u,int p){
		vis[u]=++nw;prt[u]=p;
		for(edge*e=bg[u];e;e=e-&gt;nxt){
			if(e-&gt;v!=p){
				if(vis[e-&gt;v]){
					if(vis[e-&gt;v]&gt;vis[u])continue;
					else if(cir.size()==0){
						for(int i=u;i!=prt[e-&gt;v];i=prt[i]){
							cir.pb(i);
							incir[i]=1;
						}
					}else return false;
				}else if(!dfs(e-&gt;v,u))return false;
			}
		}
		return true;
	}
	void dfs2(int u,int p){
		for(edge*e=bg[u];e;e=e-&gt;nxt){
			if(e-&gt;v!=p&amp;&amp;!incir[e-&gt;v]){
				dfs2(e-&gt;v,u);
				tval[u]+=ans[e-&gt;id];
			}
		}
		for(edge*e=bg[u];e;e=e-&gt;nxt){
			if(e-&gt;v==p){
				ans[e-&gt;id]=val[u]-tval[u];
			}
		}
	}
	ll a[100010];int x[100010];
	bool run(){
		if(!dfs(1,0))return false;
		if(cir.size()%2==0)return false;
		vp(i,cir)dfs2(cir[i],0);
		lp(i,1,cir.size())a[i]=val[cir[i-1]]-tval[cir[i-1]];
		lp(i,1,cir.size()){
			for(edge*e=bg[cir[i-1]];e;e=e-&gt;nxt){
				if(i==1){
					if(e-&gt;v==cir.back()){
						x[1]=e-&gt;id;
					}
				}else{
					if(e-&gt;v==cir[i-2]){
						x[i]=e-&gt;id;
					}
				}
			}
		}
		//lp(i,1,cir.size())pf("[%d]",cir[i-1]);pf("\n");
		//lp(i,1,cir.size())pf("[%d]",x[i]);pf("\n");
		ll tmp=0;
		lp(i,1,cir.size()){
			if(i&amp;1)tmp+=a[i];
			else tmp-=a[i];
		}
		ans[x[1]]=tmp/2;
		lp(i,2,cir.size())ans[x[i]]=a[i-1]-ans[x[i-1]];
		return true;
	}
}
int main(){
	sf("%d%d",&amp;n,&amp;m);
	lp(i,1,n)sf("%lld",&amp;val[i]);
	lp(i,1,m){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		add(u,v,i);add(v,u,i);
	}
	if(tree::run()||circle::run()){
		lp(i,1,m)pf("%lld\n",ans[i]*2);
	}else{
		pf("0\n");
	}
	return 0;
}

/*
7 7
8
11
7
17
11
5
1
1 2
2 3
3 4
4 5
5 1
4 6
2 7
*/</pre><pre></pre><h2>Problem3136</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
f(x)=min{f(x-x mod y)+1},y属于M
g(x)=min{t|t是x的最优决策}
f(x)非严格单调，考虑f(x)&lt;f(x-1)，除非x%pi{M}=0，否则x-1可以选和x一样的决策，但是x%pi{M}=0时f(x)=+inf
g(x)非严格单调，由f(x)的非严格单调性可得
f(x=x'*k)&lt;=2*x'，k属于M，数学归纳法
g(x)&lt;x -&gt; g(g(x))&lt;=g(x-1) -&gt; g(g(x))&lt;=(x-1)-(x-1)%k=(x-1)-(k-1)=x-k
f(x)=f(g(g(x)))+2&lt;=f(x-k)+2=f((x'-1)*k)+2&lt;=2x'
f(n)&lt;=ceil(2n/max{M})=O(2n/|M|lg|M|）
对于f(x)相同的一段，我们只计算最后一个位置
枚举f(x)，从先前计算的点后面开始二分查找需要O(lgn|M|)
*/
int m,q,prim[100010],query[100010],frev[10000010],frevup;
bool calc(int x){
	lp(i,1,m)
		if(x-x%prim[i]&lt;=frev[frevup])
			return true;
	return false;
}
bool chec(int x){
	lp(i,1,m)
		if(x%prim[i]!=0)
			return false;
	return true;
}
int main(){
	sf("%d%d",&amp;m,&amp;q);
	lp(i,1,m)sf("%d",&amp;prim[i]);
	lp(i,1,q)sf("%d",&amp;query[i]);
	int maxn=*max_element(query+1,query+q+1);
	int maxp=*max_element(prim+1,prim+m+1);
	while(frev[frevup]!=maxn){
		int l=frev[frevup]+1,r=min(maxn,frev[frevup]+maxp);
		if(chec(l))break;
		if(calc(r))frev[++frevup]=r;
		else{
			while(l+1&lt;r){
				int m=(l+r)/2;
				if(calc(m))l=m;
				else r=m;
			}
			frev[++frevup]=l;
		}
	}
	lp(i,1,q){
		if(query[i]&gt;frev[frevup])pf("oo\n");
		else{
			int l=0,r=frevup;
			while(l+1&lt;r){
				int m=(l+r)/2;
				if(frev[m]&gt;=query[i])r=m;
				else l=m;
			}
			pf("%d\n",r);
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem3137</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
char map[4010][4010];int w,h,ans;
struct point{
	point(int a,int b):
		x(a),y(b){}
	int x,y;
};
int main(){
	sf("%d%d",&amp;h,&amp;w);
	lp(i,1,h)sf("%s",map[i]+1);
	char cur=(map[1][1]=='F'?'R':'F');
	queue&lt;point&gt;qu;qu.push(point(1,1));map[1][1]='.';
	while(!qu.empty()){
		//pf("[%d]\n",(int)qu.size());
		if(cur=='F')cur='R';
		else cur='F';
		queue&lt;point&gt;tq;++ans;
		while(!qu.empty()){
			int x=qu.front().x,y=qu.front().y;qu.pop();
			if(x!=1&amp;&amp;map[x-1][y]!='.'){
				if(map[x-1][y]==cur)qu.push(point(x-1,y));
				else tq.push(point(x-1,y));
				map[x-1][y]='.';
			}
			if(x!=h&amp;&amp;map[x+1][y]!='.'){
				if(map[x+1][y]==cur)qu.push(point(x+1,y));
				else tq.push(point(x+1,y));
				map[x+1][y]='.';
			}
			if(y!=1&amp;&amp;map[x][y-1]!='.'){
				if(map[x][y-1]==cur)qu.push(point(x,y-1));
				else tq.push(point(x,y-1));
				map[x][y-1]='.';
			}
			if(y!=w&amp;&amp;map[x][y+1]!='.'){
				if(map[x][y+1]==cur)qu.push(point(x,y+1));
				else tq.push(point(x,y+1));
				map[x][y+1]='.';
			}
		}
		qu=tq;
	}
	pf("%d\n",ans);
	return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;
        inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;fix=rand();val=a;add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;sam=INF;siz=vsiz=e;
            }
            node*ch[2];int val,vmi,vmx,mi,mx,vsum,sum,add,vsiz,siz,fix,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;
                a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;
                (tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;
                a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;
            	a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;
            	a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;
            	a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;
                (tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;
                a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;
            else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;
                    down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
        if(a==a-&gt;pr-&gt;ch[0])return 0;
        else if(a==a-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){
            swap(a-&gt;ch[0],a-&gt;ch[1]);
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;
            a-&gt;rev=0;
        }
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;
            a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;
            a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;
            a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;
            a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;
            	a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;
            	a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);*(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);
            if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);
            setchd(a,b,1);
            b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);
        node*c=access(b);
        splay(c);
        splay(a);
        if(d==1){
            c-&gt;val+=u;
            if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;
            if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){
            if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){
            if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){
            if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;
        }
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);
        splay(a);
        if(d==1){
        	a-&gt;val+=u;
        	if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
int main(){
    static vector&lt;int&gt;to[N];static int we[N],n,q,rt;
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n-1){
        int u,v;sf("%d%d",&amp;u,&amp;v);
        to[u].pb(v);to[v].pb(u);
    }
    lp(i,1,n)sf("%d",&amp;we[i]);sf("%d",&amp;rt);
    tr.build(to,we,n,rt);
    lp(i,1,q){
        int k;sf("%d",&amp;k);
        if(k==0){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            tr.mtree(tr.ns+a,b,2);
        }else if(k==1){
            int a;sf("%d",&amp;a);
            tr.evert(tr.ns+a);
        }else if(k==2){
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){
            int a;sf("%d",&amp;a);
            pf("%d\n",tr.qtree(tr.ns+a,1));
        }else if(k==4){
            int a;sf("%d",&amp;a);
            pf("%d\n",tr.qtree(tr.ns+a,2));
        }else if(k==5){
        	int a,b;sf("%d%d",&amp;a,&amp;b);
            tr.mtree(tr.ns+a,b,1);
        }else if(k==6){
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{
            int a;sf("%d",&amp;a);
            pf("%d\n",tr.qtree(tr.ns+a,3));
        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
    	if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
            	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
        	max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
int main(){
    static vector&lt;int&gt;to[N];static int we[N],n,q,rt;sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n-1){int u,v;sf("%d%d",&amp;u,&amp;v);to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)sf("%d",&amp;we[i]);sf("%d",&amp;rt);tr.build(to,we,n,rt);
    lp(i,1,q){
        int k;sf("%d",&amp;k);
        if(k==0){int a,b;sf("%d%d",&amp;a,&amp;b);tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a;sf("%d",&amp;a);tr.evert(tr.ns+a);
        }else if(k==2){int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a;sf("%d",&amp;a);pf("%d\n",tr.qtree(tr.ns+a,1));
        }else if(k==4){int a;sf("%d",&amp;a);pf("%d\n",tr.qtree(tr.ns+a,2));
        }else if(k==5){int a,b;sf("%d%d",&amp;a,&amp;b);tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a,b;sf("%d%d",&amp;a,&amp;b);pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a,b;sf("%d%d",&amp;a,&amp;b);pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a,b;sf("%d%d",&amp;a,&amp;b);tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a,b;sf("%d%d",&amp;a,&amp;b);pf("%d\n",tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a;sf("%d",&amp;a);pf("%d\n",tr.qtree(tr.ns+a,3));}
    }
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
#include&lt;cctype&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
    	if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
            	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
        	max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char buff[10000010],*ptr=buff;
inline char gchr(){
    for(;!isdigit(*ptr);++ptr);
    return *ptr++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;isdigit(*ptr);++ptr)t=t*10+*ptr-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
	fread(buff,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
    	if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
            	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
        	max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char buff[10000010],*ptr=buff;
inline bool dig(char c){
	return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*ptr);++ptr);
    return *ptr++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*ptr);++ptr)t=t*10+*ptr-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
	fread(buff,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
    	if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
            	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
        	max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char buff[10000010],*ptr=buff;
inline bool dig(char c){
	return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*ptr);++ptr);
    return *ptr++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*ptr);++ptr)t=t*10+*ptr-'0';
    return t;
}
inline void pint(int a){
    pf("%d\n",a);
}
int main(){
	fread(buff,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
            	a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
            	a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
            	a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
    	if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
            	a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
        		lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
        	if(a-&gt;virsiz){
            	a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
            	a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
            	if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
            	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
        	max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    } 
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char bin[10000010],*pin=bin;
char bout[10000010],*pout=bout;
inline bool dig(char c){
	return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*pin);++pin);
    return *pin++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*pin);++pin)t=t*10+*pin-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)*pout++='0'+tmp[i];
    *pout++='\n';
}
int main(){
	fread(bin,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    fwrite(bout,1,pout-bout,stdout);
    return 0;
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
#define IL inline
const int A=100010,B=~0u&gt;&gt;1;
IL void C(int&amp;a,int b){if(b&lt;a)a=b;}
IL void D(int&amp;a,int b){if(b&gt;a)a=b;}
struct E{
    struct F{
        E*G;IL F(struct E*a):G(a){}
        struct X{
            IL X(){}
            IL X(int a,int b,int c,int d,int e){
                H[0]=H[1]=0;I=a;J=rand();S=0;
                O=K=b;P=L=c;Q=M=d;R=N=e;T=B;
            }
            X*H[2];int I,J,K,L,M,N,O,P,Q,R,S,T;
        }U[A];
        IL void V(X*a){
            if(a-&gt;T!=B){
                a-&gt;O=a-&gt;P=a-&gt;K=a-&gt;L=a-&gt;T;
                a-&gt;M=a-&gt;T*a-&gt;N;a-&gt;Q=a-&gt;T*a-&gt;R;
                (G-&gt;V+(a-U))-&gt;AN=0;(G-&gt;V+(a-U))-&gt;AM=a-&gt;T;
                (G-&gt;V+(a-U))-&gt;AS=0;(G-&gt;V+(a-U))-&gt;AQ=a-&gt;T;
                lp(i,0,1)if(a-&gt;H[i])a-&gt;H[i]-&gt;S=0,a-&gt;H[i]-&gt;T=a-&gt;T;a-&gt;T=B;
            }
            if(a-&gt;S){
            	a-&gt;O+=a-&gt;S;a-&gt;P+=a-&gt;S;
            	a-&gt;K+=a-&gt;S;a-&gt;L+=a-&gt;S;
            	a-&gt;M+=a-&gt;S*a-&gt;N;a-&gt;Q+=a-&gt;S*a-&gt;R;
                (G-&gt;V+(a-U))-&gt;AN+=a-&gt;S;(G-&gt;V+(a-U))-&gt;AS+=a-&gt;S;
                lp(i,0,1)if(a-&gt;H[i])a-&gt;H[i]-&gt;S+=a-&gt;S;a-&gt;S=0;
            }
        }
        IL void W(X*a){
            lp(i,0,1)if(a-&gt;H[i])V(a-&gt;H[i]);
            a-&gt;O=a-&gt;K;lp(i,0,1)if(a-&gt;H[i])C(a-&gt;O,a-&gt;H[i]-&gt;O);
            a-&gt;P=a-&gt;L;lp(i,0,1)if(a-&gt;H[i])D(a-&gt;P,a-&gt;H[i]-&gt;P);
            a-&gt;Q=a-&gt;M;lp(i,0,1)if(a-&gt;H[i])a-&gt;Q+=a-&gt;H[i]-&gt;Q;
            a-&gt;R=a-&gt;N;lp(i,0,1)if(a-&gt;H[i])a-&gt;R+=a-&gt;H[i]-&gt;R;
        }
        IL void Y(X*&amp;a,int d){
            X*b=a-&gt;H[d];a-&gt;H[d]=b-&gt;H[!d];b-&gt;H[!d]=a;
            W(a);W(b);a=b;
        }
        IL void Z(X*&amp;a,X*b){
            if(!a)a=b;else{
                V(a);int d=b-&gt;I&gt;a-&gt;I;
                Z(a-&gt;H[d],b);W(a);
                if(a-&gt;H[d]-&gt;J&lt;a-&gt;J)Y(a,d);
            }
        }
        IL void AA(X*&amp;a,int b){
            V(a);if(a-&gt;I==b){
                if(!a-&gt;H[0])a=a-&gt;H[1];
                else if(!a-&gt;H[1])a=a-&gt;H[0];
                else{
                    int d=a-&gt;H[1]-&gt;J&lt;a-&gt;H[0]-&gt;J;V(a-&gt;H[d]);
                    Y(a,d);AA(a-&gt;H[!d],b);W(a);
                }
            }else{int d=b&gt;a-&gt;I;AA(a-&gt;H[d],b);W(a);}
        }
    };
    IL E():AB(this){}
    struct AC{
        IL AC(){}
        IL AC(int a,AC*b){
            AD[0]=AD[1]=0;AE=b;
            AT=0;AF=a;AG=AH=a;AR=1;
            AP=AL=AS=0;AJ=B;AK=-B;AQ=B;
            AM=B;AO=0;AN=0;
        }
        AC*AD[2],*AE;
        int AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR,AS;
        F::X*AT;
    }V[A];F AB;
    IL int AU(AC*a){
    	if(a==a-&gt;AE-&gt;AD[0])return 0;else if(a==a-&gt;AE-&gt;AD[1])return 1;else return 2;
    }
    IL void AV(AC*a){
        if(a-&gt;AP){swap(a-&gt;AD[0],a-&gt;AD[1]);lp(i,0,1)if(a-&gt;AD[i])a-&gt;AD[i]-&gt;AP^=1;a-&gt;AP=0;}
        if(a-&gt;AQ!=B){
            a-&gt;AF=a-&gt;AG=a-&gt;AH=a-&gt;AQ;a-&gt;AI=a-&gt;AQ*a-&gt;AR;
            lp(i,0,1)if(a-&gt;AD[i])a-&gt;AD[i]-&gt;AQ=a-&gt;AQ,a-&gt;AD[i]-&gt;AS=0;a-&gt;AQ=B;
        }
        if(a-&gt;AS){
            a-&gt;AF+=a-&gt;AS;a-&gt;AG+=a-&gt;AS;a-&gt;AH+=a-&gt;AS;a-&gt;AI+=a-&gt;AS*a-&gt;AR;
            lp(i,0,1)if(a-&gt;AD[i])a-&gt;AD[i]-&gt;AS+=a-&gt;AS;a-&gt;AS=0;
        }
        if(a-&gt;AM!=B){
            if(a-&gt;AO){
            	a-&gt;AJ=a-&gt;AK=a-&gt;AM;a-&gt;AL=a-&gt;AM*a-&gt;AO;
            	if(a-&gt;AT)a-&gt;AT-&gt;S=0,a-&gt;AT-&gt;T=a-&gt;AM;
        		lp(i,0,1)if(a-&gt;AD[i])a-&gt;AD[i]-&gt;AN=0,a-&gt;AD[i]-&gt;AM=a-&gt;AM;
            }
            a-&gt;AM=B;
        }
        if(a-&gt;AN){
        	if(a-&gt;AO){
            	a-&gt;AJ+=a-&gt;AN;a-&gt;AK+=a-&gt;AN;
            	a-&gt;AL+=a-&gt;AN*a-&gt;AO;
            	if(a-&gt;AT)a-&gt;AT-&gt;S+=a-&gt;AN;
            	lp(i,0,1)if(a-&gt;AD[i])a-&gt;AD[i]-&gt;AN+=a-&gt;AN;
            }
            a-&gt;AN=0;
        }
    }
    IL void AW(AC*a){
        lp(i,0,1)if(a-&gt;AD[i])AV(a-&gt;AD[i]);
        if(a-&gt;AT)AB.V(a-&gt;AT);
        a-&gt;AG=a-&gt;AF;lp(i,0,1)if(a-&gt;AD[i])C(a-&gt;AG,a-&gt;AD[i]-&gt;AG);
        a-&gt;AJ=B;lp(i,0,1)if(a-&gt;AD[i])C(a-&gt;AJ,a-&gt;AD[i]-&gt;AJ);
        if(a-&gt;AT)C(a-&gt;AJ,a-&gt;AT-&gt;O);
        a-&gt;AH=a-&gt;AF;lp(i,0,1)if(a-&gt;AD[i])D(a-&gt;AH,a-&gt;AD[i]-&gt;AH);
        a-&gt;AK=-B;lp(i,0,1)if(a-&gt;AD[i])D(a-&gt;AK,a-&gt;AD[i]-&gt;AK);
        if(a-&gt;AT)D(a-&gt;AK,a-&gt;AT-&gt;P);
        a-&gt;AI=a-&gt;AF;lp(i,0,1)if(a-&gt;AD[i])a-&gt;AI+=a-&gt;AD[i]-&gt;AI;
        a-&gt;AL=0;lp(i,0,1)if(a-&gt;AD[i])a-&gt;AL+=a-&gt;AD[i]-&gt;AL;
        if(a-&gt;AT)a-&gt;AL+=a-&gt;AT-&gt;Q;
        a-&gt;AR=1;lp(i,0,1)if(a-&gt;AD[i])a-&gt;AR+=a-&gt;AD[i]-&gt;AR;
        a-&gt;AO=0;lp(i,0,1)if(a-&gt;AD[i])a-&gt;AO+=a-&gt;AD[i]-&gt;AO;
        if(a-&gt;AT)a-&gt;AO+=a-&gt;AT-&gt;R;
    }
    IL void AX(AC*a,AC*b,int d){a-&gt;AD[d]=b;if(b)b-&gt;AE=a;AW(a);}
    IL void AY(AC*a,AC*b){
        AV(a);
        *(AB.U+(a-V))=F::X(a-V,min(a-&gt;AJ,a-&gt;AG),
        	max(a-&gt;AK,a-&gt;AH),a-&gt;AL+a-&gt;AI,a-&gt;AO+a-&gt;AR);
        AB.Z(b-&gt;AT,AB.U+(a-V));
    }
    IL void AZ(AC*a,AC*b){AB.AA(b-&gt;AT,a-V);}
    IL void BA(AC*a){
        AC*b=a-&gt;AE,*c=a-&gt;AE-&gt;AE;int d1=AU(a),d2=3;if(c)d2=AU(b);
        AX(b,a-&gt;AD[!d1],d1);AX(a,b,!d1);
        if(d2&lt;2)AX(c,a,d2);
        else if(d2==2){AZ(b,c);AY(a,c);a-&gt;AE=c;}
        else a-&gt;AE=0;
    }
    IL void BB(AC*a){
        if(a-&gt;AE&amp;&amp;AU(a)&lt;2)BB(a-&gt;AE);
        else if(a-&gt;AE)AZ(a,a-&gt;AE),AY(a,a-&gt;AE);
        AV(a);
    }
    IL void BC(AC*a){
        BB(a);
        while(a-&gt;AE&amp;&amp;AU(a)&lt;2){
            AC*b=a-&gt;AE;
            if(!b-&gt;AE||AU(b)&gt;1)BA(a);
            else if(AU(a)==AU(b))BA(b),BA(a);
            else BA(a),BA(a);
        }
    } 
    IL AC*BD(AC*a){
        AC*b=0;
        while(a){
            BC(a);if(a-&gt;AD[1])AY(a-&gt;AD[1],a);
            if(b)AZ(b,a);AX(a,b,1);b=a;a=a-&gt;AE;
        }
        return b;
    }
    IL void BE(AC*a){BD(a);BC(a);a-&gt;AP=1;}
    IL int BF(AC*a,AC*b,int d){
        BD(a);AC*c=BD(b);BC(c);BC(a);int ret=c-&gt;AF;
        if(d==1){
            if(a!=c)C(ret,a-&gt;AG);
            if(c-&gt;AD[1])AV(c-&gt;AD[1]),C(ret,c-&gt;AD[1]-&gt;AG);
        }else if(d==2){
            if(a!=c)D(ret,a-&gt;AH);
            if(c-&gt;AD[1])AV(c-&gt;AD[1]),D(ret,c-&gt;AD[1]-&gt;AH);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;AI;
            if(c-&gt;AD[1])AV(c-&gt;AD[1]),ret+=c-&gt;AD[1]-&gt;AI;
        }
        return ret;
    }
    IL void BG(AC*a,AC*b,int u,int d){
        BD(a);AC*c=BD(b);BC(c);BC(a);
        if(d==1){
            c-&gt;AF+=u;if(a!=c)a-&gt;AS=u,AZ(a,c),AY(a,c);
            if(c-&gt;AD[1])AV(c-&gt;AD[1]),c-&gt;AD[1]-&gt;AS=u;
        }else if(d==2){
            c-&gt;AF=u;if(a!=c)a-&gt;AQ=u,AZ(a,c),AY(a,c);
            if(c-&gt;AD[1])AV(c-&gt;AD[1]),c-&gt;AD[1]-&gt;AQ=u;
        }
        AW(c);
    }
    IL int BH(AC*a,int d){
        BD(a);
        BC(a);int ret=a-&gt;AF;
        if(d==1){if(a-&gt;AT)AB.V(a-&gt;AT),C(ret,a-&gt;AT-&gt;O);
        }else if(d==2){if(a-&gt;AT)AB.V(a-&gt;AT),D(ret,a-&gt;AT-&gt;P);
        }else if(d==3){if(a-&gt;AT)AB.V(a-&gt;AT),ret+=a-&gt;AT-&gt;Q;}
        return ret;
    }
    IL void BI(AC*a,int u,int d){
        BD(a);BC(a);
        if(d==1){a-&gt;AF+=u;if(a-&gt;AT)AB.V(a-&gt;AT),a-&gt;AT-&gt;S=u;
        }else if(d==2){a-&gt;AF=u;if(a-&gt;AT)AB.V(a-&gt;AT),a-&gt;AT-&gt;T=u;}
        AW(a);
    }
    IL void BJ(AC*a,AC*b){
        BD(b);if(BD(a)!=a){
            BC(a);AC*c=a-&gt;AD[0];AV(c);
            while(c-&gt;AD[1])c=c-&gt;AD[1],AV(c);
            BC(c);c-&gt;AD[1]=0;AW(c);BD(b);
            BC(b);AY(a,b);a-&gt;AE=b;AW(b);
        }
    }
    IL void BK(vector&lt;int&gt;*BW,int*BX,int n,int rt){
        static int BY[A];vector&lt;int&gt;BV;
        queue&lt;int&gt;BZ;BZ.push(rt);
        while(!BZ.empty()){
            int u=BZ.front();BZ.pop();BV.pb(u);
            vp(i,BW[u]){int v=BW[u][i];if(v!=BY[u])BZ.push(v),BY[v]=u;}
        }
        lp(i,0,n-1){int u=BV[i];V[u]=AC(BX[u],BY[u]?V+BY[u]:0);}
        rp(i,n-1,0){int u=BV[i];AW(V+u);if(BY[u])AY(V+u,V+BY[u]);}
    }
}tr;
char bin[10000010],*pin=bin;
char BU[10000010],*BR=BU;
IL bool BL(char c){
	return c&gt;='0'&amp;&amp;c&lt;='9';
}
IL char BM(){
    for(;!BL(*pin);++pin);
    return *pin++;
}
IL int BN(){
    int t=BM()-'0';
    for(;BL(*pin);++pin)t=t*10+*pin-'0';
    return t;
}
IL void BO(int a){
    static char BP[11];int BQ=0;
    do{
        BP[++BQ]=a%10;
        a/=10;
    }while(a);
    rp(i,BQ,1)*BR++='0'+BP[i];
    *BR++='\n';
}
int main(){
	fread(bin,1,10000000,stdin);
    static vector&lt;int&gt;to[A];static int BS[A];int n=BN(),q=BN(),BT;
    lp(i,1,n-1){int u=BN(),v=BN();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)BS[i]=BN();BT=BN();tr.BK(to,BS,n,BT);
    lp(i,1,q){
        int k=BN();
        if(k==0){int a=BN(),b=BN();tr.BI(tr.V+a,b,2);
        }else if(k==1){int a=BN();tr.BE(tr.V+a);
        }else if(k==2){int a=BN(),b=BN(),c=BN();tr.BG(tr.V+a,tr.V+b,c,2);
        }else if(k==3){int a=BN();BO(tr.BH(tr.V+a,1));
        }else if(k==4){int a=BN();BO(tr.BH(tr.V+a,2));
        }else if(k==5){int a=BN(),b=BN();tr.BI(tr.V+a,b,1);
        }else if(k==6){int a=BN(),b=BN(),c=BN();tr.BG(tr.V+a,tr.V+b,c,1);
        }else if(k==7){int a=BN(),b=BN();BO(tr.BF(tr.V+a,tr.V+b,1));
        }else if(k==8){int a=BN(),b=BN();BO(tr.BF(tr.V+a,tr.V+b,2));
        }else if(k==9){int a=BN(),b=BN();tr.BJ(tr.V+a,tr.V+b);
        }else if(k==10){int a=BN(),b=BN();BO(tr.BF(tr.V+a,tr.V+b,3));
        }else{int a=BN();BO(tr.BH(tr.V+a,3));}
    }
    fwrite(BU,1,BR-BU,stdout);
    return 0;
}

</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
                a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
                a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
                a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    down(a-&gt;ch[0]);rotate(a,0);erase(a-&gt;ch[1],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
        if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
                a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
            if(a-&gt;virsiz){
                a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
                a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
            max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(a-&gt;pr&amp;&amp;direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    }
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char bin[10000010],*pin=bin;
char bout[10000010],*pout=bout;
inline bool dig(char c){
    return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*pin);++pin);
    return *pin++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*pin);++pin)t=t*10+*pin-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)*pout++='0'+tmp[i];
    *pout++='\n';
}
int main(){
    fread(bin,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    fwrite(bout,1,pout-bout,stdout);
    return 0;
}</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
                a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
                a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
                a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    down(a-&gt;ch[0]);rotate(a,0);erase(a-&gt;ch[1],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
        if(a==a-&gt;pr-&gt;ch[0])return 0;else if(a==a-&gt;pr-&gt;ch[1])return 1;else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){swap(a-&gt;ch[0],a-&gt;ch[1]);lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;}
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
                a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
            if(a-&gt;virsiz){
                a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
                a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
            max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=3;if(c)d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(a-&gt;pr&amp;&amp;direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);while(a-&gt;pr&amp;&amp;direct(a)&lt;2)rotate(a);
    }
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char bin[10000010],*pin=bin;
char bout[10000010],*pout=bout;
inline bool dig(char c){
    return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*pin);++pin);
    return *pin++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*pin);++pin)t=t*10+*pin-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)*pout++='0'+tmp[i];
    *pout++='\n';
}
int main(){
    fread(bin,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    fwrite(bout,1,pout-bout,stdout);
    return 0;
}</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
const int N=100010,INF=~0u&gt;&gt;1;
inline void gmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline void gmax(int&amp;a,int b){if(b&gt;a)a=b;}
struct lct{
    struct treap{
        lct*tr;inline treap(struct lct*a):tr(a){}
        struct node{
            inline node(){}
            inline node(int a,int b,int c,int d,int e){
                ch[0]=ch[1]=0;val=a;fix=rand();add=0;
                mi=vmi=b;mx=vmx=c;sum=vsum=d;siz=vsiz=e;sam=INF;
            }
            node*ch[2];int val,fix,vmi,vmx,vsum,vsiz,mi,mx,sum,siz,add,sam;
        }ns[N];
        inline void down(node*a){
            if(a-&gt;sam!=INF){
                a-&gt;mi=a-&gt;mx=a-&gt;vmi=a-&gt;vmx=a-&gt;sam;
                a-&gt;vsum=a-&gt;sam*a-&gt;vsiz;a-&gt;sum=a-&gt;sam*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd=0;(tr-&gt;ns+(a-ns))-&gt;virsam=a-&gt;sam;
                (tr-&gt;ns+(a-ns))-&gt;add=0;(tr-&gt;ns+(a-ns))-&gt;sam=a-&gt;sam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add=0,a-&gt;ch[i]-&gt;sam=a-&gt;sam;a-&gt;sam=INF;
            }
            if(a-&gt;add){
                a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;
                a-&gt;vmi+=a-&gt;add;a-&gt;vmx+=a-&gt;add;
                a-&gt;vsum+=a-&gt;add*a-&gt;vsiz;a-&gt;sum+=a-&gt;add*a-&gt;siz;
                (tr-&gt;ns+(a-ns))-&gt;viradd+=a-&gt;add;(tr-&gt;ns+(a-ns))-&gt;add+=a-&gt;add;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
            }
        }
        inline void update(node*a){
            lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
            a-&gt;mi=a-&gt;vmi;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
            a-&gt;mx=a-&gt;vmx;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
            a-&gt;sum=a-&gt;vsum;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
            a-&gt;siz=a-&gt;vsiz;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        }
        inline void rotate(node*&amp;a,int d){
            node*b=a-&gt;ch[d];a-&gt;ch[d]=b-&gt;ch[!d];b-&gt;ch[!d]=a;
            update(a);update(b);a=b;
        }
        inline void insert(node*&amp;a,node*b){
            if(!a)a=b;else{
                down(a);int d=b-&gt;val&gt;a-&gt;val;
                insert(a-&gt;ch[d],b);update(a);
                if(a-&gt;ch[d]-&gt;fix&lt;a-&gt;fix)rotate(a,d);
            }
        }
        inline void erase(node*&amp;a,int b){
            down(a);if(a-&gt;val==b){
                if(!a-&gt;ch[0])a=a-&gt;ch[1];
                else if(!a-&gt;ch[1])a=a-&gt;ch[0];
                else{
                    int d=a-&gt;ch[1]-&gt;fix&lt;a-&gt;ch[0]-&gt;fix;down(a-&gt;ch[d]);
                    rotate(a,d);erase(a-&gt;ch[!d],b);update(a);
                }
            }else{int d=b&gt;a-&gt;val;erase(a-&gt;ch[d],b);update(a);}
        }
    };
    inline lct():trp(this){}
    struct node{
        inline node(){}
        inline node(int a,node*b){
            ch[0]=ch[1]=0;pr=b;
            vir=0;val=a;mi=mx=a;siz=1;
            rev=virsum=add=0;virmi=INF;virmx=-INF;sam=INF;
            virsam=INF;virsiz=0;viradd=0;
        }
        node*ch[2],*pr;
        int val,mi,mx,sum,virmi,virmx,virsum,virsam,viradd,virsiz,rev,sam,siz,add;
        treap::node*vir;
    }ns[N];treap trp;
    inline int direct(node*a){
        if(!a-&gt;pr)return 3;
        else if(a==a-&gt;pr-&gt;ch[0])return 0;
        else if(a==a-&gt;pr-&gt;ch[1])return 1;
        else return 2;
    }
    inline void down(node*a){
        if(a-&gt;rev){
        	swap(a-&gt;ch[0],a-&gt;ch[1]);
        	lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;rev^=1;a-&gt;rev=0;
        }
        if(a-&gt;sam!=INF){
            a-&gt;val=a-&gt;mi=a-&gt;mx=a-&gt;sam;a-&gt;sum=a-&gt;sam*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;sam=a-&gt;sam,a-&gt;ch[i]-&gt;add=0;a-&gt;sam=INF;
        }
        if(a-&gt;add){
            a-&gt;val+=a-&gt;add;a-&gt;mi+=a-&gt;add;a-&gt;mx+=a-&gt;add;a-&gt;sum+=a-&gt;add*a-&gt;siz;
            lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;add+=a-&gt;add;a-&gt;add=0;
        }
        if(a-&gt;virsam!=INF){
            if(a-&gt;virsiz){
                a-&gt;virmi=a-&gt;virmx=a-&gt;virsam;a-&gt;virsum=a-&gt;virsam*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add=0,a-&gt;vir-&gt;sam=a-&gt;virsam;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd=0,a-&gt;ch[i]-&gt;virsam=a-&gt;virsam;
            }
            a-&gt;virsam=INF;
        }
        if(a-&gt;viradd){
            if(a-&gt;virsiz){
                a-&gt;virmi+=a-&gt;viradd;a-&gt;virmx+=a-&gt;viradd;
                a-&gt;virsum+=a-&gt;viradd*a-&gt;virsiz;
                if(a-&gt;vir)a-&gt;vir-&gt;add+=a-&gt;viradd;
                lp(i,0,1)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;viradd+=a-&gt;viradd;
            }
            a-&gt;viradd=0;
        }
    }
    inline void update(node*a){
        lp(i,0,1)if(a-&gt;ch[i])down(a-&gt;ch[i]);
        if(a-&gt;vir)trp.down(a-&gt;vir);
        a-&gt;mi=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;mi,a-&gt;ch[i]-&gt;mi);
        a-&gt;virmi=INF;lp(i,0,1)if(a-&gt;ch[i])gmin(a-&gt;virmi,a-&gt;ch[i]-&gt;virmi);
        if(a-&gt;vir)gmin(a-&gt;virmi,a-&gt;vir-&gt;mi);
        a-&gt;mx=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;mx,a-&gt;ch[i]-&gt;mx);
        a-&gt;virmx=-INF;lp(i,0,1)if(a-&gt;ch[i])gmax(a-&gt;virmx,a-&gt;ch[i]-&gt;virmx);
        if(a-&gt;vir)gmax(a-&gt;virmx,a-&gt;vir-&gt;mx);
        a-&gt;sum=a-&gt;val;lp(i,0,1)if(a-&gt;ch[i])a-&gt;sum+=a-&gt;ch[i]-&gt;sum;
        a-&gt;virsum=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsum+=a-&gt;ch[i]-&gt;virsum;
        if(a-&gt;vir)a-&gt;virsum+=a-&gt;vir-&gt;sum;
        a-&gt;siz=1;lp(i,0,1)if(a-&gt;ch[i])a-&gt;siz+=a-&gt;ch[i]-&gt;siz;
        a-&gt;virsiz=0;lp(i,0,1)if(a-&gt;ch[i])a-&gt;virsiz+=a-&gt;ch[i]-&gt;virsiz;
        if(a-&gt;vir)a-&gt;virsiz+=a-&gt;vir-&gt;siz;
    }
    inline void setchd(node*a,node*b,int d){a-&gt;ch[d]=b;if(b)b-&gt;pr=a;update(a);}
    inline void connect(node*a,node*b){
        down(a);
        *(trp.ns+(a-ns))=treap::node(a-ns,min(a-&gt;virmi,a-&gt;mi),
            max(a-&gt;virmx,a-&gt;mx),a-&gt;virsum+a-&gt;sum,a-&gt;virsiz+a-&gt;siz);
        trp.insert(b-&gt;vir,trp.ns+(a-ns));
    }
    inline void disconnect(node*a,node*b){trp.erase(b-&gt;vir,a-ns);}
    inline void rotate(node*a){
        node*b=a-&gt;pr,*c=a-&gt;pr-&gt;pr;int d1=direct(a),d2=direct(b);
        setchd(b,a-&gt;ch[!d1],d1);setchd(a,b,!d1);
        if(d2&lt;2)setchd(c,a,d2);
        else if(d2==2){disconnect(b,c);connect(a,c);a-&gt;pr=c;}
        else a-&gt;pr=0;
    }
    inline void release(node*a){
        if(direct(a)&lt;2)release(a-&gt;pr);
        else if(a-&gt;pr)disconnect(a,a-&gt;pr),connect(a,a-&gt;pr);
        down(a);
    }
    inline void splay(node*a){
        release(a);
        while(direct(a)&lt;2){
            node*b=a-&gt;pr;
            if(!b-&gt;pr||direct(b)&gt;1)rotate(a);
            else if(direct(a)==direct(b))rotate(b),rotate(a);
            else rotate(a),rotate(a);
        }
    }
    inline node*access(node*a){
        node*b=0;
        while(a){
            splay(a);if(a-&gt;ch[1])connect(a-&gt;ch[1],a);
            if(b)disconnect(b,a);setchd(a,b,1);b=a;a=a-&gt;pr;
        }
        return b;
    }
    inline void evert(node*a){access(a);splay(a);a-&gt;rev=1;}
    inline int qchain(node*a,node*b,int d){
        access(a);node*c=access(b);splay(c);splay(a);int ret=c-&gt;val;
        if(d==1){
            if(a!=c)gmin(ret,a-&gt;mi);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmin(ret,c-&gt;ch[1]-&gt;mi);
        }else if(d==2){
            if(a!=c)gmax(ret,a-&gt;mx);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),gmax(ret,c-&gt;ch[1]-&gt;mx);
        }else if(d==3){
            if(a!=c)ret+=a-&gt;sum;
            if(c-&gt;ch[1])down(c-&gt;ch[1]),ret+=c-&gt;ch[1]-&gt;sum;
        }
        return ret;
    }
    inline void mchain(node*a,node*b,int u,int d){
        access(a);node*c=access(b);splay(c);splay(a);
        if(d==1){
            c-&gt;val+=u;if(a!=c)a-&gt;add=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;add=u;
        }else if(d==2){
            c-&gt;val=u;if(a!=c)a-&gt;sam=u,disconnect(a,c),connect(a,c);
            if(c-&gt;ch[1])down(c-&gt;ch[1]),c-&gt;ch[1]-&gt;sam=u;
        }
        update(c);
    }
    inline int qtree(node*a,int d){
        access(a);
        splay(a);int ret=a-&gt;val;
        if(d==1){if(a-&gt;vir)trp.down(a-&gt;vir),gmin(ret,a-&gt;vir-&gt;mi);
        }else if(d==2){if(a-&gt;vir)trp.down(a-&gt;vir),gmax(ret,a-&gt;vir-&gt;mx);
        }else if(d==3){if(a-&gt;vir)trp.down(a-&gt;vir),ret+=a-&gt;vir-&gt;sum;}
        return ret;
    }
    inline void mtree(node*a,int u,int d){
        access(a);splay(a);
        if(d==1){a-&gt;val+=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;add=u;
        }else if(d==2){a-&gt;val=u;if(a-&gt;vir)trp.down(a-&gt;vir),a-&gt;vir-&gt;sam=u;}
        update(a);
    }
    inline void stparent(node*a,node*b){
        access(b);if(access(a)!=a){
            splay(a);node*c=a-&gt;ch[0];down(c);
            while(c-&gt;ch[1])c=c-&gt;ch[1],down(c);
            splay(c);c-&gt;ch[1]=0;update(c);access(b);
            splay(b);connect(a,b);a-&gt;pr=b;update(b);
        }
    }
    inline void build(vector&lt;int&gt;*to,int*we,int n,int rt){
        static int pr[N];vector&lt;int&gt;vec;
        queue&lt;int&gt;qu;qu.push(rt);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vec.pb(u);
            vp(i,to[u]){int v=to[u][i];if(v!=pr[u])qu.push(v),pr[v]=u;}
        }
        lp(i,0,n-1){int u=vec[i];ns[u]=node(we[u],pr[u]?ns+pr[u]:0);}
        rp(i,n-1,0){int u=vec[i];update(ns+u);if(pr[u])connect(ns+u,ns+pr[u]);}
    }
}tr;
char bin[10000010],*pin=bin;
char bout[10000010],*pout=bout;
inline bool dig(char c){
    return c&gt;='0'&amp;&amp;c&lt;='9';
}
inline char gchr(){
    for(;!dig(*pin);++pin);
    return *pin++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;dig(*pin);++pin)t=t*10+*pin-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)*pout++='0'+tmp[i];
    *pout++='\n';
}
int main(){
    fread(bin,1,10000000,stdin);
    static vector&lt;int&gt;to[N];static int we[N];int n=gint(),q=gint(),rt;
    lp(i,1,n-1){int u=gint(),v=gint();to[u].pb(v);to[v].pb(u);}
    lp(i,1,n)we[i]=gint();rt=gint();tr.build(to,we,n,rt);
    lp(i,1,q){
        int k=gint();
        if(k==0){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,2);
        }else if(k==1){int a=gint();tr.evert(tr.ns+a);
        }else if(k==2){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,2);
        }else if(k==3){int a=gint();pint(tr.qtree(tr.ns+a,1));
        }else if(k==4){int a=gint();pint(tr.qtree(tr.ns+a,2));
        }else if(k==5){int a=gint(),b=gint();tr.mtree(tr.ns+a,b,1);
        }else if(k==6){int a=gint(),b=gint(),c=gint();tr.mchain(tr.ns+a,tr.ns+b,c,1);
        }else if(k==7){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,1));
        }else if(k==8){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,2));
        }else if(k==9){int a=gint(),b=gint();tr.stparent(tr.ns+a,tr.ns+b);
        }else if(k==10){int a=gint(),b=gint();pint(tr.qchain(tr.ns+a,tr.ns+b,3));
        }else{int a=gint();pint(tr.qtree(tr.ns+a,3));}
    }
    fwrite(bout,1,pout-bout,stdout);
    return 0;
}

</pre><pre></pre><h2>Problem3155</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll a[100010],s[100010];int n,m;
ll sum[100010*4],tag[100010*4];
void down(int x,int l,int r){
    sum[x]+=(r-l+1)*tag[x];
    if(l!=r){
        tag[x*2]+=tag[x];
        tag[x*2+1]+=tag[x];
    }
    tag[x]=0;
}
void update(int x,int l,int r){
    int m=(l+r)/2;
    down(x*2,l,m);down(x*2+1,m+1,r);
    sum[x]=sum[x*2]+sum[x*2+1];
}
void build(int x,int l,int r){
    if(l==r)sum[x]=s[l];
    else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        update(x,l,r);
    }
}
void modify(int x,int l,int r,int b,int e,ll d){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)tag[x]=d;
    else{
        int m=(l+r)/2;
        if(b&lt;=m)modify(x*2,l,m,b,e,d);
        if(e&gt;m)modify(x*2+1,m+1,r,b,e,d);
        update(x,l,r);
    }
}
ll ask(int x,int l,int r,int b,int e){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)return sum[x];
    else{
        ll rt=0;
        int m=(l+r)/2;
        if(b&lt;=m)rt+=ask(x*2,l,m,b,e);
        if(e&gt;m)rt+=ask(x*2+1,m+1,r,b,e);
        return rt;
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%lld",&amp;a[i]);
    lp(i,1,n)s[i]=s[i-1]+a[i];
    build(1,1,n);
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int u;sf("%d",&amp;u);
            pf("%lld\n",ask(1,1,n,1,u));
        }else{
            int u,v;sf("%d%d",&amp;u,&amp;v);
            modify(1,1,n,u,n,v-a[u]);
            a[u]=v;
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3156</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,a[1000010];
ll x[1000010],y[1000010],f[1000010];
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i]);
    reverse(a+1,a+n+1);
    x[1]=1;y[1]=a[1]+1;f[1]=a[1];
    deque&lt;int&gt;qu;qu.push_back(1);
    lp(i,2,n){
        while(qu.size()&gt;1){
            int j=qu[0],k=qu[1];
            if(f[j]+ll(i-j)*(i-j-1)/2&gt;=f[k]+ll(i-k)*(i-k-1)/2)
                qu.pop_front();
            else break;
        }
        f[i]=f[qu[0]]+ll(i-qu[0])*(i-qu[0]-1)/2+a[i];
        x[i]=i;y[i]=f[i]+i*ll(i+1)/2;
        while(qu.size()&gt;1){
            int j=qu[qu.size()-2],k=qu[qu.size()-1];
            if(double(y[k]-y[j])/(x[k]-x[j])&gt;=double(y[i]-y[k])/(x[i]-x[k]))
                qu.pop_back();
            else break;
        }
        qu.push_back(i);
    }
    ll ans=f[n];
    lp(i,1,n)
        ans=min(ans,f[i]+ll(n-i)*(n-i+1)/2);
    pf("%lld\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3157</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
/*
f(n,a) to f(2n,a) O(m^2lgn)
*/
ll n,m,p=1000000007;
struct data{ll f[210];};
ll mypow(ll x,ll y){
	ll z=1;
	while(y){
		if(y&amp;1)z=z*x%p;
		x=x*x%p;
		y&gt;&gt;=1;
	}
	return z;
}
ll com[210][210];
vector&lt;int&gt;op;
void dfs(ll x){
	if(x==1)return;
	if(x&amp;1){
		dfs(x/2);
		op.pb(1);
		op.pb(2);
	}else{
		dfs(x/2);
		op.pb(1);
	}
}
int main(){
	sf("%lld%lld",&amp;n,&amp;m);
	lp(i,0,m)lp(j,0,m)if(j==0||j==i)com[i][j]=1;else com[i][j]=(com[i-1][j]+com[i-1][j-1])%p;
	data t1;lp(i,0,m)t1.f[i]=m;
	dfs(n);ll now=1;
	vp(u,op){
		if(op[u]==2){
			++now;
			lp(a,0,m)t1.f[a]=(t1.f[a]+mypow(now,a)*mypow(m,now))%p;
		}else{
			data t2;
			lp(a,0,m){
				t2.f[a]=0;
				lp(j,0,a)t2.f[a]=(t2.f[a]+com[a][j]*mypow(now,a-j)%p*t1.f[j]%p)%p;
				t2.f[a]=t2.f[a]*mypow(m,now)%p;
				t2.f[a]=(t2.f[a]+t1.f[a])%p;
			}
			swap(t1,t2);
			now*=2;
		}
	}
	pf("%lld\n",t1.f[m]);
	return 0;
}
</pre><pre></pre><h2>Problem3158</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
pair&lt;int,int&gt;a[1010];int n;
int gcd(int x,int y){return y?gcd(y,x%y):x;}
bool check(ll x,ll y){
    ll t=sqrt(double(x*x+y*y));
    if(t*t&lt;x*x+y*y)++t;
    if(t*t&gt;x*x+y*y)--t;
    return t*t==x*x+y*y&amp;&amp;gcd(x,y)==1;
}
namespace isap{
    struct edge{int v,c;};vector&lt;edge&gt;edges;
    int vcnt;vector&lt;int&gt;to[1010];
    void add(int u,int v,int c){
        edge e;e.v=v;e.c=c;to[u].push_back(edges.size());
        edges.push_back(e);
    }
    int dis[1010],gap[1010];
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=edges[to[u][i]],&amp;ev=edges[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                int t=dfs(e.v,min(e.c,g));
                g-=t,e.c-=t,ev.c+=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    int isap(){
        gap[0]=vcnt;int r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i].first);
    lp(i,1,n)sf("%d",&amp;a[i].second);
    isap::vcnt=n+2;
    lp(i,1,n)if(a[i].first&amp;1){
        isap::add(1,i+1,a[i].second);
        isap::add(i+1,1,0);
        lp(j,1,n)if(a[j].first%2==0){
            if(check(a[i].first,a[j].first)){
                isap::add(i+1,j+1,~0u&gt;&gt;1);
                isap::add(j+1,i+1,0);
            }
        }
    }else{
        isap::add(i+1,n+2,a[i].second);
        isap::add(n+2,i+1,0);
    }
    int ans=0;lp(i,1,n)ans+=a[i].second;
    pf("%d\n",ans-isap::isap());
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3159</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int n,q;
#include&lt;cstdlib&gt;
namespace splay{
	struct node{
		inline node(int v){
			val=sum=mx=mi=v;
			rev=del=0;
			ch[0]=ch[1]=0;
			siz=1;fix=rand();
		}
		node*ch[2];
		int siz,val,mx,mi,rev,del,fix;
		ll sum;
	};
	inline void down(node*x){
		if(x-&gt;rev){
			swap(x-&gt;ch[0],x-&gt;ch[1]);
			lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
			x-&gt;rev=0;
		}
		if(x-&gt;del){
			x-&gt;val+=x-&gt;del;
			x-&gt;sum+=ll(x-&gt;del)*x-&gt;siz;
			x-&gt;mx+=x-&gt;del;
			x-&gt;mi+=x-&gt;del;
			lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;del+=x-&gt;del;
			x-&gt;del=0;
		}
	}
	inline void update(node*x){
		lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
		x-&gt;siz=1;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
		x-&gt;sum=x-&gt;val;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
		x-&gt;mx=x-&gt;val;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;mx=max(x-&gt;mx,x-&gt;ch[i]-&gt;mx);
		x-&gt;mi=x-&gt;val;
		lp(i,0,1)if(x-&gt;ch[i])x-&gt;mi=min(x-&gt;mi,x-&gt;ch[i]-&gt;mi);
	}
	inline node*merge(node*x,node*y){
		if(!x)return y;if(!y)return x;
		if(x-&gt;fix&lt;y-&gt;fix){
			down(x);
			x-&gt;ch[1]=merge(x-&gt;ch[1],y);
			update(x);
			return x;
		}else{
			down(y);
			y-&gt;ch[0]=merge(x,y-&gt;ch[0]);
			update(y);
			return y;
		}
	}
	inline pair&lt;node*,node*&gt;split(node*x,int k){
		if(!x)return mp((node*)0,(node*)0);
		down(x);
		int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
		if(k&gt;=t){
			pair&lt;node*,node*&gt;ret=split(x-&gt;ch[1],k-t);
			x-&gt;ch[1]=ret.first;
			update(x);
			return mp(x,ret.second);
		}else{
			pair&lt;node*,node*&gt;ret=split(x-&gt;ch[0],k);
			x-&gt;ch[0]=ret.second;
			update(x);
			return mp(ret.first,x);
		}
	}
	inline node*cut(node*&amp;x,int l,int r){
		pair&lt;node*,node*&gt;t1=split(x,l-1);
		pair&lt;node*,node*&gt;t2=split(t1.second,r-l+1);
		x=merge(t1.first,t2.second);
		return t2.first;
	}
	inline void link(node*&amp;x,node*y,int k){
		pair&lt;node*,node*&gt;t1=split(x,k);
		x=merge(merge(t1.first,y),t1.second);
	}
	inline node*build(int n){
		node*ret=0;
		lp(i,1,n)ret=merge(ret,new node(0));
		return ret;
	}
	inline int getmin(node*&amp;x,int l,int r){
		node*t=cut(x,l,r);
		down(t);
		int ret=t-&gt;mi;
		link(x,t,l-1);
		return ret;
	}
	inline int getmax(node*&amp;x,int l,int r){
		node*t=cut(x,l,r);
		down(t);
		int ret=t-&gt;mx;
		link(x,t,l-1);
		return ret;
	}
	inline ll getsum(node*&amp;x,int l,int r){
		node*t=cut(x,l,r);
		down(t);
		ll ret=t-&gt;sum;
		link(x,t,l-1);
		return ret;
	}
	inline void increase(node*&amp;x,int l,int r,int d){
		node*t=cut(x,l,r);
		down(t);
		t-&gt;del=d;
		link(x,t,l-1);
	}
	inline void invert(node*x){
		x-&gt;rev=1;
	}
}
namespace chain{
	vector&lt;int&gt;to[50010];
	int tmp[50010];
	splay::node*tree;
	int dep[50010],siz[50010],chd[50010],prt[50010];
	inline void dfs1(int u,int p){
		dep[u]=dep[p]+1;
		siz[u]=1;prt[u]=p;
		vp(i,to[u]){
			int v=to[u][i];
			if(v!=p){
				dfs1(v,u);
				siz[u]+=siz[v];
				if(siz[v]&gt;siz[chd[u]])chd[u]=v;
			}
		}
	}
	int top[50010],pos[50010],nw;
	inline void dfs2(int u,int a){
		pos[u]=++nw;top[u]=a;
		if(chd[u])dfs2(chd[u],a);
		vp(i,to[u]){
			int v=to[u][i];
			if(v!=prt[u]&amp;&amp;v!=chd[u])
				dfs2(v,v);
		}
	}
	inline void build(){
		int r;sf("%d%d%d",&amp;n,&amp;q,&amp;r);
		tree=splay::build(n);
		//pf("[%d]",tree-&gt;siz);
		lp(i,1,n-1){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			to[u].pb(v);
			to[v].pb(u);
		}
		dfs1(r,0);
		dfs2(r,r);
		//lp(i,1,n)pf("[%d,%d,%d,%d]\n",pos[i],siz[i],prt[i],top[i]);ps;
	}
	inline void increase(int u,int v,int d){
		if(dep[u]&gt;dep[v])swap(u,v);
		while(top[u]!=top[v])
			splay::increase(tree,pos[top[v]],pos[v],d),v=prt[top[v]];
		splay::increase(tree,pos[u],pos[v],d);
	}
	inline ll getsum(int u,int v){
		ll ret=0;
		while(top[u]!=top[v]){
			if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
			ret+=splay::getsum(tree,pos[top[v]],pos[v]);
			v=prt[top[v]];
		}
		if(dep[u]&gt;dep[v])swap(u,v);
		//pf("[%d,%d]\n",pos[u],pos[v]);
		ret+=splay::getsum(tree,pos[u],pos[v]);
		return ret;
	}
	inline int getmin(int u,int v){
		int ret=~0u&gt;&gt;1;
		while(top[u]!=top[v]){
			if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
			ret=min(ret,splay::getmin(tree,pos[top[v]],pos[v]));
			v=prt[top[v]];
		}
		if(dep[u]&gt;dep[v])swap(u,v);
		ret=min(ret,splay::getmin(tree,pos[u],pos[v]));
		return ret;
	}
	inline int getmax(int u,int v){
		int ret=-(~0u&gt;&gt;1);
		while(top[u]!=top[v]){
			if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
			ret=max(ret,splay::getmax(tree,pos[top[v]],pos[v]));
			v=prt[top[v]];
		}
		if(dep[u]&gt;dep[v])swap(u,v);
		ret=max(ret,splay::getmax(tree,pos[u],pos[v]));
		return ret;
	}
	inline void invert(int u,int v){
		vector&lt;pair&lt;int,int&gt; &gt;tmp;
		if(dep[u]&gt;dep[v])swap(u,v);
		while(top[u]!=top[v])
			tmp.pb(mp(pos[top[v]],pos[v])),v=prt[top[v]];
		tmp.pb(mp(pos[u],pos[v]));
		splay::node*tmp2=0;
		reverse(tmp.begin(),tmp.end());
		wp(i,tmp)splay::link(tmp2,splay::cut(tree,tmp[i].first,tmp[i].second),0);
		splay::invert(tmp2);
		vp(i,tmp)splay::link(tree,splay::cut(tmp2,1,tmp[i].second-tmp[i].first+1),tmp[i].first-1);
	}
}
int main(){
	chain::build();
	lp(i,1,q){
		static char op[11];
		sf("%s",op);
		if(op[0]=='I'&amp;&amp;op[2]=='c'){
			int u,v,d;sf("%d%d%d",&amp;u,&amp;v,&amp;d);
			chain::increase(u,v,d);
		}else if(op[0]=='S'){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			pf("%lld\n",chain::getsum(u,v));
		}else if(op[0]=='M'&amp;&amp;op[1]=='a'){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			pf("%d\n",chain::getmax(u,v));
		}else if(op[0]=='M'&amp;&amp;op[1]=='i'){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			pf("%d\n",chain::getmin(u,v));
		}else{
			int u,v;sf("%d%d",&amp;u,&amp;v);
			chain::invert(u,v);
		}
	}
	return 0;
}
/*
5 16 1
1 2
2 3
3 4
4 5
Increase 1 1 1
Increase 1 2 1
Increase 1 3 1
Increase 1 4 1
Increase 1 5 1
Sum 1 1
Sum 2 2
Sum 3 3
Sum 4 4
Sum 5 5
Invert 1 3
Sum 1 1
Sum 2 2
Sum 3 3
Sum 4 4
Sum 5 5
*/
/*
7 19 1
1 2
1 5
5 6
6 7
2 3
2 4
Increase 1 1 1
Increase 2 2 2
Increase 3 3 3
Increase 4 4 4
Increase 5 5 5
Increase 6 6 6
Increase 7 7 7
Invert 6 5
Invert 1 6
Invert 1 3
Sum 1 1
Sum 2 2
Sum 3 3
Sum 4 4
Sum 5 5
Sum 6 6
Sum 7 7
Sum 3 4
Sum 3 6
*/</pre><pre></pre><h2>Problem3159</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int n,q;
namespace splay{
    struct node{
        inline node(int v){
            val=sum=mx=mi=v;
            rev=del=0;
            ch[0]=ch[1]=pr=0;
            siz=1;
        }
        node*ch[2],*pr;
        int siz,val,mx,mi,rev,del;
        ll sum;
    };
    inline void down(node*x){
        if(x-&gt;rev){
            swap(x-&gt;ch[0],x-&gt;ch[1]);
            lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
            x-&gt;rev=0;
        }
        if(x-&gt;del){
            x-&gt;val+=x-&gt;del;
            x-&gt;sum+=ll(x-&gt;del)*x-&gt;siz;
            x-&gt;mx+=x-&gt;del;
            x-&gt;mi+=x-&gt;del;
            lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;del+=x-&gt;del;
            x-&gt;del=0;
        }
    }
    inline void update(node*x){
        lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;sum=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
        x-&gt;mx=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;mx=max(x-&gt;mx,x-&gt;ch[i]-&gt;mx);
        x-&gt;mi=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;mi=min(x-&gt;mi,x-&gt;ch[i]-&gt;mi);
    }
    inline int direct(node*x){return x!=x-&gt;pr-&gt;ch[0];}
    inline void setchd(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;update(x);}
    inline void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;int d1=direct(x),d2;if(z)d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);
        setchd(x,y,!d1);
        if(z)setchd(z,x,d2);else x-&gt;pr=0;
    }
    inline void splay(node*x,node*y){
        while(x-&gt;pr!=y){
            if(x-&gt;pr-&gt;pr==y)rotate(x);
            else if(direct(x)==direct(x-&gt;pr))rotate(x-&gt;pr),rotate(x);
            else rotate(x),rotate(x);
        }
    }
    inline node*select(node*x,node*y,int k){
        down(x);
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(k&lt;=t)return select(x-&gt;ch[0],y,k);
        else if(k==t+1){splay(x,y);return x;}
        else return select(x-&gt;ch[1],y,k-(t+1));
    }
    inline void increase(node*&amp;x,int l,int r,int d){
        x=select(x,0,l);select(x,x,r+2);
        x-&gt;ch[1]-&gt;ch[0]-&gt;del+=d;
        update(x-&gt;ch[1]);update(x);
    }
    inline void invert(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        x-&gt;ch[1]-&gt;ch[0]-&gt;rev^=1;
    }
    inline ll getsum(node*&amp;x,int l,int r){
        //pf("[%d,%d]\n",l,r);
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;sum;
    }
    inline int getmax(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;mx;
    }
    inline int getmin(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;mi;
    }
    inline node*cut(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        node*t=x-&gt;ch[1]-&gt;ch[0];x-&gt;ch[1]-&gt;ch[0]=0;
        update(x-&gt;ch[1]);update(x);t-&gt;pr=0;
        t=select(t,0,1);setchd(t,new node(0),0);
        t=select(t,0,t-&gt;siz);setchd(t,new node(0),1);
        return t;
    }
    inline void link(node*&amp;x,node*y,int p){
        y=select(y,0,2);delete y-&gt;ch[0];y-&gt;ch[0]=0;update(y);
        y=select(y,0,y-&gt;siz-1);delete y-&gt;ch[1];y-&gt;ch[1]=0;update(y);
        x=select(x,0,p+1);select(x,x,p+2);
        setchd(x-&gt;ch[1],y,0);
        update(x);
    }
    inline node*create(){node*t1=new node(0);setchd(t1,new node(0),1);return t1;}
    inline node*build(int*a,int l,int r){
        int m=(l+r)/2;
        node*ret=new node(a[m]);
        if(l!=m)setchd(ret,build(a,l,m-1),0);
        if(m!=r)setchd(ret,build(a,m+1,r),1);
        return ret;
    }
}
namespace chain{
    vector&lt;int&gt;to[50010];
    int tmp[50010];
    splay::node*tree;
    int dep[50010],siz[50010],chd[50010],prt[50010];
    inline void dfs1(int u,int p){
        dep[u]=dep[p]+1;
        siz[u]=1;prt[u]=p;
        vp(i,to[u]){
            int v=to[u][i];
            if(v!=p){
                dfs1(v,u);
                siz[u]+=siz[v];
                if(siz[v]&gt;siz[chd[u]])chd[u]=v;
            }
        }
    }
    int top[50010],pos[50010],nw;
    inline void dfs2(int u,int a){
        pos[u]=++nw;top[u]=a;
        if(chd[u])dfs2(chd[u],a);
        vp(i,to[u]){
            int v=to[u][i];
            if(v!=prt[u]&amp;&amp;v!=chd[u])
                dfs2(v,v);
        }
    }
    inline void build(){
        int r;sf("%d%d%d",&amp;n,&amp;q,&amp;r);
        tree=splay::build(tmp,0,n+1);
        //pf("[%d]",tree-&gt;siz);
        lp(i,1,n-1){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            to[u].pb(v);
            to[v].pb(u);
        }
        dfs1(r,0);
        dfs2(r,r);
        //lp(i,1,n)pf("[%d,%d,%d,%d]\n",pos[i],siz[i],prt[i],top[i]);ps;
    }
    inline void increase(int u,int v,int d){
        if(dep[u]&gt;dep[v])swap(u,v);
        while(top[u]!=top[v])
            splay::increase(tree,pos[top[v]],pos[v],d),v=prt[top[v]];
        splay::increase(tree,pos[u],pos[v],d);
    }
    inline ll getsum(int u,int v){
        ll ret=0;
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret+=splay::getsum(tree,pos[top[v]],pos[v]);
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        //pf("[%d,%d]\n",pos[u],pos[v]);
        ret+=splay::getsum(tree,pos[u],pos[v]);
        return ret;
    }
    inline int getmin(int u,int v){
        int ret=~0u&gt;&gt;1;
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret=min(ret,splay::getmin(tree,pos[top[v]],pos[v]));
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        ret=min(ret,splay::getmin(tree,pos[u],pos[v]));
        return ret;
    }
    inline int getmax(int u,int v){
        int ret=-(~0u&gt;&gt;1);
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret=max(ret,splay::getmax(tree,pos[top[v]],pos[v]));
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        ret=max(ret,splay::getmax(tree,pos[u],pos[v]));
        return ret;
    }
    inline void invert(int u,int v){
        vector&lt;pair&lt;int,int&gt; &gt;tmp;
        if(dep[u]&gt;dep[v])swap(u,v);
        while(top[u]!=top[v])
            tmp.pb(mp(pos[top[v]],pos[v])),v=prt[top[v]];
        tmp.pb(mp(pos[u],pos[v]));
        splay::node*tmp2=splay::create();
        reverse(tmp.begin(),tmp.end());
        wp(i,tmp)splay::link(tmp2,splay::cut(tree,tmp[i].first,tmp[i].second),0);
        splay::invert(tmp2,1,tmp2-&gt;siz-2);
        vp(i,tmp)splay::link(tree,splay::cut(tmp2,1,tmp[i].second-tmp[i].first+1),tmp[i].first-1);
    }
}
int main(){
    chain::build();
    lp(i,1,q){
        static char op[11];
        sf("%s",op);
        if(op[0]=='I'&amp;&amp;op[2]=='c'){
            int u,v,d;sf("%d%d%d",&amp;u,&amp;v,&amp;d);
            chain::increase(u,v,d);
        }else if(op[0]=='S'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%lld\n",chain::getsum(u,v));
        }else if(op[0]=='M'&amp;&amp;op[1]=='a'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",chain::getmax(u,v));
        }else if(op[0]=='M'&amp;&amp;op[1]=='i'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",chain::getmin(u,v));
        }else{
            int u,v;sf("%d%d",&amp;u,&amp;v);
            chain::invert(u,v);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3159</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
int n,q;
namespace splay{
    struct node{
        inline node(int v){
            val=sum=mx=mi=v;
            rev=del=0;
            ch[0]=ch[1]=pr=0;
            siz=1;
        }
        node*ch[2],*pr;
        int siz,val,mx,mi,rev,del;
        ll sum;
    };
    inline void down(node*x){
        if(x-&gt;rev){
            swap(x-&gt;ch[0],x-&gt;ch[1]);
            lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
            x-&gt;rev=0;
        }
        if(x-&gt;del){
            x-&gt;val+=x-&gt;del;
            x-&gt;sum+=ll(x-&gt;del)*x-&gt;siz;
            x-&gt;mx+=x-&gt;del;
            x-&gt;mi+=x-&gt;del;
            lp(i,0,1)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;del+=x-&gt;del;
            x-&gt;del=0;
        }
    }
    inline void update(node*x){
        lp(i,0,1)if(x-&gt;ch[i])down(x-&gt;ch[i]);
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;sum=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
        x-&gt;mx=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;mx=max(x-&gt;mx,x-&gt;ch[i]-&gt;mx);
        x-&gt;mi=x-&gt;val;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;mi=min(x-&gt;mi,x-&gt;ch[i]-&gt;mi);
    }
    inline int direct(node*x){return x!=x-&gt;pr-&gt;ch[0];}
    inline void setchd(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;update(x);}
    inline void rotate(node*x){
        node*y=x-&gt;pr,*z=y-&gt;pr;int d1=direct(x),d2;if(z)d2=direct(y);
        setchd(y,x-&gt;ch[!d1],d1);
        setchd(x,y,!d1);
        if(z)setchd(z,x,d2);else x-&gt;pr=0;
    }
    inline void splay(node*x,node*y){
        while(x-&gt;pr!=y)rotate(x);
    }
    inline node*select(node*x,node*y,int k){
        down(x);
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0;
        if(k&lt;=t)return select(x-&gt;ch[0],y,k);
        else if(k==t+1){splay(x,y);return x;}
        else return select(x-&gt;ch[1],y,k-(t+1));
    }
    inline void increase(node*&amp;x,int l,int r,int d){
        x=select(x,0,l);select(x,x,r+2);
        x-&gt;ch[1]-&gt;ch[0]-&gt;del+=d;
        update(x-&gt;ch[1]);update(x);
    }
    inline void invert(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        x-&gt;ch[1]-&gt;ch[0]-&gt;rev^=1;
    }
    inline ll getsum(node*&amp;x,int l,int r){
        //pf("[%d,%d]\n",l,r);
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;sum;
    }
    inline int getmax(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;mx;
    }
    inline int getmin(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        down(x-&gt;ch[1]-&gt;ch[0]);
        return x-&gt;ch[1]-&gt;ch[0]-&gt;mi;
    }
    inline node*cut(node*&amp;x,int l,int r){
        x=select(x,0,l);select(x,x,r+2);
        node*t=x-&gt;ch[1]-&gt;ch[0];x-&gt;ch[1]-&gt;ch[0]=0;
        update(x-&gt;ch[1]);update(x);t-&gt;pr=0;
        t=select(t,0,1);setchd(t,new node(0),0);
        t=select(t,0,t-&gt;siz);setchd(t,new node(0),1);
        return t;
    }
    inline void link(node*&amp;x,node*y,int p){
        y=select(y,0,2);delete y-&gt;ch[0];y-&gt;ch[0]=0;update(y);
        y=select(y,0,y-&gt;siz-1);delete y-&gt;ch[1];y-&gt;ch[1]=0;update(y);
        x=select(x,0,p+1);select(x,x,p+2);
        setchd(x-&gt;ch[1],y,0);
        update(x);
    }
    inline node*create(){node*t1=new node(0);setchd(t1,new node(0),1);return t1;}
    inline node*build(int*a,int l,int r){
        int m=(l+r)/2;
        node*ret=new node(a[m]);
        if(l!=m)setchd(ret,build(a,l,m-1),0);
        if(m!=r)setchd(ret,build(a,m+1,r),1);
        return ret;
    }
}
namespace chain{
    vector&lt;int&gt;to[50010];
    int tmp[50010];
    splay::node*tree;
    int dep[50010],siz[50010],chd[50010],prt[50010];
    inline void dfs1(int u,int p){
        dep[u]=dep[p]+1;
        siz[u]=1;prt[u]=p;
        vp(i,to[u]){
            int v=to[u][i];
            if(v!=p){
                dfs1(v,u);
                siz[u]+=siz[v];
                if(siz[v]&gt;siz[chd[u]])chd[u]=v;
            }
        }
    }
    int top[50010],pos[50010],nw;
    inline void dfs2(int u,int a){
        pos[u]=++nw;top[u]=a;
        if(chd[u])dfs2(chd[u],a);
        vp(i,to[u]){
            int v=to[u][i];
            if(v!=prt[u]&amp;&amp;v!=chd[u])
                dfs2(v,v);
        }
    }
    inline void build(){
        int r;sf("%d%d%d",&amp;n,&amp;q,&amp;r);
        tree=splay::build(tmp,0,n+1);
        //pf("[%d]",tree-&gt;siz);
        lp(i,1,n-1){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            to[u].pb(v);
            to[v].pb(u);
        }
        dfs1(r,0);
        dfs2(r,r);
        //lp(i,1,n)pf("[%d,%d,%d,%d]\n",pos[i],siz[i],prt[i],top[i]);ps;
    }
    inline void increase(int u,int v,int d){
        if(dep[u]&gt;dep[v])swap(u,v);
        while(top[u]!=top[v])
            splay::increase(tree,pos[top[v]],pos[v],d),v=prt[top[v]];
        splay::increase(tree,pos[u],pos[v],d);
    }
    inline ll getsum(int u,int v){
        ll ret=0;
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret+=splay::getsum(tree,pos[top[v]],pos[v]);
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        //pf("[%d,%d]\n",pos[u],pos[v]);
        ret+=splay::getsum(tree,pos[u],pos[v]);
        return ret;
    }
    inline int getmin(int u,int v){
        int ret=~0u&gt;&gt;1;
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret=min(ret,splay::getmin(tree,pos[top[v]],pos[v]));
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        ret=min(ret,splay::getmin(tree,pos[u],pos[v]));
        return ret;
    }
    inline int getmax(int u,int v){
        int ret=-(~0u&gt;&gt;1);
        while(top[u]!=top[v]){
            if(dep[top[u]]&gt;dep[top[v]])swap(u,v);
            ret=max(ret,splay::getmax(tree,pos[top[v]],pos[v]));
            v=prt[top[v]];
        }
        if(dep[u]&gt;dep[v])swap(u,v);
        ret=max(ret,splay::getmax(tree,pos[u],pos[v]));
        return ret;
    }
    inline void invert(int u,int v){
        vector&lt;pair&lt;int,int&gt; &gt;tmp;
        if(dep[u]&gt;dep[v])swap(u,v);
        while(top[u]!=top[v])
            tmp.pb(mp(pos[top[v]],pos[v])),v=prt[top[v]];
        tmp.pb(mp(pos[u],pos[v]));
        splay::node*tmp2=splay::create();
        reverse(tmp.begin(),tmp.end());
        wp(i,tmp)splay::link(tmp2,splay::cut(tree,tmp[i].first,tmp[i].second),0);
        splay::invert(tmp2,1,tmp2-&gt;siz-2);
        vp(i,tmp)splay::link(tree,splay::cut(tmp2,1,tmp[i].second-tmp[i].first+1),tmp[i].first-1);
    }
}
int main(){
    chain::build();
    lp(i,1,q){
        static char op[11];
        sf("%s",op);
        if(op[0]=='I'&amp;&amp;op[2]=='c'){
            int u,v,d;sf("%d%d%d",&amp;u,&amp;v,&amp;d);
            chain::increase(u,v,d);
        }else if(op[0]=='S'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%lld\n",chain::getsum(u,v));
        }else if(op[0]=='M'&amp;&amp;op[1]=='a'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",chain::getmax(u,v));
        }else if(op[0]=='M'&amp;&amp;op[1]=='i'){
            int u,v;sf("%d%d",&amp;u,&amp;v);
            pf("%d\n",chain::getmin(u,v));
        }else{
            int u,v;sf("%d%d",&amp;u,&amp;v);
            chain::invert(u,v);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3163</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,a[1010],b[1010],c[1010];
vector&lt;int&gt;ans[1010];
void merge(vector&lt;int&gt;&amp;dp,int i){
    int ci=c[i];
    vector&lt;int&gt;tc;
    for(int j=1;j&lt;=ci;j*=2)tc.pb(j),ci-=j;
    if(ci)tc.pb(ci);
    vp(j,tc){
        int ta=tc[j]*a[i],tb=tc[j]*b[i];
        rp(k,1000,ta)dp[k]=max(dp[k],dp[k-ta]+tb);
    }
}
void solve(int l,int r,vector&lt;int&gt;dp){
    if(l==r)ans[l]=dp;
    else{
        int m=(l+r)/2;
        vector&lt;int&gt;dpl=dp,dpr=dp;
        lp(i,l,m)merge(dpr,i);
        lp(i,m+1,r)merge(dpl,i);
        solve(l,m,dpl);
        solve(m+1,r,dpr);
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i]);
    solve(1,n,vector&lt;int&gt;(1010,0));
    int q;sf("%d",&amp;q);
    lp(i,1,q){
        int d,e;sf("%d%d",&amp;d,&amp;e);
        pf("%d\n",ans[d+1][e]);
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3164</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n;vector&lt;int&gt;ch[200010];
namespace task1{
    int dp[200010],iswin[200010];
    void dfs(int u,int d){
        if(ch[u].size()==0){
            dp[u]=1;
        }else{
            vp(i,ch[u])dfs(ch[u][i],d+1);
            if(d%2==1){
                dp[u]=~0u&gt;&gt;1;
                vp(i,ch[u])dp[u]=min(dp[u],dp[ch[u][i]]);
            }else{
                vp(i,ch[u])dp[u]+=dp[ch[u][i]];
            }
        }
    }
    void flag(int u,int d){
        if(ch[u].size()==0){
            iswin[u]=1;
        }else{
            if(d%2==1){
                vp(i,ch[u])if(dp[ch[u][i]]==dp[u])flag(ch[u][i],d+1);
            }else{
                vp(i,ch[u])flag(ch[u][i],d+1);
            }
        }
    }
    void solve(){
        dfs(1,1);
        flag(1,1);
        //lp(i,1,n)if(iswin[i])pf("%d ",i);pf("\n");
    }
}
namespace task2{
    int dp[200010],iswin[200010];
    void dfs(int u,int d){
        if(ch[u].size()==0){
            dp[u]=1;
        }else{
            vp(i,ch[u])dfs(ch[u][i],d+1);
            if(d%2==0){
                dp[u]=~0u&gt;&gt;1;
                vp(i,ch[u])dp[u]=min(dp[u],dp[ch[u][i]]);
            }else{
                vp(i,ch[u])dp[u]+=dp[ch[u][i]];
            }
        }
    }
    void flag(int u,int d){
        if(ch[u].size()==0){
            iswin[u]=1;
        }else{
            if(d%2==0){
                vp(i,ch[u])if(dp[ch[u][i]]==dp[u])flag(ch[u][i],d+1);
            }else{
                vp(i,ch[u])flag(ch[u][i],d+1);
            }
        }
    }
    void solve(){
        dfs(1,1);
        flag(1,1);
        //lp(i,1,n)if(iswin[i])pf("%d ",i);pf("\n");
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,2,n){
        int p;sf("%d",&amp;p);
        ch[p].pb(i);
    }
    task1::solve();
    task2::solve();
    vector&lt;int&gt;ans;int ans2=0;
    lp(i,1,n)if(task1::iswin[i]&amp;&amp;task2::iswin[i])ans.pb(i),ans2^=i;
    pf("%d %d %d\n",ans[0],(int)ans.size(),ans2);
    //ps;
    return 0;
}
/*
7
1
1
2
2
3
3
*/
</pre><pre></pre><h2>Problem3165</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
struct data{
	double y1,y2;int id;
}seg[40010*4];
double calcu(int x1,double y1,int x2,double y2,int x){
	double k=(y2-y1)/(x2-x1),b=y1-k*x1;
	return k*x+b;
}
void update(int x,int l,int r,double y1,double y2,int id){
	if(y1&gt;seg[x].y1-1e-8&amp;&amp;y2&gt;seg[x].y2-1e-8){
		swap(y1,seg[x].y1);
		swap(y2,seg[x].y2);
		swap(id,seg[x].id);
	}else if(y1&lt;seg[x].y1&amp;&amp;y2&lt;seg[x].y2){
		return;
	}else{
		if(y1&gt;seg[x].y1){
			swap(y1,seg[x].y1);
			swap(y2,seg[x].y2);
			swap(id,seg[x].id);
		}
		int m=(l+r)/2;
		if(calcu(l,y1,r,y2,m)&lt;calcu(l,seg[x].y1,r,seg[x].y2,m)){
			update(x*2+1,m+1,r,calcu(l,y1,r,y2,m+1),y2,id);
		}else{
			swap(y1,seg[x].y1);
			swap(y2,seg[x].y2);
			swap(id,seg[x].id);
			update(x*2,l,m,y1,calcu(l,y1,r,y2,m),id);
		}
	}
}
void insert(int x,int l,int r,int x1,double y1,int x2,double y2,int id){
	if(x1==l&amp;&amp;x2==r)update(x,l,r,y1,y2,id);
	else{
		int m=(l+r)/2;
		if(x2&lt;=m)insert(x*2,l,m,x1,y1,x2,y2,id);
		else if(x1&gt;m)insert(x*2+1,m+1,r,x1,y1,x2,y2,id);
		else{
			insert(x*2,l,m,x1,y1,m,calcu(x1,y1,x2,y2,m),id);
			insert(x*2+1,m+1,r,m+1,calcu(x1,y1,x2,y2,m+1),x2,y2,id);
		}
	}
}
pair&lt;int,double&gt;query(int x,int l,int r,int t){
	if(l==r)return mp(seg[x].id,seg[x].y1);
	else{
		pair&lt;int,double&gt;ret(seg[x].id,calcu(l,seg[x].y1,r,seg[x].y2,t)),ret2;
		int m=(l+r)/2;
		if(t&lt;=m)ret2=query(x*2,l,m,t);
		else ret2=query(x*2+1,m+1,r,t);
		if(ret.second&gt;ret2.second+1e-8)return ret;
		else if(ret2.second&gt;ret.second+1e-8)return ret2;
		else if(ret.first&lt;ret2.first)return ret;
		else return ret2;
	}
}
int main(){
	int n,lst=0,nw=0;sf("%d",&amp;n);
	lp(i,1,n){
		int t;sf("%d",&amp;t);
		if(t==0){
			int x;sf("%d",&amp;x);
			x=(x+lst-1)%39989+1;
			pf("%d\n",lst=query(1,1,40000,x).first);
		}else{
			int x1,y1,x2,y2;
			sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			x1=(x1+lst-1)%39989+1;
			y1=(y1+lst-1)%1000000000+1;
			x2=(x2+lst-1)%39989+1;
			y2=(y2+lst-1)%1000000000+1;
			if(x1&gt;x2)swap(x1,x2),swap(y1,y2);
			if(x1==x2)y1=y2=max(y1,y2);
			insert(1,1,40000,x1,y1,x2,y2,++nw);
		}
	}
	//ps;
	return 0;
}</pre><pre></pre><h2>Problem3166</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;stack&gt;
int ans=0,n,a[50010];
void solve(){
	stack&lt;int&gt;stk;
	lp(i,1,n){
		while(!stk.empty()&amp;&amp;a[stk.top()]&lt;a[i]){
			int l=stk.top(),r=i;
			int k=a[stk.top()];
			lp(j,l+1,r)ans=max(ans,(k^a[j]));
			for(int j=r+1;j&lt;=n&amp;&amp;a[j]&lt;k;++j)
				ans=max(ans,(k^a[j]));
			for(int j=l-1;j&amp;&amp;a[j]&lt;k;--j)
				ans=max(ans,(k^a[j]));
			stk.pop();
		}
		stk.push(i);
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d",&amp;a[i]);
	solve();
	reverse(a+1,a+n+1);
	solve();
	pf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3168</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace input{
	int n,a[310][310],b[310][310];
	void run(){
		sf("%d",&amp;n);
		lp(i,1,n)lp(j,1,n)sf("%d",&amp;a[i][j]);
		lp(i,1,n)lp(j,1,n)sf("%d",&amp;b[i][j]);
	}
}
namespace gauss{
	int n;double a[310][610];
	double eps=1e-6;
	double myabs(double x){
		return x&gt;0?x:-x;
	}
	void prtmat(){
		lp(i,1,n){
			lp(j,1,2*n)pf("%lf%c",a[i][j],j==2*n?'\n':' ');
		}
		pf("\n");
	}
	bool run(){
		//prtmat();
		lp(i,1,n){
			int j;for(j=i;j&lt;=n;++j)if(myabs(a[j][i])&gt;eps)break;
			if(j==n+1)return false;
			lp(k,1,2*n)swap(a[i][k],a[j][k]);
			double t=a[i][i];
			lp(k,1,2*n)a[i][k]/=t;
			lp(k,1,n)if(k!=i){
				t=a[k][i];
				lp(l,1,2*n)a[k][l]-=t*a[i][l];
			}
			//prtmat();
		}
		return true;
	}
}
namespace hungary{
	int n;vector&lt;int&gt;to[310];int lk[310],vis[310],ans[310];
	void add(int u,int v){
		to[u].pb(v);
		//pf("[%d,%d]\n",u,v);
	}
	int dfs(int u,int lim=0){
		vp(i,to[u]){
			int v=to[u][i];
			if(!vis[v]){
				vis[v]=1;
				if(!lk[v]||(lk[v]&gt;lim&amp;&amp;dfs(lk[v],lim))){
					lk[v]=u;ans[u]=v;
					return 1;
				}
			}
		}
		return 0;
	}
	bool run(){
		lp(i,1,n)sort(to[i].begin(),to[i].end());
		//lp(i,1,n)vp(j,to[i])pf("[%d,%d]\n",i,to[i][j]);
		lp(i,1,n){
			lp(j,1,n)vis[j]=0;
			if(!dfs(i))return false;
		}
		lp(u,1,n){
			//lp(j,1,n)pf("[%d]",ans[j]);pf("\n");
			vp(i,to[u]){
				int v=to[u][i];
				if(lk[v]==u)break;
				if(lk[v]&lt;u)continue;
				int w=ans[u];ans[u]=0;
				lk[w]=0;
				lp(j,1,n)vis[j]=0;
				vis[v]=1;
				if(dfs(lk[v],u)){
					ans[u]=v;
					lk[v]=u;
					break;
				}
				ans[u]=w;
				lk[w]=u;
			}
			//lp(j,1,n)pf("[%d]",ans[j]);pf("\n\n");
		}
		return true;
	}
}
int main(){
	input::run();
	gauss::n=input::n;
	lp(i,1,input::n){
		lp(j,1,input::n)gauss::a[i][j]=input::a[j][i];
		gauss::a[i][input::n+i]=1;
	}
	if(!gauss::run())pf("NIE\n");
	else{
		hungary::n=input::n;
		lp(i,1,input::n){
			lp(j,1,input::n){
				double t=0;
				lp(k,input::n+1,2*input::n)
					t+=input::b[i][k-input::n]*gauss::a[j][k];
				if(gauss::myabs(t)&gt;gauss::eps)hungary::add(j,i);
			}
		}
		if(!hungary::run())pf("NIE\n");
		else{
			pf("TAK\n");
			lp(i,1,input::n)pf("%d\n",hungary::ans[i]);
		}
	}
	return 0;
}
/*
3
1 0 0
0 1 0
0 0 1
2 3 0
0 7 8
0 0 9
*/</pre><pre></pre><h2>Problem3168</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
namespace input{
    int n,a[310][310],b[310][310];
    void run(){
        sf("%d",&amp;n);
        lp(i,1,n)lp(j,1,n)sf("%d",&amp;a[i][j]);
        lp(i,1,n)lp(j,1,n)sf("%d",&amp;b[i][j]);
    }
}
namespace gauss{
    int n;double a[310][610];
    double eps=1e-6;
    double myabs(double x){
        return x&gt;0?x:-x;
    }
    void prtmat(){
        lp(i,1,n){
            lp(j,1,2*n)pf("%lf%c",a[i][j],j==2*n?'\n':' ');
        }
        pf("\n");
    }
    bool run(){
        //prtmat();
        lp(i,1,n){
            int j;for(j=i;j&lt;=n;++j)if(myabs(a[j][i])&gt;eps)break;
            if(j==n+1)return false;
            lp(k,1,2*n)swap(a[i][k],a[j][k]);
            double t=a[i][i];
            lp(k,1,2*n)a[i][k]/=t;
            lp(k,1,n)if(k!=i){
                t=a[k][i];
                lp(l,1,2*n)a[k][l]-=t*a[i][l];
            }
            //prtmat();
        }
        return true;
    }
}
namespace hungary{
    int n;vector&lt;int&gt;to[310];int lk[310],vis[310],ans[310];
    void add(int u,int v){
        to[u].pb(v);
        //pf("[%d,%d]\n",u,v);
    }
    int dfs(int u,int lim=0){
        vp(i,to[u]){
            int v=to[u][i];
            if(!vis[v]){
                vis[v]=1;
                if(!lk[v]||(lk[v]&gt;lim&amp;&amp;dfs(lk[v],lim))){
                    lk[v]=u;ans[u]=v;
                    return 1;
                }
            }
        }
        return 0;
    }
    bool run(){
        //lp(i,1,n)vp(j,to[i])pf("[%d,%d]\n",i,to[i][j]);
        lp(i,1,n){
            lp(j,1,n)vis[j]=0;
            if(!dfs(i))return false;
        }
        lp(i,1,n)sort(to[i].begin(),to[i].end());
        lp(u,1,n){
            //lp(j,1,n)pf("[%d]",ans[j]);pf("\n");
            vp(i,to[u]){
                int v=to[u][i];
                if(lk[v]==u)break;
                if(lk[v]&lt;u)continue;
                int w=ans[u];ans[u]=0;
                lk[w]=0;
                lp(j,1,n)vis[j]=0;
                vis[v]=1;
                if(dfs(lk[v],u)){
                    ans[u]=v;
                    lk[v]=u;
                    break;
                }
                ans[u]=w;
                lk[w]=u;
            }
            //lp(j,1,n)pf("[%d]",ans[j]);pf("\n\n");
        }
        return true;
    }
}
int main(){
    input::run();
    gauss::n=input::n;
    lp(i,1,input::n){
        lp(j,1,input::n)gauss::a[i][j]=input::a[j][i];
        gauss::a[i][input::n+i]=1;
    }
    if(!gauss::run())pf("NIE\n");
    else{
        hungary::n=input::n;
        lp(i,1,input::n){
            lp(j,1,input::n){
                double t=0;
                lp(k,input::n+1,2*input::n)
                    t+=input::b[i][k-input::n]*gauss::a[j][k];
                if(gauss::myabs(t)&gt;gauss::eps)hungary::add(j,i);
            }
        }
        if(!hungary::run())pf("NIE\n");
        else{
            pf("TAK\n");
            lp(i,1,input::n)pf("%d\n",hungary::ans[i]);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3170</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
struct point{int x,y;long long ans;};
bool cmp1(point a,point b){
    return a.x&lt;b.x; 
}
bool cmp2(point a,point b){
    return a.y&lt;b.y; 
}
point pt[100010];int n;
typedef long long ll;
ll lsum[100010],rsum[100010];
ll ans[100010];
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d%d",&amp;pt[i].x,&amp;pt[i].y);
    lp(i,1,n){
        int x=pt[i].x,y=pt[i].y;
        pt[i].x=x-y;
        pt[i].y=x+y;
        pt[i].ans=0;
    }
    sort(pt+1,pt+n+1,cmp1);
    lp(i,1,n)lsum[i]=lsum[i-1]+pt[i].x;
    rp(i,n,1)rsum[i]=rsum[i+1]+pt[i].x;
    lp(i,1,n)pt[i].ans+=ll(pt[i].x)*(i-1)-lsum[i-1]+rsum[i+1]-ll(pt[i].x)*(n-i);
    sort(pt+1,pt+n+1,cmp2);
    lp(i,1,n)lsum[i]=lsum[i-1]+pt[i].y;
    rp(i,n,1)rsum[i]=rsum[i+1]+pt[i].y;
    lp(i,1,n)pt[i].ans+=ll(pt[i].y)*(i-1)-lsum[i-1]+rsum[i+1]-ll(pt[i].y)*(n-i);
    ll as=-1;
    lp(i,1,n)if(as==-1||as&gt;pt[i].ans)as=pt[i].ans;
    pf("%lld\n",as/2);
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3171</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace mcmf{
    struct edge{int v,c,w;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1010];int vcnt;
    int dis[1010],in[1010];
    void add(int u,int v,int c,int w){
        edge t;t.v=v;t.c=c;t.w=w;to[u].push_back(eg.size());
        eg.push_back(t);
    }
    bool spfa(){
        lp(i,1,vcnt)dis[i]=~0u&gt;&gt;1,in[i]=0;dis[1]=0;in[1]=1;
        queue&lt;int&gt;qu;qu.push(1);
        while(!qu.empty()){
            int u=qu.front();qu.pop();in[u]=0;
            lp(i,0,int(to[u].size()-1)){
                edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
                if(e.c&amp;&amp;dis[u]+e.w&lt;dis[e.v]){
                    dis[e.v]=dis[u]+e.w;
                    if(!in[e.v]){
                        in[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return dis[vcnt]!=~0u&gt;&gt;1;
    }
    int cst;
    int dfs(int u,int f){
        if(u==vcnt)return f;
        in[u]=1;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[u]+e.w==dis[e.v]&amp;&amp;!in[e.v]){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t,cst+=t*e.w;
                if(!g)return f;
            }
        }
        return f-g;
    }
    int solve(){
        while(spfa()){
            lp(i,1,vcnt)in[i]=0;
            dfs(1,~0u&gt;&gt;1); 
        }
        return cst;
    }
}
int main(){
    static int r,c;static char mp[21][21];
    sf("%d%d",&amp;r,&amp;c);
    static int id[21][21][2];
    int st=++mcmf::vcnt;
    lp(i,1,r)lp(j,1,c)id[i][j][0]=++mcmf::vcnt,id[i][j][1]=++mcmf::vcnt;
    int et=++mcmf::vcnt;
    lp(i,1,r)sf("%s",mp[i]+1);
    lp(i,1,r)lp(j,1,c){
        mcmf::add(st,id[i][j][0],1,0);
        mcmf::add(id[i][j][0],st,0,0);
        mcmf::add(et,id[i][j][1],0,0);
        mcmf::add(id[i][j][1],et,1,0);
        if(i!=1){
            mcmf::add(id[i][j][0],id[i-1][j][1],1,int(mp[i][j]!='U'));
            mcmf::add(id[i-1][j][1],id[i][j][0],0,-int(mp[i][j]!='U'));
        }else{
            mcmf::add(id[i][j][0],id[r][j][1],1,int(mp[i][j]!='U'));
            mcmf::add(id[r][j][1],id[i][j][0],0,-int(mp[i][j]!='U'));
        }
        if(i!=r){
            mcmf::add(id[i][j][0],id[i+1][j][1],1,int(mp[i][j]!='D'));
            mcmf::add(id[i+1][j][1],id[i][j][0],0,-int(mp[i][j]!='D'));
        }else{
            mcmf::add(id[i][j][0],id[1][j][1],1,int(mp[i][j]!='D'));
            mcmf::add(id[1][j][1],id[i][j][0],0,-int(mp[i][j]!='D'));
        }
        if(j!=1){
            mcmf::add(id[i][j][0],id[i][j-1][1],1,int(mp[i][j]!='L'));
            mcmf::add(id[i][j-1][1],id[i][j][0],0,-int(mp[i][j]!='L'));
        }else{
            mcmf::add(id[i][j][0],id[i][c][1],1,int(mp[i][j]!='L'));
            mcmf::add(id[i][c][1],id[i][j][0],0,-int(mp[i][j]!='L'));
        }
        if(j!=c){
            mcmf::add(id[i][j][0],id[i][j+1][1],1,int(mp[i][j]!='R'));
            mcmf::add(id[i][j+1][1],id[i][j][0],0,-int(mp[i][j]!='R'));
        }else{
            mcmf::add(id[i][j][0],id[i][1][1],1,int(mp[i][j]!='R'));
            mcmf::add(id[i][1][1],id[i][j][0],0,-int(mp[i][j]!='R'));
        }
    }
    pf("%d\n",mcmf::solve());
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
vector&lt;char&gt;gob;
vector&lt;int&gt;usa;
namespace acm{
    int ch[1000010][26],fa[1000010],cnt[1000010],nw=1;
    char tmp[1000010];
    vector&lt;int&gt;vfs;
    void ins(){
        sf("%s",tmp+1);
        int len=strlen(tmp+1);int u=1;
        for(int i=1;i&lt;=len;++i){
            gob.push_back(tmp[i]-'a');
            if(!ch[u][tmp[i]-'a'])
                ch[u][tmp[i]-'a']=++nw;
            u=ch[u][tmp[i]-'a'];
        }
        gob.push_back(60);
        usa.push_back(u);
    }
    void bud(){
        queue&lt;int&gt;qu;
        lp(i,0,25)if(!ch[1][i])ch[1][i]=1;
        else fa[ch[1][i]]=1,qu.push(ch[1][i]);
        while(!qu.empty()){
            int u=qu.front();qu.pop();vfs.push_back(u);
            lp(i,0,25)if(!ch[u][i])ch[u][i]=ch[fa[u]][i];
            else{
                fa[ch[u][i]]=ch[fa[u]][i];
                qu.push(ch[u][i]);
            }
        }
    }
    void run(){
        for(int i=0,u=1;i&lt;gob.size();++i){
            if(gob[i]==60){u=1;continue;}
            u=ch[u][gob[i]];
            ++cnt[u];
        }
        //lp(i,1,nw)pf("[%d]",cnt[i]);pf("\n");
        rp(i,int(vfs.size()-1),0){
            int u=vfs[i];
            cnt[fa[u]]+=cnt[u];
        }
        //lp(i,1,nw)pf("[%d]",cnt[i]);
        lp(i,0,int(usa.size()-1))
            pf("%d\n",cnt[usa[i]]);
    }
}
int main(){
    int n;sf("%d",&amp;n);
    lp(i,1,n)acm::ins();
    acm::bud();
    acm::run();
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem3173</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace seg{
    int cnt[4*100010];
    void build(int x,int l,int r){
        if(l==r)cnt[x]=1;
        else{
            int m=(l+r)/2;
            build(x*2,l,m);
            build(x*2+1,m+1,r);
            cnt[x]=cnt[x*2]+cnt[x*2+1];
        }
    }
    int query(int x,int l,int r,int k){
        if(l==r){cnt[x]=0;return l;}
        else{
            int m=(l+r)/2,u;
            if(cnt[x*2]&gt;=k)u=query(x*2,l,m,k);
            else u=query(x*2+1,m+1,r,k-cnt[x*2]);
            --cnt[x];
            return u;
        }
    }
}
int n,a[100010],f[100010];
int db[100010];
void add(int u,int v){
    for(;u&lt;=n;u+=u&amp;-u)db[u]=max(db[u],v);
} 
int ask(int u){
    int r=0;
    for(;u;u-=u&amp;-u)r=max(r,db[u]);
    return r;
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i]),++a[i];
    seg::build(1,1,n);
    rp(i,n,1)a[i]=seg::query(1,1,n,a[i]);
    lp(i,1,n)add(a[i],(f[i]=ask(a[i])+1));
    lp(i,2,n)f[i]=max(f[i],f[i-1]);
    lp(i,1,n)pf("%d\n",f[i]);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3174</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
using namespace std;
typedef long long ll;
pair&lt;int,int&gt;peo[2010];int n,h;
bool cmp(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){
	return a.first+a.second&lt;b.first+b.second;
}
int f[2010][2010],s[2010];
int main(){
	sf("%d",&amp;n);
	lp(i,1,n)sf("%d%d",&amp;peo[i].first,&amp;peo[i].second);
	sf("%d",&amp;h);
	sort(peo+1,peo+n+1,cmp);
	rp(i,n,1)s[i]=s[i+1]+peo[i].first;
	lp(i,1,n){
		lp(j,0,i){
			f[i][j]=-1;
			if(j!=i&amp;&amp;f[i-1][j]!=-1)
				f[i][j]=max(f[i][j],f[i-1][j]+peo[i].first);
			if(j!=0&amp;&amp;f[i-1][j-1]!=-1&amp;&amp;s[i]+f[i-1][j-1]+peo[i].second&gt;=h)
				f[i][j]=max(f[i][j],f[i-1][j-1]);
			//pf("(%d,%d,%d)\n",i,j,f[i][j]);
		}
	}
	int ans=0;lp(i,1,n)if(f[n][i]!=-1)ans=i;
	pf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3175</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
namespace isap{
    struct edge{int v,c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[40010];
    int dis[40010],gap[40010],vcnt;
    void add(int u,int v,int c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    int dfs(int u,int f){
        if(u==vcnt)return f;
        int g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                int t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    } 
    int run(){
        int r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        return r;
    }
}
int n,nw,cd[210][210],st,et;
char mp[210][210];
int dir[8][2]={{-1,-2},{-2,-1},{1,-2},{2,-1},{-1,2},{-2,1},{1,2},{2,1}};
bool ava(int i,int j){
    return i&gt;0&amp;&amp;i&lt;=n&amp;&amp;j&gt;0&amp;&amp;j&lt;=n&amp;&amp;mp[i][j]=='0';
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%s",mp[i]+1);
    st=++nw;lp(i,1,n)lp(j,1,n)if(mp[i][j]=='0')cd[i][j]=++nw;
    et=++nw;
    isap::vcnt=nw;
    lp(i,1,n)lp(j,1,n){
        if(mp[i][j]=='0'){
            if((i+j)&amp;1){
                isap::add(st,cd[i][j],1);
                isap::add(cd[i][j],st,0);
                lp(k,0,7){
                    int tx=i+dir[k][0],ty=j+dir[k][1];
                    if(ava(tx,ty)){
                        isap::add(cd[i][j],cd[tx][ty],~0u&gt;&gt;1);
                        isap::add(cd[tx][ty],cd[i][j],0);
                    }
                }
            }else{
                isap::add(cd[i][j],et,1);
                isap::add(et,cd[i][j],0);
            }
        }
    }
    pf("%d\n",nw-isap::run()-2);
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem3186</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int main(){
    int n,m;
    vector&lt;pair&lt;int,int&gt; &gt;a;
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n){
        int u,v;
        sf("%d%d",&amp;u,&amp;v);
        if(u&gt;v)a.push_back(make_pair(v,u));
    }
    sort(a.begin(),a.end());
    //lp(i,0,int(a.size()-1))
        //pf("[%d,%d]\n",a[i].first,a[i].second); 
    ll ans=m;
    lp(i,0,int(a.size()-1)){
        int lt=a[i].first,rt=a[i].second,j=i;
        while(j+1&lt;a.size()&amp;&amp;a[j+1].first&lt;=rt)
            rt=max(rt,a[j+1].second),++j;
        ans+=(rt-lt)*2; 
        i=j;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3187</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m;char mp[15][15];
vector&lt;pair&lt;ll,int&gt; &gt;hs[2][4007];
void add(int t,ll s,int d){
    vector&lt;pair&lt;ll,int&gt; &gt;&amp;h=hs[t][s%4007];
    lp(i,0,int(h.size()-1))
        if(h[i].first==s){
            h[i].second=(h[i].second+d)%10007;
            return;
        }
    h.push_back(make_pair(s,d)); 
}
void clear(int d){
    lp(i,0,4006)hs[d][i].clear(); 
}
int code[15];
void dec(ll s){
    lp(i,1,m+1)code[i]=(s&amp;7),s&gt;&gt;=3;
}
ll enc(){
    static int id[15];
    lp(i,1,m+1)id[code[i]]=-1;
    id[0]=0;int nw=0;
    lp(i,1,m+1)if(id[code[i]]==-1)
        id[code[i]]=++nw;
    ll r=0;
    rp(i,m+1,1){
        r&lt;&lt;=3;
        r+=id[code[i]];
    }
    return r;
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%s",mp[i]+1);
    int cur=0,pre=1;
    add(cur,0,1);
    lp(i,1,n)lp(j,1,m){
        swap(cur,pre);
        clear(cur);
        lp(k,0,4006){
            lp(l,0,int(hs[pre][k].size()-1)){
                ll s=hs[pre][k][l].first;int d=hs[pre][k][l].second;
                dec(s);int left=code[j],up=code[j+1];
                if(i==1&amp;&amp;j==1){
                    if(j!=m&amp;&amp;mp[i][j+1]!='#'){
                        code[1]=0;code[2]=1;
                        add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                    }
                    if(i!=n&amp;&amp;mp[i+1][j]!='#'){
                        code[1]=1;code[2]=0;
                        add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                    }
                }else if(i==n&amp;&amp;j==m){
                    if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                        code[j]=code[j+1]=0;
                        add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                    }
                }else if(mp[i][j]=='#'){
                    code[j]=code[j+1]=0;
                    add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                }else{
                    if(left&amp;&amp;up){
                        if(left!=up){
                            code[j]=code[j+1]=0;
                            lp(u,1,m+1)if(code[u]==left)code[u]=up;
                            add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                        }
                    }else if((left&amp;&amp;!up)||(up&amp;&amp;!left)){
                        int t=left?left:up;
                        if(i!=n&amp;&amp;mp[i+1][j]!='#'){
                            code[j]=t;code[j+1]=0;
                            add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                        }
                        if(j!=m&amp;&amp;mp[i][j+1]!='#'){
                            code[j]=0;code[j+1]=t;
                            add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                        }
                    }else{
                        code[j]=code[j+1]=0;
                        add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                        if(i!=n&amp;&amp;mp[i+1][j]!='#'&amp;&amp;j!=m&amp;&amp;mp[i][j+1]!='#'){
                            code[j]=code[j+1]=13;
                            add(cur,j==m?(enc()&lt;&lt;3):enc(),d);
                        }
                    }
                }
            }
        }
    }
    int ans=0;
    lp(i,0,4006)
        lp(j,0,int(hs[cur][i].size()-1))
            ans=(ans+hs[cur][i][j].second)%10007;
    pf("%d\n",ans);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3188</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
struct splay{
    struct node{
        node(ll v){
            ch[0]=ch[1]=pr=0;
            sz=1;sum=val=v;del1=del2=0;
            sam=~0u&gt;&gt;1;
        }
        node*ch[2],*pr;
        int sz;
        ll sum,del1,del2,val,sam;
    }*rt;
    void down(node*x){
        if(x-&gt;sam!=~0u&gt;&gt;1){
            lp(i,0,1)if(x-&gt;ch[i]){
                x-&gt;ch[i]-&gt;sam=x-&gt;sam;
                x-&gt;ch[i]-&gt;del1=x-&gt;ch[i]-&gt;del2=0;
            }
            x-&gt;val=x-&gt;sam;
            x-&gt;sum=x-&gt;sz*x-&gt;sam; 
            x-&gt;sam=~0u&gt;&gt;1;
        }
        if(x-&gt;del1||x-&gt;del2){
            int t=0;
            if(x-&gt;ch[0]){
                x-&gt;ch[0]-&gt;del1+=x-&gt;del1;
                x-&gt;ch[0]-&gt;del2+=x-&gt;del2;
                t=x-&gt;ch[0]-&gt;sz;
            }
            x-&gt;sum+=x-&gt;sz*x-&gt;del1+ll(x-&gt;sz)*(x-&gt;sz-1)/2*x-&gt;del2;
            x-&gt;val+=x-&gt;del1+x-&gt;del2*t;
            if(x-&gt;ch[1]){
                x-&gt;ch[1]-&gt;del1+=x-&gt;del1+x-&gt;del2*(t+1);
                x-&gt;ch[1]-&gt;del2+=x-&gt;del2;
            }
            x-&gt;del1=x-&gt;del2=0;
        } 
    }
    void upda(node*x){
        x-&gt;sum=x-&gt;val;
        x-&gt;sz=1;
        lp(i,0,1)if(x-&gt;ch[i]){
            down(x-&gt;ch[i]);
            x-&gt;sum+=x-&gt;ch[i]-&gt;sum;
            x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
        }
    }
    int tp(node*x){return x==x-&gt;pr-&gt;ch[1];}
    void st(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;upda(x);}
    void rot(node*x){
        node*y=x-&gt;pr,*z=x-&gt;pr-&gt;pr;
        int d1=tp(x),d2=z?tp(y):-1;
        st(y,x-&gt;ch[!d1],d1);
        st(x,y,!d1);
        if(d2!=-1)st(z,x,d2);
        else x-&gt;pr=0,rt=x;
    }
    node*kth(node*x,int k){
        down(x);
        int t=x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0;
        if(t+1==k)return x;
        else if(t+1&lt;k)return kth(x-&gt;ch[1],k-(t+1));
        else return kth(x-&gt;ch[0],k); 
    }
    void spl(node*x,node*p){
        while(x-&gt;pr!=p){
            if(x-&gt;pr-&gt;pr==p)rot(x);
            else if(tp(x)==tp(x-&gt;pr))rot(x-&gt;pr),rot(x);
            else rot(x),rot(x);
        }
    }
    void insert(int p,int v){
        spl(kth(rt,p),0);
        spl(kth(rt,p+1),rt);
        st(rt-&gt;ch[1],new node(v),0);
        upda(rt);
    }
    ll asksum(int p,int q){
        spl(kth(rt,p),0);
        spl(kth(rt,q+2),rt);
        down(rt-&gt;ch[1]-&gt;ch[0]);
        return rt-&gt;ch[1]-&gt;ch[0]-&gt;sum;
    }
    ll makesame(int p,int q,int c){
        spl(kth(rt,p),0);
        spl(kth(rt,q+2),rt);
        rt-&gt;ch[1]-&gt;ch[0]-&gt;sam=c;
        rt-&gt;ch[1]-&gt;ch[0]-&gt;del1=rt-&gt;ch[1]-&gt;ch[0]-&gt;del2=0;
        upda(rt-&gt;ch[1]);
        upda(rt);
    }
    ll addnum(int p,int q,int c){
        spl(kth(rt,p),0);
        spl(kth(rt,q+2),rt);
        rt-&gt;ch[1]-&gt;ch[0]-&gt;del1+=c;
        rt-&gt;ch[1]-&gt;ch[0]-&gt;del2+=c;
        upda(rt-&gt;ch[1]);
        upda(rt);
    }
}tree;
int main(){
    tree.rt=new splay::node(0);
    tree.st(tree.rt,new splay::node(0),0);
    int n,q;sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        tree.insert(i,t);
    }
    lp(i,1,q){
        int t;sf("%d",&amp;t);
        if(t==1){
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            tree.makesame(a,b,c); 
        }else if(t==2){
            int a,b,c;sf("%d%d%d",&amp;a,&amp;b,&amp;c);
            tree.addnum(a,b,c); 
        }else if(t==3){
            int a,b;sf("%d%d",&amp;a,&amp;b);
            tree.insert(a,b);
        }else{
            int a,b;sf("%d%d",&amp;a,&amp;b);
            pf("%lld\n",tree.asksum(a,b));
        }
    }
    //ps;
    return 0;
}

</pre><pre></pre><h2>Problem3189</h2><pre>#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 1100;
const int MAXM = 100100;

struct rect {
  int id, c, x1, y1, x2, y2;
  rect() {}
  rect(int _id, int _c, int _x1, int _y1, int _x2, int _y2) {
    id = _id, c = _c, x1 = _x1, y1 = _y1, x2 = _x2, y2 = _y2;
  }
};

struct cmp {
  bool operator () (const rect &amp;A, const rect &amp;B) {
    return A.id &gt; B.id;
  }
};

int N, K, M, S;
enum {SAVE, LOAD, PAINT};
int command[MAXM];

int save[MAXM];
int load[MAXM];
rect paint[MAXM];

vector&lt; rect &gt; beg[MAXN];
vector&lt; rect &gt; end[MAXN];

int odd = 1;
inline int f(int x) { return (x &amp; 1) ? odd : !odd; }

struct node {
  set&lt; rect, cmp &gt; R[2];
  node() {}
};

struct tree {
  node A[2 * MAXN];
  tree() {}

  rect r;
  int a, b;

  void doit(int x, int lo, int hi, int add) {
    if (lo &gt; b || hi &lt; a) return;
    
    if (a &lt;= lo &amp;&amp; hi &lt;= b) {
      if (add) {
        A[x].R[f(a)].insert(r);
      } else
        A[x].R[f(a ^ (r.x2 - r.x1 + 1))].erase(r);
      return;
    }
    
    doit(2 * x, lo, (lo + hi) / 2, add);
    doit(2 * x + 1, (lo + hi) / 2 + 1, hi, add);
  }

  void insert(rect _r) {
    r = _r; a = r.y1; b = r.y2;
    doit(1, 0, 1 &lt;&lt; 10, 1);
  }

  void remove(rect _r) {
    r = _r; a = r.y1; b = r.y2;
    doit(1, 0, 1 &lt;&lt; 10, 0);
  }

  int query(int x, int lo, int hi) {
    int ret = -1;
    if (lo &gt; a || hi &lt; a) return ret;

    if (!A[x].R[f(a)].empty())
      ret = max(ret, A[x].R[f(a)].begin()-&gt;id);
    
    if (lo == hi) return ret;
    ret = max(ret, query(2 * x, lo, (lo + hi) / 2));
    ret = max(ret, query(2 * x + 1, (lo + hi) / 2 + 1, hi));
    return ret;
  }

  int query(int x) {
    a = x;
    int ret = query(1, 0, 1 &lt;&lt; 10);
    return (ret == -1) ? 1 : paint[ret].c;
  }
} T;

int main(void) 
{
  scanf("%d %d %d", &amp;N, &amp;K, &amp;M);

  for (int i = 0; i &lt; M; ++i) {
    char buff[10]; scanf("%s", buff);
    char c = buff[0];

    switch (c) {
      case 'S': 
        command[i] = SAVE;
        save[i] = ++S;
        break;
      case 'L':
        int x; scanf("%d", &amp;x);
        command[i] = LOAD;
        load[i] = x;
        break;
      case 'P':
        int c, x1, y1, x2, y2;
        scanf("%d %d %d %d %d", &amp;c, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
        command[i] = PAINT;
        paint[i] = rect(i, c, x1, y1, x2, y2);
    }
  }

  for (int i = M - 1; i &gt;= 0; --i) {
    switch (command[i]) {
      case SAVE: 
        break;
      case LOAD:
        int x; x = load[i];
        while (save[i] != x) --i;
        break;
      case PAINT:
        beg[paint[i].x1].push_back(paint[i]);
        end[paint[i].x2 + 1].push_back(paint[i]);
    }
  }

  for (int row = 0; row &lt; N; ++row, odd ^= 1) {
    for (int i = 0; i &lt; end[row].size(); ++i)
      T.remove(end[row][i]);
    for (int i = 0; i &lt; beg[row].size(); ++i)
      T.insert(beg[row][i]);
    for (int col = 0; col &lt; N; ++col)
      printf("%d ", T.query(col));
    printf("\n");
  }

  return 0;
}
</pre><pre></pre><h2>Problem3189</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,k,m;
struct tree{
    set&lt;pair&lt;int,int&gt; &gt;node[1010*4];
    void add(int x,int l,int r,int b,int e,pair&lt;int,int&gt;t){
        if(l==b&amp;&amp;r==e)node[x].insert(t);
        else{
            int m=(l+r)/2;
            if(e&lt;=m)add(x*2,l,m,b,e,t);
            else if(b&gt;m)add(x*2+1,m+1,r,b,e,t);
            else add(x*2,l,m,b,m,t),add(x*2+1,m+1,r,m+1,e,t);
        }
    }
    void rem(int x,int l,int r,int b,int e,pair&lt;int,int&gt;t){
        if(l==b&amp;&amp;r==e)node[x].erase(t);
        else{
            int m=(l+r)/2;
            if(e&lt;=m)rem(x*2,l,m,b,e,t);
            else if(b&gt;m)rem(x*2+1,m+1,r,b,e,t);
            else rem(x*2,l,m,b,m,t),rem(x*2+1,m+1,r,m+1,e,t);
        }
    }
    pair&lt;int,int&gt;ask(int x,int l,int r,int p){
        pair&lt;int,int&gt;t=node[x].empty()?make_pair(0,1):*node[x].rbegin();
        if(l!=r){
            int m=(l+r)/2;
            if(p&lt;=m)t=max(t,ask(x*2,l,m,p));
            else t=max(t,ask(x*2+1,m+1,r,p));
        }
        return t;
    } 
}odd,even;
struct query{
    int tp;//1 paint 2 save 3 load
    int id;
    int tm,x1,y1,x2,y2,cl;
};
vector&lt;query&gt;q1,toadd[2010],torem[1010]; 
int main(){
    sf("%d%d%d",&amp;n,&amp;k,&amp;m);int nw=0;
    lp(i,1,m){
        char op[11];
        sf("%s",op+1);
        if(op[1]=='P'){
            query t;t.tp=1;t.tm=i;
            sf("%d%d%d%d%d",&amp;t.cl,&amp;t.x1,&amp;t.y1,&amp;t.x2,&amp;t.y2);
            ++t.x1;++t.x2;++t.y1;++t.y2;
            q1.push_back(t);
        }else if(op[1]=='S'){
            query t;t.tp=2;t.id=++nw;
            q1.push_back(t);
        }else{
            query t;t.tp=3;sf("%d",&amp;t.id);
            q1.push_back(t);
        }
    }
    rp(i,int(q1.size()-1),0){
        if(q1[i].tp==1){
            toadd[q1[i].x1].push_back(q1[i]);
            torem[q1[i].x2+1].push_back(q1[i]);
        }
        else if(q1[i].tp==3){
            int j=i-1;
            while(q1[j].tp!=2||q1[j].id!=q1[i].id)--j;
            i=j;
        }
    }
    lp(i,1,n){
        lp(j,0,int(torem[i].size()-1))
            if((torem[i][j].x1+torem[i][j].y1)&amp;1)
                odd.rem(1,1,n,torem[i][j].y1,torem[i][j].y2,make_pair(torem[i][j].tm,torem[i][j].cl));
            else
                even.rem(1,1,n,torem[i][j].y1,torem[i][j].y2,make_pair(torem[i][j].tm,torem[i][j].cl));
        lp(j,0,int(toadd[i].size()-1)){
            if((toadd[i][j].x1+toadd[i][j].y1)&amp;1)
                odd.add(1,1,n,toadd[i][j].y1,toadd[i][j].y2,make_pair(toadd[i][j].tm,toadd[i][j].cl));
            else
                even.add(1,1,n,toadd[i][j].y1,toadd[i][j].y2,make_pair(toadd[i][j].tm,toadd[i][j].cl));
        }
        lp(j,1,n){
            if((i+j)&amp;1)pf("%d ",odd.ask(1,1,n,j).second);
            else pf("%d ",even.ask(1,1,n,j).second);
        }
        pf("\n"); 
    }
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3190</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt; 
#include&lt;complex&gt;
#include&lt;deque&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
typedef double db;
struct car{
    ll s,v;int idx;
};
bool hehe(car a,car b,car c){
    double x=double(b.s-a.s)/(a.v-b.v);
    double y=a.v*x+a.s;
    double z=c.v*x+c.s;
    return z-y&gt;1e-8;
}
bool hehe2(car a,car b){
    double x=double(b.s-a.s)/(a.v-b.v);
    return x&lt;-1e-8;
}
bool operator&lt;(car a,car b){
    return a.v==b.v?a.s&gt;b.s:a.v&lt;b.v;
}
vector&lt;car&gt;cars;int n;
int win[10010],tran[10010];
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        cars.push_back(car());
        cars[i-1].idx=i;
    }
    lp(i,1,n)sf("%lld",&amp;cars[i-1].s);
    lp(i,1,n)sf("%lld",&amp;cars[i-1].v);
    sort(cars.begin(),cars.end());
    deque&lt;car&gt;qu;
    lp(i,0,n-1){
        if(i!=0&amp;&amp;cars[i].v==cars[i-1].v&amp;&amp;cars[i].s==cars[i-1].s){
            tran[cars[i].idx]=cars[i-1].idx;
            continue;
        }
        while(qu.size()&gt;=2){
            car a=qu[qu.size()-2],b=qu[qu.size()-1];
            if(hehe(a,b,cars[i]))qu.pop_back();
            else break;
        }
        if(qu.empty()||qu.back().v!=cars[i].v)
            qu.push_back(cars[i]);
    }
    while(qu.size()&gt;=2){
        car a=qu[0],b=qu[1];
        if(hehe2(a,b))qu.pop_front();
        else break;
    }
    lp(i,0,int(qu.size()-1))win[qu[i].idx]=1;
    lp(i,1,n)if(win[tran[i]])win[i]=1;
    vector&lt;int&gt;ans;
    lp(i,1,n)if(win[i])ans.push_back(i);
    pf("%d\n",ans.size());
    lp(i,0,int(ans.size()-1))
        pf("%d%c",ans[i],i+1==ans.size()?'\n':' ');
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3191</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,m,c[101];double f[101][101];
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,m)sf("%d",&amp;c[i]);
    f[1][1]=1;
    lp(i,2,n)
        lp(j,1,i)
            lp(k,1,m){
                int t=((c[k]-1)%i)+1;
                if(t==j)continue;
                if(t&lt;j){
                    f[i][j]+=f[i-1][j-t]/double(m);
                    //pf("[%d,%d-&gt;%d,%d](%d)\n",i,j,i-1,j-t,c[k]); 
                }else if(t!=i){
                    f[i][j]+=f[i-1][i-(t-j)]/double(m);
                    //pf("[%d,%d-&gt;%d,%d](%d)\n",i,j,i-1,i-(t-j),c[k]); 
                }else{
                    f[i][j]+=f[i-1][j]/double(m);
                    //pf("[%d,%d-&gt;%d,%d](%d)\n",i,j,i-1,j,c[k]); 
                }
            }
    lp(i,1,n)pf("%.2lf%%%c",f[n][i]*100,i==n?'\n':' ');
    //ps;
    return 0; 
} 
</pre><pre></pre><h2>Problem3192</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt; 
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
map&lt;int,int&gt;po;int n1,n2;
int db[100010];
void add(int u,int v){
    for(;u&lt;=n1+n2+1;u+=u&amp;-u)db[u]+=v;
}
int ask(int u){
    int r=0;
    for(;u;u-=u&amp;-u)r+=db[u];
    return r;
}
int main(){
    sf("%d%d",&amp;n1,&amp;n2);
    rp(i,n1,1){
        int t;sf("%d",&amp;t);
        po[t]=i;
        add(i,1);
    }
    lp(i,1,n2){
        int t;sf("%d",&amp;t);
        po[t]=n1+1+i;
        add(n1+1+i,1);
    }
    long long ans=0;
    int lst=n1+1;
    for(map&lt;int,int&gt;::reverse_iterator it=po.rbegin();it!=po.rend();++it){
        int t=it-&gt;second;
        if(t&gt;lst)ans+=ask(t-1)-ask(lst);
        else ans+=ask(lst)-ask(t);
        add(t,-1);
        lst=t;
    }
    pf("%lld\n",ans);
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
namespace trp{
    struct node{
        node(int a){
            ch[0]=ch[1]=0;
            vl=a;sz=1;fx=rand();
        }
        node*ch[2];
        int vl,sz,fx;
    };
    void upd(node*x){
        x-&gt;sz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
    }
    void rot(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        upd(x);upd(y);x=y;
    }
    void ins(node*&amp;x,int v){
        if(!x)x=new node(v);
        else{
            if(v&lt;x-&gt;vl){
                ins(x-&gt;ch[0],v);
                upd(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)
                    rot(x,0);
            }else{
                ins(x-&gt;ch[1],v);
                upd(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)
                    rot(x,1);
            }
        }
    }
    void rem(node*&amp;x,int v){
        if(x-&gt;vl==v){
            if(!x-&gt;ch[0])x=x-&gt;ch[1];
            else if(!x-&gt;ch[1])x=x-&gt;ch[0];
            else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx)
                rot(x,0),rem(x-&gt;ch[1],v),upd(x);
            else
                rot(x,1),rem(x-&gt;ch[0],v),upd(x);
        }else{
            rem(x-&gt;ch[v&gt;x-&gt;vl],v),upd(x);
        }
    }
    int less(node*x,int v){
        if(!x)return 0;
        else if(x-&gt;vl&lt;v)return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+less(x-&gt;ch[1],v);
        else return less(x-&gt;ch[0],v); 
    }
    int pre(node*x,int v){
        if(!x)return -(~0u&gt;&gt;1);
        else if(x-&gt;vl&lt;v)return max(x-&gt;vl,pre(x-&gt;ch[1],v));
        else return pre(x-&gt;ch[0],v);
    }
    int nxt(node*x,int v){
        if(!x)return ~0u&gt;&gt;1;
        else if(x-&gt;vl&gt;v)return min(x-&gt;vl,nxt(x-&gt;ch[0],v));
        else return nxt(x-&gt;ch[1],v);
    }
    
}
namespace seg{
    struct node{
        node(int a,int b){
            ch[0]=ch[1]=0;
            tp=0;l=a;r=b;
        }
        node*ch[2];trp::node*tp;int l,r;
    };
    node*build(int l,int r){
        node*x=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;ch[0]=build(l,m);
            x-&gt;ch[1]=build(m+1,r);
        }
        return x;
    }
    void insert(node*x,int p,int v){
        trp::ins(x-&gt;tp,v);
        if(x-&gt;l!=x-&gt;r){
            if(p&lt;=x-&gt;ch[0]-&gt;r)
                insert(x-&gt;ch[0],p,v);
            else
                insert(x-&gt;ch[1],p,v);
        }
    }
    void remove(node*x,int p,int v){
        trp::rem(x-&gt;tp,v);
        if(x-&gt;l!=x-&gt;r){
            if(p&lt;=x-&gt;ch[0]-&gt;r)
                remove(x-&gt;ch[0],p,v);
            else
                remove(x-&gt;ch[1],p,v);
        }
    }
    int rank(node*x,int b,int e,int v){
       if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r)return trp::less(x-&gt;tp,v);
       else{
            int as=0;
            if(b&lt;=x-&gt;ch[0]-&gt;r)as+=rank(x-&gt;ch[0],b,e,v);
            if(e&gt;x-&gt;ch[0]-&gt;r)as+=rank(x-&gt;ch[1],b,e,v);
            return as;
       } 
    }
    int prev(node*x,int b,int e,int v){
        if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r)return trp::pre(x-&gt;tp,v);
        else{
            int as=-(~0u&gt;&gt;1);
            if(b&lt;=x-&gt;ch[0]-&gt;r)as=max(as,prev(x-&gt;ch[0],b,e,v));
            if(e&gt;x-&gt;ch[0]-&gt;r)as=max(as,prev(x-&gt;ch[1],b,e,v));
            return as;
        }
    }
    int next(node*x,int b,int e,int v){
        if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r)return trp::nxt(x-&gt;tp,v);
        else{
            int as=~0u&gt;&gt;1;
            if(b&lt;=x-&gt;ch[0]-&gt;r)as=min(as,next(x-&gt;ch[0],b,e,v));
            if(e&gt;x-&gt;ch[0]-&gt;r)as=min(as,next(x-&gt;ch[1],b,e,v));
            return as;
        }
    }
}
int main(){
    static int a[50010],n,m;
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)sf("%d",&amp;a[i]);
    seg::node*rt=seg::build(1,n);
    lp(i,1,n)seg::insert(rt,i,a[i]);
    lp(i,1,m){
        int op;sf("%d",&amp;op);
        if(op==1){
            int l,r,k;sf("%d%d%d",&amp;l,&amp;r,&amp;k);
            pf("%d\n",seg::rank(rt,l,r,k)+1);
        }else if(op==2){
            int l,r,k;sf("%d%d%d",&amp;l,&amp;r,&amp;k);
            int lf=-1,rf=100000000;
            while(lf+1&lt;rf){
                int mf=(lf+rf)/2;
                if(seg::rank(rt,l,r,mf)&lt;=k-1)lf=mf;
                else rf=mf;
            }
            pf("%d\n",lf);
        }else if(op==3){
            int pos,k;sf("%d%d",&amp;pos,&amp;k);
            seg::remove(rt,pos,a[pos]);
            a[pos]=k;
            seg::insert(rt,pos,a[pos]);
        }else if(op==4){
            int l,r,k;sf("%d%d%d",&amp;l,&amp;r,&amp;k);
            pf("%d\n",seg::prev(rt,l,r,k));
        }else{
            int l,r,k;sf("%d%d%d",&amp;l,&amp;r,&amp;k);
            pf("%d\n",seg::next(rt,l,r,k));
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3197</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;queue&gt;
namespace mcmf{
	struct edge{
		edge(int x,int y,int z):
			v(x),c(y),w(z){}
		int v,c,w;
	};
	vector&lt;edge&gt;eg;
	vector&lt;int&gt;bg[1010];
	int vcnt,cst;
	void init(){
		lp(i,1,vcnt)bg[i].clear();
		eg.clear();
		cst=0;
	}
	void add(int u,int v,int c,int w){
		bg[u].pb(eg.size());
		eg.pb(edge(v,c,w));
		//pf("(%d,%d,%d,%d)\n",u,v,c,w);
	}
	int vis[1010],dis[1010];
	bool spfa(){
		lp(i,2,vcnt)dis[i]=~0u&gt;&gt;1,vis[i]=0;
		dis[1]=0;vis[1]=1;
		queue&lt;int&gt;qu;qu.push(1);vis[1]=1;
		while(!qu.empty()){
			int u=qu.front();qu.pop();vis[u]=0;
			vp(i,bg[u]){
				edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
				if(e.c&amp;&amp;dis[e.v]&gt;dis[u]+e.w){
					dis[e.v]=dis[u]+e.w;
					if(!vis[e.v]){
						vis[e.v]=1;
						qu.push(e.v);
					}
				}
			}
		}
		return dis[vcnt]!=~0u&gt;&gt;1;
	}
	int dfs(int u,int f){
		if(u==vcnt)return f;
		int g=f;vis[u]=1;
		vp(i,bg[u]){
			edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
			if(e.c&amp;&amp;!vis[e.v]&amp;&amp;dis[e.v]==dis[u]+e.w){
				int t=dfs(e.v,min(g,e.c));
				g-=t;e.c-=t;ev.c+=t;cst+=e.w*t;
				if(!g)return f;
			}
		}
		return f-g;
	}
	int run(){
		int ret=0;
		while(spfa()){
			int t;do{
				fill(vis+1,vis+vcnt+1,0);
				ret+=(t=dfs(1,~0u&gt;&gt;1));
			}while(t);
		}
		return ret;
	}
}
vector&lt;int&gt;to[1010];int n,vala[1010],valb[1010],ans=~0u&gt;&gt;1;
vector&lt;int&gt;center;
namespace calccenter{
	int siza[1010],maxa[1010];
	void dfsa(int u,int p){
		siza[u]=1;
		vp(i,to[u]){
			if(to[u][i]!=p){
				dfsa(to[u][i],u);
				siza[u]+=siza[to[u][i]];
				maxa[u]=max(maxa[u],siza[to[u][i]]);
			}
		}
	}
	void run(){
		dfsa(1,0);int tm=~0u&gt;&gt;1;
		lp(i,1,n){
			maxa[i]=max(maxa[i],n-siza[i]);
			tm=min(tm,maxa[i]);
		}
		lp(i,1,n){
			if(maxa[i]==tm)
				center.pb(i);
		}
		//vp(i,center)pf("[%d]",center[i]);pf("\n");
	}
}
namespace orzsevenk{
	int can[1010][1010];
	vector&lt;int&gt;levela[1010];
	vector&lt;int&gt;levelb[1010];
	vector&lt;int&gt;cha[1010],chb[1010];
	int depa[1010],depb[1010];
	int siza[1010],sizb[1010];
	void dfsa(int u,int p){
		cha[p].pb(u);
		depa[u]=depa[p]+1;
		siza[u]=1;
		levela[depa[u]].pb(u);
		vp(i,to[u]){
			if(to[u][i]!=p){
				dfsa(to[u][i],u);
				siza[u]+=siza[to[u][i]];
			}
		}
	}
	void dfsb(int u,int p){
		chb[p].pb(u);
		depb[u]=depb[p]+1;
		sizb[u]=1;
		levelb[depb[u]].pb(u);
		vp(i,to[u]){
			if(to[u][i]!=p){
				dfsb(to[u][i],u);
				sizb[u]+=sizb[to[u][i]];
			}
		}
	}
	void run(int roota,int rootb){
		lp(i,1,n)levela[i].clear();
		lp(i,1,n)levelb[i].clear();
		lp(i,1,n)cha[i].clear();
		lp(i,1,n)chb[i].clear();
		dfsa(roota,0);
		dfsb(rootb,0);
		/*lp(i,1,n){
			vp(j,levela[i])pf("[%d]",levela[i][j]);
			pf("\n");
		}
		pf("\n");
		lp(i,1,n){
			vp(j,levelb[i])pf("[%d]",levelb[i][j]);
			pf("\n");
		}
		pf("\n\n");*/
		rp(lev,n,1){
			vp(ii,levela[lev])vp(jj,levelb[lev]){
				int ua=levela[lev][ii];
				int ub=levelb[lev][jj];
				if(cha[ua].size()!=chb[ub].size())can[ua][ub]=-1;
				else if(cha[ua].size()==0)can[ua][ub]=(vala[ua]!=valb[ub]);
				else{
					//pf("[%d,%d,%d]\n",ua,ub,lev);
					mcmf::vcnt=cha[ua].size()*2+2;
					mcmf::init();
					vp(iii,cha[ua]){
						vp(jjj,chb[ub]){
							int va=cha[ua][iii];int idva=iii+1+1;
							int vb=chb[ub][jjj];int idvb=jjj+2+cha[ua].size();
							//pf("{%d,%d,%d,%d}\n",va,idva,vb,idvb);
							if(can[va][vb]!=-1){
								mcmf::add(idva,idvb,1,can[va][vb]);
								mcmf::add(idvb,idva,0,-can[va][vb]);
							}
						}
					}
					vp(iii,cha[ua]){
						int va=cha[ua][iii];;int idva=iii+1+1;
						mcmf::add(1,idva,1,0);
						mcmf::add(idva,1,0,0);
					}
					vp(jjj,chb[ub]){
						int vb=chb[ub][jjj];int idvb=jjj+2+cha[ua].size();
						mcmf::add(idvb,mcmf::vcnt,1,0);
						mcmf::add(mcmf::vcnt,idvb,0,0);
					}
					if(mcmf::run()!=cha[ua].size())can[ua][ub]=-1;
					else can[ua][ub]=mcmf::cst+(vala[ua]!=valb[ub]);
				}
			}
		}
		//lp(i,1,n)pf("[%d]\n",can[i][i]);
		if(can[roota][rootb]!=-1)
			ans=min(ans,can[roota][rootb]);
	}
}
int main(){
	sf("%d",&amp;n);
	lp(i,1,n-1){
		int u,v;sf("%d%d",&amp;u,&amp;v);
		to[u].pb(v);
		to[v].pb(u);
	}
	lp(i,1,n)sf("%d",&amp;vala[i]);
	lp(i,1,n)sf("%d",&amp;valb[i]);
	calccenter::run();
	//orzsevenk::run(1,1);
	vp(i,center)vp(j,center)orzsevenk::run(center[i],center[j]);
	pf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll; 
ll f[(1&lt;&lt;6)+1][(1&lt;&lt;6)+1][7][1&lt;&lt;6],u[1&lt;&lt;6];
void printset(int x){
    pf("[");lp(i,0,5)pf("%d",(x&gt;&gt;i)&amp;1);pf("]"); 
}
void printstate(int i,int j,int k,int l){
    pf("[%d,%d,%d,",i,j,k);
    printset(l),
    pf(",%I64d]",f[i][j][k][l]);
}
int now;
struct val{
    int v[6];
};
bool operator&lt;(val a,val b){
    lp(i,0,5)if((now&gt;&gt;i)&amp;1)
        if(a.v[i]!=b.v[i])return a.v[i]&lt;b.v[i];
    return false;
}
bool operator==(val a,val b){
    lp(i,0,5)if((now&gt;&gt;i)&amp;1)if(a.v[i]!=b.v[i])return false;
    return true;
}
int N,K;
vector&lt;val&gt;V;
ll calc(){
    ll r=0;
    sort(V.begin(),V.end());
    lp(i,0,int(V.size()-1)){
        int j=i;while(j+1&lt;V.size()&amp;&amp;V[j+1]==V[j])++j;
        ll t=j-i+1;
        r+=t*(t-1)/2;
        i=j;
    }
    return r;
}
ll ans[1&lt;&lt;6];
int main(){
    lp(i,0,(1&lt;&lt;6)-1)for(int j=i;j;j-=j&amp;-j)++u[i];
    //lp(i,0,(1&lt;&lt;6)-1)printset(i),pf(" %d\n",u[i]);
    lp(i,0,6)f[0][0][i][0]=1;
    lp(i,1,(1&lt;&lt;6)){
        lp(j,0,i){
            lp(k,0,6){
                lp(l,0,(1&lt;&lt;6)-1){
                    f[i][j][k][l]+=f[i-1][j][k][l];
                    if(j!=0&amp;&amp;(l&amp;(i-1))==i-1&amp;&amp;u[i-1]==k){
                        for(int m=i-1;;m=((m-1)&amp;(i-1))){
                            f[i][j][k][l]+=f[i-1][j-1][k][l-(i-1)+m];
                            //printstate(i,j,k,l);pf("-&gt;");printstate(i-1,j-1,k,l-(i-1)+m);pf("\n");
                            if(!m)break;
                        }
                    }
                    //if(f[i][j][k][l])
                        //printstate(i,j,k,l),pf("\n\n");
                }
            }
        }
    }
    sf("%d%d",&amp;N,&amp;K);
    lp(i,1,N){
        val t;lp(j,0,5)sf("%d",&amp;t.v[j]);
        V.push_back(t);
    }
    lp(i,0,(1&lt;&lt;6)-1){
        now=i;
        ans[i]=calc();
        //printset(i);pf("[%lld]\n",ans[i]); 
    }
    ll tans=0;
    lp(i,0,(1&lt;&lt;6)-1){
        lp(j,1,(1&lt;&lt;6)){
            tans+=ans[i]*f[1&lt;&lt;6][j][K][i]*((j%2==1)?1:-1);
            //if(ans[i]*f[1&lt;&lt;6][j][K][i])
                //printset(i),pf("[%d,%I64d,%d]\n",j,ans[i]*f[1&lt;&lt;6][j][K][i],((j%2==1)?1:-1)); 
        }
    }
    ll tans2=0;
    if(K!=6)
    lp(i,0,(1&lt;&lt;6)-1){
        lp(j,1,(1&lt;&lt;6)){
            tans2+=ans[i]*f[1&lt;&lt;6][j][K+1][i]*((j%2==1)?1:-1);
            //if(ans[i]*f[1&lt;&lt;6][j][K][i])
                //printset(i),pf("[%d,%I64d,%d]\n",j,ans[i]*f[1&lt;&lt;6][j][K][i],((j%2==1)?1:-1)); 
        }
    }
    pf("%lld\n",tans-tans2);
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll; 
ll f[(1&lt;&lt;6)+1][(1&lt;&lt;6)+1][7][1&lt;&lt;6],u[1&lt;&lt;6];
void printset(int x){
    pf("[");lp(i,0,5)pf("%d",(x&gt;&gt;i)&amp;1);pf("]"); 
}
void printstate(int i,int j,int k,int l){
    pf("[%d,%d,%d,",i,j,k);
    printset(l),
    pf(",%I64d]",f[i][j][k][l]);
}
int now;
struct val{
    int v[6];
};
bool operator&lt;(val a,val b){
    lp(i,0,5)if((now&gt;&gt;i)&amp;1)
        if(a.v[i]!=b.v[i])return a.v[i]&lt;b.v[i];
    return false;
}
bool operator==(val a,val b){
    lp(i,0,5)if((now&gt;&gt;i)&amp;1)if(a.v[i]!=b.v[i])return false;
    return true;
}
int N,K;
vector&lt;val&gt;V;
ll calc(){
    ll r=0;
    sort(V.begin(),V.end());
    lp(i,0,int(V.size()-1)){
        int j=i;while(j+1&lt;V.size()&amp;&amp;V[j+1]==V[j])++j;
        ll t=j-i+1;
        r+=t*(t-1)/2;
        i=j;
    }
    return r;
}
ll ans[1&lt;&lt;6];
int main(){
    lp(i,0,(1&lt;&lt;6)-1)for(int j=i;j;j-=j&amp;-j)++u[i];
    //lp(i,0,(1&lt;&lt;6)-1)printset(i),pf(" %d\n",u[i]);
    lp(i,0,6)f[0][0][i][0]=1;
    sf("%d%d",&amp;N,&amp;K);
    lp(i,1,(1&lt;&lt;6)){
        lp(j,0,i){
            lp(k,0,6){
                if(k!=K&amp;&amp;k!=K+1)continue; 
                lp(l,0,(1&lt;&lt;6)-1){
                    f[i][j][k][l]+=f[i-1][j][k][l];
                    if(j!=0&amp;&amp;(l&amp;(i-1))==i-1&amp;&amp;u[i-1]==k){
                        for(int m=i-1;;m=((m-1)&amp;(i-1))){
                            f[i][j][k][l]+=f[i-1][j-1][k][l-(i-1)+m];
                            //printstate(i,j,k,l);pf("-&gt;");printstate(i-1,j-1,k,l-(i-1)+m);pf("\n");
                            if(!m)break;
                        }
                    }
                    //if(f[i][j][k][l])
                        //printstate(i,j,k,l),pf("\n\n");
                }
            }
        }
    }
    lp(i,1,N){
        val t;lp(j,0,5)sf("%d",&amp;t.v[j]);
        V.push_back(t);
    }
    lp(i,0,(1&lt;&lt;6)-1){
        now=i;
        ans[i]=calc();
        //printset(i);pf("[%lld]\n",ans[i]); 
    }
    ll tans=0;
    lp(i,0,(1&lt;&lt;6)-1){
        lp(j,1,(1&lt;&lt;6)){
            tans+=ans[i]*f[1&lt;&lt;6][j][K][i]*((j%2==1)?1:-1);
            //if(ans[i]*f[1&lt;&lt;6][j][K][i])
                //printset(i),pf("[%d,%I64d,%d]\n",j,ans[i]*f[1&lt;&lt;6][j][K][i],((j%2==1)?1:-1)); 
        }
    }
    ll tans2=0;
    if(K!=6)
    lp(i,0,(1&lt;&lt;6)-1){
        lp(j,1,(1&lt;&lt;6)){
            tans2+=ans[i]*f[1&lt;&lt;6][j][K+1][i]*((j%2==1)?1:-1);
            //if(ans[i]*f[1&lt;&lt;6][j][K][i])
                //printset(i),pf("[%d,%I64d,%d]\n",j,ans[i]*f[1&lt;&lt;6][j][K][i],((j%2==1)?1:-1)); 
        }
    }
    pf("%lld\n",tans-tans2);
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3199</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;complex&gt;
#include&lt;deque&gt;
#include&lt;queue&gt;
namespace hpi{ 
	double myabs(double a){
		return a&gt;0?a:-a;
	}
    double eps=1e-8;
    typedef complex&lt;double&gt;point;
    double det(point a,point b){
        return imag(conj(a)*b);
    }
    struct line{
        line(point d,point e,int i):
            p(d),q(e),a(arg(q-p)),id(i){}
        point p,q;double a;int id;
    };
    point operator*(line d,line e){
        point p1=d.p,q1=d.q,p2=e.p,q2=e.q;
        double a1=det(p2-q1,q2-p2),a2=det(p1-q2,q2-p2);
        return (a1*p1+a2*q1)/(a1+a2);
    }
    bool operator&lt;(line a,line b){
        if(myabs(a.a-b.a)&gt;eps)return a.a&lt;b.a;
        else return det(a.q-b.p,b.q-b.p)&lt;-eps;
    }
    vector&lt;line&gt;lns;
    deque&lt;line&gt;ans;
    void init(){
    	lns.clear();
    	ans.clear();
	}
	void add(double x1,double y1,double x2,double y2,int id){
		lns.pb(line(point(x1,y1),point(x2,y2),id));
	}
    bool left(line a,line b,line c){
        point t=a*b;
        return det(t-c.p,c.q-c.p)&lt;-eps;
    }
    void solve(){
        sort(lns.begin(),lns.end());
        lp(i,0,int(lns.size()-1)){
            while(ans.size()&gt;1&amp;&amp;!left(ans.back(),ans[ans.size()-2],lns[i]))
                ans.pop_back();
            while(ans.size()&gt;1&amp;&amp;!left(ans[0],ans[1],lns[i]))
                ans.pop_front();
            if(ans.empty()||myabs(ans.back().a-lns[i].a)&gt;eps)
                ans.push_back(lns[i]);
        }
        while(ans.size()&gt;1&amp;&amp;!left(ans[ans.size()-1],ans[ans.size()-2],ans.front()))
            ans.pop_back();
        if(ans.size()&lt;3)ans.clear();
    }
}
namespace bfs{
	int vcnt;
	int dis[1010],vis[1010];
	vector&lt;int&gt;to[1010];
	void init(){
		lp(i,1,vcnt)to[i].clear();
		lp(i,1,vcnt)vis[i]=0;
	}
	void add(int u,int v){
		to[u].pb(v);
		to[v].pb(u);
	}
	int run(int st,int et){
		dis[st]=0;vis[st]=1;
		queue&lt;int&gt;qu;qu.push(st);
		while(!qu.empty()){
			int u=qu.front();qu.pop();
			vp(i,to[u]){
				if(!vis[to[u][i]]){
					vis[to[u][i]]=1;
					dis[to[u][i]]=dis[u]+1;
					qu.push(to[u][i]);
				}
			}
		}
		return dis[et];
	}
}
int main(){
	int test;sf("%d",&amp;test);
	lp(kase,1,test){
		int n,x1,y1,x0,y0,st=-1,et;
		sf("%d%d%d%d%d",&amp;n,&amp;x1,&amp;y1,&amp;x0,&amp;y0);
		static double tx[1010],ty[1010];et=n+1;
		lp(i,1,n)sf("%lf%lf",&amp;tx[i],&amp;ty[i]);
		bfs::vcnt=n+1;
		bfs::init();
		double bestdis;int bestst=-1;
		lp(i,1,n){
			if(bestst==-1||double(tx[i]-x0)*double(tx[i]-x0)+double(ty[i]-y0)*double(ty[i]-y0)&lt;bestdis){
				bestdis=double(tx[i]-x0)*double(tx[i]-x0)+double(ty[i]-y0)*double(ty[i]-y0);
				bestst=i;
			}
		}
		st=bestst;
		lp(i,1,n){
			hpi::init();
			hpi::add(0,0,x1,0,n+1);
			hpi::add(x1,0,x1,y1,n+1);
			hpi::add(x1,y1,0,y1,n+1);
			hpi::add(0,y1,0,0,n+1);
			lp(j,1,n)if(j!=i){
				double vx=tx[j]-tx[i];
				double vy=ty[j]-ty[i];
				double vvx=-vy;
				double vvy=vx;
				double mx=(tx[j]+tx[i])/2;
				double my=(ty[j]+ty[i])/2;
				hpi::add(mx,my,mx+vvx,my+vvy,j);
			}
			hpi::solve();
			vp(j,hpi::ans){
				bfs::add(i,hpi::ans[j].id);
			}
		}
		pf("%d\n",bfs::run(st,et));
	}
	return 0;
}</pre><pre></pre><h2>Problem3201</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll p=1000000007;
ll pmod(ll a,ll b){
    ll r=1;
    while(b){
        if(b&amp;1)r=r*a%p;
        a=a*a%p;
        b&gt;&gt;=1;
    }
    return r;
}
ll com[1010][1010];
ll a[1010],f[1010];int n;
int main(){
    lp(i,0,1005)lp(j,0,i)
        if(j==0||j==i)com[i][j]=1;
        else com[i][j]=(com[i-1][j]+com[i-1][j-1])%p;
    int test;sf("%d",&amp;test);
    lp(kase,1,test){
        sf("%d",&amp;n);
        lp(i,1,n)sf("%lld",&amp;a[i]);
        f[0]=1;
        sort(a+1,a+n+1);
        lp(i,1,n){
            f[i]=pmod(a[i],i);
            lp(j,1,i-1){
                f[i]=(f[i]-f[j-1]*com[i][j-1]%p*pmod(a[i]-a[j],i-j+1)%p+p)%p;
            }
        }
        pf("%lld\n",f[n]); 
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll n,a,p=1000000007;
ll mui[10000010],pr[10000010];
void calc_mui(){
    static ll isp[10000010];
    mui[1]=1;
    lp(i,2,10000005){
        if(!isp[i]){
            pr[++pr[0]]=i;
            mui[i]=-1;
        }
        for(ll j=1;j&lt;=pr[0]&amp;&amp;pr[j]*i&lt;=10000005;++j){
            if(i%pr[j]==0){
                isp[i*pr[j]]=1;
                mui[i*pr[j]]=0;
                break;
            }else{
                isp[i*pr[j]]=1;
                mui[i*pr[j]]=-mui[i];
            }
        }
    }
}
struct num{
    num(ll t=0):x(t/p),y(t%p){}
    ll x,y;
}m;
inline num operator+(num a,num b){
    num c;
    c.x=(a.x+b.x)%p;
    c.y=a.y+b.y;
    if(c.y&gt;=p){
        c.y-=p;
        c.x=(c.x+1)%p;
    }
    return c;
}
inline num operator-(num a,num b){
    num c;
    c.x=(a.x-b.x+p)%p;
    c.y=a.y-b.y;
    if(c.y&lt;0){
        c.y+=p;
        c.x=(c.x-1+p)%p;
    }
    return c;
}
inline num operator*(num a,num b){
    num c;
    c.x=(a.x*b.y+b.x*a.y)%p;
    c.y=a.y*b.y;
    c.x=(c.x+c.y/p)%p;
    c.y%=p;
    return c;
}
void calc_m(){
    static num s[10000010];static int f=0;
    if(!f){
        lp(i,1,10000005)s[i]=num(ll(i)*ll(i+1)/2)+s[i-1];
        f=1;
    }
    m=num(0);
    lp(i,1,a)
        if(mui[i]==1)m=m+s[a/i];
        else if(mui[i]==-1)m=m-s[a/i];
}
struct mat{num d[3][3];};
mat mul(const mat&amp;x,const mat&amp;y){
    mat r;lp(i,1,2)lp(j,1,2)r.d[i][j]=num(0);
    lp(i,1,2)
        lp(j,1,2)
            lp(k,1,2){
                r.d[i][j]=r.d[i][j]+x.d[i][k]*y.d[k][j];
            }
    return r;
}
num calc_h(ll x){
    mat r;r.d[1][1]=num(0);r.d[1][2]=num(m-1);
    r.d[2][1]=num(1);r.d[2][2]=num(m-2);
    mat t;lp(i,1,2)lp(j,1,2)t.d[i][j]=num(i==j);
    for(ll y=x;y;y&gt;&gt;=1){
        if(y&amp;1)t=mul(t,r);
        r=mul(r,r);
    }
    return t.d[1][1]*num(m);
}
ll inv(ll x){
    ll r=1;x%=p;
    for(ll y=p-2;y;y&gt;&gt;=1){
        if(y&amp;1)r=r*x%p;
        x=x*x%p;
    }
    return r;
}
ll phi(ll x){
    ll r=x;
    for(ll i=1;i&lt;=pr[0]&amp;&amp;pr[i]*pr[i]&lt;=x;++i)
        if(x%pr[i]==0){
            r/=pr[i];
            r*=pr[i]-1;
            while(x%pr[i]==0)x/=pr[i];
        }
    if(x!=1)r/=x,r*=x-1;
    return r;
}
int main(){
    calc_mui();
    int test;sf("%d",&amp;test);
    lp(kase,1,test){
        sf("%lld%lld",&amp;n,&amp;a);
        calc_m();
        num ans=num(0);
        for(ll i=1;i*i&lt;=n;++i){
            if(n%i==0){
                ans=ans+calc_h(i)*num(phi(n/i));
                if(i*i!=n)ans=ans+calc_h(n/i)*num(phi(i));
            }
        }
        ll ans2;
        if(n%p!=0)ans2=ans.y*inv(n)%p;
        else ans2=ans.x*inv(n/p)%p;
        pf("%lld\n",ans2);
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3203</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll n,d,s[100010],x[100010];
double slope(pair&lt;ll,ll&gt;a,pair&lt;ll,ll&gt;b){
	return (a.second-b.second)/double(a.first-b.first);
}
int main(){
	sf("%lld%lld",&amp;n,&amp;d);
	lp(i,1,n){
		sf("%lld%lld",&amp;s[i],&amp;x[i]);
		s[i]+=s[i-1];
	}
	vector&lt;pair&lt;ll,ll&gt; &gt;pts;
	double ans=0;
	lp(i,1,n){
		while(pts.size()&gt;2){
			pair&lt;ll,ll&gt;a=pts[pts.size()-2],b=pts.back();
			if(slope(a,b)&gt;slope(b,mp(i*d,s[i-1]))-1e-8)pts.pop_back();
			else break;
		}
		pts.pb(mp(i*d,s[i-1]));
		int l=0,r=pts.size()-1;
		while(r-l&gt;=3){
			int m1=l+(r-l)/3,m2=r-(r-l)/3;
			if(slope(pts[m1],mp(x[i]+i*d,s[i]))&gt;slope(pts[m2],mp(x[i]+i*d,s[i])))
				r=m2;
			else
				l=m1;
		}
		/*if(i==2){
			vp(j,pts)pf("(%lld,%lld)\n",pts[j].first,pts[j].second);
			pf("(%lld,%lld)\n",x[i]+i*d,s[i]);
			pf("[%d,%d]\n",l,r);
		}*/
		double tans=0;
		lp(j,l,r)tans=max(tans,slope(pts[j],mp(x[i]+i*d,s[i])));
		//pf("%lf\n",tans);
		ans+=tans;
	}
	pf("%.0lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3206</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll wei[100010];int n;
struct edge1{
    edge1(){sf("%d%d%d",&amp;u,&amp;v,&amp;w);}
    int u,v,w;
};
bool operator&lt;(edge1 a,edge1 b){
    return a.w&lt;b.w;
}
struct edge2{
    edge2(){sf("%d%d",&amp;u,&amp;v);}
    int u,v;
};
vector&lt;edge1&gt;eg1;
vector&lt;edge2&gt;eg2;
void init(){
    int m,k;sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m)eg1.push_back(edge1());
    lp(i,1,k)eg2.push_back(edge2());
    lp(i,1,n)sf("%lld",&amp;wei[i]);
}
int pr[100010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void print(){
    lp(i,0,int(eg1.size()-1))
        pf("[%d,%d,%d]\n",eg1[i].u,eg1[i].v,eg1[i].w);
    lp(i,0,int(eg2.size()-1))
        pf("[%d,%d]\n",eg2[i].u,eg2[i].v);
    lp(i,1,n)pf("%lld%c",wei[i],i==n?'\n':' ');
}
void contract(){
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(eg2.size()-1)){
        int u=eg2[i].u,v=eg2[i].v;
        if(fd(u)!=fd(v))pr[fd(u)]=v;
    }
    sort(eg1.begin(),eg1.end());
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(tmp.size()-1)){
        int u=tmp[i].u,v=tmp[i].v;
        pr[fd(u)]=v;
    }
    static int id[100010];static ll tw[100010];
    int nw=1;id[fd(1)]=1;
    lp(i,1,n)if(pr[i]==i&amp;&amp;!id[i])id[i]=++nw;
    lp(i,1,n)tw[id[fd(i)]]+=wei[i];
    lp(i,0,int(eg1.size()-1)){
        int&amp;u=eg1[i].u,&amp;v=eg1[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    lp(i,0,int(eg2.size()-1)){
        int&amp;u=eg2[i].u,&amp;v=eg2[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    n=nw;
    lp(i,1,n)wei[i]=tw[i];
    //print();
}
void reduct(){
    lp(i,1,n)pr[i]=i;
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    eg1=tmp;
    //print();
}
struct edge3{
    edge3(int a,int b,int c):
        v(a),t(b),w(c){}
    int v,t,w;
};
vector&lt;edge3&gt;to[100010];
bool upda(int u,int p,int v,int w){
    if(u==v)return true;
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            if(upda(to[u][i].v,u,v,w)){
                if(to[u][i].t==2)
                    to[u][i].w=min(to[u][i].w,w);
                return true;
            }
        }
    } 
    return false;
}
ll sum[100010];
ll dp(int u,int p){
    ll r=0;
    sum[u]=wei[u];
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            r+=dp(to[u][i].v,u);
            sum[u]+=sum[to[u][i].v];
            if(to[u][i].t==2)
                r+=to[u][i].w*sum[to[u][i].v];
        }
    }
    return r;
}
void solve(){
    ll ans=0;
    lp(s,0,(1&lt;&lt;eg2.size())-1){
        lp(i,1,n)to[i].clear();
        lp(i,1,n)pr[i]=i;
        lp(i,0,int(eg2.size()-1))if((s&gt;&gt;i)&amp;1){
            int u=eg2[i].u,v=eg2[i].v;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,2,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,2,~0u&gt;&gt;1));
            }
        }
        lp(i,0,int(eg1.size()-1)){
            int u=eg1[i].u,v=eg1[i].v,w=eg1[i].w;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,1,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,1,~0u&gt;&gt;1));
            }else{
                upda(u,0,v,w);
                upda(v,0,u,w);
            }
        }
        ans=max(ans,dp(1,0));
    }
    pf("%lld\n",ans);
}
int main(){
    init();
    contract();
    reduct(); 
    solve();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3206</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll wei[1000010];int n;
struct edge1{
    edge1(){sf("%d%d%d",&amp;u,&amp;v,&amp;w);}
    int u,v,w;
};
bool operator&lt;(edge1 a,edge1 b){
    return a.w&lt;b.w;
}
struct edge2{
    edge2(){sf("%d%d",&amp;u,&amp;v);}
    int u,v;
};
vector&lt;edge1&gt;eg1;
vector&lt;edge2&gt;eg2;
void init(){
    int m,k;sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m)eg1.push_back(edge1());
    lp(i,1,k)eg2.push_back(edge2());
    lp(i,1,n)sf("%lld",&amp;wei[i]);
}
int pr[1000010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void print(){
    lp(i,0,int(eg1.size()-1))
        pf("[%d,%d,%d]\n",eg1[i].u,eg1[i].v,eg1[i].w);
    lp(i,0,int(eg2.size()-1))
        pf("[%d,%d]\n",eg2[i].u,eg2[i].v);
    lp(i,1,n)pf("%lld%c",wei[i],i==n?'\n':' ');
}
void contract(){
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(eg2.size()-1)){
        int u=eg2[i].u,v=eg2[i].v;
        if(fd(u)!=fd(v))pr[fd(u)]=v;
    }
    sort(eg1.begin(),eg1.end());
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(tmp.size()-1)){
        int u=tmp[i].u,v=tmp[i].v;
        pr[fd(u)]=v;
    }
    static int id[1000010];static ll tw[1000010];
    int nw=1;id[fd(1)]=1;
    lp(i,1,n)if(pr[i]==i&amp;&amp;!id[i])id[i]=++nw;
    lp(i,1,n)tw[id[fd(i)]]+=wei[i];
    lp(i,0,int(eg1.size()-1)){
        int&amp;u=eg1[i].u,&amp;v=eg1[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    lp(i,0,int(eg2.size()-1)){
        int&amp;u=eg2[i].u,&amp;v=eg2[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    n=nw;
    lp(i,1,n)wei[i]=tw[i];
    //print();
}
void reduct(){
    lp(i,1,n)pr[i]=i;
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    eg1=tmp;
    //print();
}
struct edge3{
    edge3(int a,int b,int c):
        v(a),t(b),w(c){}
    int v,t,w;
};
vector&lt;edge3&gt;to[1000010];
bool upda(int u,int p,int v,int w){
    if(u==v)return true;
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            if(upda(to[u][i].v,u,v,w)){
                if(to[u][i].t==2)
                    to[u][i].w=min(to[u][i].w,w);
                return true;
            }
        }
    } 
    return false;
}
ll sum[1000010];
ll dp(int u,int p){
    ll r=0;
    sum[u]=wei[u];
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            r+=dp(to[u][i].v,u);
            sum[u]+=sum[to[u][i].v];
            if(to[u][i].t==2)
                r+=to[u][i].w*sum[to[u][i].v];
        }
    }
    return r;
}
void solve(){
    ll ans=0;
    lp(s,0,(1&lt;&lt;eg2.size())-1){
        lp(i,1,n)to[i].clear();
        lp(i,1,n)pr[i]=i;
        lp(i,0,int(eg2.size()-1))if((s&gt;&gt;i)&amp;1){
            int u=eg2[i].u,v=eg2[i].v;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,2,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,2,~0u&gt;&gt;1));
            }
        }
        lp(i,0,int(eg1.size()-1)){
            int u=eg1[i].u,v=eg1[i].v,w=eg1[i].w;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,1,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,1,~0u&gt;&gt;1));
            }else{
                upda(u,0,v,w);
                upda(v,0,u,w);
            }
        }
        ans=max(ans,dp(1,0));
    }
    pf("%lld\n",ans);
}
int main(){
    init();
    contract();
    reduct(); 
    solve();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3206</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll wei[100010];int n;
struct edge1{
    edge1(){sf("%d%d%d",&amp;u,&amp;v,&amp;w);}
    int u,v,w;
};
bool operator&lt;(edge1 a,edge1 b){
    return a.w&lt;b.w;
}
struct edge2{
    edge2(){sf("%d%d",&amp;u,&amp;v);}
    int u,v;
};
vector&lt;edge1&gt;eg1;
vector&lt;edge2&gt;eg2;
void init(){
    int m,k;sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    lp(i,1,m)eg1.push_back(edge1());
    lp(i,1,k)eg2.push_back(edge2());
    lp(i,1,n)sf("%lld",&amp;wei[i]);
}
int pr[100010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void contract(){
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(eg2.size()-1)){
        int u=eg2[i].u,v=eg2[i].v;
        if(fd(u)!=fd(v))pr[fd(u)]=v;
    }
    sort(eg1.begin(),eg1.end());
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    lp(i,1,n)pr[i]=i;
    lp(i,0,int(tmp.size()-1)){
        int u=tmp[i].u,v=tmp[i].v;
        pr[fd(u)]=v;
    }
    static int id[100010];static ll tw[100010];
    int nw=1;id[fd(1)]=1;
    lp(i,1,n)if(pr[i]==i&amp;&amp;!id[i])id[i]=++nw;
    lp(i,1,n)tw[id[fd(i)]]+=wei[i];
    lp(i,0,int(eg1.size()-1)){
        int&amp;u=eg1[i].u,&amp;v=eg1[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    lp(i,0,int(eg2.size()-1)){
        int&amp;u=eg2[i].u,&amp;v=eg2[i].v;
        u=id[fd(u)];v=id[fd(v)];
    }
    n=nw;
    lp(i,1,n)wei[i]=tw[i];
    //print();
}
void reduct(){
    lp(i,1,n)pr[i]=i;
    vector&lt;edge1&gt;tmp;
    lp(i,0,int(eg1.size()-1)){
        int u=eg1[i].u,v=eg1[i].v;
        if(fd(u)!=fd(v)){
            pr[fd(u)]=v;
            tmp.push_back(eg1[i]);
        }
    }
    eg1=tmp;
    //print();
}
struct edge3{
    edge3(int a,int b,int c):
        v(a),t(b),w(c){}
    int v,t,w;
};
vector&lt;edge3&gt;to[100010];
bool upda(int u,int p,int v,int w){
    if(u==v)return true;
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            if(upda(to[u][i].v,u,v,w)){
                if(to[u][i].t==2)
                    to[u][i].w=min(to[u][i].w,w);
                return true;
            }
        }
    }
    return false;
}
ll sum[100010];
ll dp(int u,int p){
    ll r=0;
    sum[u]=wei[u];
    lp(i,0,int(to[u].size()-1)){
        if(to[u][i].v!=p){
            r+=dp(to[u][i].v,u);
            sum[u]+=sum[to[u][i].v];
            if(to[u][i].t==2)
                r+=to[u][i].w*sum[to[u][i].v];
        }
    }
    return r;
}
void solve(){
    ll ans=0;
    lp(s,0,(1&lt;&lt;eg2.size())-1){
        lp(i,1,n)to[i].clear();
        lp(i,1,n)pr[i]=i;
        lp(i,0,int(eg2.size()-1))if((s&gt;&gt;i)&amp;1){
            int u=eg2[i].u,v=eg2[i].v;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,2,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,2,~0u&gt;&gt;1));
            }
        }
        lp(i,0,int(eg1.size()-1)){
            int u=eg1[i].u,v=eg1[i].v,w=eg1[i].w;
            if(fd(u)!=fd(v)){
                pr[fd(u)]=v;
                to[u].push_back(edge3(v,1,~0u&gt;&gt;1));
                to[v].push_back(edge3(u,1,~0u&gt;&gt;1));
            }else{
                upda(u,0,v,w);
                upda(v,0,u,w);
            }
        }
        ans=max(ans,dp(1,0));
    }
    pf("%lld\n",ans);
}
int main(){
    init();
    contract();
    reduct();
    solve();
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3207</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll p=1000000009,q=1000000007,a1[100010],a2[100010],b1[100010],b2[100010];int n,m,k;
vector&lt;pair&lt;ll,ll&gt; &gt;qu1[100010];
vector&lt;int&gt;qu2[100010];
ll pw1[110],pw2[110];
ll gt1(int l,int r){return (a1[r]-a1[l-1]*pw1[r-l+1]%p+p)%p;}
ll gt2(int l,int r){return (a2[r]-a2[l-1]*pw2[r-l+1]%q+q)%q;}
int ans[100010];
int main(){
    sf("%d%d%d",&amp;n,&amp;m,&amp;k);
    pw1[0]=1;lp(i,1,k)pw1[i]=pw1[i-1]*27%p;
    pw2[0]=1;lp(i,1,k)pw2[i]=pw2[i-1]*27%q;
    lp(i,1,n)sf("%lld",&amp;a1[i]),a2[i]=a1[i];
    lp(i,1,n)a1[i]=(a1[i-1]*27+a1[i])%p;
    lp(i,1,n)a2[i]=(a2[i-1]*27+a2[i])%q;
    lp(i,1,n-k+1)b1[i]=gt1(i,i+k-1);
    lp(i,1,n-k+1)b2[i]=gt2(i,i+k-1);
    lp(i,1,m){
        int x,y;
        sf("%d%d",&amp;x,&amp;y);
        y=y-k+1;
        static ll tmp1[110],tmp2[110];
        lp(j,1,k)sf("%lld",&amp;tmp1[j]),tmp2[j]=tmp1[j];
        lp(j,1,k)tmp1[j]=(tmp1[j-1]*27+tmp1[j])%p;
        lp(j,1,k)tmp2[j]=(tmp2[j-1]*27+tmp2[j])%q;
        qu1[y].push_back(make_pair(tmp1[k],tmp2[k]));
        qu2[y].push_back(i);
        qu1[x-1].push_back(make_pair(tmp1[k],tmp2[k]));
        qu2[x-1].push_back(-i);
    }
    map&lt;pair&lt;ll,ll&gt;,int&gt;mp;
    lp(i,1,n-k+1){
        ++mp[make_pair(b1[i],b2[i])];
        lp(j,0,int(qu1[i].size()-1)){
            pair&lt;ll,ll&gt; t1=qu1[i][j];int t2=qu2[i][j];
            if(t2&lt;0)ans[-t2]-=mp[t1];
            else ans[t2]+=mp[t1];
        }
    }
    lp(i,1,m)pf("%s\n",ans[i]!=0?"No":"Yes");
    //ps;
    return 0; 
}
</pre><pre></pre><h2>Problem3208</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
int n,m,a[710][710],b[710][710],p[710][710];
struct data{
    int x,y;
};
bool operator&lt;(data x,data y){
    return a[x.x][x.y]&lt;a[y.x][y.y];
}
bool ava(int x,int y){
    return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n&amp;&amp;!b[x][y];
}
int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}};
int ind[710][710],dp[710][710];
int dfs(int x,int y){
    if(ind[x][y])return dp[x][y];
    ind[x][y]=1;dp[x][y]=1;
    lp(j,0,3){
        int tx=x+dir[j][0],ty=y+dir[j][1];
            if(ava(tx,ty)&amp;&amp;a[tx][ty]&lt;a[x][y]){
                dp[x][y]=max(dp[x][y],dfs(tx,ty)+1);
            }
        }
    return dp[x][y];
} 
int dpp(){
    int flg=0;
    lp(i,1,n)lp(j,1,n)if(!b[i][j]){
       ind[i][j]=0;
       flg=1;
    }
    if(!flg)return 0;
    int ans=0;
    lp(i,1,n)lp(j,1,n)if(!b[i][j]){
       ans=max(ans,dfs(i,j));
    }
    return ans;
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)lp(j,1,n)sf("%d",&amp;a[i][j]);
    sf("%d",&amp;m);
    lp(i,1,m){
        char op[11];sf("%s",op);
        if(op[0]=='C'){
            int x,y,z;sf("%d%d%d",&amp;x,&amp;y,&amp;z);
            a[x][y]=z;
        }else if(op[0]=='S'){
            int x1,y1,x2,y2;sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            lp(j,x1,x2)lp(k,y1,y2)b[j][k]=1; 
        }else if(op[0]=='B'){
            int x1,y1,x2,y2;sf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            lp(j,x1,x2)lp(k,y1,y2)b[j][k]=0; 
        }else{
            pf("%d\n",dpp());
        }
    }
    //ps;
    return 0;
}
/*
3
1 2 3
1 2 3
1 2 3
1
Q
*/
</pre><pre></pre><h2>Problem3209</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll comb[110][110],p=10000007;
ll pmd(ll x,ll y){
    ll r=1;
    while(y){
        if(y&amp;1)r=r*x%p;
        x=x*x%p;
        y&gt;&gt;=1;
    }
    return r;
}
ll calc(int d0,int po,ll n){
    if(po==0){
        //pf("[%d,%d,%lld,%lld]\n",d0,po,n,n%2==0?d0:d0*(d0+1)%p);
        if(n%2==0)return d0;
        else return d0*(d0+1)%p;
    }else{
        if(((n&gt;&gt;po)&amp;1)==0)return calc(d0,po-1,n);
        else{
            ll r=1;
            lp(i,(d0==0?1:0),po)r=r*pmd(i+d0,comb[po][i])%p;
            r=calc(d0+1,po-1,n)*r%p;
            //pf("[%d,%d,%lld,%lld]\n",d0,po,n,r);
            return r;
        }
    }
}
int main(){
    lp(i,0,105)
        lp(j,0,i)
            if(j==0||j==i)comb[i][j]=1;
            else comb[i][j]=(comb[i-1][j]+comb[i-1][j-1]);
    ll n;sf("%lld",&amp;n);
    pf("%lld\n",calc(0,59,n));
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3210</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll x[100010],y[100010];int n;
ll sumx[100010],sumy[100010];
ll ansx=-1,ansy=-1;
ll ansx2,ansy2;
ll calc(ll xx,ll yy){
    int i=lower_bound(x+1,x+n+1,xx)-x;
    ll r=0;
    r+=ll(i-1)*xx-sumx[i-1]+sumx[n]-sumx[i-1]-ll(n-i+1)*xx;
    i=lower_bound(y+1,y+n+1,yy)-y;
    r+=ll(i-1)*yy-sumy[i-1]+sumy[n]-sumy[i-1]-ll(n-i+1)*yy;
    return r;
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n){
        sf("%lld%lld",&amp;x[i],&amp;y[i]); 
        ll t1=x[i],t2=y[i];
        x[i]=t1-t2;y[i]=t1+t2;
    }
    sort(x+1,x+n+1);
    lp(i,1,n)sumx[i]=sumx[i-1]+x[i];
    lp(i,1,n){
        ll t=x[i]*(i-1)-sumx[i-1]+(sumx[n]-sumx[i])-x[i]*(n-i);
        if(ansx==-1||t&lt;ansx){
            ansx=t;ansx2=x[i];}
    }
    sort(y+1,y+n+1);
    lp(i,1,n)sumy[i]=sumy[i-1]+y[i];
    lp(i,1,n){
        ll t=y[i]*(i-1)-sumy[i-1]+(sumy[n]-sumy[i])-y[i]*(n-i);
        if(ansy==-1||t&lt;ansy){
            ansy=t;ansy2=y[i];}
    }
    if((ansx2+ansy2)%2==0){
        pf("%lld\n",calc(ansx2,ansy2)/2);
    }else{
        ll ty1=min(calc(ansx2-1,ansy2),calc(ansx2+1,ansy2));
        ll ty2=min(calc(ansx2,ansy2+1),calc(ansx2,ansy2-1));
        pf("%lld\n",min(ty1,ty2)/2);
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
typedef long double ld;
ll db[100010];int n,m;
void add(int i,ll d){
    for(;i&lt;=n;i+=i&amp;-i)db[i]+=d;
}
ll ask(int i){
    ll r=0;
    for(;i;i-=i&amp;-i)r+=db[i];
    return r;
}
ll a[100010];int nxt[100010];
int fd(int x){return x==nxt[x]?x:nxt[x]=fd(nxt[x]);}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n+1)nxt[i]=i;//must n+1
    lp(i,1,n){
        sf("%lld",&amp;a[i]);
        add(i,a[i]);
    }
    sf("%d",&amp;m);
    lp(i,1,m){
        int x,l,r;
        sf("%d%d%d",&amp;x,&amp;l,&amp;r);
        if(x==1)pf("%lld\n",ask(r)-ask(l-1));
        else{
            for(int j=fd(l);j&lt;=r;j=fd(j+1)){
                ll nt=ll(sqrt(ld(a[j]))+1e-8);
                add(j,nt-a[j]);
                a[j]=nt;
                if(a[j]==1||a[j]==0)nxt[j]=j+1;
            }
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3212</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll sum[100010*4],del[100010*4],a[100010];int n,q;
void down(int x,int l,int r){
    sum[x]+=(r-l+1)*del[x];
    if(l!=r)del[x*2]+=del[x],del[x*2+1]+=del[x];
    del[x]=0;
}
void upda(int x,int l,int r){
    int m=(l+r)/2;
    down(x*2,l,m);down(x*2+1,m+1,r);
    sum[x]=sum[x*2]+sum[x*2+1];
}
void build(int x,int l,int r){
    if(l==r){
        sum[x]=a[l];
    }else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        upda(x,l,r); 
    }
}
ll ask(int x,int l,int r,int b,int e){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)return sum[x];
    else{
        int m=(l+r)/2;ll ret=0;
        if(b&lt;=m)ret+=ask(x*2,l,m,b,e);
        if(e&gt;m)ret+=ask(x*2+1,m+1,r,b,e);
        return ret;
    }
}
void add(int x,int l,int r,int b,int e,int dd){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)del[x]=dd;
    else{
        int m=(l+r)/2;
        if(b&lt;=m)add(x*2,l,m,b,e,dd);
        if(e&gt;m)add(x*2+1,m+1,r,b,e,dd);
        upda(x,l,r);
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n)sf("%lld",&amp;a[i]);
    build(1,1,n);
    lp(i,1,q){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int l,r;sf("%d%d",&amp;l,&amp;r);
            pf("%lld\n",ask(1,1,n,l,r));
        }else{
            int l,r,c;sf("%d%d%d",&amp;l,&amp;r,&amp;c);
            add(1,1,n,l,r,c);
        }
    }
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3212</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
typedef long long ll;
ll sum[100010*4],del[100010*4],a[100010];int n,q;
inline void down(int x,int l,int r){
    sum[x]+=(r-l+1)*del[x];
    if(l!=r)del[x*2]+=del[x],del[x*2+1]+=del[x];
    del[x]=0;
}
inline void upda(int x,int l,int r){
    int m=(l+r)/2;
    down(x*2,l,m);down(x*2+1,m+1,r);
    sum[x]=sum[x*2]+sum[x*2+1];
}
void build(int x,int l,int r){
    if(l==r){
        sum[x]=a[l];
    }else{
        int m=(l+r)/2;
        build(x*2,l,m);
        build(x*2+1,m+1,r);
        upda(x,l,r); 
    }
}
ll ask(int x,int l,int r,int b,int e){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)return sum[x];
    else{
        int m=(l+r)/2;ll ret=0;
        if(b&lt;=m)ret+=ask(x*2,l,m,b,e);
        if(e&gt;m)ret+=ask(x*2+1,m+1,r,b,e);
        return ret;
    }
}
void add(int x,int l,int r,int b,int e,int dd){
    down(x,l,r);
    if(b&lt;=l&amp;&amp;e&gt;=r)del[x]=dd;
    else{
        int m=(l+r)/2;
        if(b&lt;=m)add(x*2,l,m,b,e,dd);
        if(e&gt;m)add(x*2+1,m+1,r,b,e,dd);
        upda(x,l,r);
    }
}
int main(){
    sf("%d%d",&amp;n,&amp;q);
    lp(i,1,n)sf("%lld",&amp;a[i]);
    build(1,1,n);
    lp(i,1,q){
        char op[11];sf("%s",op);
        if(op[0]=='Q'){
            int l,r;sf("%d%d",&amp;l,&amp;r);
            pf("%lld\n",ask(1,1,n,l,r));
        }else{
            int l,r,c;sf("%d%d%d",&amp;l,&amp;r,&amp;c);
            add(1,1,n,l,r,c);
        }
    }
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3216</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
inline void check19940417(){//19940417=7*2848631
    int t=19940417;
    lp(i,1,t)
        if(t%i==0)pf("%d\n",i);
}
ll pw1[30],pw2[3000010];
ll inv1[30],inv2[3000010];
inline ll comb1(ll a,ll b){
    if(a&lt;b)return 0;
    return pw1[a]*inv1[pw1[b]*pw1[a-b]%7]%7;
}
inline ll comb2(ll a,ll b){
    if(a&lt;b)return 0;
    return pw2[a]*inv2[pw2[b]*pw2[a-b]%2848631]%2848631;
}
inline ll lucas1(ll a,ll b){
    ll r=1;
    while(a||b){
        r=r*comb1(a%7,b%7)%7;
        a/=7;b/=7;
    }
    return r;
}
inline ll lucas2(ll a,ll b){
    ll r=1;
    while(a||b){
        r=r*comb2(a%2848631,b%2848631)%2848631;
        a/=2848631;b/=2848631;
    }
    return r;
}
struct data{int x,y;};
inline bool operator&lt;(data a,data b){
    return a.x&lt;b.x;
}
inline bool operator==(data a,data b){
    return a.x==b.x;
}
inline ll calc1(ll x1,ll y1,ll x2,ll y2){
    ll dx=x2-x1,dy=(y1&gt;y2?y1-y2:y2-y1);
    ll t=(dx+dy)/2;
    if(t&gt;dx)return 0;
    return lucas1(dx,t);
}
inline ll calc2(ll x1,ll y1,ll x2,ll y2){
    ll dx=x2-x1,dy=(y1&gt;y2?y1-y2:y2-y1);
    ll t=(dx+dy)/2;
    if(t&gt;dx)return 0;
    return lucas2(dx,t);
}
int main(){
    //check19940417();
    pw1[0]=1;lp(i,1,20)pw1[i]=pw1[i-1]*i%7;
    pw2[0]=1;lp(i,1,2900000)pw2[i]=pw2[i-1]*i%2848631;
    inv1[1]=1;
    lp(i,2,6)inv1[i]=(-7/i+7)*inv1[7%i]%7;
    inv2[1]=1;
    lp(i,2,2848630)inv2[i]=ll(-2848631/i+2848631)*inv2[2848631%i]%2848631;
    static data ds[1000010];
    int n,k;sf("%d%d",&amp;n,&amp;k);
    lp(i,1,k)sf("%d%d",&amp;ds[i].x,&amp;ds[i].y);
    ds[++k].x=0;ds[k].y=0;ds[++k].x=n;ds[k].y=0;
    sort(ds+1,ds+k+1);
    k=unique(ds+1,ds+k+1)-ds-1;
    //lp(i,1,k)pf("[%d,%d]\n",ds[i].x,ds[i].y);
    ll ansmx=0,anscnt1=1,anscnt2=1;
    lp(i,1,k-1){
        ll x1=ds[i].x,y1=ds[i].y;
        ll x2=ds[i+1].x,y2=ds[i+1].y;
        anscnt1=anscnt1*(calc1(x1,y1,x2,y2)-calc1(x1,-y1-2,x2,y2)+7)%7;
        anscnt2=anscnt2*(calc2(x1,y1,x2,y2)-calc2(x1,-y1-2,x2,y2)+19940417)%19940417;
    }
    lp(i,1,k-1){
        data a=ds[i],b=ds[i+1];
        int dx=b.x-a.x;
        int dy=a.y-b.y;if(dy&lt;0)dy=-dy;
        if(a.y-b.y&lt;0)ansmx=max(ansmx,ll(a.y)+(ll(dx)+ll(dy))/2);
        else ansmx=max(ansmx,ll(b.y)+(ll(dx)+ll(dy))/2);
    }
    ll anscnt=(anscnt1*2848631%19940417*inv1[2848631%7]%19940417+anscnt2*7%19940417*inv2[7]%19940417)%19940417;
    pf("%lld %lld\n",anscnt,ansmx);
    //ps;
    return 0;
} 
</pre><pre></pre><h2>Problem3216</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll p[2]={7,2848631};
ll inv[3000010];
ll isv[7];
ll fac[3000010];
ll ccm[7][7];
ll com(ll a,ll b,ll d){
    if(a&lt;b)return 0; 
    else if(d==0)return ccm[a][b];
    else return ll(fac[a])*inv[ll(fac[b])*fac[a-b]%p[1]]%p[1];
}
ll lus(ll a,ll b,ll d){
    ll r=1;
    while(a||b){
        r=ll(r)*com(a%p[d],b%p[d],d)%p[d];
        a/=p[d];
        b/=p[d];
    }
    return r;
}
ll cal(ll x1,ll y1,ll x2,ll y2,ll d){
    int dx=x2-x1,dy=y2&gt;y1?y2-y1:y1-y2;
    if((dx+dy)%2==1||(dx+dy)/2&gt;dx)return 0;
    return lus(dx,(dx+dy)/2,d);
}
ll sov(ll x1,ll y1,ll x2,ll y2,ll d){
    return (cal(x1,y1,x2,y2,d)-cal(x1,-y1-2,x2,y2,d)+p[d])%p[d];
}
struct point{ll x,y;};
bool operator&lt;(const point&amp;a,const point&amp;b){return a.x&lt;b.x;}
bool operator==(const point&amp;a,const point&amp;b){return a.x==b.x;}
int main(){
    lp(i,0,p[0]-1)lp(j,0,i)if(j==0||j==i)ccm[i][j]=1;else ccm[i][j]=(ccm[i-1][j-1]+ccm[i-1][j])%p[0];
    inv[1]=1;lp(j,2,p[1]-1)inv[j]=ll(p[1]-p[1]/j)*inv[p[1]%j]%p[1];
    fac[0]=1;lp(j,1,p[1]-1)fac[j]=ll(fac[j-1])*j%p[1];
    isv[1]=1;lp(j,2,6)isv[j]=(7-7/j)*isv[7%j]%7;
    ll n,k;sf("%lld%lld",&amp;n,&amp;k);
    static point pts[1000010];
    lp(i,1,k)sf("%lld%lld",&amp;pts[i].x,&amp;pts[i].y);
    pts[++k].x=0;pts[k].y=0;pts[++k].x=n;pts[k].y=0;
    sort(pts+1,pts+k+1);
    k=unique(pts+1,pts+k+1)-pts-1;
    ll mx=0,cnt[2]={1,1};
    lp(i,1,k-1){
        lp(j,0,1)cnt[j]=ll(cnt[j])*sov(pts[i].x,pts[i].y,pts[i+1].x,pts[i+1].y,j)%p[j];
        ll dx=pts[i+1].x-pts[i].x,dy=pts[i+1].y-pts[i].y;
        if(dy&gt;0)mx=max(mx,pts[i].y+(dx+dy)/2);
        else mx=max(mx,pts[i+1].y+(dx-dy)/2);
    }
    ll ans=(ll(cnt[0])*p[1]*isv[p[1]%7]%(p[0]*p[1])+ll(cnt[1])*p[0]*inv[7]%(p[0]*p[1]))%(p[0]*p[1]);
    pf("%lld %lld\n",ans,mx);
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3216</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
int p[2]={7,2848631};
int inv[3000010];
int isv[7];
int fac[3000010];
int ccm[7][7];
int com(int a,int b,int d){
    if(a&lt;b)return 0;
    else if(d==0)return ccm[a][b];
    else return ll(fac[a])*inv[ll(fac[b])*fac[a-b]%p[1]]%p[1];
}
int lus(int a,int b,int d){
    int r=1;
    while(a||b){
        r=ll(r)*com(a%p[d],b%p[d],d)%p[d];
        a/=p[d];
        b/=p[d];
    }
    return r;
}
int cal(int x1,int y1,int x2,int y2,int d){
    int dx=x2-x1,dy=y2&gt;y1?y2-y1:y1-y2;
    if((dx+dy)%2==1||(dx+dy)/2&gt;dx)return 0;
    return lus(dx,(dx+dy)/2,d);
}
int sov(int x1,int y1,int x2,int y2,int d){
    return (cal(x1,y1,x2,y2,d)-cal(x1,-y1-2,x2,y2,d)+p[d])%p[d];
}
struct point{int x,y;};
bool operator&lt;(const point&amp;a,const point&amp;b){return a.x&lt;b.x;}
bool operator==(const point&amp;a,const point&amp;b){return a.x==b.x;}
int main(){
    lp(i,0,p[0]-1)lp(j,0,i)if(j==0||j==i)ccm[i][j]=1;else ccm[i][j]=(ccm[i-1][j-1]+ccm[i-1][j])%p[0];
    inv[1]=1;lp(j,2,p[1]-1)inv[j]=ll(p[1]-p[1]/j)*inv[p[1]%j]%p[1];
    fac[0]=1;lp(j,1,p[1]-1)fac[j]=ll(fac[j-1])*j%p[1];
    isv[1]=1;lp(j,2,6)isv[j]=(7-7/j)*isv[7%j]%7;
    int n,k;sf("%d%d",&amp;n,&amp;k);
    static point pts[1000010];
    lp(i,1,k)sf("%d%d",&amp;pts[i].x,&amp;pts[i].y);
    pts[++k].x=0;pts[k].y=0;pts[++k].x=n;pts[k].y=0;
    sort(pts+1,pts+k+1);
    k=unique(pts+1,pts+k+1)-pts-1;
    int mx=0,cnt[2]={1,1};
    lp(i,1,k-1){
        lp(j,0,1)cnt[j]=ll(cnt[j])*sov(pts[i].x,pts[i].y,pts[i+1].x,pts[i+1].y,j)%p[j];
        int dx=pts[i+1].x-pts[i].x,dy=pts[i+1].y-pts[i].y;
        if(dy&gt;0)mx=max(mx,pts[i].y+(dx+dy)/2);
        else mx=max(mx,pts[i+1].y+(dx-dy)/2);
    }
    int ans=(ll(cnt[0])*p[1]*isv[p[1]%7]%(p[0]*p[1])+ll(cnt[1])*p[0]*inv[7]%(p[0]*p[1]))%(p[0]*p[1]);
    pf("%d %d\n",ans,mx);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
    	node*t;if(sts==stk)t=bfs++;
    	else{
    		t=*(sts--);
    		if(t-&gt;cl)*(++sts)=t-&gt;cl;
    		if(t-&gt;cr)*(++sts)=t-&gt;cr;
    	}
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
        		y=y-&gt;cr;
        	}else{
        		if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
        		y=y-&gt;cl;
        	}
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
        		else y=y-&gt;cr;
        	}else{
        		if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
        		else y=y-&gt;cl;
        	}
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
        	if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
        	else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
inline char gchr(){
    char c;
    for(c=getchar();c==' '||c=='\n';c=getchar());
    return c;
}
inline int gint(){
    int ty;sf("%d",&amp;ty);return ty;
    int t=gchr()-'0';
    for(char c=getchar();c!=' '&amp;&amp;c!='\n';c=getchar())
        t=t*10+c-'0';
    return t;
}
inline void pint(int a){
    pf("%d\n",a);return;
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
    int n=gint(),m=gint();treap::node*rt=0;
    lp(i,1,n){
        int t=gint();
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op=gchr();
        if(op=='I'){
            int x=gint(),y=gint();
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x=gint();
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
            int x=gint(),y=gint();
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l=gint(),r=gint();
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            sort(c+1,c+cs+1);
            int u=c[cs-1],ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pint(lst=ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
    	node*t;if(sts==stk)t=bfs++;
    	else{
    		t=*(sts--);
    		if(t-&gt;cl)*(++sts)=t-&gt;cl;
    		if(t-&gt;cr)*(++sts)=t-&gt;cr;
    	}
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
        		y=y-&gt;cr;
        	}else{
        		if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
        		y=y-&gt;cl;
        	}
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
        		else y=y-&gt;cr;
        	}else{
        		if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
        		else y=y-&gt;cl;
        	}
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
        	if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
        	else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
inline char gchr(){
    char c;
    for(c=getchar();c==' '||c=='\n';c=getchar());
    return c;
}
inline int gint(){
    int ty;sf("%d",&amp;ty);return ty;
    int t=gchr()-'0';
    for(char c=getchar();c!=' '&amp;&amp;c!='\n';c=getchar())
        t=t*10+c-'0';
    return t;
}
inline void pint(int a){
    pf("%d\n",a);return;
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
    int n=gint(),m=gint();treap::node*rt=0;
    lp(i,1,n){
        int t=gint();
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op=gchr();
        if(op=='I'){
       	 	int x,y;
            sf("%d%d",&amp;x,&amp;y);
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x;sf("%d",&amp;x);
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
        	int x,y;
            sf("%d%d",&amp;x,&amp;y);
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l,r;sf("%d%d",&amp;l,&amp;r);
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            sort(c+1,c+cs+1);
            int u=c[cs-1],ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pint(lst=ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
    	node*t;if(sts==stk)t=bfs++;
    	else{
    		t=*(sts--);
    		if(t-&gt;cl)*(++sts)=t-&gt;cl;
    		if(t-&gt;cr)*(++sts)=t-&gt;cr;
    	}
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
        		y=y-&gt;cr;
        	}else{
        		if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
        		y=y-&gt;cl;
        	}
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
        	if((v&gt;&gt;i)&amp;1){
        		if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
        		else y=y-&gt;cr;
        	}else{
        		if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
        		else y=y-&gt;cl;
        	}
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
        	if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
        	else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);treap::node*rt=0;
    lp(i,1,n){
        int t;sf("%d",&amp;t);
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op;for(op=getchar();op==' '||op=='\n';op=getchar());
        if(op=='I'){
       	 	int x,y;
            sf("%d%d",&amp;x,&amp;y);
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x;sf("%d",&amp;x);
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
        	int x,y;
            sf("%d%d",&amp;x,&amp;y);
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l,r;sf("%d%d",&amp;l,&amp;r);
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            sort(c+1,c+cs+1);
            int u=c[cs-1],ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pf("%d\n",lst=ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
        node*t;if(sts==stk)t=bfs++;
        else{
            t=*(sts--);
            if(t-&gt;cl)*(++sts)=t-&gt;cl;
            if(t-&gt;cr)*(++sts)=t-&gt;cr;
        }
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
                y=y-&gt;cr;
            }else{
                if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
                y=y-&gt;cl;
            }
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
                else y=y-&gt;cr;
            }else{
                if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
                else y=y-&gt;cl;
            }
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
            if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
            else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
static char buff[3000010],*ptr=buff;
char gchr(){
    for(;*ptr=='\n'||*ptr==' ';++ptr);
    return *ptr++;
}
int gint(){
    int t=gchr()-'0';
    for(;*ptr!='\n'&amp;&amp;*ptr!=' '&amp;&amp;*ptr!=0;++ptr)t=t*10+*ptr-'0';
    return t; 
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
    fread(buff,1,3000000,stdin);
    int n=gint(),m=gint();treap::node*rt=0;
    lp(i,1,n){
        int t=gint();
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op=gchr();
        if(op=='I'){
            int x=gint(),y=gint();
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x=gint();
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
            int x=gint(),y=gint();
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l=gint(),r=gint();
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            sort(c+1,c+cs+1);
            int u=c[cs-1],ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pint(lst=ans);
        }
    }
    //ps;
    return 0;
}
</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
        node*t;if(sts==stk)t=bfs++;
        else{
            t=*(sts--);
            if(t-&gt;cl)*(++sts)=t-&gt;cl;
            if(t-&gt;cr)*(++sts)=t-&gt;cr;
        }
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
                y=y-&gt;cr;
            }else{
                if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
                y=y-&gt;cl;
            }
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
                else y=y-&gt;cr;
            }else{
                if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
                else y=y-&gt;cl;
            }
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
            if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
            else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
static char buff[3000010],*ptr=buff;
inline char gchr(){
    for(;*ptr=='\n'||*ptr==' ';++ptr);
    return *ptr++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;*ptr!='\n'&amp;&amp;*ptr!=' '&amp;&amp;*ptr!=0;++ptr)t=t*10+*ptr-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
    fread(buff,1,3000000,stdin);
    int n=gint(),m=gint();treap::node*rt=0;
    lp(i,1,n){
        int t=gint();
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op=gchr();
        if(op=='I'){
            int x=gint(),y=gint();
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x=gint();
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
            int x=gint(),y=gint();
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l=gint(),r=gint();
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            sort(c+1,c+cs+1);
            int u=c[cs-1],ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pint(lst=ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
namespace trie{
    struct node{
        node*cl,*cr;int cnt;
    };
    node buff[30000010];node*bfs=buff;
    node*stk[30000010];node**sts=stk;
    inline node*newnode(node*a,node*b,int c){
        node*t;if(sts==stk)t=bfs++;
        else{
            t=*(sts--);
            if(t-&gt;cl)*(++sts)=t-&gt;cl;
            if(t-&gt;cr)*(++sts)=t-&gt;cr;
        }
        t-&gt;cl=a;t-&gt;cr=b;t-&gt;cnt=c;
        return t;
    }
    inline node*merge(node*x,node*y){
        if(!x&amp;&amp;!y)return newnode(0,0,0);
        else{
            node*a=0;if((x&amp;&amp;x-&gt;cl)||(y&amp;&amp;y-&gt;cl))a=merge(x?x-&gt;cl:0,y?y-&gt;cl:0);
            node*b=0;if((x&amp;&amp;x-&gt;cr)||(y&amp;&amp;y-&gt;cr))b=merge(x?x-&gt;cr:0,y?y-&gt;cr:0);
            node*c=newnode(a,b,0);
            if(!c-&gt;cl&amp;&amp;!c-&gt;cr)c-&gt;cnt=(x?x-&gt;cnt:0)+(y?y-&gt;cnt:0);
            return c;
        }
    }
    inline node*insert(node*&amp;x,int v){
        if(!x)x=newnode(0,0,0);
        node*y=x;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(!y-&gt;cr)y-&gt;cr=newnode(0,0,0);
                y=y-&gt;cr;
            }else{
                if(!y-&gt;cl)y-&gt;cl=newnode(0,0,0);
                y=y-&gt;cl;
            }
        }
        ++y-&gt;cnt;
    }
    inline int query(node*x,int v){
        node*y=x;int r=0;
        rp(i,19,0){
            if((v&gt;&gt;i)&amp;1){
                if(y-&gt;cl)y=y-&gt;cl,r+=(1&lt;&lt;i);
                else y=y-&gt;cr;
            }else{
                if(y-&gt;cr)y=y-&gt;cr,r+=(1&lt;&lt;i);
                else y=y-&gt;cl;
            }
        }
        return r;
    }
    inline void remove(node*&amp;x,int v,int d){
        if(d==-1){if(!--x-&gt;cnt){*(++sts)=x;x=0;}}
        else{
            if((v&gt;&gt;d)&amp;1)remove(x-&gt;cr,v,d-1);
            else remove(x-&gt;cl,v,d-1);
            if(!x-&gt;cl&amp;&amp;!x-&gt;cr){*(++sts)=x;x=0;}
        }
    }
    inline void clear(node*&amp;x){
        if(x){*(++sts)=x;x=0;}
    }
}
namespace treap{
    struct node{
        node(){};
        node*ch[2];int v,mx[2];trie::node*tr;int siz,fx;
    };
    node buff[200010];int bfs;
    inline node*newnode(int a){
        node*t=&amp;buff[bfs++];
        t-&gt;v=a;t-&gt;tr=trie::newnode(0,0,0);trie::insert(t-&gt;tr,t-&gt;v);
        t-&gt;mx[0]=a;t-&gt;mx[1]=-1;t-&gt;siz=1;t-&gt;fx=rand();t-&gt;ch[0]=t-&gt;ch[1]=0;
        return t;
    }
    inline void lupdate(node*x){
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        x-&gt;mx[0]=x-&gt;v;x-&gt;mx[1]=-1;
        static int tmp[6];int ts=0;tmp[ts++]=x-&gt;v;tmp[ts++]=-1;
        lp(i,0,1)if(x-&gt;ch[i])tmp[ts++]=x-&gt;ch[i]-&gt;mx[0],tmp[ts++]=x-&gt;ch[i]-&gt;mx[1];
        sort(tmp,tmp+ts);
        x-&gt;mx[0]=tmp[ts-1];x-&gt;mx[1]=tmp[ts-2];
    }
    inline void update(node*x){
        lupdate(x);
        trie::clear(x-&gt;tr);x-&gt;tr=trie::merge(x-&gt;ch[0]?x-&gt;ch[0]-&gt;tr:0,x-&gt;ch[1]?x-&gt;ch[1]-&gt;tr:0);
        trie::insert(x-&gt;tr,x-&gt;v);
    }
    inline void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        trie::clear(y-&gt;tr);
        y-&gt;tr=x-&gt;tr;x-&gt;tr=0;
        update(x);
        lupdate(y);
        x=y;
    }
    inline void insert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            trie::insert(x-&gt;tr,v);
            if(t&lt;=k){
                insert(x-&gt;ch[1],k-t,v);lupdate(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)rotate(x,1);
            }else{
                insert(x-&gt;ch[0],k,v);lupdate(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)rotate(x,0);
            }
        }
    }
    inline int modify(node*x,int k,int v){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(k&lt;=t)r=modify(x-&gt;ch[0],k,v);
        else if(t+1==k)r=x-&gt;v,x-&gt;v=v;
        else r=modify(x-&gt;ch[1],k-(t+1),v);
        lupdate(x);
        trie::remove(x-&gt;tr,r,19);
        trie::insert(x-&gt;tr,v);
        return r;
    }
    inline int remove(node*&amp;x){
        int r=x-&gt;v;
        if(!x-&gt;ch[0]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[1];
        }else if(!x-&gt;ch[1]){
            trie::clear(x-&gt;tr);
            x=x-&gt;ch[0];
        }else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx){
            rotate(x,0);
            remove(x-&gt;ch[1]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else{
            rotate(x,1);
            remove(x-&gt;ch[0]);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }
        return r;
    }
    inline int remove(node*&amp;x,int k){
        int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),r;
        if(t&gt;=k){
            r=remove(x-&gt;ch[0],k);
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else if(k&gt;t+1){
            r=remove(x-&gt;ch[1],k-(t+1));
            trie::remove(x-&gt;tr,r,19);
            lupdate(x);
        }else r=remove(x);
        return r;
    }
    inline void query(node*x,int l,int r,int*a,int&amp;as,trie::node**b,int&amp;bs,int*c,int&amp;cs){
        int t1=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0),t2=(x-&gt;ch[1]?x-&gt;ch[1]-&gt;siz:0);
        if(l==1&amp;&amp;r==t1+t2+1){
            b[++bs]=x-&gt;tr;
            c[++cs]=x-&gt;mx[0];
            c[++cs]=x-&gt;mx[1];
        }else if(l&lt;=t1+1&amp;&amp;r&gt;=t1+1){
            a[++as]=x-&gt;v;
            c[++cs]=x-&gt;v;
            if(l&lt;t1+1)query(x-&gt;ch[0],l,t1,a,as,b,bs,c,cs);
            if(r&gt;t1+1)query(x-&gt;ch[1],1,r-(t1+1),a,as,b,bs,c,cs);
        }else if(r&lt;t1+1)
            query(x-&gt;ch[0],l,r,a,as,b,bs,c,cs);
        else
            query(x-&gt;ch[1],l-(t1+1),r-(t1+1),a,as,b,bs,c,cs);
    }
    inline void lrotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        x-&gt;siz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;siz+=x-&gt;ch[i]-&gt;siz;
        y-&gt;siz=1;
        lp(i,0,1)if(y-&gt;ch[i])y-&gt;siz+=y-&gt;ch[i]-&gt;siz;
        x=y;
    }
    inline void linsert(node*&amp;x,int k,int v){
        if(!x)x=newnode(v);
        else{
            int t=(x-&gt;ch[0]?x-&gt;ch[0]-&gt;siz:0)+1;
            if(t&lt;=k){
                linsert(x-&gt;ch[1],k-t,v);++x-&gt;siz;
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)lrotate(x,1);
            }else{
                linsert(x-&gt;ch[0],k,v);++x-&gt;siz;
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)lrotate(x,0);
            }
        }
    }
    inline void lbuild(node*x){
        if(x-&gt;ch[0]||x-&gt;ch[1]){
            lp(i,0,1)if(x-&gt;ch[i])lbuild(x-&gt;ch[i]);
            update(x);
        }
    }
}
static char buff[3000010],*ptr=buff;
inline char gchr(){
    for(;*ptr=='\n'||*ptr==' ';++ptr);
    return *ptr++;
}
inline int gint(){
    int t=gchr()-'0';
    for(;*ptr!='\n'&amp;&amp;*ptr!=' '&amp;&amp;*ptr!=0;++ptr)t=t*10+*ptr-'0';
    return t;
}
inline void pint(int a){
    static char tmp[11];int ts=0;
    do{
        tmp[++ts]=a%10;
        a/=10;
    }while(a);
    rp(i,ts,1)putchar('0'+tmp[i]);
    putchar('\n');
}
int main(){
    fread(buff,1,3000000,stdin);
    int n=gint(),m=gint();treap::node*rt=0;
    lp(i,1,n){
        int t=gint();
        treap::linsert(rt,i-1,t);
    }
    treap::lbuild(rt);
    int lst=0;
    lp(i,1,m){
        char op=gchr();
        if(op=='I'){
            int x=gint(),y=gint();
            x=(x+lst)%n;
            y=((y+lst)&amp;1048575);
            treap::insert(rt,x,y);++n;
        }else if(op=='D'){
            int x=gint();
            x=(x+lst)%n;++x;
            treap::remove(rt,x);--n;
        }else if(op=='C'){
            int x=gint(),y=gint();
            x=(x+lst)%n;++x;
            y=((y+lst)&amp;1048575);
            treap::modify(rt,x,y);
        }else{
            int l=gint(),r=gint();
            l=(l+ll(lst))%n;++l;
            r=(r+ll(lst))%n;++r;
            static int a[200010],c[200010];
            static trie::node*b[200010];int as=0,bs=0,cs=0;
            treap::query(rt,l,r,a,as,b,bs,c,cs);
            int pc=-1;
            lp(j,1,cs)if(pc==-1||c[j]&gt;c[pc])pc=j;
            int u=-1;
            lp(j,1,cs)if(j!=pc)u=max(u,c[j]);
            int ans=0;
            lp(j,1,as)ans=max(ans,(u^a[j]));
            lp(j,1,bs)ans=max(ans,trie::query(b[j],u));
            pint(lst=ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
namespace isap{
    struct edge{int v;ll c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
    int dis[1000010],gap[1000010],vcnt;
    void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                ll t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    } 
    ll run(){
        ll r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
namespace lisa{
	vector&lt;int&gt;data;
	void add(int a){data.pb(a);}
	void build(){
		sort(data.begin(),data.end());
		data.erase(unique(data.begin(),data.end()),data.end());
	}
	int ask(int x){
		return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
	}
}int nw;
namespace seg{
	struct node{
		node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
		node*ch[2];int l,r,idx,lf;
	};
	node*build(int l,int r){
		node*ret=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			ret-&gt;ch[0]=build(l,m);
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			ret-&gt;ch[1]=build(m+1,r);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
	void link(node*x,int b,int e,int y){
		if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
			isap::add(y,x-&gt;idx,big);
			isap::add(x-&gt;idx,y,0);
		}else{
			if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
			if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
		}
	}
	node*add(node*x,int p,int y){
		node*ret=new node(x-&gt;l,x-&gt;r);
		if(x-&gt;l==x-&gt;r){
			isap::add(ret-&gt;idx,x-&gt;idx,big),isap::add(x-&gt;idx,ret-&gt;idx,0);
			ret-&gt;lf=y;isap::add(ret-&gt;idx,y,big),isap::add(y,ret-&gt;idx,0);
		}else{
			if(p&lt;=x-&gt;ch[0]-&gt;r){
				ret-&gt;ch[0]=add(x-&gt;ch[0],p,y);
				ret-&gt;ch[1]=x-&gt;ch[1];
			}else{
				ret-&gt;ch[1]=add(x-&gt;ch[1],p,y);
				ret-&gt;ch[0]=x-&gt;ch[0];
			}
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
}
int main(){
	static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
	static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
	lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
	st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
	lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
	seg::node*rt=seg::build(1,lisa::data.size());
	lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=add(rt,a[i],ct[i]);isap::vcnt=et=++nw;
	lp(i,1,n)isap::add(st,ct[i],b[i]),isap::add(ct[i],st,0),isap::add(ct[i],et,w[i]),
		isap::add(et,ct[i],0),isap::add(ct[i],tk[i],p[i]),isap::add(tk[i],ct[i],0);
	pf("%lld\n",ans-isap::run());
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
namespace isap{
    struct edge{int v;ll c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
    int dis[1000010],gap[1000010],vcnt;
    inline void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                ll t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    } 
    ll run(){
        ll r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
namespace lisa{
	vector&lt;int&gt;data;
	void add(int a){data.pb(a);}
	void build(){
		sort(data.begin(),data.end());
		data.erase(unique(data.begin(),data.end()),data.end());
	}
	int ask(int x){
		return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
	}
}int nw;
namespace seg{
	struct node{
		node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
		node*ch[2];int l,r,idx,lf;
	};
	node*build(int l,int r){
		node*ret=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			ret-&gt;ch[0]=build(l,m);
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			ret-&gt;ch[1]=build(m+1,r);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
	void link(node*x,int b,int e,int y){
		if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
			isap::add(y,x-&gt;idx,big);
			isap::add(x-&gt;idx,y,0);
		}else{
			if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
			if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
		}
	}
	node*add(node*x,int p,int y){
		node*ret=new node(x-&gt;l,x-&gt;r);
		if(x-&gt;l==x-&gt;r){
			isap::add(ret-&gt;idx,x-&gt;idx,big),isap::add(x-&gt;idx,ret-&gt;idx,0);
			ret-&gt;lf=y;isap::add(ret-&gt;idx,y,big),isap::add(y,ret-&gt;idx,0);
		}else{
			if(p&lt;=x-&gt;ch[0]-&gt;r){
				ret-&gt;ch[0]=add(x-&gt;ch[0],p,y);
				ret-&gt;ch[1]=x-&gt;ch[1];
			}else{
				ret-&gt;ch[1]=add(x-&gt;ch[1],p,y);
				ret-&gt;ch[0]=x-&gt;ch[0];
			}
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
}
int main(){
	static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
	static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
	lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
	st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
	lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
	seg::node*rt=seg::build(1,lisa::data.size());
	lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=add(rt,a[i],ct[i]);isap::vcnt=et=++nw;
	lp(i,1,n)isap::add(st,ct[i],b[i]),isap::add(ct[i],st,0),isap::add(ct[i],et,w[i]),
		isap::add(et,ct[i],0),isap::add(ct[i],tk[i],p[i]),isap::add(tk[i],ct[i],0);
	pf("%lld\n",ans-isap::run());
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
namespace isap{
    struct edge{int v;ll c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
    int dis[1000010],gap[1000010],vcnt;
    inline void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                ll t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    } 
    inline ll run(){
        ll r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
namespace lisa{
	vector&lt;int&gt;data;
	inline void add(int a){data.pb(a);}
	inline void build(){
		sort(data.begin(),data.end());
		data.erase(unique(data.begin(),data.end()),data.end());
	}
	inline int ask(int x){
		return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
	}
}int nw;
namespace seg{
	struct node{
		node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
		node*ch[2];int l,r,idx,lf;
	};
	inline node*build(int l,int r){
		node*ret=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			ret-&gt;ch[0]=build(l,m);
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			ret-&gt;ch[1]=build(m+1,r);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
	inline void link(node*x,int b,int e,int y){
		if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
			isap::add(y,x-&gt;idx,big);
			isap::add(x-&gt;idx,y,0);
		}else{
			if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
			if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
		}
	}
	inline node*add(node*x,int p,int y){
		node*ret=new node(x-&gt;l,x-&gt;r);
		if(x-&gt;l==x-&gt;r){
			isap::add(ret-&gt;idx,x-&gt;idx,big),isap::add(x-&gt;idx,ret-&gt;idx,0);
			ret-&gt;lf=y;isap::add(ret-&gt;idx,y,big),isap::add(y,ret-&gt;idx,0);
		}else{
			if(p&lt;=x-&gt;ch[0]-&gt;r){
				ret-&gt;ch[0]=add(x-&gt;ch[0],p,y);
				ret-&gt;ch[1]=x-&gt;ch[1];
			}else{
				ret-&gt;ch[1]=add(x-&gt;ch[1],p,y);
				ret-&gt;ch[0]=x-&gt;ch[0];
			}
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
}
int main(){
	static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
	static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
	lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
	st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
	lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
	seg::node*rt=seg::build(1,lisa::data.size());
	lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=add(rt,a[i],ct[i]);isap::vcnt=et=++nw;
	lp(i,1,n)isap::add(st,ct[i],b[i]),isap::add(ct[i],st,0),isap::add(ct[i],et,w[i]),
		isap::add(et,ct[i],0),isap::add(ct[i],tk[i],p[i]),isap::add(tk[i],ct[i],0);
	pf("%lld\n",ans-isap::run());
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
namespace isap{
    struct edge{int v;ll c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
    int dis[1000010],gap[1000010],vcnt;
    inline void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
    ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;int mh=vcnt-1;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
                ll t=dfs(e.v,min(g,e.c));
                e.c-=t,ev.c+=t,g-=t;
                if(!g||dis[1]==vcnt)return f-g;
            }
            if(e.c)mh=min(mh,dis[e.v]);
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[dis[u]=mh+1];
        return f-g;
    } 
    inline ll run(){
        ll r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
namespace lisa{
	vector&lt;int&gt;data;
	inline void add(int a){data.pb(a);}
	inline void build(){
		sort(data.begin(),data.end());
		data.erase(unique(data.begin(),data.end()),data.end());
	}
	inline int ask(int x){
		return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
	}
}int nw;
namespace seg{
	struct node{
		node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
		node*ch[2];int l,r,idx,lf;
	};
	inline node*build(int l,int r){
		node*ret=new node(l,r);
		if(l!=r){
			int m=(l+r)/2;
			ret-&gt;ch[0]=build(l,m);
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			ret-&gt;ch[1]=build(m+1,r);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
	inline void link(node*x,int b,int e,int y){
		if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
			isap::add(y,x-&gt;idx,big);
			isap::add(x-&gt;idx,y,0);
		}else{
			if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
			if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
		}
	}
	inline node*add(node*x,int p,int y){
		node*ret=new node(x-&gt;l,x-&gt;r);
		if(x-&gt;l==x-&gt;r){
			isap::add(ret-&gt;idx,x-&gt;idx,big),isap::add(x-&gt;idx,ret-&gt;idx,0);
			ret-&gt;lf=y;isap::add(ret-&gt;idx,y,big),isap::add(y,ret-&gt;idx,0);
		}else{
			if(p&lt;=x-&gt;ch[0]-&gt;r){
				ret-&gt;ch[0]=add(x-&gt;ch[0],p,y);
				ret-&gt;ch[1]=x-&gt;ch[1];
			}else{
				ret-&gt;ch[1]=add(x-&gt;ch[1],p,y);
				ret-&gt;ch[0]=x-&gt;ch[0];
			}
			isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
			isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
			isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
			isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
		}
		return ret;
	}
}
int main(){
	static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
	static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
	lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
	st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
	lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
	seg::node*rt=seg::build(1,lisa::data.size());
	lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=add(rt,a[i],ct[i]);isap::vcnt=et=++nw;
	lp(i,1,n)isap::add(st,ct[i],b[i]),isap::add(ct[i],st,0),isap::add(ct[i],et,w[i]),
		isap::add(et,ct[i],0),isap::add(ct[i],tk[i],p[i]),isap::add(tk[i],ct[i],0);
	pf("%lld\n",ans-isap::run());
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
namespace isap{
    struct edge{int v;ll c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
    int dis[1000010],gap[1000010],vcnt;
    inline void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
	ll dfs(int u,ll f){
        if(u==vcnt)return f;
        ll g=f;int mh=~0u&gt;&gt;2;
        lp(i,0,int(to[u].size()-1)){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c){
            	if(dis[e.v]+1==dis[u]){
                	ll t=dfs(e.v,min(g,e.c));
                	e.c-=t,ev.c+=t,g-=t;
                	if(!g||dis[1]==vcnt)return f-g;
                }
                mh=min(mh,dis[e.v]);
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    } 
    inline ll run(){
        ll r=0;gap[0]=vcnt;
        while(dis[1]&lt;vcnt)r+=dfs(1,big);
        return r;
    }
}
namespace lisa{
    vector&lt;int&gt;data;
    inline void add(int a){data.pb(a);}
    inline void build(){
        sort(data.begin(),data.end());
        data.erase(unique(data.begin(),data.end()),data.end());
    }
    inline int ask(int x){
        return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
    }
}int nw;
namespace seg{
    struct node{
        node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
        node*ch[2];int l,r,idx,lf;
    };
    inline node*build(int l,int r){
        node*ret=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            ret-&gt;ch[0]=build(l,m);
            isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
            isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
            ret-&gt;ch[1]=build(m+1,r);
            isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
            isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
        }
        return ret;
    }
    inline void link(node*x,int b,int e,int y){
        if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
            isap::add(y,x-&gt;idx,big);
            isap::add(x-&gt;idx,y,0);
        }else{
            if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
            if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
        }
    }
    inline node*add(node*x,int p,int y){
        node*ret=new node(x-&gt;l,x-&gt;r);
        if(x-&gt;l==x-&gt;r){
            isap::add(ret-&gt;idx,x-&gt;idx,big),isap::add(x-&gt;idx,ret-&gt;idx,0);
            ret-&gt;lf=y;isap::add(ret-&gt;idx,y,big),isap::add(y,ret-&gt;idx,0);
        }else{
            if(p&lt;=x-&gt;ch[0]-&gt;r){
                ret-&gt;ch[0]=add(x-&gt;ch[0],p,y);
                ret-&gt;ch[1]=x-&gt;ch[1];
            }else{
                ret-&gt;ch[1]=add(x-&gt;ch[1],p,y);
                ret-&gt;ch[0]=x-&gt;ch[0];
            }
            isap::add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
            isap::add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
            isap::add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
            isap::add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
        }
        return ret;
    }
}
int main(){
    static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
    static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
    lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
    st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
    lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
    seg::node*rt=seg::build(1,lisa::data.size());
    lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=add(rt,a[i],ct[i]);isap::vcnt=et=++nw;
    lp(i,1,n)isap::add(st,ct[i],b[i]),isap::add(ct[i],st,0),isap::add(ct[i],et,w[i]),
        isap::add(et,ct[i],0),isap::add(ct[i],tk[i],p[i]),isap::add(tk[i],ct[i],0);
    pf("%lld\n",ans-isap::run());
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
using namespace std;
typedef long long ll;
ll big=1000000000000000000ll;
struct edge{int v;ll c;};
vector&lt;edge&gt;eg;vector&lt;int&gt;to[1000010];
int dis[1000010],gap[1000010],vcnt;
void add(int u,int v,ll c){edge e;e.v=v;e.c=c;to[u].pb(eg.size());eg.pb(e);}
ll dfs(int u,ll f){
    if(u==vcnt)return f;
    ll g=f;
    lp(i,0,int(to[u].size()-1)){
        edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
        if(e.c&amp;&amp;dis[e.v]+1==dis[u]){
            ll t=dfs(e.v,min(g,e.c));
            e.c-=t,ev.c+=t,g-=t;
            if(!g||dis[1]==vcnt)return f-g;
        }
    }
    if(!--gap[dis[u]])dis[1]=vcnt;
    ++gap[++dis[u]];
    return f-g;
}
namespace lisa{
    vector&lt;int&gt;data;
    void add(int a){data.pb(a);}
    void build(){
        sort(data.begin(),data.end());
        data.erase(unique(data.begin(),data.end()),data.end());
    }
    int ask(int x){
        return lower_bound(data.begin(),data.end(),x)-data.begin()+1;
    }
}int nw;
namespace seg{
    struct node{
        node(int a,int b){l=a;r=b;ch[0]=ch[1]=0;idx=++nw;lf=0;}
        node*ch[2];int l,r,idx,lf;
    };
    node*build(int l,int r){
        node*ret=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            ret-&gt;ch[0]=build(l,m);
            add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
            add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
            ret-&gt;ch[1]=build(m+1,r);
            add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
            add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
        }
        return ret;
    }
    void link(node*x,int b,int e,int y){
        if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r){
            add(y,x-&gt;idx,big);
            add(x-&gt;idx,y,0);
        }else{
            if(b&lt;=x-&gt;ch[0]-&gt;r)link(x-&gt;ch[0],b,e,y);
            if(e&gt;x-&gt;ch[0]-&gt;r)link(x-&gt;ch[1],b,e,y);
        }
    }
    node*ins(node*x,int p,int y){
        node*ret=new node(x-&gt;l,x-&gt;r);
        if(x-&gt;l==x-&gt;r){
            add(ret-&gt;idx,x-&gt;idx,big),add(x-&gt;idx,ret-&gt;idx,0);
            ret-&gt;lf=y;add(ret-&gt;idx,y,big),add(y,ret-&gt;idx,0);
        }else{
            if(p&lt;=x-&gt;ch[0]-&gt;r){
                ret-&gt;ch[0]=ins(x-&gt;ch[0],p,y);
                ret-&gt;ch[1]=x-&gt;ch[1];
            }else{
                ret-&gt;ch[1]=ins(x-&gt;ch[1],p,y);
                ret-&gt;ch[0]=x-&gt;ch[0];
            }
            add(ret-&gt;idx,ret-&gt;ch[0]-&gt;idx,big);
            add(ret-&gt;ch[0]-&gt;idx,ret-&gt;idx,0);
            add(ret-&gt;idx,ret-&gt;ch[1]-&gt;idx,big);
            add(ret-&gt;ch[1]-&gt;idx,ret-&gt;idx,0);
        }
        return ret;
    }
}
int main(){
    static int n,a[5010],b[5010],w[5010],l[5010],r[5010],p[5010];
    static int ct[5010],tk[5010],st,et;sf("%d",&amp;n);ll ans=0;
    lp(i,1,n)sf("%d%d%d%d%d%d",&amp;a[i],&amp;b[i],&amp;w[i],&amp;l[i],&amp;r[i],&amp;p[i]),ans+=b[i]+w[i];
    st=++nw;lp(i,1,n)ct[i]=++nw,tk[i]=++nw,lisa::add(a[i]),lisa::add(l[i]),lisa::add(r[i]);
    lisa::build();lp(i,1,n)a[i]=lisa::ask(a[i]),l[i]=lisa::ask(l[i]),r[i]=lisa::ask(r[i]);
    seg::node*rt=seg::build(1,lisa::data.size());
    lp(i,1,n)link(rt,l[i],r[i],tk[i]),rt=ins(rt,a[i],ct[i]);vcnt=et=++nw;
    lp(i,1,n)add(st,ct[i],b[i]),add(ct[i],st,0),add(ct[i],et,w[i]),
        add(et,ct[i],0),add(ct[i],tk[i],p[i]),add(tk[i],ct[i],0);
    gap[0]=vcnt;while(dis[1]&lt;vcnt)ans-=dfs(1,big);pf("%lld\n",ans);
    return 0;
}
/*
10
0 1 7 3 9 2
7 4 0 9 10 5
1 0 4 2 10 2
7 9 1 5 7 2
6 3 5 3 6 2
6 6 4 1 8 1
6 1 6 0 6 5
2 2 5 0 9 3
5 1 3 0 2 5
5 6 7 1 1 2
*/</pre><pre></pre><h2>Problem3221</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int n,q;
namespace segment{
	struct node{
		inline node(node*a,node*b,int c,int d,ll e,ll f,ll g){
			ch[0]=a;ch[1]=b;
			l=c;r=d;
			d1=e;d2=f;
			sum=g;
		}
		node*ch[2];int l,r;ll d1,d2,sum;
	};
	inline node*build(int l,int r){
		if(l==r)return new node(0,0,l,r,0,0,0);
		else{
			int m=(l+r)/2;
			return new node(build(l,m),build(m+1,r),l,r,0,0,0);
		}
	}
	inline ll query(node*x,int l,int r){
		//if(x-&gt;l==1&amp;&amp;x-&gt;r==n)pf("[%d,%d]\n",l,r);
		ll fir=x-&gt;d1+(l-x-&gt;l)*x-&gt;d2;
		ll num=r-l+1;
		ll del=x-&gt;d2;
		ll ret=num*fir+num*(num-1)/2*del;
		if(l==x-&gt;l&amp;&amp;r==x-&gt;r){
			return ret+x-&gt;sum;
		}else{
			int m=x-&gt;ch[0]-&gt;r;
			if(r&lt;=m){
				return ret+query(x-&gt;ch[0],l,r);
			}else if(l&gt;m){
				return ret+query(x-&gt;ch[1],l,r);
			}else{
				return ret+query(x-&gt;ch[0],l,m)+query(x-&gt;ch[1],m+1,r);
			}
		}
	}
	inline node*modify(node*x,int l,int r,ll d1,ll d2){
		//if(x-&gt;l==1&amp;&amp;x-&gt;r==n)pf("{%d,%d,%lld,%lld}\n",l,r,d1,d2);
		if(l==x-&gt;l&amp;&amp;r==x-&gt;r)return new node(x-&gt;ch[0],x-&gt;ch[1],x-&gt;l,x-&gt;r,x-&gt;d1+d1,x-&gt;d2+d2,x-&gt;sum);
		else{
			ll fir=d1;ll num=r-l+1;ll del=d2;
			ll ret=num*fir+num*(num-1)/2*del;
			int m=x-&gt;ch[0]-&gt;r;
			if(r&lt;=m)return new node(modify(x-&gt;ch[0],l,r,d1,d2),x-&gt;ch[1],x-&gt;l,x-&gt;r,x-&gt;d1,x-&gt;d2,x-&gt;sum+ret);
			else if(l&gt;m)return new node(x-&gt;ch[0],modify(x-&gt;ch[1],l,r,d1,d2),x-&gt;l,x-&gt;r,x-&gt;d1,x-&gt;d2,x-&gt;sum+ret);
			else{
				ll d3=d1+(m-l+1)*d2;
				return new node(modify(x-&gt;ch[0],l,m,d1,d2),modify(x-&gt;ch[1],m+1,r,d3,d2),x-&gt;l,x-&gt;r,x-&gt;d1,x-&gt;d2,x-&gt;sum+ret);
			}
		}
	}
	void print(node*x){
		if(!x)return;
		pf("[%d,%d,%lld,%lld,%lld]\n",x-&gt;l,x-&gt;r,x-&gt;d1,x-&gt;d2,x-&gt;sum);
		lp(i,0,1)print(x-&gt;ch[i]);
	}
}
namespace tree{
	vector&lt;int&gt;to[100010];
	inline void init(){
		lp(i,1,n-1){
			int u,v;sf("%d%d",&amp;u,&amp;v);
			to[u].pb(v);
			to[v].pb(u);
		}
	}
	int siz[100010],dep[100010],chd[100010],prt[100010],pos[100010],top[100010],nw;
	inline void dfs1(int u,int p){
		prt[u]=p;dep[u]=dep[p]+1;siz[u]=1;
		vp(i,to[u]){
			int v=to[u][i];
			if(v!=p){
				dfs1(v,u);
				siz[u]+=siz[v];
				if(siz[v]&gt;siz[chd[u]])chd[u]=v;
			}
		}
	}
	inline void dfs2(int u,int a){
		pos[u]=++nw;top[u]=a;
		if(chd[u])dfs2(chd[u],a);
		vp(i,to[u]){
			int v=to[u][i];
			if(v!=prt[u]&amp;&amp;v!=chd[u]){
				dfs2(v,v);
			}
		}
	}
	vector&lt;segment::node*&gt;save;segment::node*now;
	inline void build(){
		dfs1(1,0);
		dfs2(1,1);
		//lp(i,1,n)pf("[%d,%d,%d,%d,%d,%d]\n",siz[i],dep[i],chd[i],prt[i],pos[i],top[i]);
		save.pb(now=segment::build(1,n));
		//segment::print(now);
	}
	inline void load(int x){
		//pf("(%d)",x);
		now=save[x];
	}
	inline void tmodify(int u,int v,ll d1,ll d2){
		//pf("{%d,%d,%lld,%lld}\n",u,v,d1,d2);
		//segment::print(now);
		//pf("\n");
		while(top[u]!=top[v]){
			now=segment::modify(now,pos[top[u]],pos[u],d1+d2*(pos[u]-pos[top[u]]),-d2);
			d1+=(pos[u]-pos[top[u]]+1)*d2;
			u=prt[top[u]];
		}
		now=segment::modify(now,pos[v],pos[u],d1+d2*(pos[u]-pos[v]),-d2);
		//segment::print(now);
		//pf("---------\n\n");
	}
	inline void modify(int u,int v,ll d1,ll d2){
		int tu=u,tv=v;
		while(top[tu]!=top[tv]){
			if(dep[top[tu]]&lt;dep[top[tv]])swap(tu,tv);
			tu=prt[top[tu]];
		}
		if(dep[tu]&gt;dep[tv])swap(tu,tv);
		int w=tu;
		tmodify(u,w,d1,d2);
		tmodify(v,w,d1+d2*(dep[u]-dep[w]+dep[v]-dep[w]),-d2);
		tmodify(w,w,-d1-d2*(dep[u]-dep[w]),0);
		save.pb(now);
	}
	inline ll query(int u,int v){
		ll ret=0;
		while(top[u]!=top[v]){
			if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
			ret+=segment::query(now,pos[top[u]],pos[u]);
			u=prt[top[u]];
		}
		if(dep[u]&lt;dep[v])swap(u,v);
		return ret+segment::query(now,pos[v],pos[u]);
	}
}
int main(){
	sf("%d%d",&amp;n,&amp;q);
	tree::init();
	tree::build();
	ll lastans=0;
	lp(i,1,q){
		static char op[11];
		sf("%s",op);
		if(op[0]=='c'){
			ll x,y,a,b;
			sf("%lld%lld%lld%lld",&amp;x,&amp;y,&amp;a,&amp;b);
			x=(x^lastans);y=(y^lastans);
			tree::modify(x,y,a,b);
		}else if(op[0]=='q'){
			ll x,y;sf("%lld%lld",&amp;x,&amp;y);
			x=(x^lastans);y=(y^lastans);
			pf("%lld\n",lastans=tree::query(x,y));
		}else{
			ll x;sf("%lld",&amp;x);
			x=(x^lastans);
			tree::load(x);
		}
	}
	return 0;
}
/*
5 7
1 2
2 3
3 4
4 5
c 1 4 2 3
c 2 3 5 10
q 1 3
l 1
q 1 3
*/</pre><pre></pre><h2>Problem3223</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

const int MXN = 100003;
int val[MXN], siz[MXN], prt[MXN], chd[MXN][2];
bool rev[MXN];
int sam[MXN], sum[MXN], mxL[MXN], mxR[MXN], mxM[MXN];
int queSiz = 1, stk[MXN], stkSiz = 0, root = 0;

int a[100002], n, m;

inline void pushUp(int x) { // 维护自底向上的标记。 
    siz[x] = siz[chd[x][0]] + siz[chd[x][1]] + 1;
}

inline void pushDown(int x) { // 维护自顶向下的标记。 
    if (rev[x]) {
        rev[chd[x][0]] = !rev[chd[x][0]];
        rev[chd[x][1]] = !rev[chd[x][1]];
        std::swap(chd[x][0], chd[x][1]);
        rev[x] = false;
    }
}

inline void rotate(int x, int d) {
    int y = prt[x], z = prt[y];
    pushDown(y); pushDown(x);
    chd[y][!d] = chd[x][d]; prt[chd[x][d]] = y; // 维护 y 和 x 的孩子的关系。 
    prt[x] = z; chd[z][y != chd[z][0]] = x; // 维护 x 和 z的关系 
    prt[y] = x; chd[x][d] = y;// 维护 x 和 y 的关系。 
    pushUp(y);
}

void splay(int x, int p) { // 把 x 伸展到 p 的下面。 
    while (prt[x] != p) {
        int y = prt[x], z = prt[y];
        /*
        if (z == p) rotate(x, chd[y][0] == x); // 单旋。 
        else
            if (y == chd[z][0])
                if (x == chd[y][0]) rotate(y, 1), rotate(x, 1); //  一字旋转。 
                else rotate(x, 0), rotate(x, 1); // 之字旋转。 
            else
                if (x == chd[y][1]) rotate(y, 0), rotate(x, 0); //  一字旋转。       
                else rotate(x, 1), rotate(x, 0); // 之字旋转。 
        */
        rotate(x, chd[y][0] == x);
    }
    pushUp(x); // 最后对 x 进行维护，减少对 x 的多余维护。 
    if (p == 0) root = x;
}

void select(int k, int p) { // 把第 k 个元素伸展到 p 的下面。 
    int x = root;
    while (true) {
        pushDown(x); // 要先维护 x ，因为 x 的左孩子的 siz 可能改变。 
        if (k == siz[chd[x][0]] + 1) break;
        if (k &lt; siz[chd[x][0]] + 1)  x = chd[x][0];
        else k -= siz[chd[x][0]] + 1, x = chd[x][1];
    }
    splay(x, p);
}


void reverse(int l, int r) {
    select(l - 1, 0); select(r + 1, root);
    rev[chd[chd[root][1]][0]] = !rev[chd[chd[root][1]][0]];
    splay(chd[chd[root][1]][0], 0);
}

void build(int &amp;x, int *l, int *r) {
    if (l &gt; r) x = 0;
    else {
        int *m = l + ((r - l) &gt;&gt; 1);
        x = queSiz++;
        val[x] = *m; siz[x] = 1;
        build(chd[x][0], l, m - 1); build(chd[x][1], m + 1, r);
        prt[chd[x][0]] = prt[chd[x][1]] = x;
        pushUp(x);
    }
}  

void print(int x) {
    if (x != 0) {
        pushDown(x);
        print(chd[x][0]);
        printf("%d\40", val[x]);
        print(chd[x][1]);
        if (x == root)
            printf("\n");
    }
}


int main() {
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 0; i &lt;= n + 1; ++i)
        a[i] = i;
    build(root, a, a + n + 1);
    for (int i = 0; i &lt; m; ++i) {
        int l, r;
        scanf("%d%d", &amp;l, &amp;r);
        reverse(l + 1, r + 1);
    }
    select(1, 0);
    select(n + 2, root);
    print(chd[chd[root][1]][0]);
    //system("pause");
    return 0;
}

</pre><pre></pre><h2>Problem3224</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cstdio&gt;
 
const int MXN = 100000;
int val[MXN], siz[MXN], chd[MXN][2], fix[MXN];
int tot = 1, stk[MXN], stkSiz = 0, root = 0;
 
inline void rotate(int &amp;x, int d) {
    int y = chd[x][!d];  chd[x][!d] = chd[y][d]; chd[y][d] = x;
    siz[y] = siz[x]; siz[x] = siz[chd[x][0]] + siz[chd[x][1]] + 1;
    x = y;
}
 
void insert(int &amp;x,int v) {
    if (x == 0) {
        if (stkSiz != 0) x = stk[--stkSiz], chd[x][0] = chd[x][1] = 0;
        else x = tot++;
        val[x] = v; siz[x] = 1; fix[x] = std::rand();
    } else {
        int d = v &gt; val[x]; insert(chd[x][d], v); ++siz[x];
        if (fix[chd[x][d]] &lt; fix[x]) rotate(x, !d);
    }
}
 
void _delete(int &amp;x,int v){
    if (v == val[x])
        if (!chd[x][0] || !chd[x][1])
            stk[stkSiz++] = x, x = chd[x][!chd[x][0]];
        else {
            int d = fix[chd[x][0]] &gt; fix[chd[x][1]];
            rotate(x, !d); _delete(chd[x][!d], v); --siz[x];
        }
    else
        _delete(chd[x][v &gt; val[x]], v), --siz[x];
}
 
int select(int x, int k) {
    if (k &lt;= siz[chd[x][0]]) return select(chd[x][0], k);
    else if (k == siz[chd[x][0]] + 1) return val[x];
    else return select(chd[x][1], k - (siz[chd[x][0]] + 1));
}
 
int rank(int x, int v) {
    if (x == 0) return 1;   
    if (v &lt;= val[x]) return rank(chd[x][0], v);
    else return rank(chd[x][1] ,v) + siz[chd[x][0]] + 1;
}
 
int pred(int x, int v) {
    if (x == 0) return -0x7fffffff;
    if (v &lt;= val[x]) return pred(chd[x][0], v);
    else return std::max(val[x], pred(chd[x][1], v));
}
 
int succ(int x, int v) {
    if (x == 0) return 0x7fffffff;
    if (v &gt;= val[x]) return succ(chd[x][1], v);
    else return std::min(val[x], succ(chd[x][0], v));
}
 
void print(int x) {
    if (x) {
        print(chd[x][0]);
        std::printf("[ID%d,VA%d,SZ%d,C0%d,C1%d,FX%d]\40", x, val[x], siz[x], chd[x][0], chd[x][1], fix[x]);
        print(chd[x][1]);
    }
}
 
int main() {
    //std::srand(std::time(0));;
    int n, op, v;
    std::scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; ++i) {
        std::scanf("%d%d", &amp;op, &amp;v);
        switch(op) {
            case 1 : insert(root, v); break;
            case 2 : _delete(root, v); break;
            case 3 : std::printf("%d\n", rank(root, v)); break;
            case 4 : std::printf("%d\n", select(root, v)); break;
            case 5 : std::printf("%d\n", pred(root, v)); break;
            case 6 : std::printf("%d\n", succ(root, v));; break;
        }
        //std::printf("\n");
        //print(root);
        //std::printf("\n");
    }
    //system("pause");
    return 0;
}</pre><pre></pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
int sam[500010],rev[500010],val[500010];
void build(int x,int l,int r){
	sam[x]=-1;rev[x]=0;
	if(l!=r){
		int m=(l+r)/2;
		build(x*2,l,m);
		build(x*2+1,m+1,r);
	}
}
void down(int x,int l,int r){
	if(sam[x]!=-1){
		if(l!=r)sam[x*2]=sam[x*2+1]=sam[x],rev[x*2]=rev[x*2+1]=0;
		else val[x]=sam[x];
		sam[x]=-1;
	}
	if(rev[x]){
		if(l!=r)rev[x*2]^=1,rev[x*2+1]^=1;
		else val[x]^=1;
		rev[x]=0;
	}
}
void same(int x,int l,int r,int b,int e,int t){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)sam[x]=t;
	else{
		int m=(l+r)/2;
		if(b&lt;=m)same(x*2,l,m,b,e,t);
		if(e&gt;m)same(x*2+1,m+1,r,b,e,t);
	}
}
void rever(int x,int l,int r,int b,int e){
	down(x,l,r);
	if(b&lt;=l&amp;&amp;e&gt;=r)rev[x]=1;
	else{
		int m=(l+r)/2;
		if(b&lt;=m)rever(x*2,l,m,b,e);
		if(e&gt;m)rever(x*2+1,m+1,r,b,e);
	}
}
struct rag{char l,r;int a,b;};
pair&lt;int,int&gt; getrag(){
	rag t;
	for(t.l=getchar();t.l!='['&amp;&amp;t.l!='(';t.l=getchar());
	sf("%d",&amp;t.a);
	for(char c=getchar();c!=',';c=getchar());
	sf("%d",&amp;t.b);
	for(t.r=getchar();t.r!=']'&amp;&amp;t.r!=')';t.r=getchar());
	int va=t.a*2,vb=t.b*2;
	if(t.l=='(')++va;
	if(t.r==')')--vb;
	return mp(va,vb);
}
int access(int x,int l,int r,int p){
	down(x,l,r);
	if(l==r)return val[x];
	else{
		int m=(l+r)/2;
		if(p&lt;=m)return access(x*2,l,m,p);
		else return access(x*2+1,m+1,r,p);
	}
}
char getop(){
	char c;
	for(c=getchar();c!='U'&amp;&amp;c!='I'&amp;&amp;c!='D'&amp;&amp;c!='C'&amp;&amp;c!='S'&amp;&amp;c!=EOF;c=getchar());
	return c;
}
int main(){
	build(1,0,65536*2+1);
	while(true){
		char op=getop();if(op==EOF)break;pair&lt;int,int&gt;rg=getrag();
		if(op=='U'){
			same(1,0,65536*2+1,rg.first,rg.second,1);
		}else if(op=='I'){
			if(rg.first!=0)same(1,0,65536*2+1,0,rg.first-1,0);
			same(1,0,65536*2+1,rg.second+1,65536*2+1,0);
		}else if(op=='D'){
			same(1,0,65536*2+1,rg.first,rg.second,0);
		}else if(op=='S'){
			rever(1,0,65536*2+1,rg.first,rg.second);
		}else{
			if(rg.first!=0)same(1,0,65536*2+1,0,rg.first-1,0);
			same(1,0,65536*2+1,rg.second+1,65536*2+1,0);
			rever(1,0,65536*2+1,rg.first,rg.second);
		}
	}
	vector&lt;int&gt;ans;
	vector&lt;rag&gt;rgs;
	lp(i,0,65536*2)ans.pb(access(1,0,65536*2+1,i));
	vp(i,ans){
		if(!ans[i])continue;
		int j=i;
		while(j+1&lt;ans.size()&amp;&amp;ans[j+1])++j;
		//pf("[%d,%d]\n",i,j);
		rag rr;
		if(i%2==0){
			rr.l='[';
			rr.a=i/2;
		}else{
			rr.l='(';
			rr.a=(i-1)/2;
		}
		if(j%2==0){
			rr.r=']';
			rr.b=j/2;
		}else{
			rr.r=')';
			rr.b=(j+1)/2;
		}
		rgs.pb(rr);
		i=j;
	}
	if(rgs.empty())pf("empty set\n");
	else{
		vp(i,rgs){
			pf("%c%d,%d%c ",rgs[i].l,rgs[i].a,rgs[i].b,rgs[i].r);
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem3230</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;sstream&gt;
struct sa{
    char s[100010];int n,m,sa[100010],t[2][100010],*r,*g,c[100010],h[100010],mh[100010][21],pw[100010];
    ll dl[100010];
    void build(){
        m=256;r=t[0];g=t[1];
        lp(i,1,m)c[i]=0;
        lp(i,1,n)++c[r[i]=s[i]];
        lp(i,1,m)c[i]+=c[i-1];
        rp(i,n,1)sa[c[r[i]]--]=i;
        for(int j=1,p=0;j&lt;=n;j*=2,p=0){
            lp(i,n-j+1,n)g[++p]=i;
            lp(i,1,n)if(sa[i]&gt;j)g[++p]=sa[i]-j;
            lp(i,1,m)c[i]=0;
            lp(i,1,n)++c[r[g[i]]];
            lp(i,1,m)c[i]+=c[i-1];
            rp(i,n,1)sa[c[r[g[i]]]--]=g[i];
            swap(g,r);p=r[sa[1]]=1;
            lp(i,2,n)if(g[sa[i]]==g[sa[i-1]]&amp;&amp;sa[i]+j&lt;=n&amp;&amp;sa[i-1]+j&lt;=n&amp;&amp;
                g[sa[i]+j]==g[sa[i-1]+j])r[sa[i]]=p;
            else r[sa[i]]=++p;
            if((m=p)==n)break;
        }
        for(int i=1,j=0;i&lt;=n;++i,j?--j:j){
            if(r[i]!=1){
                while(i+j&lt;=n&amp;&amp;sa[r[i]-1]+j&lt;=n&amp;&amp;s[i+j]==s[sa[r[i]-1]+j])++j;
                h[r[i]]=j;
            }else h[r[i]]=0;
        }
        lp(i,1,n)mh[i][0]=h[i];
        for(int j=1;(1&lt;&lt;j)&lt;=n;++j)
        	for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)
        		mh[i][j]=min(mh[i][j-1],mh[i+(1&lt;&lt;(j-1))][j-1]);
        pw[1]=0;
        lp(i,2,n)if((1&lt;&lt;(pw[i-1]+1))&lt;=i)pw[i]=pw[i-1]+1;
        	else pw[i]=pw[i-1];
        dl[1]=n-sa[1]+1;
        lp(i,2,n)dl[i]=dl[i-1]+n-sa[i]+1-h[i];
    }
    int lcp(int x,int y){
    	if(x==y)return n-x+1;
    	x=r[x];y=r[y];
    	if(x&gt;y)swap(x,y);++x;
    	int t=pw[y-x+1];
    	return min(mh[x][t],mh[y-(1&lt;&lt;t)+1][t]);
    }
    pair&lt;int,int&gt;kth(ll x){
    	if(dl[n]&lt;x)return mp(-1,-1);
    	int y=0,z=n;
    	while(y+1&lt;z){
    		int w=(y+z)/2;
    		if(dl[w]&lt;x)y=w;
    		else z=w;
    	}
    	if(y)x-=dl[y];
    	return mp(sa[y+1],sa[y+1]+h[y+1]+x-1);
    }
}sa1,sa2;
int main(){
	int n,q;static char s[100010];
	sf("%d%d%s",&amp;n,&amp;q,s+1);
	sa1.n=sa2.n=n;
	lp(i,1,n)sa1.s[i]=sa2.s[i]=s[i];
	reverse(sa2.s+1,sa2.s+n+1);
	sa1.build();sa2.build();
	lp(i,1,q){
		ll x,y;sf("%lld%lld",&amp;x,&amp;y);
		pair&lt;int,int&gt;xx=sa1.kth(x),yy=sa1.kth(y);
		if(xx.first==-1||yy.first==-1)pf("-1\n");
		else{
			//pf("[%d,%d],[%d,%d]\n",xx.first,xx.second,yy.first,yy.second);
			int t1=sa1.lcp(xx.first,yy.first);
			t1=min(t1,min(xx.second-xx.first+1,yy.second-yy.first+1));
			int t2=sa2.lcp(n-xx.second+1,n-yy.second+1);
			t2=min(t2,min(xx.second-xx.first+1,yy.second-yy.first+1));
			pf("%lld\n",ll(t1)*ll(t1)+ll(t2)*ll(t2));
		}
	}
    return 0;
}</pre><pre></pre><h2>Problem3231</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
ll N,M,P,K;
struct mat{
    mat(int _n){
        n=_n;
        lp(i,1,n)lp(j,1,n)m[i][j]=0;
    }
    ll n,m[107][107];
};
mat mul(const mat&amp;a,const mat&amp;b){
    mat c(a.n);
    lp(i,1,a.n)lp(j,1,a.n)lp(k,1,a.n)c.m[i][j]=(c.m[i][j]+ll(a.m[i][k])*b.m[k][j])%P;
    return c;
}
mat mypow(mat a,ll b){
    mat r(a.n);lp(i,1,a.n)lp(j,1,a.n)r.m[i][j]=(i==j);
    while(b){
        if(b&amp;1)r=mul(r,a);
        a=mul(a,a);
        b&gt;&gt;=1;
    }
    return r;
}
ll B[21],C[21];
ll calc(ll n){
	mat tmp1(K+1);
	lp(j,1,K-1)tmp1.m[j+1][j]=1;
	lp(i,1,K)tmp1.m[i][K]=C[K-i+1]%P;
	tmp1.m[K+1][K+1]=1;
	if(K!=1)tmp1.m[2][K+1]=1;
	else tmp1.m[1][K+1]=C[1];
	tmp1=mypow(tmp1,n-1);
	mat tmp2(K+1);
	lp(j,1,K)tmp2.m[1][j]=B[j]%P;
	tmp2.m[1][K+1]=B[1]%P;
	tmp2=mul(tmp2,tmp1);
	return tmp2.m[1][K+1];
}
int main(){
	sf("%lld",&amp;K);
	lp(i,1,K)sf("%lld",&amp;B[i]);
	lp(i,1,K)sf("%lld",&amp;C[i]);
	sf("%lld%lld%lld",&amp;M,&amp;N,&amp;P);
	if(P*P&lt;0)ps;
	pf("%lld\n",(calc(N)-(M!=1?calc(M-1):0)+P)%P);
	return 0;
}
/*
15
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
1 10000000 1000000007
*/
</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{
        edge(int a,double b):v(a),c(b){}
        int v;double c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
    void add(int u,int v,double c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        //pf("(%d,%d,%lf)\n",u,v,c);
    }
    double dfs(int u,double f){
        //pf("((%d,%lf))\n",u,f);
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(fab(e.c)&gt;eps&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                //pf("(((%d,%lf)))\n",u,f);
                e.c-=t,ev.c+=t,g-=t;
                if(fab(g)&lt;eps||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,10000);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}
/*
2 1
1
1
1
10
1
1 1
1 1
*/
/*
1 1
1
1
1
1 1
*/
</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{
        edge(int a,double b):v(a),c(b){}
        int v;double c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
    void add(int u,int v,double c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        //pf("(%d,%d,%lf)\n",u,v,c);
    }
    double dfs(int u,double f){
        //pf("((%d,%lf))\n",u,f);
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(fab(e.c)&gt;eps&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                //pf("(((%d,%lf)))\n",u,f);
                e.c-=t,ev.c+=t,g-=t;
                if(fab(g)&lt;eps)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,10000);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
	struct edge{int v;double c;};
	vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
	void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
	int vcnt,dis[100010],gap[100010];
	void clear(){lp(i,1,vcnt)dis[i]=gap[i]=0,to[i].clear();eg.clear();gap[0]=vcnt;}
	double dfs(int u,double f){
		if(u==vcnt)return f;
		double g=f;
		vp(i,to[u]){
			edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
			if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
				double t=dfs(e.v,min(g,e.c));
				g-=t,e.c-=t,ev.c+=t;
				if(g&lt;1e-6||dis[1]==vcnt)return f-g;
			}
		}
		if(!--gap[dis[u]])dis[1]=vcnt;
		++gap[++dis[u]];
		return f-g;
	}
	double solve(){
		double r=0;
		while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
		return r;
	}
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{
        edge(int a,double b):v(a),c(b){}
        int v;double c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
    void add(int u,int v,double c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        //pf("(%d,%d,%lf)\n",u,v,c);
    }
    double dfs(int u,double f){
        //pf("((%d,%lf))\n",u,f);
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(fab(e.c)&gt;eps&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                //pf("(((%d,%lf)))\n",u,f);
                e.c-=t,ev.c+=t,g-=t;
                if(fab(g)&lt;eps||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{
        edge(int a,double b):v(a),c(b){}
        int v;double c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
    void add(int u,int v,double c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        //pf("(%d,%d,%lf)\n",u,v,c);
    }
    double dfs(int u,double f){
        //pf("((%d,%lf))\n",u,f);
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&gt;eps&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                //pf("(((%d,%lf)))\n",u,f);
                e.c-=t,ev.c+=t,g-=t;
                if(g&lt;eps||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{
        edge(int a,double b):v(a),c(b){}
        int v;double c;
    };
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
    void add(int u,int v,double c){
        to[u].pb(eg.size());
        eg.pb(edge(v,c));
        //pf("(%d,%d,%lf)\n",u,v,c);
    }
   double dfs(int u,double f){
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(g&lt;1e-6||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{int v;double c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=0;
        eg.clear();gap[0]=vcnt;
    }
 void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
   double dfs(int u,double f){
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(g&lt;1e-6||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
double fab(double a){return a&gt;0?a:-a;}
double eps=1e-6,inf=1e100;
namespace isap{
    struct edge{int v;double c;};
    vector&lt;edge&gt;eg;vector&lt;int&gt;to[100010];
    int dis[100010],vcnt,gap[100010];
    void clear(){
        lp(i,0,vcnt)to[i].clear(),dis[i]=gap[i]=0;
        eg.clear();gap[0]=vcnt;
    }
 void add(int u,int v,double c){edge t;t.v=v;t.c=c;to[u].pb(eg.size());eg.pb(t);}
   double dfs(int u,double f){
        if(u==vcnt)return f;
        double g=f;
        vp(i,to[u]){
            edge&amp;e=eg[to[u][i]],&amp;ev=eg[to[u][i]^1];
            if(e.c&gt;1e-6&amp;&amp;dis[u]==dis[e.v]+1){
                double t=dfs(e.v,min(g,e.c));
                g-=t,e.c-=t,ev.c+=t;
                if(g&lt;1e-6||dis[1]==vcnt)return f-g;
            }
        }
        if(!--gap[dis[u]])dis[1]=vcnt;
        ++gap[++dis[u]];
        return f-g;
    }
    double solve(){
        double r=0;
        while(dis[1]&lt;vcnt)r+=dfs(1,~0u&gt;&gt;1);
        //pf("[%lf,%d]\n",r,vcnt);
        return r;
    }
}
namespace mcut{
    double wei[100010];vector&lt;int&gt;to[100010];int vcnt;
    void clear(){
        lp(i,1,vcnt)to[i].clear();
    }
    void add(int u,int v){
        to[u].pb(v);
    }
    double solve(){
        isap::vcnt=vcnt+2;isap::clear();
        double ret=0;
        lp(i,1,vcnt)if(wei[i]&gt;eps)isap::add(1,i+1,wei[i]),isap::add(i+1,1,0),ret+=wei[i];
        else isap::add(i+1,vcnt+2,-wei[i]),isap::add(vcnt+2,i+1,0);
        lp(i,1,vcnt)vp(j,to[i])isap::add(i+1,to[i][j]+1,inf),isap::add(to[i][j]+1,i+1,0);
        return ret-isap::solve();
    }
}
int n,m;double lr[60][60],ud[60][60],wt[60][60];
int idnw,id[60][60],idlr[60][60],idud[60][60];
double calc(double t){
    mcut::vcnt=idnw;
    mcut::clear();
    lp(i,1,n)lp(j,1,m){
        mcut::wei[id[i][j]]=wt[i][j]-(lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1])*t;
        //pf("[%lf,%lf]\n",lr[i][j]+lr[i+1][j]+ud[i][j]+ud[i][j+1],t);
    }
    lp(i,1,n+1)lp(j,1,m){
        mcut::wei[idlr[i][j]]=lr[i][j]*t*2;
        if(i!=1&amp;&amp;i!=n+1)mcut::add(idlr[i][j],id[i-1][j]),mcut::add(idlr[i][j],id[i][j]);
        else mcut::wei[idlr[i][j]]=0;
    }
    lp(i,1,n)lp(j,1,m+1){
        mcut::wei[idud[i][j]]=ud[i][j]*t*2;
        if(j!=1&amp;&amp;j!=m+1)mcut::add(idud[i][j],id[i][j-1]),mcut::add(idud[i][j],id[i][j]);
        else mcut::wei[idud[i][j]]=0;
    }
    return mcut::solve();
}
int main(){
    sf("%d%d",&amp;n,&amp;m);
    lp(i,1,n)lp(j,1,m)sf("%lf",&amp;wt[i][j]),id[i][j]=++idnw;
    lp(i,1,n+1)lp(j,1,m)sf("%lf",&amp;lr[i][j]),idlr[i][j]=++idnw;
    lp(i,1,n)lp(j,1,m+1)sf("%lf",&amp;ud[i][j]),idud[i][j]=++idnw;
    //pf("%lf\n",calc(0.2));ps;
    double l=0,r=1;
    while(calc(r)&gt;eps)r*=2;
    while(r-l&gt;eps){
        double m=(l+r)/2;
        if(calc(m)&gt;eps)l=m;
        else r=m;
    }
    pf("%.3lf\n",l);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3236</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
namespace input{
	int n,m,a[1000010],l[1000010],r[1000010],u[1000010],v[1000010];
	void init(){
		sf("%d%d",&amp;n,&amp;m);
		lp(i,1,n)sf("%d",&amp;a[i]);
		lp(i,1,m)sf("%d%d%d%d",&amp;l[i],&amp;r[i],&amp;u[i],&amp;v[i]);
	}
}
namespace treap{
    struct node{
        node(int a){
            ch[0]=ch[1]=0;
            vl=a;sz=1;fx=rand();
        }
        node*ch[2];
        int vl,sz,fx;
    };
    void update(node*x){
        x-&gt;sz=1;
        lp(i,0,1)if(x-&gt;ch[i])x-&gt;sz+=x-&gt;ch[i]-&gt;sz;
    }
    void rotate(node*&amp;x,int d){
        node*y=x-&gt;ch[d];
        x-&gt;ch[d]=y-&gt;ch[!d];
        y-&gt;ch[!d]=x;
        update(x);update(y);x=y;
    }
    void insert(node*&amp;x,int v){
        if(!x)x=new node(v);
        else{
            if(v&lt;x-&gt;vl){
                insert(x-&gt;ch[0],v);
                update(x);
                if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;fx)
                    rotate(x,0);
            }else{
                insert(x-&gt;ch[1],v);
                update(x);
                if(x-&gt;ch[1]-&gt;fx&lt;x-&gt;fx)
                    rotate(x,1);
            }
        }
    }
    void remove(node*&amp;x,int v){
        if(x-&gt;vl==v){
            if(!x-&gt;ch[0])x=x-&gt;ch[1];
            else if(!x-&gt;ch[1])x=x-&gt;ch[0];
            else if(x-&gt;ch[0]-&gt;fx&lt;x-&gt;ch[1]-&gt;fx)
                rotate(x,0),remove(x-&gt;ch[1],v),update(x);
            else
                rotate(x,1),remove(x-&gt;ch[0],v),update(x);
        }else{
            remove(x-&gt;ch[v&gt;x-&gt;vl],v),update(x);
        }
    }
    int lesseq(node*x,int v){
        if(!x)return 0;
        else if(x-&gt;vl&lt;=v)return (x-&gt;ch[0]?x-&gt;ch[0]-&gt;sz:0)+1+lesseq(x-&gt;ch[1],v);
        else return lesseq(x-&gt;ch[0],v);
    }
}
namespace segment{
    struct node{
        node(int a,int b){
            ch[0]=ch[1]=0;
            tp=0;l=a;r=b;
        }
        node*ch[2];treap::node*tp;int l,r;
    };
    node*build(int l,int r){
        node*x=new node(l,r);
        if(l!=r){
            int m=(l+r)/2;
            x-&gt;ch[0]=build(l,m);
            x-&gt;ch[1]=build(m+1,r);
        }
        return x;
    }
    void insert(node*x,int p,int v){
        treap::insert(x-&gt;tp,v);
        if(x-&gt;l!=x-&gt;r){
            if(p&lt;=x-&gt;ch[0]-&gt;r)
                insert(x-&gt;ch[0],p,v);
            else
                insert(x-&gt;ch[1],p,v);
        }
    }
    void remove(node*x,int p,int v){
        treap::remove(x-&gt;tp,v);
        if(x-&gt;l!=x-&gt;r){
            if(p&lt;=x-&gt;ch[0]-&gt;r)
                remove(x-&gt;ch[0],p,v);
            else
                remove(x-&gt;ch[1],p,v);
        }
    }
    int lesseq(node*x,int b,int e,int v){
       if(b&lt;=x-&gt;l&amp;&amp;e&gt;=x-&gt;r)return treap::lesseq(x-&gt;tp,v);
       else{
            int ret=0;
            if(b&lt;=x-&gt;ch[0]-&gt;r)ret+=lesseq(x-&gt;ch[0],b,e,v);
            if(e&gt;x-&gt;ch[0]-&gt;r)ret+=lesseq(x-&gt;ch[1],b,e,v);
            return ret;
       }
    }
    int count(node*x,int b,int e,int u,int v){
    	return lesseq(x,b,e,v)-lesseq(x,b,e,u-1);
    }
}
namespace subtask1{
	int ans[1000010];
	void solve(){
		segment::node*rt=segment::build(1,input::n);
		lp(i,1,input::n)segment::insert(rt,i,input::a[i]);
		lp(i,1,input::m)ans[i]=segment::count(rt,input::l[i],input::r[i],input::u[i],input::v[i]);
	}
}
namespace subtask2{
	map&lt;int,int&gt;top;
	int pr[1000010];
	struct query{
		int idx,l,r,u,v;
	};
	int ans[1000010];
	vector&lt;query&gt;qs[1000010];
	void solve(){
		lp(i,1,input::n){
			pr[i]=top[input::a[i]];
			top[input::a[i]]=i;
		}
		lp(i,1,input::m){
			query t;t.idx=i;
			t.l=input::l[i];
			t.r=input::r[i];
			t.u=input::u[i];
			t.v=input::v[i];
			qs[t.r].pb(t);
		}
		segment::node*rt=segment::build(1,input::n);
		lp(i,1,input::n){
			segment::insert(rt,i,input::a[i]);
			if(pr[i])segment::remove(rt,pr[i],input::a[i]);
			vp(j,qs[i]){
				ans[qs[i][j].idx]=segment::count(rt,qs[i][j].l,qs[i][j].r,qs[i][j].u,qs[i][j].v);
			}
		}
	}
}
int main(){
	input::init();
	subtask1::solve();
	subtask2::solve();
	lp(i,1,input::m)pf("%d %d\n",subtask1::ans[i],subtask2::ans[i]);
	return 0;
}</pre><pre></pre><h2>Problem3237</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct graph{
	int n;vector&lt;pair&lt;int,int&gt; &gt;eg;
};
vector&lt;int&gt;qs[100010];int ans[100010];
int pr[10010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void solve(graph*g,int l,int r){
	/*pf("[%d]\n",g-&gt;n);
	vp(i,g-&gt;eg)pf("[%d,%d]\n",g-&gt;eg[i].first,g-&gt;eg[i].second);
	pf("[%d,%d]\n",l,r);
	pf("\n");*/
	static int vis[200010];
	vp(i,g-&gt;eg)vis[i]=0;
	lp(i,l,r)vp(j,qs[i])vis[qs[i][j]]=1;
	lp(i,1,g-&gt;n)pr[i]=i;
	vp(i,g-&gt;eg)if(!vis[i]){
		int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second;
		if(fd(u)!=fd(v))pr[fd(u)]=v;
	}
	int nw=0;static int lb[10010];
	lp(i,1,g-&gt;n)if(pr[i]==i)lb[i]=++nw;
	lp(i,1,g-&gt;n)if(pr[i]!=i)lb[i]=lb[fd(i)];
	graph*tg=new graph;tg-&gt;n=nw;
	int enw=0;static int elb[200010];
	vp(i,g-&gt;eg)if(vis[i]){
		int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second;
		tg-&gt;eg.pb(mp(lb[u],lb[v]));
		elb[i]=enw++;
	}
	lp(i,l,r)vp(j,qs[i])qs[i][j]=elb[qs[i][j]];
	if(l!=r){
		int m=(l+r)/2;
		solve(tg,l,m);
		solve(tg,m+1,r);
	}else ans[l]=(tg-&gt;n==1);
}
int main(){
	int n,m;sf("%d%d",&amp;n,&amp;m);graph*g=new graph;g-&gt;n=n;
	lp(i,1,m){
		int a,b;sf("%d%d",&amp;a,&amp;b);
		g-&gt;eg.pb(mp(a,b));
	}
	int k;sf("%d",&amp;k);
	lp(i,1,k){
		int c;sf("%d",&amp;c);
		lp(j,1,c){
			int t;sf("%d",&amp;t);
			qs[i].pb(t-1);
		}
	}
	solve(g,1,k);
	lp(i,1,k)pf("%s\n",ans[i]?"Connected":"Disconnected");
	return 0;
}</pre><pre></pre><h2>Problem3237</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
struct graph{
    int n;vector&lt;pair&lt;int,int&gt; &gt;eg;
};
vector&lt;int&gt;qs[100010];int ans[100010];
int pr[10010];
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
void solve(graph*g,int l,int r){
    /*pf("[%d]\n",g-&gt;n);
    vp(i,g-&gt;eg)pf("[%d,%d]\n",g-&gt;eg[i].first,g-&gt;eg[i].second);
    pf("[%d,%d]\n",l,r);
    pf("\n");*/
    if(g-&gt;n==1){lp(i,l,r)ans[i]=1;return;}
    if(g-&gt;eg.size()+1&lt;g-&gt;n)return;
    static int vis[200010];
    vp(i,g-&gt;eg)vis[i]=0;
    lp(i,l,r)vp(j,qs[i])vis[qs[i][j]]=1;
    lp(i,1,g-&gt;n)pr[i]=i;
    vp(i,g-&gt;eg)if(!vis[i]){
        int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second;
        if(fd(u)!=fd(v))pr[fd(u)]=v;
    }
    int nw=0;static int lb[10010];
    lp(i,1,g-&gt;n)if(pr[i]==i)lb[i]=++nw;
    lp(i,1,g-&gt;n)if(pr[i]!=i)lb[i]=lb[fd(i)];
    graph*tg=new graph;tg-&gt;n=nw;
    int enw=0;static int elb[200010];
    vp(i,g-&gt;eg)if(vis[i]){
        int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second;
        tg-&gt;eg.pb(mp(lb[u],lb[v]));
        elb[i]=enw++;
    }
    lp(i,l,r)vp(j,qs[i])qs[i][j]=elb[qs[i][j]];
    if(l!=r){
        int m=(l+r)/2;
        solve(tg,l,m);
        solve(tg,m+1,r);
    }else ans[l]=(tg-&gt;n==1);
}
int main(){
    int n,m;sf("%d%d",&amp;n,&amp;m);graph*g=new graph;g-&gt;n=n;
    lp(i,1,m){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        g-&gt;eg.pb(mp(a,b));
    }
    int k;sf("%d",&amp;k);
    lp(i,1,k){
        int c;sf("%d",&amp;c);
        lp(j,1,c){
            int t;sf("%d",&amp;t);
            qs[i].pb(t-1);
        }
    }
    solve(g,1,k);
    lp(i,1,k)pf("%s\n",ans[i]?"Connected":"Disconnected");
    return 0;
}</pre><pre></pre><h2>Problem3237</h2><pre>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt; 
#include&lt;vector&gt; 
#include&lt;utility&gt; 
#define sf scanf 
#define pf printf 
#define ps for(;;) 
#define fr freopen 
#define pb push_back 
#define mp make_pair 
#define lp(i,a,b) for(int i=a;i&lt;=b;++i) 
#define rp(i,a,b) for(int i=a;i&gt;=b;--i) 
#define vp(i,v) for(int i=0;i&lt;v.size();++i) 
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i) 
typedef long long ll; 
using namespace std; 
struct graph{ 
    int n;vector&lt;pair&lt;int,int&gt; &gt;eg; 
}; 
vector&lt;int&gt;qs[100010];int ans[100010]; 
int pr[10010]; 
int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);} 
void solve(graph*g,int l,int r){ 
    static int vis[200010]; 
    vp(i,g-&gt;eg)vis[i]=0; 
    lp(i,l,r)vp(j,qs[i])vis[qs[i][j]]=1; 
    lp(i,1,g-&gt;n)pr[i]=i; 
    vp(i,g-&gt;eg)if(!vis[i]){ 
        int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second; 
        if(fd(u)!=fd(v))pr[fd(u)]=v; 
    } 
    int nw=0;static int lb[10010]; 
    lp(i,1,g-&gt;n)if(pr[i]==i)lb[i]=++nw; 
    lp(i,1,g-&gt;n)if(pr[i]!=i)lb[i]=lb[fd(i)]; 
    graph*tg=new graph;tg-&gt;n=nw; 
    int enw=0;static int elb[200010]; 
    vp(i,g-&gt;eg)if(vis[i]){ 
        int u=g-&gt;eg[i].first,v=g-&gt;eg[i].second; 
        tg-&gt;eg.pb(mp(lb[u],lb[v])); 
        elb[i]=enw++; 
    } 
    lp(i,l,r)vp(j,qs[i])qs[i][j]=elb[qs[i][j]]; 
    if(l!=r){ 
        int m=(l+r)/2; 
        solve(tg,l,m); 
        solve(tg,m+1,r); 
    }else ans[l]=(tg-&gt;n==1); 
} 
int main(){ 
    int n,m;sf("%d%d",&amp;n,&amp;m);graph*g=new graph;g-&gt;n=n; 
    lp(i,1,m){ 
        int a,b;sf("%d%d",&amp;a,&amp;b); 
        g-&gt;eg.pb(mp(a,b)); 
    } 
    int k;sf("%d",&amp;k); 
    lp(i,1,k){ 
        int c;sf("%d",&amp;c); 
        lp(j,1,c){ 
            int t;sf("%d",&amp;t); 
            qs[i].pb(t-1); 
        } 
    } 
    solve(g,1,k); 
    lp(i,1,k)pf("%s\n",ans[i]?"Connected":"Disconnected"); 
    return 0; 
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char str[500010];
namespace sam{
	const int N=500000*2+10;
	int tr[N][26],ln[N],pr[N],nw=1,lst=1,is[N],po[N];
	void add(int c,int u){
		int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
		for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
		if(!p)pr[np]=1;
		else{
			int q=tr[p][c];
			if(ln[q]==ln[p]+1)pr[np]=q;
			else{
				int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
				copy(tr[q],tr[q]+26,tr[nq]);
				pr[np]=pr[q]=nq;
				for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
			}
		}
	}
	int ch[N][26];
	int cnt[N];ll sum[N];
	ll calc(){
		ll ret=0;
		static int tmp[N],ccc[N];
		lp(i,1,nw)++ccc[ln[i]];
		lp(i,1,nw)ccc[i]+=ccc[i-1];
		lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
		rp(i,nw,1){
			int u=tmp[i];
			//pf("{%d}\n",u);
			po[pr[u]]=po[u];
			ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
			cnt[u]+=is[u];
			cnt[pr[u]]+=cnt[u];
			sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
		}
		//lp(i,1,nw)pf("[%d,%d]\n",i,pr[i]);
		//lp(i,1,nw)pf("[%d,%d]\n",ln[i],is[i]);
		//lp(i,1,nw)pf("[%d]\n",cnt[i]);
		//lp(i,1,nw)pf("[%lld]\n",sum[i]);
		lp(i,1,nw){
			static ll tsum[26],tcnt[26];
			lp(j,0,25)if(ch[i][j]){
				tcnt[j]=cnt[ch[i][j]];
				tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
				//pf("[%d,%lld,%lld]\n",j,tcnt[j],tsum[j]);
			}else tcnt[j]=tsum[j]=0;
			static ll tsump[26],tcntp[26];
			lp(j,0,25)tsump[j]=tcntp[j]=0;
			tsump[0]=tsum[0];
			tcntp[0]=tcnt[0];
			lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
			ll del=0;
			lp(j,1,25){
				del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
			}
			if(is[i]){
				del+=sum[i];
			}
			ret+=del;
			//pf("%d,%lld\n",i,del);
		}
		return ret;
	}
}
int main(){
	sf("%s",str+1);int len=strlen(str+1);
	reverse(str+1,str+len+1);
	lp(i,1,len)sam::add(str[i]-'a',i);
	pf("%lld\n",sam::calc());
	return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char str[500010];
namespace sam{
	const int N=500000*2+10;
	int tr[N][26],ln[N],pr[N],nw=1,lst=1,is[N],po[N];
	void add(int c,int u){
		int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
		for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
		if(!p)pr[np]=1;
		else{
			int q=tr[p][c];
			if(ln[q]==ln[p]+1)pr[np]=q;
			else{
				int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
				copy(tr[q],tr[q]+26,tr[nq]);
				pr[np]=pr[q]=nq;
				for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
			}
		}
	}
	int ch[N][26];
	int cnt[N];ll sum[N];
	ll calc(){
		ll ret=0;
		static int tmp[N],ccc[N];
		lp(i,1,nw)++ccc[ln[i]];
		lp(i,1,nw)ccc[i]+=ccc[i-1];
		lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
		rp(i,nw,1){
			int u=tmp[i];
			po[pr[u]]=po[u];
			ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
			cnt[u]+=is[u];
			cnt[pr[u]]+=cnt[u];
			sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
		}
		lp(i,1,nw){
			static ll tsum[26],tcnt[26];
			lp(j,0,25)if(ch[i][j]){
				tcnt[j]=cnt[ch[i][j]];
				tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
			}else tcnt[j]=tsum[j]=0;
			static ll tsump[26],tcntp[26];
			lp(j,0,25)tsump[j]=tcntp[j]=0;
			tsump[0]=tsum[0];
			tcntp[0]=tcnt[0];
			lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
			ll del=0;
			lp(j,1,25){
				del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
			}
			if(is[i]){
				del+=sum[i];
			}
			ret+=del;
		}
		return ret;
	}
}
int main(){
	gets(str+1);int len=strlen(str+1);
	reverse(str+1,str+len+1);
	lp(i,1,len)sam::add(str[i]-'a',i);
	pf("%lld\n",sam::calc());
	return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt;tr[N];int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int ch[N][26];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i][j]){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt;tr[N];int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p].count(c);p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p].count(c)&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int ch[N][26];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i][j]){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt;tr[N];int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p].count(c);p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p].count(c)&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    map&lt;int,int&gt;ch[N];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i].count(j)){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char str[500010];
namespace sam{
    const int N=500000*2+9;
    vector&lt;pair&lt;int,int&gt; &gt;trd[N];
    vector&lt;int&gt;tr2[N];
    int tr(int u,int c){
    	int t=(u*26+c)%N;
    	vp(i,trd[t])if(trd[t][i].first==u*26+c)return trd[t][i].second;
    	return 0;
    }
    void mtr(int u,int c,int d){
    	tr2[u].pb(c);
    	int t=(u*26+c)%N;
    	vp(i,trd[t])if(trd[t][i].first==u*26+c){trd[t][i].second=d;return;}
    	trd[t].pb(mp(u*26+c,d));
    }
    int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr(p,c);p=pr[p])mtr(p,c,np);
        if(!p)pr[np]=1;
        else{
            int q=tr(p,c);
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr2[nq]=tr2[q];
                vp(i,tr2[q])mtr(nq,tr2[q][i],tr(q,tr2[q][i]));
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr(p,c)==q;p=pr[p])mtr(p,c,nq);
            }
        }
    }
    int ch[N][26];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i][j]){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+9;
    vector&lt;pair&lt;int,int&gt; &gt;trd[N];
    vector&lt;int&gt;tr2[N];
    int tr(int u,int c){
    	int t=(u*26+c)%N;
    	vp(i,trd[t])if(trd[t][i].first==u*26+c)return trd[t][i].second;
    	return 0;
    }
    void mtr(int u,int c,int d){
    	tr2[u].pb(c);
    	int t=(u*26+c)%N;
    	vp(i,trd[t])if(trd[t][i].first==u*26+c){trd[t][i].second=d;return;}
    	trd[t].pb(mp(u*26+c,d));
    }
    int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr(p,c);p=pr[p])mtr(p,c,np);
        if(!p)pr[np]=1;
        else{
            int q=tr(p,c);
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr2[nq]=tr2[q];
                vp(i,tr2[q])mtr(nq,tr2[q][i],tr(q,tr2[q][i]));
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr(p,c)==q;p=pr[p])mtr(p,c,nq);
            }
        }
    }
    map&lt;int,int&gt;ch[N];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i].count(j)){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt;tr[N];int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    map&lt;int,int&gt;ch[N];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i].count(j)){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt;tr[N];int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p].count(c);p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p].count(c)&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int cnt[N];ll sum[N];
    ll calc(){
    	lp(i,1,nw)tr[i].clear();
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            tr[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(tr[i].count(j)){
                tcnt[j]=cnt[tr[i][j]];
                tsum[j]=sum[tr[i][j]]+ll(ln[tr[i][j]]-ln[i])*cnt[tr[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char str[500010];
namespace sam2{
 const int N=500000*2+10;
    struct node{
    	node*tr[26],*pr;
    	int ln,po;bool is;
    }ns[N];
    int nw=1;
    node*lst=ns+1;
    void add(int c,int u){
        node*p=lst,*np=&amp;ns[++nw];np-&gt;ln=p-&gt;ln+1;lst=np;np-&gt;is=1;np-&gt;po=u;
        for(;p&amp;&amp;!p-&gt;tr[c];p=p-&gt;pr)p-&gt;tr[c]=np;
        if(!p)np-&gt;pr=ns+1;
        else{
            node*q=p-&gt;tr[c];
            if(q-&gt;ln==p-&gt;ln+1)np-&gt;pr=q;
            else{
                node*nq=&amp;ns[++nw];nq-&gt;ln=p-&gt;ln+1;nq-&gt;pr=q-&gt;pr;
                copy(q-&gt;tr,q-&gt;tr+26,nq-&gt;tr);
                np-&gt;pr=q-&gt;pr=nq;
                for(;p&amp;&amp;p-&gt;tr[c]==q;p=p-&gt;pr)p-&gt;tr[c]=nq;
            }
        }
    }
}
namespace sam{
	const int N=500000*2+10;
	int tr[N][26],ln[N],pr[N],nw=1,lst=1,is[N],po[N];
	void add(int c,int u){
		int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
		for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
		if(!p)pr[np]=1;
		else{
			int q=tr[p][c];
			if(ln[q]==ln[p]+1)pr[np]=q;
			else{
				int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
				copy(tr[q],tr[q]+26,tr[nq]);
				pr[np]=pr[q]=nq;
				for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
			}
		}
	}
	int ch[N][26];
	int cnt[N];ll sum[N];
	ll calc(){
		ll ret=0;
		static int tmp[N],ccc[N];
		lp(i,1,nw)++ccc[ln[i]];
		lp(i,1,nw)ccc[i]+=ccc[i-1];
		lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
		rp(i,nw,1){
			int u=tmp[i];
			po[pr[u]]=po[u];
			ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
			cnt[u]+=is[u];
			cnt[pr[u]]+=cnt[u];
			sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
		}
		lp(i,1,nw){
			static ll tsum[26],tcnt[26];
			lp(j,0,25)if(ch[i][j]){
				tcnt[j]=cnt[ch[i][j]];
				tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
			}else tcnt[j]=tsum[j]=0;
			static ll tsump[26],tcntp[26];
			lp(j,0,25)tsump[j]=tcntp[j]=0;
			tsump[0]=tsum[0];
			tcntp[0]=tcnt[0];
			lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
			ll del=0;
			lp(j,1,25){
				del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
			}
			if(is[i]){
				del+=sum[i];
			}
			ret+=del;
		}
		return ret;
	}
}
int main(){
	gets(str+1);int len=strlen(str+1);
	reverse(str+1,str+len+1);
	lp(i,1,len)sam::add(str[i]-'a',i);
	lp(i,1,len)sam2::add(str[i]-'a',i);
	pf("%lld\n",sam::calc());
	return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
char str[500010];
namespace sam2{
const int N=500000*2+10;
	int tr[N][26],ln[N],pr[N],nw=1,lst=1,is[N],po[N];
	void add(int c,int u){
		int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
		for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
		if(!p)pr[np]=1;
		else{
			int q=tr[p][c];
			if(ln[q]==ln[p]+1)pr[np]=q;
			else{
				int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
				copy(tr[q],tr[q]+26,tr[nq]);
				pr[np]=pr[q]=nq;
				for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
			}
		}
	}
}
namespace sam{
	const int N=500000*2+10;
	int tr[N][26],ln[N],pr[N],nw=1,lst=1,is[N],po[N];
	void add(int c,int u){
		int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
		for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
		if(!p)pr[np]=1;
		else{
			int q=tr[p][c];
			if(ln[q]==ln[p]+1)pr[np]=q;
			else{
				int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
				copy(tr[q],tr[q]+26,tr[nq]);
				pr[np]=pr[q]=nq;
				for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
			}
		}
	}
	int ch[N][26];
	int cnt[N];ll sum[N];
	ll calc(){
		ll ret=0;
		static int tmp[N],ccc[N];
		lp(i,1,nw)++ccc[ln[i]];
		lp(i,1,nw)ccc[i]+=ccc[i-1];
		lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
		rp(i,nw,1){
			int u=tmp[i];
			po[pr[u]]=po[u];
			ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
			cnt[u]+=is[u];
			cnt[pr[u]]+=cnt[u];
			sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
		}
		lp(i,1,nw){
			static ll tsum[26],tcnt[26];
			lp(j,0,25)if(ch[i][j]){
				tcnt[j]=cnt[ch[i][j]];
				tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
			}else tcnt[j]=tsum[j]=0;
			static ll tsump[26],tcntp[26];
			lp(j,0,25)tsump[j]=tcntp[j]=0;
			tsump[0]=tsum[0];
			tcntp[0]=tcnt[0];
			lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
			ll del=0;
			lp(j,1,25){
				del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
			}
			if(is[i]){
				del+=sum[i];
			}
			ret+=del;
		}
		return ret;
	}
}
int main(){
	gets(str+1);int len=strlen(str+1);
	reverse(str+1,str+len+1);
	lp(i,1,len)sam::add(str[i]-'a',i);
	lp(i,1,len)sam2::add(str[i]-'a',i);
	pf("%lld\n",sam::calc());
	return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;tr1/unordered_map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    tr1::unordered_map&lt;int,int&gt; tr[N];
    int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int ch[N][26];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i][j]){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;cstring&gt;
#include&lt;tr1/unordered_map&gt;
#include&lt;map&gt;
char str[500010];
namespace sam{
    const int N=500000*2+10;
    map&lt;int,int&gt; tr[N];
    int ln[N],pr[N],nw=1,lst=1,is[N],po[N];
    void add(int c,int u){
        int p=lst,np=++nw;ln[np]=ln[p]+1;lst=np;is[np]=1;po[np]=u;
        for(;p&amp;&amp;!tr[p][c];p=pr[p])tr[p][c]=np;
        if(!p)pr[np]=1;
        else{
            int q=tr[p][c];
            if(ln[q]==ln[p]+1)pr[np]=q;
            else{
                int nq=++nw;ln[nq]=ln[p]+1;pr[nq]=pr[q];
                tr[nq]=tr[q];
                pr[np]=pr[q]=nq;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])tr[p][c]=nq;
            }
        }
    }
    int ch[N][26];
    int cnt[N];ll sum[N];
    ll calc(){
        ll ret=0;
        static int tmp[N],ccc[N];
        lp(i,1,nw)++ccc[ln[i]];
        lp(i,1,nw)ccc[i]+=ccc[i-1];
        lp(i,1,nw)tmp[ccc[ln[i]]--]=i;
        rp(i,nw,1){
            int u=tmp[i];
            po[pr[u]]=po[u];
            ch[pr[u]][str[po[u]-ln[pr[u]]]-'a']=u;
            cnt[u]+=is[u];
            cnt[pr[u]]+=cnt[u];
            sum[pr[u]]+=sum[u]+ll(ln[u]-ln[pr[u]])*cnt[u];
        }
        lp(i,1,nw){
            static ll tsum[26],tcnt[26];
            lp(j,0,25)if(ch[i][j]){
                tcnt[j]=cnt[ch[i][j]];
                tsum[j]=sum[ch[i][j]]+ll(ln[ch[i][j]]-ln[i])*cnt[ch[i][j]];
            }else tcnt[j]=tsum[j]=0;
            static ll tsump[26],tcntp[26];
            lp(j,0,25)tsump[j]=tcntp[j]=0;
            tsump[0]=tsum[0];
            tcntp[0]=tcnt[0];
            lp(j,1,25)tsump[j]+=tsump[j-1]+tsum[j],tcntp[j]+=tcntp[j-1]+tcnt[j];
            ll del=0;
            lp(j,1,25){
                del+=tsum[j]*tcntp[j-1]+tsump[j-1]*tcnt[j];
            }
            if(is[i]){
                del+=sum[i];
            }
            ret+=del;
        }
        return ret;
    }
}
int main(){
    gets(str+1);int len=strlen(str+1);
    reverse(str+1,str+len+1);
    lp(i,1,len)sam::add(str[i]-'a',i);
    pf("%lld\n",sam::calc());
    return 0;
}</pre><pre></pre><h2>Problem3239</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define pb push_back
#define mp make_pair
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vp(i,v) for(int i=0;i&lt;v.size();++i)
#define wp(i,v) for(int i=int(v.size()-1);i&gt;=0;--i)
typedef long long ll;
using namespace std;
#include&lt;map&gt;
#include&lt;cmath&gt;
ll qpow(ll x,ll y,ll z){
	ll r=1;
	while(y){
		if(y&amp;1)r=r*x%z;
		x=x*x%z;
		y&gt;&gt;=1;
	}
	return r;
}
ll bsgs(ll a,ll b,ll c){
    ll m=ll(sqrt(double(c-1))+0.5);
    map&lt;ll,ll&gt;pm;
    lp(i,0,m-1)pm[qpow(a,i,c)]=i;
    lp(i,0,(c-1)/m){
        ll t=qpow(qpow(a,i*m,c),c-2,c)*b%c;
        if(pm.count(t))return pm[t]+i*m;
    }
    return -1;
}
int main(){
	ll a,b,c;
	while(sf("%lld%lld%lld",&amp;c,&amp;a,&amp;b)!=EOF){
		ll ans=bsgs(a,b,c);
		if(ans==-1)pf("no solution\n");
		else pf("%lld\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem3302</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define fr freopen
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
const int mx=500010;
int bg[mx*2],to[mx*2],nx[mx*2],nw;
int n,wei[mx];
void add(int u,int v){to[++nw]=v;nx[nw]=bg[u];bg[u]=nw;}
void build_tree(){
    sf("%d",&amp;n);
    lp(i,1,n-1){
        int a,b;sf("%d%d",&amp;a,&amp;b);
        add(a,b),add(b,a);
    }
    lp(i,1,n)sf("%d",&amp;wei[i]);
}
int prt[mx],stk[mx*2],que[mx];
void calc_prt(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int p=stk[stk[0]--],u=stk[stk[0]--];
        prt[u]=p;
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=p)stk[++stk[0]]=v,stk[++stk[0]]=u;
        }
    }
}
long long sumd[mx],engd[mx];
void calc_sumd(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            sumd[u]=wei[u];
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])sumd[u]+=sumd[v];
            }
        }
    }
}
void calc_engd(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])engd[u]+=engd[v]+sumd[v];
            }
        }
    }
}
long long engu[mx],sumu[mx];
void calc_sumu(){
    long long t=0;lp(i,1,n)t+=wei[i];
    lp(i,1,n)sumu[i]=t-sumd[i];
}
void calc_engu(){
    stk[0]=1;stk[1]=1;
    while(stk[0]){
        int u=stk[stk[0]--];
        if(prt[u]){
            for(int i=bg[prt[u]];i;i=nx[i]){
                int w=to[i];
                if(w!=u&amp;&amp;w!=prt[prt[u]]){
                    engu[u]+=engd[w]+sumd[w];
                }
            }
            engu[u]+=sumu[prt[u]]+engu[prt[u]];
        }
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=prt[u])stk[++stk[0]]=v;
        }
    }
}
int lt[mx],rt[mx],ti;
void calc_dfs(){
    stk[0]=2;stk[1]=1;stk[2]=0;
    while(stk[0]){
        int t=stk[stk[0]--],u=stk[stk[0]--];
        if(t==0){
            stk[++stk[0]]=u,stk[++stk[0]]=1;
            lt[u]=++ti;
            for(int i=bg[u];i;i=nx[i]){
                int v=to[i];
                if(v!=prt[u])stk[++stk[0]]=v,stk[++stk[0]]=0;
            }
        }else{
            rt[u]=ti;
        }
    }
}
long long ans=-1;
int stku[mx],stkx[mx],stky[mx],stkdx[mx],stkdy[mx],stktp;
long long stkex[mx],stkey[mx];
void calc_ans(){
    for(int i=bg[1];i;i=nx[i]){
        int v=to[i];
        ++stktp;
        stku[stktp]=v;
        stkx[stktp]=1;
        stkex[stktp]=engd[1]-(engd[v]+sumd[v]);
        stkdx[stktp]=0;
        stky[stktp]=v;
        stkey[stktp]=engd[v];
        stkdy[stktp]=0;
    }
    while(stktp){
        int u=stku[stktp];
        int x=stkx[stktp];
        long long ex=stkex[stktp];
        int dx=stkdx[stktp];
        int y=stky[stktp];
        long long ey=stkey[stktp];
        int dy=stkdy[stktp];
        --stktp;
        while(true){
            int flg=0;
            for(int i=bg[x];i;i=nx[i]){
                int z=to[i],k=0;
                long long t=0;
                if(z==u)continue;
                if(z==prt[x]){
                    if(lt[x]&lt;=lt[prt[u]]&amp;&amp;rt[x]&gt;=rt[prt[u]])k=dx+1;
                    else k=dx-1;
                }else{
                    if(lt[x]&lt;=lt[prt[u]]&amp;&amp;rt[x]&gt;=rt[prt[u]]){
                        if(lt[z]&lt;=lt[prt[u]]&amp;&amp;rt[z]&gt;=rt[prt[u]])k=dx-1;
                        else k=dx+1;
                    }else k=dx+1;
                }
                t=engd[z]+engu[z]+sumu[z]-(engd[u]+(k+1)*sumd[u]);
                if(t&lt;ex){x=z,ex=t,dx=k,flg=1;break;}
            }
            if(!flg)break;
        }
        while(true){
            int flg=0;
            for(int i=bg[y];i;i=nx[i]){
                int z=to[i],k=0;long long t;
                if(z==prt[u])continue;
                if(z==prt[y])k=dy-1;
                else k=dy+1;
                t=engd[z]+engu[z]+sumu[z]-(engu[u]+(k+1)*sumu[u]);
                if(t&lt;ey){y=z,ey=t,dy=k,flg=1;break;}
            }
            if(!flg)break;
        }
        if(ans==-1||ans&gt;ex+ey)ans=ex+ey;
        for(int i=bg[u];i;i=nx[i]){
            int v=to[i];
            if(v!=prt[u]){
                if(!(lt[v]&lt;=lt[y]&amp;&amp;rt[v]&gt;=rt[y])){
                    ++stktp;
                    stku[stktp]=v;
                    stkx[stktp]=x;
                    stkex[stktp]=ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1);
                    stkdx[stktp]=dx+1;
                    stky[stktp]=v;
                    stkey[stktp]=engd[v];
                    stkdy[stktp]=0;
                }else{
                    ++stktp;
                    stku[stktp]=v;
                    stkx[stktp]=x;
                    stkex[stktp]=ex+(engd[u]-(engd[v]+sumd[v]))+(sumd[u]-sumd[v])*(dx+1);
                    stkdx[stktp]=dx+1;
                    stky[stktp]=y;
                    stkey[stktp]=ey-(engd[u]-(engd[v]+sumd[v]))-dy*(sumd[u]-sumd[v]);
                    stkdy[stktp]=dy-1;
                }
            }
        }
    }
}
int main(){
    build_tree();
    calc_prt();
    calc_sumd();
    calc_engd();
    calc_sumu();
    calc_engu();
    calc_dfs();
    calc_ans();
    pf("%lld\n",ans);
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3328</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimitiveRoot{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;bool chk(T a,int c=10){
        if(a==1)
            return false;
        T u=a-1,t=0;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            T x=pow(T(rand()*1.0/RAND_MAX*(a-2)+1),u,a),y;
            for(int j=0;j&lt;t;++j){
                y=x;
                x=mul(x,x,a);
                if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)
                    return false;
            }
            if(x!=1)
                return false;
        }
        return true;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;fac(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=fac(b),v=fac(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
    template&lt;class T&gt;void dfs(vector&lt;pair&lt;T,int&gt; &gt;&amp;f,int i,T now,vector&lt;T&gt;&amp;r){
        if(i==f.size()){
            r.push_back(now);
            return;
        }
        for(int j=0;j&lt;=f[i].second;++j,now*=f[i].first)
            dfs(f,i+1,now,r);
    }
    template&lt;class T&gt;T run(T a){
        vector&lt;pair&lt;T,int&gt; &gt;fa=fac(a),fpa;
        if(fa.size()==0||fa.size()&gt;2)
            return -1;
        if(fa.size()==1&amp;&amp;fa[0].first==2&amp;&amp;fa[0].second&gt;2)
            return -1;
        if(fa.size()==2&amp;&amp;fa[0]!=make_pair(T(2),1))
            return -1;
        T pa=a;
        for(int i=0;i&lt;fa.size();++i)
            pa=pa/fa[i].first*(fa[i].first-1);
        fpa=fac(pa);
        vector&lt;T&gt;fs;
        dfs(fpa,0,1,fs);
        for(T g=1,f=0;;++g,f=0){
            for(int i=0;i&lt;fs.size();++i)
                if(fs[i]!=pa&amp;&amp;pow(g,fs[i],a)==1){
                    f=1;
                    break;
                }
            if(!f)
                return g;
        }
    }
}


#include&lt;bits/stdc++.h&gt;
using namespace std;
template&lt;class T&gt;struct ModularInteger{
    ModularInteger(T t=0):
        v(t){
        if(v&lt;0||v&gt;=p)
            v=(v%p+p)%p;
    }
    ModularInteger&lt;T&gt;&amp;operator=(T a){
        v=a;
        if(v&lt;0||v&gt;=p)
            v%=p;
        return*this;
    }
    ModularInteger&lt;T&gt;operator-(){
        return v?p-v:0;
    }
    ModularInteger&lt;T&gt;&amp;operator+=(ModularInteger&lt;T&gt;a){
        return*this=*this+a;
    }
    ModularInteger&lt;T&gt;&amp;operator-=(ModularInteger&lt;T&gt;a){
        return*this=*this-a;
    }
    ModularInteger&lt;T&gt;&amp;operator*=(ModularInteger&lt;T&gt;a){
        return*this=*this*a;
    }
    ModularInteger&lt;T&gt;&amp;operator/=(ModularInteger&lt;T&gt;a){
        return*this=*this/a;
    }
    T v;
    static T p;
};
template&lt;class T&gt;ModularInteger&lt;T&gt;pow(ModularInteger&lt;T&gt;a,long long b){
    ModularInteger&lt;T&gt;r(1);
    for(;b;b&gt;&gt;=1,a=a*a)
        if(b&amp;1)
            r=r*a;
    return r;
}
template&lt;class T&gt;ModularInteger&lt;T&gt;inv(ModularInteger&lt;T&gt;a){
    return pow(a,a.p-2);
}
template&lt;class T&gt;vector&lt;ModularInteger&lt;T&gt; &gt;sqrt(ModularInteger&lt;T&gt;a){
    vector&lt;ModularInteger&lt;T&gt; &gt;r;
    if(!a.v)
        r.push_back(ModularInteger&lt;T&gt;(0));
    else if(pow(a,a.p-1&gt;&gt;1).v==1){
        int s=a.p-1,t=0;
        ModularInteger&lt;T&gt;b=1;
        for(;pow(b,a.p-1&gt;&gt;1).v!=a.p-1;b=rand()*1.0/RAND_MAX*(a.p-1));
        for(;s%2==0;++t,s/=2);
        ModularInteger&lt;T&gt;x=pow(a,(s+1)/2),e=pow(a,s);
        for(int i=1;i&lt;t;++i,e=x*x/a)
            if(pow(e,1&lt;&lt;t-i-1).v!=1)
                x=x*pow(b,(1&lt;&lt;i-1)*s);
        r.push_back(x);
        r.push_back(-x);
    }
    return r;
}
template&lt;class T&gt;ModularInteger&lt;T&gt;operator+(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    ModularInteger&lt;T&gt;c(a.v+b.v);
    if(c.v&gt;=a.p)
        c.v-=a.p;
    return c;
}
template&lt;class T&gt;ModularInteger&lt;T&gt;operator-(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    ModularInteger&lt;T&gt;c(a.v-b.v);
    if(c.v&lt;0)
        c.v+=a.p;
    return c;
}
template&lt;class T&gt;ModularInteger&lt;T&gt;operator*(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    if(typeid(T)!=typeid(int))
        return ModularInteger&lt;T&gt;((a.v*b.v-(long long)(((long double)a.v*b.v+0.5)/a.p)*a.p+a.p)%a.p);
    else
        return ModularInteger&lt;T&gt;((long long)a.v*b.v%a.p);
}
template&lt;class T&gt;ModularInteger&lt;T&gt;operator/(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    return a*inv(b);
}
template&lt;class T&gt;bool operator==(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    return a.v==b.v;
}
template&lt;class T&gt;bool operator!=(ModularInteger&lt;T&gt;a,ModularInteger&lt;T&gt;b){
    return a.v!=b.v;
}
template&lt;class T&gt;istream&amp;operator&gt;&gt;(istream&amp;s,ModularInteger&lt;T&gt;&amp;a){
    s&gt;&gt;a.v;
    return s;
}
template&lt;class T&gt;ostream&amp;operator&lt;&lt;(ostream&amp;s,ModularInteger&lt;T&gt;a){
    s&lt;&lt;a.v;
    if(a.v&lt;0||a.v&gt;=a.p)
        a.v%=a.p;
    return s;
}
template&lt;class T&gt;T ModularInteger&lt;T&gt;::p=1e9+7;


#include&lt;bits/stdc++.h&gt;
template&lt;class T,int N&gt;struct Matrix{
    Matrix(T t=0){
        for(int i=0;i&lt;N;++i)
            for(int j=0;j&lt;N;++j)
                u[i][j]=i==j?t:0;
    }
    T u[N][N];
};
template&lt;class T,int N&gt;Matrix&lt;T,N&gt;operator+(const Matrix&lt;T,N&gt;&amp;a,const Matrix&lt;T,N&gt;&amp;b){
    Matrix&lt;T,N&gt;c;
    for(int i=0;i&lt;N;++i)
        for(int j=0;j&lt;N;++j)
            c.u[i][j]=a.u[i][j]+b.u[i][j];
    return c;
}
template&lt;class T,int N&gt;Matrix&lt;T,N&gt;operator*(const Matrix&lt;T,N&gt;&amp;a,const Matrix&lt;T,N&gt;&amp;b){
    Matrix&lt;T,N&gt;c;
    for(int i=0;i&lt;N;++i)
        for(int j=0;j&lt;N;++j)
            for(int k=0;k&lt;N;++k)
                c.u[i][j]+=a.u[i][k]*b.u[k][j];
    return c;
}
template&lt;class T,int N&gt;Matrix&lt;T,N&gt;operator*(const Matrix&lt;T,N&gt;&amp;a,const T&amp;b){
    Matrix&lt;T,N&gt;c=a;
    for(int i=0;i&lt;N;++i)
        for(int j=0;j&lt;N;++j)
            c.u[i][j]*=b;
    return c;
}
template&lt;class T,int N&gt;Matrix&lt;T,N&gt;operator/(const Matrix&lt;T,N&gt;&amp;a,const T&amp;b){
    Matrix&lt;T,N&gt;c=a;
    for(int i=0;i&lt;N;++i)
        for(int j=0;j&lt;N;++j)
            c.u[i][j]/=b;
    return c;
}
template&lt;class T,int N&gt;Matrix&lt;T,N&gt;pow(Matrix&lt;T,N&gt;a,long long b){
    Matrix&lt;T,N&gt;r(1);
    for(;b;a=a*a,b&gt;&gt;=1)
        if(b&amp;1)
            r=r*a;
    return r;
}
template&lt;class T,int N&gt;ostream&amp;operator&lt;&lt;(ostream&amp;s,const Matrix&lt;T,N&gt;a){
    for(int i=0;i&lt;N;++i)
        for(int j=0;j&lt;N;++j)
            s&lt;&lt;a.u[i][j]&lt;&lt;(j+1==N?'\n':' ');
    return s;
}

int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        ModularInteger&lt;int&gt; k;
        int p;long long n;
        cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;
        ModularInteger&lt;int&gt;::p=p;
        ModularInteger&lt;int&gt;w=pow(ModularInteger&lt;int&gt;(PrimitiveRoot::run(p)),(p-1)/k.v);
        typedef Matrix&lt;ModularInteger&lt;int&gt; ,2&gt;Mat;
        Mat g;
        g.u[0][0]=g.u[0][1]=g.u[1][0]=1;
        Mat r;
        //cout&lt;&lt;w&lt;&lt;endl;
        //cout&lt;&lt;g&lt;&lt;endl;
        for(int i=1;i&lt;=k.v;++i){
            Mat t=g*pow(w,i)+Mat(1);
            r=r+pow(t,n);
        }
        r=r/k;
        cout&lt;&lt;r.u[0][0]&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3503</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;
using namespace std;
namespace gae{
    const int N=1600,M=1600;
    int n,m,p[M+10];bitset&lt;M+10&gt;a[N+10];
    void run(){
        for(int i=1;i&lt;=n;++i){
            int j=1;for(;j&lt;=m&amp;&amp;!a[i][j];++j);
            if(j&lt;=m){
                p[j]=i;
                for(int k=1;k&lt;=n;++k)if(k!=i&amp;&amp;a[k][j])
                    a[k]^=a[i];
            }
        }
    }
}
#define ID(x,y) (m*(x-1)+y)
#define AB(x,y) (x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m)
int dx[]={0,-1,1,0,0}; 
int dy[]={0,0,0,-1,1};
int main(){
    int n,m;scanf("%d%d",&amp;n,&amp;m);
    gae::n=n*m;
    gae::m=n*m;
    for(int i=1;i&lt;=n;++i)
        for(int j=1;j&lt;=m;++j){
            for(int t=0;t&lt;5;++t){
                int x=i+dx[t],y=j+dy[t];
                if(AB(x,y))
                    gae::a[ID(i,j)][ID(x,y)]=1;
            }
        }
    gae::run();
    static int val[100010];
    for(int i=1;i&lt;=gae::m;++i){
        if(!gae::p[i]){
            val[i]=1;
            for(int j=1;j&lt;=gae::n;++j)if(gae::a[j][i])gae::a[j][0]=!gae::a[j][0];
        }
    }
     for(int i=1;i&lt;=gae::m;++i)
        if(gae::p[i]){
            val[i]=gae::a[gae::p[i]][0];
        }
    /*for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            printf("%d",val[ID(i,j)]);
        }
        printf("\n");
    }*/
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            printf("%d%c",val[ID(i,j)],j==m?'\n':' ');
        }
    }
    //for(;;);
    return 0;
} 
</pre><pre></pre><h2>Problem3524</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;
using namespace std;
struct node{
    node(){}
    node(node*ch0,node*ch1,int _cnt){ch[0]=ch0,ch[1]=ch1,cnt=_cnt;}
    node*ch[2];int cnt;
}*nds[500010];
node pour[10750010];
node*ptr=pour;
node*newnode(node*ch0,node*ch1,int _cnt){
    if(ptr&gt;=pour+10500010)for(;;);
    *ptr=node(ch0,ch1,_cnt);
    return ptr++;
}
node*build(int l,int r){
    return newnode(0,0,0);
}
node*make(int l,int r,int v){
    if(l==r)return newnode(0,0,1);
    else{
        int m=(l+r)/2;
        if(v&lt;=m)return newnode(make(l,m,v),0,1);
        else return newnode(0,make(m+1,r,v),1);
    }
}
node*add(node*x,int l,int r,int v){
    if(l==r){
        return newnode(0,0,x-&gt;cnt+1);
    }else{
        int m=(l+r)/2;
        if(v&lt;=m){
            if(!x-&gt;ch[0])return newnode(make(l,m,v),x-&gt;ch[1],x-&gt;cnt+1);
            return newnode(add(x-&gt;ch[0],l,m,v),x-&gt;ch[1],x-&gt;cnt+1);
        }
        else{
            if(!x-&gt;ch[1])return newnode(x-&gt;ch[0],make(m+1,r,v),x-&gt;cnt+1);
            return newnode(x-&gt;ch[0],add(x-&gt;ch[1],m+1,r,v),x-&gt;cnt+1);
        }
    }
}
int C(node*x){
    if(!x)return 0;
    else return x-&gt;cnt;
}
int C0(node*x){
    if(!x)return 0;
    else return C(x-&gt;ch[0]);
}
int C1(node*x){
    if(!x)return 0;
    else return C(x-&gt;ch[1]);
}
node*CC0(node*x){
    if(!x)return 0;
    else return x-&gt;ch[0];
}
node*CC1(node*x){
    if(!x)return 0;
    else return x-&gt;ch[1];
}
int ask(node*x,node*y,int l,int r,int di){
    if(l==r){
        if(C(x)-C(y)&gt;di)return l;
        else return 0;
    }else{
        int m=(l+r)/2;
        if(C0(x)-C0(y)&gt;di)
            return ask(CC0(x),CC0(y),l,m,di);
        else if(C1(x)-C1(y)&gt;di)
            return ask(CC1(x),CC1(y),m+1,r,di);
        else return 0;
    }
}
int main(){
    int n,m;
    scanf("%d%d",&amp;n,&amp;m);
    nds[0]=build(1,n);
    for(int i=1;i&lt;=n;++i){
        int t;scanf("%d",&amp;t);
        nds[i]=add(nds[i-1],1,n,t);
    }
    for(int i=1;i&lt;=m;++i){
        int l,r;scanf("%d%d",&amp;l,&amp;r);
        printf("%d\n",ask(nds[r],nds[l-1],1,n,(r-l+1)/2));
    }
    //for(;;);
    return 0;
} 
</pre><pre></pre><h2>Problem3527</h2><pre>#include&lt;cstdio&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef complex&lt;double&gt; cpx;
double pi=acos(-1.0);cpx im(0,1);
void fft(cpx*a,int n,int s){
    for(int i=0;i&lt;n;++i){
        int j=0;for(int k=0;(1&lt;&lt;k)&lt;n;++k)j&lt;&lt;=1,j+=((i&gt;&gt;k)&amp;1);
        if(i&lt;j)swap(a[i],a[j]);
    }
    for(int i=1;(1&lt;&lt;i)&lt;=n;++i){
        int m=(1&lt;&lt;i);cpx wm=exp(double(s)*im*2.0*pi/double(m));
        for(int j=0;j&lt;n;j+=m){
            cpx w=1;
            for(int k=0;k&lt;m/2;++k){
                cpx u=a[j+k],v=w*a[j+k+m/2];
                a[j+k]=u+v;
                a[j+k+m/2]=u-v;
                w*=wm;
            }
        }
    }
}
int main(){
    int n;scanf("%d",&amp;n);
    static double a[100010];
    for(int i=0;i&lt;n;++i)
        scanf("%lf",a+i);
        
    int myn=1;while(myn&lt;2*n)myn*=2;
    static cpx mya[300010];
    for(int i=0;i&lt;n;++i)
        mya[i]=a[i];
    static cpx myb[300010];
    for(int i=1;i&lt;n;++i)myb[i]=1/(double(i)*double(i));
    static cpx myc[300010];
    fft(mya,myn,1);
    fft(myb,myn,1);
    for(int i=0;i&lt;myn;++i)
        myc[i]=mya[i]*myb[i];
    fft(myc,myn,-1);
    
    //for(int i=0;i&lt;n;++i)printf("%lf\n",real(myc[i])/myn);
    
    reverse(a,a+n);
    
    int myn2=1;while(myn2&lt;2*n)myn2*=2;
    static cpx mya2[300010];
    for(int i=0;i&lt;n;++i)
        mya2[i]=a[i];
    static cpx myb2[300010];
    for(int i=1;i&lt;n;++i)myb2[i]=1/(double(i)*double(i));
    static cpx myc2[300010];
    fft(mya2,myn2,1);
    fft(myb2,myn2,1);
    for(int i=0;i&lt;myn2;++i)
        myc2[i]=mya2[i]*myb2[i];
    fft(myc2,myn2,-1);
    
    for(int i=0;i&lt;n;++i)printf("%lf\n",real(myc[i])/myn-real(myc2[n-i-1])/myn2);
    //for(;;);
    return 0;
}
/*
5
4006373.885184
15375036.435759
1717456.469144
8514941.004912
1410681.345880

5
1
3
5
7
9
*/
</pre><pre></pre><h2>Problem3530</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
static char N[1210];int NL;
int ans=0;
namespace acm{
    const int L=2000,M=10;const char W='0';
    int ch[L+10][M+10],fa[L+10],tg[L+10],nw=1;
    void insert(char*s){
        int u=1;for(;*s;++s){
            if(!ch[u][*s-W])ch[u][*s-W]=++nw;
            u=ch[u][*s-W];
        }
        ++tg[u];
    }
    void build(){
        queue&lt;int&gt;qu;
        for(int i=0;i&lt;M;++i)
            if(!ch[1][i])ch[1][i]=1;
            else fa[ch[1][i]]=1,qu.push(ch[1][i]);
        while(!qu.empty()){
            int u=qu.front();qu.pop();
            if(tg[fa[u]])tg[u]=1;//!
            for(int i=0;i&lt;M;++i)
                if(!ch[u][i])ch[u][i]=ch[fa[u]][i];
                else fa[ch[u][i]]=ch[fa[u]][i],qu.push(ch[u][i]);
        }
    }
    void test(){
        while(true){
            static char s[1010];
            scanf("%s",s);
            int ty=1;
            char*pt=s;
            for(int u=1;*pt;++pt){
                u=ch[u][*pt-'0'];
                if(tg[u])ty=0;
            }
            if(ty==1)printf("No\n");
            else printf("Yes\n");
        }
    }
    int dp[1210][1510];
    void rundp(){
        for(int i=1;i&lt;=nw;++i)
            dp[0][i]=(tg[i]==1?0:1);
        for(int i=1;i&lt;=1205;++i){
            for(int j=1;j&lt;=nw;++j){
                if(tg[j])continue;
                for(int k=0;k&lt;M;++k){
                    dp[i][j]+=dp[i-1][ch[j][k]];
                    dp[i][j]%=1000000007;
                }
            }
        }
    }
    void run_same(){
        int u=1;
        for(int i=1;i&lt;=NL;++i){
            u=ch[u][N[i]-'0'];
            if(tg[u])return;
        }
        ++ans;
        ans%=1000000007;
    }
    void run_short(){
        for(int i=1;i&lt;NL;++i){
            for(int w=1;w&lt;M;++w){
                ans+=dp[i-1][ch[1][w]];
                ans%=1000000007;
            }
        }
    }
    void run_other(){
        int u=1;
        for(int i=1;i&lt;=NL;++i){
            for(int w=0;w&lt;N[i]-'0';++w){
                if(i==1&amp;&amp;w==0)continue;
                ans+=dp[NL-i][ch[u][w]];
                ans%=1000000007;
            }
            u=ch[u][N[i]-'0'];
            if(tg[u])return;
        }
    }
}
int main(){
    scanf("%s",N+1);NL=strlen(N+1);
    int m;scanf("%d",&amp;m);
    for(int i=1;i&lt;=m;++i){
        static char S[1510];
        scanf("%s",S+1);
        acm::insert(S+1);
    }
    acm::build();
    //acm::test();
    acm::rundp();
    acm::run_same();
    //printf("%d\n",ans);
    acm::run_short();
    //printf("%d\n",ans);
    acm::run_other();
    printf("%d\n",ans);
    //for(;;);
    return 0;
}
</pre><pre></pre><h2>Problem3544</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
int main(){
    int n;long long m,ans=0;
    scanf("%d%lld",&amp;n,&amp;m);
    static long long a[200010];
    for(int i=1;i&lt;=n;++i)
        scanf("%lld",a+i),
        a[i]=(a[i]%m+m)%m,
        a[i]+=a[i-1],
        a[i]%=m;
    set&lt;long long&gt;st;
    st.insert(0);
    for(int i=1;i&lt;=n;++i){
        set&lt;long long&gt;::iterator it=st.lower_bound(m-a[i]);
        if(it==st.begin()){
            ans=max(ans,*st.rbegin()+a[i]-m);
        }else if(it==st.end()){
            ans=max(ans,*st.rbegin()+a[i]);
        }else{
            --it;
            ans=max(ans,*it+a[i]);
            ans=max(ans,*st.rbegin()+a[i]-m);
        }
        st.insert((m-a[i])%m);
    }
    printf("%lld\n",ans);
    //for(;;);
    return 0;
}
</pre><pre></pre><h2>Problem3545</h2><pre>#include&lt;cstdio&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
namespace seg{
    struct node{
        node(int _l,int _r):
            l(_l),r(_r),s(0){
                ch[0]=ch[1]=0;}
        int l,r,s;
        node*ch[2];
    };
    void update(node*x){
        x-&gt;s=0;
        if(x-&gt;ch[0])x-&gt;s+=x-&gt;ch[0]-&gt;s;
        if(x-&gt;ch[1])x-&gt;s+=x-&gt;ch[1]-&gt;s;
    }
    void insert(node*x,int h){
        if(x-&gt;l==x-&gt;r){
            x-&gt;s=1;
        }else{
            int m=x-&gt;l+(x-&gt;r-x-&gt;l)/2;
            if(h&lt;=m){
                if(!x-&gt;ch[0])x-&gt;ch[0]=new node(x-&gt;l,m);
                insert(x-&gt;ch[0],h);
                update(x);
            }else{
                if(!x-&gt;ch[1])x-&gt;ch[1]=new node(m+1,x-&gt;r);
                insert(x-&gt;ch[1],h);
                update(x); 
            }
        }
    }
    void insert2(node*x,int h){
        if(x-&gt;l==x-&gt;r){
            --x-&gt;s;
        }else{
            int m=x-&gt;l+(x-&gt;r-x-&gt;l)/2;
            if(h&lt;=m){
                insert2(x-&gt;ch[0],h);
                update(x);
            }else{
                insert2(x-&gt;ch[1],h);
                update(x); 
            }
        }
    }
    node*merge(node*x,node*y){
        if(!x)return y;
        if(!y)return x;
        x-&gt;s+=y-&gt;s;
        if(x-&gt;l!=x-&gt;r){
            x-&gt;ch[0]=merge(x-&gt;ch[0],y-&gt;ch[0]);
            x-&gt;ch[1]=merge(x-&gt;ch[1],y-&gt;ch[1]);
        }
        delete y;
        return x;
    }
    int query(node*x,int k){
        //printf("[%d,%d,%d]\n",x-&gt;l,x-&gt;r,k);
        if(x-&gt;s&lt;k||k&lt;1)return -1;
        if(x-&gt;l==x-&gt;r)return x-&gt;l;
        int t=x-&gt;ch[1]?x-&gt;ch[1]-&gt;s:0;
        if(k&lt;=t)return query(x-&gt;ch[1],k);
        else return query(x-&gt;ch[0],k-t);
    }
}
namespace ufs{
    int prt[100010];
    int fd(int x){return x==prt[x]?x:prt[x]=fd(prt[x]);}
    void link(int x,int y){prt[fd(y)]=x;}
}
struct edge{
    int u,v,w;
};
bool cmp1(edge a,edge b){
    return a.w&lt;b.w;
}
struct ques{
  int v,x,k,idx;  
};
bool cmp2(ques a,ques b){
    return a.x&lt;b.x;
}
int main(){
    //freopen("p3.out","r",stdin);
    int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q);
    static seg::node*nds[100010];
    static int hei[100010];
    for(int i=1;i&lt;=n;++i){
        int h;scanf("%d",&amp;h);
        nds[i]=new seg::node(0,1000000000);
        seg::insert(nds[i],h);
        ufs::prt[i]=i;
        hei[i]=h;
    }
    static edge egs[500010];
    for(int i=1;i&lt;=m;++i)
        scanf("%d%d%d",&amp;egs[i].u,&amp;egs[i].v,&amp;egs[i].w);
    sort(egs+1,egs+m+1,cmp1);
    static ques qs[500010];
    for(int i=1;i&lt;=q;++i){
        scanf("%d%d%d",&amp;qs[i].v,&amp;qs[i].x,&amp;qs[i].k);
        qs[i].idx=i;
    }
    sort(qs+1,qs+q+1,cmp2);
    static int ans[500010];int pt=1;
    for(int i=1;i&lt;=q;++i){
        while(pt&lt;=m&amp;&amp;egs[pt].w&lt;=qs[i].x){
            int u=egs[pt].u;
            int v=egs[pt].v;
            int w=egs[pt].w;
            if(ufs::fd(u)!=ufs::fd(v)){
                seg::node*tmp=seg::merge(nds[ufs::fd(u)],nds[ufs::fd(v)]);
                ufs::link(u,v);
                nds[ufs::fd(u)]=tmp;
            }
            ++pt;
        }
        //for(;;);
        ans[qs[i].idx]=seg::query(nds[ufs::fd(qs[i].v)],qs[i].k);
        //for(;;);
    }
    for(int i=1;i&lt;=q;++i)printf("%d\n",ans[i]);
    //for(;;);
    return 0;
}
</pre><pre></pre><h2>Problem3638</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
#define rp(i,a,b) for(int i=a;i&gt;=b;--i)
using namespace std;
int n,q,a[100010];
struct node{
    node*ch[2];int l,r;
    int mxl,mxr,mxs;int mxlp,mxrp,mxspl,mxspr;
    int mil,mir,mis;int milp,mirp,mispl,mispr;
    int rev,sum;
}*rt;
void down(node*u){
    if(u-&gt;rev==1){
        swap(u-&gt;mxl,u-&gt;mil);swap(u-&gt;mxlp,u-&gt;milp);
        swap(u-&gt;mxr,u-&gt;mir);swap(u-&gt;mxrp,u-&gt;mirp);
        swap(u-&gt;mxs,u-&gt;mis);swap(u-&gt;mxspl,u-&gt;mispl);
        swap(u-&gt;mxspr,u-&gt;mispr);
        u-&gt;mxl=-u-&gt;mxl;u-&gt;mxr=-u-&gt;mxr;
        u-&gt;mxs=-u-&gt;mxs;
        u-&gt;mil=-u-&gt;mil;u-&gt;mir=-u-&gt;mir;
        u-&gt;mis=-u-&gt;mis;
        u-&gt;rev=0;u-&gt;sum=-u-&gt;sum;
        if(u-&gt;l!=u-&gt;r){
            u-&gt;ch[0]-&gt;rev^=1;
            u-&gt;ch[1]-&gt;rev^=1;
        }
    }
}
void update(node*u){
    down(u-&gt;ch[0]);
    down(u-&gt;ch[1]);
    u-&gt;sum=u-&gt;ch[0]-&gt;sum+u-&gt;ch[1]-&gt;sum;
    if(u-&gt;ch[0]-&gt;mxl&gt;u-&gt;ch[0]-&gt;sum+u-&gt;ch[1]-&gt;mxl){
        u-&gt;mxl=u-&gt;ch[0]-&gt;mxl;
        u-&gt;mxlp=u-&gt;ch[0]-&gt;mxlp;
    }else{
        u-&gt;mxl=u-&gt;ch[0]-&gt;sum+u-&gt;ch[1]-&gt;mxl;
        u-&gt;mxlp=u-&gt;ch[1]-&gt;mxlp;
    }
    if(u-&gt;ch[1]-&gt;mxr&gt;u-&gt;ch[1]-&gt;sum+u-&gt;ch[0]-&gt;mxr){
        u-&gt;mxr=u-&gt;ch[1]-&gt;mxr;
        u-&gt;mxrp=u-&gt;ch[1]-&gt;mxrp;
    }else{
        u-&gt;mxr=u-&gt;ch[1]-&gt;sum+u-&gt;ch[0]-&gt;mxr;
        u-&gt;mxrp=u-&gt;ch[0]-&gt;mxrp;
    }
    if(u-&gt;ch[0]-&gt;mxs&gt;=u-&gt;ch[1]-&gt;mxs&amp;&amp;u-&gt;ch[0]-&gt;mxs&gt;=u-&gt;ch[0]-&gt;mxr+u-&gt;ch[1]-&gt;mxl){
        u-&gt;mxs=u-&gt;ch[0]-&gt;mxs;
        u-&gt;mxspl=u-&gt;ch[0]-&gt;mxspl;
        u-&gt;mxspr=u-&gt;ch[0]-&gt;mxspr;
    }else if(u-&gt;ch[1]-&gt;mxs&gt;=u-&gt;ch[0]-&gt;mxs&amp;&amp;u-&gt;ch[1]-&gt;mxs&gt;=u-&gt;ch[0]-&gt;mxr+u-&gt;ch[1]-&gt;mxl){
        u-&gt;mxs=u-&gt;ch[1]-&gt;mxs;
        u-&gt;mxspl=u-&gt;ch[1]-&gt;mxspl;
        u-&gt;mxspr=u-&gt;ch[1]-&gt;mxspr;
    }else{
        u-&gt;mxs=u-&gt;ch[0]-&gt;mxr+u-&gt;ch[1]-&gt;mxl;
        u-&gt;mxspl=u-&gt;ch[0]-&gt;mxrp;
        u-&gt;mxspr=u-&gt;ch[1]-&gt;mxlp;
    }
    if(u-&gt;ch[0]-&gt;mil&lt;u-&gt;ch[0]-&gt;sum+u-&gt;ch[1]-&gt;mil){
        u-&gt;mil=u-&gt;ch[0]-&gt;mil;
        u-&gt;milp=u-&gt;ch[0]-&gt;milp;
    }else{
        u-&gt;mil=u-&gt;ch[0]-&gt;sum+u-&gt;ch[1]-&gt;mil;
        u-&gt;milp=u-&gt;ch[1]-&gt;milp;
    }
    if(u-&gt;ch[1]-&gt;mir&lt;u-&gt;ch[1]-&gt;sum+u-&gt;ch[0]-&gt;mir){
        u-&gt;mir=u-&gt;ch[1]-&gt;mir;
        u-&gt;mirp=u-&gt;ch[1]-&gt;mirp;
    }else{
        u-&gt;mir=u-&gt;ch[1]-&gt;sum+u-&gt;ch[0]-&gt;mir;
        u-&gt;mirp=u-&gt;ch[0]-&gt;mirp;
    }
    if(u-&gt;ch[0]-&gt;mis&lt;=u-&gt;ch[1]-&gt;mis&amp;&amp;u-&gt;ch[0]-&gt;mis&lt;=u-&gt;ch[0]-&gt;mir+u-&gt;ch[1]-&gt;mil){
        u-&gt;mis=u-&gt;ch[0]-&gt;mis;
        u-&gt;mispl=u-&gt;ch[0]-&gt;mispl;
        u-&gt;mispr=u-&gt;ch[0]-&gt;mispr;
    }else if(u-&gt;ch[1]-&gt;mis&lt;=u-&gt;ch[0]-&gt;mis&amp;&amp;u-&gt;ch[1]-&gt;mis&lt;=u-&gt;ch[0]-&gt;mir+u-&gt;ch[1]-&gt;mil){
        u-&gt;mis=u-&gt;ch[1]-&gt;mis;
        u-&gt;mispl=u-&gt;ch[1]-&gt;mispl;
        u-&gt;mispr=u-&gt;ch[1]-&gt;mispr;
    }else{
        u-&gt;mis=u-&gt;ch[0]-&gt;mir+u-&gt;ch[1]-&gt;mil;
        u-&gt;mispl=u-&gt;ch[0]-&gt;mirp;
        u-&gt;mispr=u-&gt;ch[1]-&gt;milp;
    }
    u-&gt;l=u-&gt;ch[0]-&gt;l;
    u-&gt;r=u-&gt;ch[1]-&gt;r;
}
node*build(int l,int r){
    node*t=new node;t-&gt;l=l;t-&gt;r=r;t-&gt;rev=0;
    if(l==r){
        t-&gt;mxl=t-&gt;mxr=t-&gt;mxs=a[l];
        t-&gt;mil=t-&gt;mir=t-&gt;mis=a[l];
        t-&gt;mxlp=t-&gt;mxrp=t-&gt;mxspl=t-&gt;mxspr=l;
        t-&gt;milp=t-&gt;mirp=t-&gt;mispl=t-&gt;mispr=l;
        t-&gt;sum=a[l];
    }else{
        int m=(l+r)/2;
        t-&gt;ch[0]=build(l,m);
        t-&gt;ch[1]=build(m+1,r);
        update(t);
    }
    return t;
}
void reverse(node*u,int l,int r){
    down(u);
    if(l&lt;=u-&gt;l&amp;&amp;r&gt;=u-&gt;r)u-&gt;rev=1;
    else{
        int m=(u-&gt;l+u-&gt;r)/2;
        if(l&lt;=m)reverse(u-&gt;ch[0],l,r);
        if(r&gt;m)reverse(u-&gt;ch[1],l,r);
        update(u);
    }
}
void modify(node*u,int p,int v){
    down(u);
    if(u-&gt;l==u-&gt;r){
        u-&gt;mxl=u-&gt;mxr=u-&gt;mxs=v;
        u-&gt;mil=u-&gt;mir=u-&gt;mis=v;
        u-&gt;sum=v;
    }else{
        int m=(u-&gt;l+u-&gt;r)/2;
        if(p&lt;=m)modify(u-&gt;ch[0],p,v);
        else modify(u-&gt;ch[1],p,v);
        update(u);
    }
}
void printnode(node*u){
    pf("[%d,%d]\n",u-&gt;l,u-&gt;r);
    pf("[%d,%d,%d]\n",u-&gt;mxl,u-&gt;mxr,u-&gt;mxs);
    pf("[%d,%d,%d,%d]\n",u-&gt;mxlp,u-&gt;mxrp,u-&gt;mxspl,u-&gt;mxspr);
    pf("[%d,%d,%d]\n",u-&gt;mil,u-&gt;mir,u-&gt;mis);
    pf("[%d,%d,%d,%d]\n",u-&gt;milp,u-&gt;mirp,u-&gt;mispl,u-&gt;mispr);
    pf("[%d,%d]\n\n",u-&gt;rev,u-&gt;sum);
} 
void print(node*u){
    down(u);
    printnode(u);
    if(u-&gt;l!=u-&gt;r)print(u-&gt;ch[0]),print(u-&gt;ch[1]); 
}
node query(node*u,int l,int r){
    down(u);
    if(l&lt;=u-&gt;l&amp;&amp;r&gt;=u-&gt;r)return*u;
    else{
        int m=(u-&gt;l+u-&gt;r)/2;
        if(r&lt;=m)return query(u-&gt;ch[0],l,r);
        else if(l&gt;m)return query(u-&gt;ch[1],l,r);
        else{
            node t1=query(u-&gt;ch[0],l,r);
            node t2=query(u-&gt;ch[1],l,r);
            node t3;t3.rev=0;t3.ch[0]=&amp;t1,t3.ch[1]=&amp;t2;
            update(&amp;t3);
            return t3;
        }
    }
}
int main(){
    sf("%d",&amp;n);
    lp(i,1,n)sf("%d",&amp;a[i]);
    rt=build(1,n);
    sf("%d",&amp;q);
    lp(i,1,q){
        int u;sf("%d",&amp;u);
        if(u==0){
            int v,w;sf("%d%d",&amp;v,&amp;w);
            modify(rt,v,w);
        }else{
            int ans=0;
            int l,r,k;sf("%d%d%d",&amp;l,&amp;r,&amp;k);
            vector&lt;pair&lt;int,int&gt; &gt;tmp;
            for(node t=query(rt,l,r);t.mxs&gt;0&amp;&amp;k&gt;0;t=query(rt,l,r),--k){
                tmp.push_back(make_pair(t.mxspl,t.mxspr));
                ans+=t.mxs;
                reverse(rt,t.mxspl,t.mxspr);
            }
            lp(j,0,int(tmp.size())-1){
                reverse(rt,tmp[j].first,tmp[j].second);
            }
            pf("%d\n",ans);
        }
    }
    //ps;
    return 0;
}</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        T u=a-1,t=0;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            T x=pow(T(rand()*1.0/RAND_MAX*(a-2)+1),u,a),y;
            for(int j=0;j&lt;t;++j){
                y=x;
                x=mul(x,x,a);
                if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)
                    return false;
            }
            if(x!=1)
                return false;
        }
        return true;
    }
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        T u=a-1,t=0;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            T x=pow(T(rand()*1.0/RAND_MAX*(a-2)+1),u,a),y;
            for(int j=0;j&lt;t;++j){
                y=x;
                x=mul(x,x,a);
                if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)
                    return false;
            }
            if(x!=1)
                return false;
        }
        return true;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;IntegerFactorization::run(a).back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        T u=a-1,t=0;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            T x=pow(T(rand()*1.0/RAND_MAX*(a-2)+1),u,a),y;
            for(int j=0;j&lt;t;++j){
                y=x;
                x=mul(x,x,a);
                if(x==1&amp;&amp;y!=1&amp;&amp;y!=a-1)
                    return false;
            }
            if(x!=1)
                return false;
        }
        return true;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;IntegerFactorization::run(a).back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;IntegerFactorization::run(a).back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x) {
  int n = 0;
  if (x == 0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}

uint64_t sqrt_u64(const uint64_t x) {
  uint64_t squaredbit;
  uint64_t remainder;
  uint64_t root;
  uint64_t tmp;

  if (x &lt; 1) return 0;

  // Load the binary constant 01 00 00 ... 00, where the number
  // of zero bits to the right of the single one bit
  // is even, and the one bit is as far left as is consistant
  // with that condition.
  squaredbit = ((uint64_t)1) &lt;&lt; (msb_u64(x) &amp; (-2));

  // Form bits of the answer.
  remainder = x;
  root = 0;
  while (squaredbit &gt; 0) {
    tmp = squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA) {
  *sqrtA = sqrt_u64(A);
  return *sqrtA * *sqrtA == A;
}

/***********************************************************************/
/**                                                                   **/
/**              FACTORIZATION (Shanks' SQUFOF) --GN2000Sep30-Oct01   **/
/**  squfof() returns a nontrivial factor of n, assuming n is odd,    **/
/**  composite, not a pure square, and has no small prime divisor,    **/
/**  or NULL if it fails to find one.  It works on two discriminants  **/
/**  simultaneously  (n and 5n for n=1 (mod 4), 3n                    **/
/**  and 4n for n=3 (mod 4)).                                         **/
/**  Present implementation is limited to input &lt;2^59, and works most **/
/**  of the time in signed arithmetic on integers &lt;2^31 in absolute   **/
/**  size. (Cf. Algo 8.7.2 in ACiCNT)                                 **/
/**                                                                   **/
/***********************************************************************/

/* The following is invoked to walk back along the ambiguous cycle* until we
 * hit an ambiguous form and thus the desired factor, which it returns.  If it
 * fails for any reason, it returns 0.  It doesn't interfere with timing and
 * diagnostics, which it leaves to squfof().
 *
 * Before we invoke this, we've found a form (A, B, -C) with A = a^2, where a
 * isn't blacklisted and where gcd(a, B) = 1.  According to ACiCANT, we should
 * now proceed reducing the form (a, -B, -aC), but it is easy to show that the
 * first reduction step always sends this to (-aC, B, a), and the next one,
 * with q computed as usual from B and a (occupying the c position), gives a
 * reduced form, whose third member is easiest to recover by going back to D.
 * From this point onwards, we're once again working with single-word numbers.
 * No need to track signs, just work with the abs values of the coefficients. */
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D) {
  int64_t b, c, q, qc, qcb, a0, b0, b1, c0;

  q = (dd + (B &gt;&gt; 1)) / a;
  b = ((q * a) &lt;&lt; 1) - B;

  c = ((D - b * b) &gt;&gt; 2) / a;

  a0 = a;
  b0 = b; // end of loop detection and safeguard
  b1 = b;

  // reduced cycles are finite
  // this is the reduction step
  for (;;) {
    c0 = c;
    if (c0 &gt; dd) {
      qcb = c0 - b;
      b = c0 + qcb;
      c = a - qcb;
    } else {
      q = (dd + (b &gt;&gt; 1)) / c0;
      if (q == 1) {
    qcb = c0 - b;
    b = c0 + qcb;
    c = a - qcb;
      } else {
    qc = q*c0;
    qcb = qc - b;
    b = qc + qcb;
    c = a - q*qcb;
      }
    }
    a = c0;

    if (b == b1) break;

    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b == b0 &amp;&amp; a == a0) {
      return 0;
    }

    b1 = b;
  }
  q = a &amp; 1 ? a : a &gt;&gt; 1;

  return q;
}


/* assume 2,3,5 do not divide n */
uint64_t squfof64(uint64_t n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  int64_t d1, d2;
  uint64_t nm4; // n (mod 4)
  int cnt = 0;
  int64_t a1, b1, c1, dd1, L1;
  int64_t a2, b2, c2, dd2, L2;
  int64_t a, q, c, qc, qcb;
  int64_t D1, D2;
  static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
  static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
  int blp1 = 0; // black list pointer
  int blp2 = 0;
  int act1 = 1; // is this multiple of N active
  int act2 = 1;
  int j;

  // now we have 5 &lt; n &lt; 2^59
  nm4 = n &amp; 3;
  if (nm4 == 1) { // n = 1 (mod4):  run one iteration on D1 = n, another on D2 = 5n
    D1 = n;
    D2 = 5 * n;
    d2 = (int64_t)sqrt_u64(D2);
    dd2 = (d2 &gt;&gt; 1) + (d2 &amp; 1);
    b2 = (d2 - 1) | 1; // b1, b2 will always stay odd
  } else { // n = 3 (mod4):  run one iteration on D1 = 3n, another on D2 = 4n
    D1 = 3 * n;
    D2 = 4 * n;
    dd2 = (int64_t)sqrt_u64(D2);
    d2 = dd2 &lt;&lt; 1;
    b2 = d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1 = sqrt_u64(D1);
  b1 = (d1 - 1) | 1; // largest odd number not exceeding d1

  c1 = (D1 - b1 * b1) &gt;&gt; 2;
  c2 = (D2 - b2 * b2) &gt;&gt; 2;
  L1 = sqrt_u64(d1);
  L2 = sqrt_u64(d2);

  /* dd1 used to compute floor((d1+b1)/2) as dd1+floor(b1/2), without
   * overflowing the 31bit signed integer size limit. Same for dd2. */
  dd1 = (d1 &gt;&gt; 1) + (d1 &amp; 1);
  a1 = 1;
  a2 = 1;

  /* The two (identity) forms (a1,b1,-c1) and (a2,b2,-c2) are now set up.
   *
   * a1 and c1 represent the absolute values of the a,c coefficients; we keep
   * track of the sign separately, via the iteration counter cnt: when cnt is
   * even, c is understood to be negative, else c is positive and a &lt; 0.
   *
   * L1, L2 are the limits for blacklisting small leading coefficients
   * on the principal cycle, to guarantee that when we find a square form,
   * its square root will belong to an ambiguous cycle  (i.e. won't be an
   * earlier form on the principal cycle).
   *
   * When n = 3(mod 4), D2 = 12(mod 16), and b^2 is always 0 or 4 mod 16.
   * It follows that 4*a*c must be 4 or 8 mod 16, respectively, so at most
   * one of a,c can be divisible by 2 at most to the first power.  This fact
   * is used a couple of times below.
   *
   * The flags act1, act2 remain true while the respective cycle is still
   * active;  we drop them to false when we return to the identity form with-
   * out having found a square form  (or when the blacklist overflows, which
   * shouldn't happen). */

  /* MAIN LOOP: walk around the principal cycle looking for a square form.
   * Blacklist small leading coefficients.
   *
   * The reduction operator can be computed entirely in 32-bit arithmetic:
   * Let q = floor(floor((d1+b1)/2)/c1)  (when c1&gt;dd1, q=1, which happens
   * often enough to special-case it).  Then the new b1 = (q*c1-b1) + q*c1,
   * which does not overflow, and the new c1 = a1 - q*(q*c1-b1), which is
   * bounded by d1 in abs size since both the old and the new a1 are positive
   * and bounded by d1. */
  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c = c1;
      q = (c &gt; dd1) ? 1 : (dd1 + (b1 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b1;
    b1 = c + qcb;
    c1 = a1 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b1;
    b1 = qc + qcb;
    c1 = a1 - q*qcb;
      }
      a1 = c;

      if (a1 &lt;= L1) { // blacklist this
    if (blp1 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist1[blp1++] = a1;
    }
      }
    }
    if (act2) { // send second form through reduction operator if active
      c = c2;
      q = (c &gt; dd2) ? 1 : (dd2 + (b2 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b2;
    b2 = c + qcb;
    c2 = a2 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b2;
    b2 = qc + qcb;
    c2 = a2 - q*qcb;
      }
      a2 = c;

      if (a2 &lt;= L2) { // blacklist this
    if (blp2 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist2[blp2++] = a2;
    }
      }
    }

    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;

    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)

    // examine first form if active
    if (act1 &amp;&amp; a1 == 1) {
      // back to identity
      // drop this discriminant
      act1 = 0;
    }
    if (act1) {
      if (is_square((uint64_t) a1, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j = 0; j &lt; blp1; j++)
        if (a == blacklist1[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q = squfof_ambig(a, b1, dd1, D1);
      if (nm4 == 3 &amp;&amp; q % 3 == 0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }

    // examine second form if active
    if (act2 &amp;&amp; a2 == 1) {
      // back to identity
      // drop this discriminant
      act2 = 0;
    }
    if (act2) {
      if (is_square((uint64_t)a2, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j = 0; j &lt; blp2; j++)
        if (a == blacklist2[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q = squfof_ambig(a, b2, dd2, D2);
      if (nm4 == 1 &amp;&amp; q % 5 == 0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}

#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}

long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

ll getans(ll n){
    if(n&lt;=lim){
        return sq(n);
    }else
            return IntegerFactorization::run(n).back().first;
}

int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;getans(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x) {
  int n = 0;
  if (x == 0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}
 
uint64_t sqrt_u64(const uint64_t x) {
  uint64_t squaredbit;
  uint64_t remainder;
  uint64_t root;
  uint64_t tmp;
 
  if (x &lt; 1) return 0;
 
  // Load the binary constant 01 00 00 ... 00, where the number
  // of zero bits to the right of the single one bit
  // is even, and the one bit is as far left as is consistant
  // with that condition.
  squaredbit = ((uint64_t)1) &lt;&lt; (msb_u64(x) &amp; (-2));
 
  // Form bits of the answer.
  remainder = x;
  root = 0;
  while (squaredbit &gt; 0) {
    tmp = squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA) {
  *sqrtA = sqrt_u64(A);
  return *sqrtA * *sqrtA == A;
}
 
/***********************************************************************/
/**                                                                   **/
/**              FACTORIZATION (Shanks' SQUFOF) --GN2000Sep30-Oct01   **/
/**  squfof() returns a nontrivial factor of n, assuming n is odd,    **/
/**  composite, not a pure square, and has no small prime divisor,    **/
/**  or NULL if it fails to find one.  It works on two discriminants  **/
/**  simultaneously  (n and 5n for n=1 (mod 4), 3n                    **/
/**  and 4n for n=3 (mod 4)).                                         **/
/**  Present implementation is limited to input &lt;2^59, and works most **/
/**  of the time in signed arithmetic on integers &lt;2^31 in absolute   **/
/**  size. (Cf. Algo 8.7.2 in ACiCNT)                                 **/
/**                                                                   **/
/***********************************************************************/
 
/* The following is invoked to walk back along the ambiguous cycle* until we
 * hit an ambiguous form and thus the desired factor, which it returns.  If it
 * fails for any reason, it returns 0.  It doesn't interfere with timing and
 * diagnostics, which it leaves to squfof().
 *
 * Before we invoke this, we've found a form (A, B, -C) with A = a^2, where a
 * isn't blacklisted and where gcd(a, B) = 1.  According to ACiCANT, we should
 * now proceed reducing the form (a, -B, -aC), but it is easy to show that the
 * first reduction step always sends this to (-aC, B, a), and the next one,
 * with q computed as usual from B and a (occupying the c position), gives a
 * reduced form, whose third member is easiest to recover by going back to D.
 * From this point onwards, we're once again working with single-word numbers.
 * No need to track signs, just work with the abs values of the coefficients. */
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}
 
static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D) {
  int64_t b, c, q, qc, qcb, a0, b0, b1, c0;
 
  q = (dd + (B &gt;&gt; 1)) / a;
  b = ((q * a) &lt;&lt; 1) - B;
 
  c = ((D - b * b) &gt;&gt; 2) / a;
 
  a0 = a;
  b0 = b; // end of loop detection and safeguard
  b1 = b;
 
  // reduced cycles are finite
  // this is the reduction step
  for (;;) {
    c0 = c;
    if (c0 &gt; dd) {
      qcb = c0 - b;
      b = c0 + qcb;
      c = a - qcb;
    } else {
      q = (dd + (b &gt;&gt; 1)) / c0;
      if (q == 1) {
    qcb = c0 - b;
    b = c0 + qcb;
    c = a - qcb;
      } else {
    qc = q*c0;
    qcb = qc - b;
    b = qc + qcb;
    c = a - q*qcb;
      }
    }
    a = c0;
 
    if (b == b1) break;
 
    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b == b0 &amp;&amp; a == a0) {
      return 0;
    }
 
    b1 = b;
  }
  q = a &amp; 1 ? a : a &gt;&gt; 1;
 
  return q;
}
 
 
/* assume 2,3,5 do not divide n */
uint64_t squfof64(uint64_t n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  int64_t d1, d2;
  uint64_t nm4; // n (mod 4)
  int cnt = 0;
  int64_t a1, b1, c1, dd1, L1;
  int64_t a2, b2, c2, dd2, L2;
  int64_t a, q, c, qc, qcb;
  int64_t D1, D2;
  static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
  static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
  int blp1 = 0; // black list pointer
  int blp2 = 0;
  int act1 = 1; // is this multiple of N active
  int act2 = 1;
  int j;
 
  // now we have 5 &lt; n &lt; 2^59
  nm4 = n &amp; 3;
  if (nm4 == 1) { // n = 1 (mod4):  run one iteration on D1 = n, another on D2 = 5n
    D1 = n;
    D2 = 5 * n;
    d2 = (int64_t)sqrt_u64(D2);
    dd2 = (d2 &gt;&gt; 1) + (d2 &amp; 1);
    b2 = (d2 - 1) | 1; // b1, b2 will always stay odd
  } else { // n = 3 (mod4):  run one iteration on D1 = 3n, another on D2 = 4n
    D1 = 3 * n;
    D2 = 4 * n;
    dd2 = (int64_t)sqrt_u64(D2);
    d2 = dd2 &lt;&lt; 1;
    b2 = d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1 = sqrt_u64(D1);
  b1 = (d1 - 1) | 1; // largest odd number not exceeding d1
 
  c1 = (D1 - b1 * b1) &gt;&gt; 2;
  c2 = (D2 - b2 * b2) &gt;&gt; 2;
  L1 = sqrt_u64(d1);
  L2 = sqrt_u64(d2);
 
  /* dd1 used to compute floor((d1+b1)/2) as dd1+floor(b1/2), without
   * overflowing the 31bit signed integer size limit. Same for dd2. */
  dd1 = (d1 &gt;&gt; 1) + (d1 &amp; 1);
  a1 = 1;
  a2 = 1;
 
  /* The two (identity) forms (a1,b1,-c1) and (a2,b2,-c2) are now set up.
   *
   * a1 and c1 represent the absolute values of the a,c coefficients; we keep
   * track of the sign separately, via the iteration counter cnt: when cnt is
   * even, c is understood to be negative, else c is positive and a &lt; 0.
   *
   * L1, L2 are the limits for blacklisting small leading coefficients
   * on the principal cycle, to guarantee that when we find a square form,
   * its square root will belong to an ambiguous cycle  (i.e. won't be an
   * earlier form on the principal cycle).
   *
   * When n = 3(mod 4), D2 = 12(mod 16), and b^2 is always 0 or 4 mod 16.
   * It follows that 4*a*c must be 4 or 8 mod 16, respectively, so at most
   * one of a,c can be divisible by 2 at most to the first power.  This fact
   * is used a couple of times below.
   *
   * The flags act1, act2 remain true while the respective cycle is still
   * active;  we drop them to false when we return to the identity form with-
   * out having found a square form  (or when the blacklist overflows, which
   * shouldn't happen). */
 
  /* MAIN LOOP: walk around the principal cycle looking for a square form.
   * Blacklist small leading coefficients.
   *
   * The reduction operator can be computed entirely in 32-bit arithmetic:
   * Let q = floor(floor((d1+b1)/2)/c1)  (when c1&gt;dd1, q=1, which happens
   * often enough to special-case it).  Then the new b1 = (q*c1-b1) + q*c1,
   * which does not overflow, and the new c1 = a1 - q*(q*c1-b1), which is
   * bounded by d1 in abs size since both the old and the new a1 are positive
   * and bounded by d1. */
  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c = c1;
      q = (c &gt; dd1) ? 1 : (dd1 + (b1 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b1;
    b1 = c + qcb;
    c1 = a1 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b1;
    b1 = qc + qcb;
    c1 = a1 - q*qcb;
      }
      a1 = c;
 
      if (a1 &lt;= L1) { // blacklist this
    if (blp1 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist1[blp1++] = a1;
    }
      }
    }
    if (act2) { // send second form through reduction operator if active
      c = c2;
      q = (c &gt; dd2) ? 1 : (dd2 + (b2 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b2;
    b2 = c + qcb;
    c2 = a2 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b2;
    b2 = qc + qcb;
    c2 = a2 - q*qcb;
      }
      a2 = c;
 
      if (a2 &lt;= L2) { // blacklist this
    if (blp2 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist2[blp2++] = a2;
    }
      }
    }
 
    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;
 
    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)
 
    // examine first form if active
    if (act1 &amp;&amp; a1 == 1) {
      // back to identity
      // drop this discriminant
      act1 = 0;
    }
    if (act1) {
      if (is_square((uint64_t) a1, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j = 0; j &lt; blp1; j++)
        if (a == blacklist1[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q = squfof_ambig(a, b1, dd1, D1);
      if (nm4 == 3 &amp;&amp; q % 3 == 0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
 
    // examine second form if active
    if (act2 &amp;&amp; a2 == 1) {
      // back to identity
      // drop this discriminant
      act2 = 0;
    }
    if (act2) {
      if (is_square((uint64_t)a2, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j = 0; j &lt; blp2; j++)
        if (a == blacklist2[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q = squfof_ambig(a, b2, dd2, D2);
      if (nm4 == 1 &amp;&amp; q % 5 == 0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
 
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
 
long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}
 
ll getans(ll n){
    if(n&lt;=lim*2){
        return sq(n);
    }else
            return IntegerFactorization::run(n).back().first;
}
 
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;getans(a)&lt;&lt;endl;
    }
    return 0;
}</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x) {
  int n = 0;
  if (x == 0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}
 
uint64_t sqrt_u64(const uint64_t x) {
  uint64_t squaredbit;
  uint64_t remainder;
  uint64_t root;
  uint64_t tmp;
 
  if (x &lt; 1) return 0;
 
  // Load the binary constant 01 00 00 ... 00, where the number
  // of zero bits to the right of the single one bit
  // is even, and the one bit is as far left as is consistant
  // with that condition.
  squaredbit = ((uint64_t)1) &lt;&lt; (msb_u64(x) &amp; (-2));
 
  // Form bits of the answer.
  remainder = x;
  root = 0;
  while (squaredbit &gt; 0) {
    tmp = squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA) {
  *sqrtA = sqrt_u64(A);
  return *sqrtA * *sqrtA == A;
}
 
/***********************************************************************/
/**                                                                   **/
/**              FACTORIZATION (Shanks' SQUFOF) --GN2000Sep30-Oct01   **/
/**  squfof() returns a nontrivial factor of n, assuming n is odd,    **/
/**  composite, not a pure square, and has no small prime divisor,    **/
/**  or NULL if it fails to find one.  It works on two discriminants  **/
/**  simultaneously  (n and 5n for n=1 (mod 4), 3n                    **/
/**  and 4n for n=3 (mod 4)).                                         **/
/**  Present implementation is limited to input &lt;2^59, and works most **/
/**  of the time in signed arithmetic on integers &lt;2^31 in absolute   **/
/**  size. (Cf. Algo 8.7.2 in ACiCNT)                                 **/
/**                                                                   **/
/***********************************************************************/
 
/* The following is invoked to walk back along the ambiguous cycle* until we
 * hit an ambiguous form and thus the desired factor, which it returns.  If it
 * fails for any reason, it returns 0.  It doesn't interfere with timing and
 * diagnostics, which it leaves to squfof().
 *
 * Before we invoke this, we've found a form (A, B, -C) with A = a^2, where a
 * isn't blacklisted and where gcd(a, B) = 1.  According to ACiCANT, we should
 * now proceed reducing the form (a, -B, -aC), but it is easy to show that the
 * first reduction step always sends this to (-aC, B, a), and the next one,
 * with q computed as usual from B and a (occupying the c position), gives a
 * reduced form, whose third member is easiest to recover by going back to D.
 * From this point onwards, we're once again working with single-word numbers.
 * No need to track signs, just work with the abs values of the coefficients. */
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}
 
static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D) {
  int64_t b, c, q, qc, qcb, a0, b0, b1, c0;
 
  q = (dd + (B &gt;&gt; 1)) / a;
  b = ((q * a) &lt;&lt; 1) - B;
 
  c = ((D - b * b) &gt;&gt; 2) / a;
 
  a0 = a;
  b0 = b; // end of loop detection and safeguard
  b1 = b;
 
  // reduced cycles are finite
  // this is the reduction step
  for (;;) {
    c0 = c;
    if (c0 &gt; dd) {
      qcb = c0 - b;
      b = c0 + qcb;
      c = a - qcb;
    } else {
      q = (dd + (b &gt;&gt; 1)) / c0;
      if (q == 1) {
    qcb = c0 - b;
    b = c0 + qcb;
    c = a - qcb;
      } else {
    qc = q*c0;
    qcb = qc - b;
    b = qc + qcb;
    c = a - q*qcb;
      }
    }
    a = c0;
 
    if (b == b1) break;
 
    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b == b0 &amp;&amp; a == a0) {
      return 0;
    }
 
    b1 = b;
  }
  q = a &amp; 1 ? a : a &gt;&gt; 1;
 
  return q;
}
 
 
/* assume 2,3,5 do not divide n */
uint64_t squfof64(uint64_t n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  int64_t d1, d2;
  uint64_t nm4; // n (mod 4)
  int cnt = 0;
  int64_t a1, b1, c1, dd1, L1;
  int64_t a2, b2, c2, dd2, L2;
  int64_t a, q, c, qc, qcb;
  int64_t D1, D2;
  static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
  static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
  int blp1 = 0; // black list pointer
  int blp2 = 0;
  int act1 = 1; // is this multiple of N active
  int act2 = 1;
  int j;
 
  // now we have 5 &lt; n &lt; 2^59
  nm4 = n &amp; 3;
  if (nm4 == 1) { // n = 1 (mod4):  run one iteration on D1 = n, another on D2 = 5n
    D1 = n;
    D2 = 5 * n;
    d2 = (int64_t)sqrt_u64(D2);
    dd2 = (d2 &gt;&gt; 1) + (d2 &amp; 1);
    b2 = (d2 - 1) | 1; // b1, b2 will always stay odd
  } else { // n = 3 (mod4):  run one iteration on D1 = 3n, another on D2 = 4n
    D1 = 3 * n;
    D2 = 4 * n;
    dd2 = (int64_t)sqrt_u64(D2);
    d2 = dd2 &lt;&lt; 1;
    b2 = d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1 = sqrt_u64(D1);
  b1 = (d1 - 1) | 1; // largest odd number not exceeding d1
 
  c1 = (D1 - b1 * b1) &gt;&gt; 2;
  c2 = (D2 - b2 * b2) &gt;&gt; 2;
  L1 = sqrt_u64(d1);
  L2 = sqrt_u64(d2);
 
  /* dd1 used to compute floor((d1+b1)/2) as dd1+floor(b1/2), without
   * overflowing the 31bit signed integer size limit. Same for dd2. */
  dd1 = (d1 &gt;&gt; 1) + (d1 &amp; 1);
  a1 = 1;
  a2 = 1;
 
  /* The two (identity) forms (a1,b1,-c1) and (a2,b2,-c2) are now set up.
   *
   * a1 and c1 represent the absolute values of the a,c coefficients; we keep
   * track of the sign separately, via the iteration counter cnt: when cnt is
   * even, c is understood to be negative, else c is positive and a &lt; 0.
   *
   * L1, L2 are the limits for blacklisting small leading coefficients
   * on the principal cycle, to guarantee that when we find a square form,
   * its square root will belong to an ambiguous cycle  (i.e. won't be an
   * earlier form on the principal cycle).
   *
   * When n = 3(mod 4), D2 = 12(mod 16), and b^2 is always 0 or 4 mod 16.
   * It follows that 4*a*c must be 4 or 8 mod 16, respectively, so at most
   * one of a,c can be divisible by 2 at most to the first power.  This fact
   * is used a couple of times below.
   *
   * The flags act1, act2 remain true while the respective cycle is still
   * active;  we drop them to false when we return to the identity form with-
   * out having found a square form  (or when the blacklist overflows, which
   * shouldn't happen). */
 
  /* MAIN LOOP: walk around the principal cycle looking for a square form.
   * Blacklist small leading coefficients.
   *
   * The reduction operator can be computed entirely in 32-bit arithmetic:
   * Let q = floor(floor((d1+b1)/2)/c1)  (when c1&gt;dd1, q=1, which happens
   * often enough to special-case it).  Then the new b1 = (q*c1-b1) + q*c1,
   * which does not overflow, and the new c1 = a1 - q*(q*c1-b1), which is
   * bounded by d1 in abs size since both the old and the new a1 are positive
   * and bounded by d1. */
  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c = c1;
      q = (c &gt; dd1) ? 1 : (dd1 + (b1 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b1;
    b1 = c + qcb;
    c1 = a1 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b1;
    b1 = qc + qcb;
    c1 = a1 - q*qcb;
      }
      a1 = c;
 
      if (a1 &lt;= L1) { // blacklist this
    if (blp1 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist1[blp1++] = a1;
    }
      }
    }
    if (act2) { // send second form through reduction operator if active
      c = c2;
      q = (c &gt; dd2) ? 1 : (dd2 + (b2 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b2;
    b2 = c + qcb;
    c2 = a2 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b2;
    b2 = qc + qcb;
    c2 = a2 - q*qcb;
      }
      a2 = c;
 
      if (a2 &lt;= L2) { // blacklist this
    if (blp2 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist2[blp2++] = a2;
    }
      }
    }
 
    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;
 
    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)
 
    // examine first form if active
    if (act1 &amp;&amp; a1 == 1) {
      // back to identity
      // drop this discriminant
      act1 = 0;
    }
    if (act1) {
      if (is_square((uint64_t) a1, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j = 0; j &lt; blp1; j++)
        if (a == blacklist1[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q = squfof_ambig(a, b1, dd1, D1);
      if (nm4 == 3 &amp;&amp; q % 3 == 0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
 
    // examine second form if active
    if (act2 &amp;&amp; a2 == 1) {
      // back to identity
      // drop this discriminant
      act2 = 0;
    }
    if (act2) {
      if (is_square((uint64_t)a2, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j = 0; j &lt; blp2; j++)
        if (a == blacklist2[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q = squfof_ambig(a, b2, dd2, D2);
      if (nm4 == 1 &amp;&amp; q % 5 == 0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
 
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
 
long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}
 
ll getans(ll n){
    if(1){
        return sq(n);
    }else
            return IntegerFactorization::run(n).back().first;
}
 
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;getans(a)&lt;&lt;endl;
    }
    return 0;
}</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int msb_u64(ull x) {
  int n=0;
  if (x==0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}

ull sqrt_u64(const ull x) {
  ull squaredbit;
  ull remainder;
  ull root;
  ull tmp;

  if (x &lt; 1) return 0;

  squaredbit=((ull)1) &lt;&lt; (msb_u64(x) &amp; (-2));

  // Form bits of the answer.
  remainder=x;
  root=0;
  while (squaredbit &gt; 0) {
    tmp=squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(ull A, ull* sqrtA) {
  *sqrtA=sqrt_u64(A);
  return *sqrtA * *sqrtA==A;
}
ull gcd_binary_l2r_u64(const ull a, const ull b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static ll squfof_ambig(ll a, ll B, ll dd, ll D) {
  ll b, c, q, qc, qcb, a0, b0, b1, c0;

  q=(dd+(B &gt;&gt; 1)) / a;
  b=((q * a) &lt;&lt; 1)-B;

  c=((D-b * b) &gt;&gt; 2) / a;

  a0=a;
  b0=b; // end of loop detection and safeguard
  b1=b;
  for (;;) {
    c0=c;
    if (c0 &gt; dd) {
      qcb=c0-b;
      b=c0+qcb;
      c=a-qcb;
    } else {
      q=(dd+(b &gt;&gt; 1)) / c0;
      if (q==1) {
    qcb=c0-b;
    b=c0+qcb;
    c=a-qcb;
      } else {
    qc=q*c0;
    qcb=qc-b;
    b=qc+qcb;
    c=a-q*qcb;
      }
    }
    a=c0;

    if (b==b1) break;

    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b==b0 &amp;&amp; a==a0) {
      return 0;
    }

    b1=b;
  }
  q=a &amp; 1 ? a : a &gt;&gt; 1;

  return q;
}


/* assume 2,3,5 do not divide n */
ull squfof64(ull n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  ll d1, d2;
  ull nm4; // n (mod 4)
  int cnt=0;
  ll a1, b1, c1, dd1, L1;
  ll a2, b2, c2, dd2, L2;
  ll a, q, c, qc, qcb;
  ll D1, D2;
  static ll blacklist1[1&lt;&lt;19];
  static ll blacklist2[1&lt;&lt;19];
  int blp1=0; // black list pointer
  int blp2=0;
  int act1=1; // is this multiple of N active
  int act2=1;
  int j;

  // now we have 5 &lt; n &lt; 2^59
  nm4=n &amp; 3;
  if (nm4==1) { // n=1 (mod4):  run one iteration on D1=n, another on D2=5n
    D1=n;
    D2=5 * n;
    d2=(ll)sqrt_u64(D2);
    dd2=(d2 &gt;&gt; 1)+(d2 &amp; 1);
    b2=(d2-1) | 1; // b1, b2 will always stay odd
  } else { // n=3 (mod4):  run one iteration on D1=3n, another on D2=4n
    D1=3 * n;
    D2=4 * n;
    dd2=(ll)sqrt_u64(D2);
    d2=dd2 &lt;&lt; 1;
    b2=d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1=sqrt_u64(D1);
  b1=(d1-1) | 1; // largest odd number not exceeding d1

  c1=(D1-b1 * b1) &gt;&gt; 2;
  c2=(D2-b2 * b2) &gt;&gt; 2;
  L1=sqrt_u64(d1);
  L2=sqrt_u64(d2);

  dd1=(d1 &gt;&gt; 1)+(d1 &amp; 1);
  a1=1;
  a2=1;

  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c=c1;
      q=(c &gt; dd1) ? 1 : (dd1+(b1 &gt;&gt; 1)) / c;
      if (q==1) {
    qcb=c-b1;
    b1=c+qcb;
    c1=a1-qcb;
      } else {
    qc=q*c;
    qcb=qc-b1;
    b1=qc+qcb;
    c1=a1-q*qcb;
      }
      a1=c;

      if (a1 &lt;= L1) { // blacklist this
            blacklist1[blp1++]=a1;

      }
    }
    if (act2) { // send second form through reduction operator if active
      c=c2;
      q=(c &gt; dd2) ? 1 : (dd2+(b2 &gt;&gt; 1)) / c;
      if (q==1) {
    qcb=c-b2;
    b2=c+qcb;
    c2=a2-qcb;
      } else {
    qc=q*c;
    qcb=qc-b2;
    b2=qc+qcb;
    c2=a2-q*qcb;
      }
      a2=c;

      if (a2 &lt;= L2) { // blacklist this
            blacklist2[blp2++]=a2;

      }
    }

    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;

    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)

    // examine first form if active
    if (act1 &amp;&amp; a1==1) {
      // back to identity
      // drop this discriminant
      act1=0;
    }
    if (act1) {
      if (is_square((ull) a1, (ull*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j=0; j &lt; blp1; j++)
        if (a==blacklist1[j]) {
          a=0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q=gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q=squfof_ambig(a, b1, dd1, D1);
      if (nm4==3 &amp;&amp; q % 3==0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }

    // examine second form if active
    if (act2 &amp;&amp; a2==1) {
      // back to identity
      // drop this discriminant
      act2=0;
    }
    if (act2) {
      if (is_square((ull)a2, (ull*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j=0; j &lt; blp2; j++)
        if (a==blacklist2[j]) {
          a=0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q=gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q=squfof_ambig(a, b2, dd2, D2);
      if (nm4==1 &amp;&amp; q % 5==0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else{
            //cout&lt;&lt;a%sq(a)&lt;&lt;endl;
            cout&lt;&lt;sq(a)&lt;&lt;endl;
        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x) {
  int n = 0;
  if (x == 0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}
  
uint64_t sqrt_u64(const uint64_t x) {
  uint64_t squaredbit;
  uint64_t remainder;
  uint64_t root;
  uint64_t tmp;
  
  if (x &lt; 1) return 0;
  
  // Load the binary constant 01 00 00 ... 00, where the number
  // of zero bits to the right of the single one bit
  // is even, and the one bit is as far left as is consistant
  // with that condition.
  squaredbit = ((uint64_t)1) &lt;&lt; (msb_u64(x) &amp; (-2));
  
  // Form bits of the answer.
  remainder = x;
  root = 0;
  while (squaredbit &gt; 0) {
    tmp = squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA) {
  *sqrtA = sqrt_u64(A);
  return *sqrtA * *sqrtA == A;
}
  
/***********************************************************************/
/**                                                                   **/
/**              FACTORIZATION (Shanks' SQUFOF) --GN2000Sep30-Oct01   **/
/**  squfof() returns a nontrivial factor of n, assuming n is odd,    **/
/**  composite, not a pure square, and has no small prime divisor,    **/
/**  or NULL if it fails to find one.  It works on two discriminants  **/
/**  simultaneously  (n and 5n for n=1 (mod 4), 3n                    **/
/**  and 4n for n=3 (mod 4)).                                         **/
/**  Present implementation is limited to input &lt;2^59, and works most **/
/**  of the time in signed arithmetic on integers &lt;2^31 in absolute   **/
/**  size. (Cf. Algo 8.7.2 in ACiCNT)                                 **/
/**                                                                   **/
/***********************************************************************/
  
/* The following is invoked to walk back along the ambiguous cycle* until we
 * hit an ambiguous form and thus the desired factor, which it returns.  If it
 * fails for any reason, it returns 0.  It doesn't interfere with timing and
 * diagnostics, which it leaves to squfof().
 *
 * Before we invoke this, we've found a form (A, B, -C) with A = a^2, where a
 * isn't blacklisted and where gcd(a, B) = 1.  According to ACiCANT, we should
 * now proceed reducing the form (a, -B, -aC), but it is easy to show that the
 * first reduction step always sends this to (-aC, B, a), and the next one,
 * with q computed as usual from B and a (occupying the c position), gives a
 * reduced form, whose third member is easiest to recover by going back to D.
 * From this point onwards, we're once again working with single-word numbers.
 * No need to track signs, just work with the abs values of the coefficients. */
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}
  
static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D) {
  int64_t b, c, q, qc, qcb, a0, b0, b1, c0;
  
  q = (dd + (B &gt;&gt; 1)) / a;
  b = ((q * a) &lt;&lt; 1) - B;
  
  c = ((D - b * b) &gt;&gt; 2) / a;
  
  a0 = a;
  b0 = b; // end of loop detection and safeguard
  b1 = b;
  
  // reduced cycles are finite
  // this is the reduction step
  for (;;) {
    c0 = c;
    if (c0 &gt; dd) {
      qcb = c0 - b;
      b = c0 + qcb;
      c = a - qcb;
    } else {
      q = (dd + (b &gt;&gt; 1)) / c0;
      if (q == 1) {
    qcb = c0 - b;
    b = c0 + qcb;
    c = a - qcb;
      } else {
    qc = q*c0;
    qcb = qc - b;
    b = qc + qcb;
    c = a - q*qcb;
      }
    }
    a = c0;
  
    if (b == b1) break;
  
    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b == b0 &amp;&amp; a == a0) {
      return 0;
    }
  
    b1 = b;
  }
  q = a &amp; 1 ? a : a &gt;&gt; 1;
  
  return q;
}
  
  
/* assume 2,3,5 do not divide n */
uint64_t squfof64(uint64_t n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  int64_t d1, d2;
  uint64_t nm4; // n (mod 4)
  int cnt = 0;
  int64_t a1, b1, c1, dd1, L1;
  int64_t a2, b2, c2, dd2, L2;
  int64_t a, q, c, qc, qcb;
  int64_t D1, D2;
  static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
  static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
  int blp1 = 0; // black list pointer
  int blp2 = 0;
  int act1 = 1; // is this multiple of N active
  int act2 = 1;
  int j;
  
  // now we have 5 &lt; n &lt; 2^59
  nm4 = n &amp; 3;
  if (nm4 == 1) { // n = 1 (mod4):  run one iteration on D1 = n, another on D2 = 5n
    D1 = n;
    D2 = 5 * n;
    d2 = (int64_t)sqrt_u64(D2);
    dd2 = (d2 &gt;&gt; 1) + (d2 &amp; 1);
    b2 = (d2 - 1) | 1; // b1, b2 will always stay odd
  } else { // n = 3 (mod4):  run one iteration on D1 = 3n, another on D2 = 4n
    D1 = 3 * n;
    D2 = 4 * n;
    dd2 = (int64_t)sqrt_u64(D2);
    d2 = dd2 &lt;&lt; 1;
    b2 = d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1 = sqrt_u64(D1);
  b1 = (d1 - 1) | 1; // largest odd number not exceeding d1
  
  c1 = (D1 - b1 * b1) &gt;&gt; 2;
  c2 = (D2 - b2 * b2) &gt;&gt; 2;
  L1 = sqrt_u64(d1);
  L2 = sqrt_u64(d2);
  
  /* dd1 used to compute floor((d1+b1)/2) as dd1+floor(b1/2), without
   * overflowing the 31bit signed integer size limit. Same for dd2. */
  dd1 = (d1 &gt;&gt; 1) + (d1 &amp; 1);
  a1 = 1;
  a2 = 1;
  
  /* The two (identity) forms (a1,b1,-c1) and (a2,b2,-c2) are now set up.
   *
   * a1 and c1 represent the absolute values of the a,c coefficients; we keep
   * track of the sign separately, via the iteration counter cnt: when cnt is
   * even, c is understood to be negative, else c is positive and a &lt; 0.
   *
   * L1, L2 are the limits for blacklisting small leading coefficients
   * on the principal cycle, to guarantee that when we find a square form,
   * its square root will belong to an ambiguous cycle  (i.e. won't be an
   * earlier form on the principal cycle).
   *
   * When n = 3(mod 4), D2 = 12(mod 16), and b^2 is always 0 or 4 mod 16.
   * It follows that 4*a*c must be 4 or 8 mod 16, respectively, so at most
   * one of a,c can be divisible by 2 at most to the first power.  This fact
   * is used a couple of times below.
   *
   * The flags act1, act2 remain true while the respective cycle is still
   * active;  we drop them to false when we return to the identity form with-
   * out having found a square form  (or when the blacklist overflows, which
   * shouldn't happen). */
  
  /* MAIN LOOP: walk around the principal cycle looking for a square form.
   * Blacklist small leading coefficients.
   *
   * The reduction operator can be computed entirely in 32-bit arithmetic:
   * Let q = floor(floor((d1+b1)/2)/c1)  (when c1&gt;dd1, q=1, which happens
   * often enough to special-case it).  Then the new b1 = (q*c1-b1) + q*c1,
   * which does not overflow, and the new c1 = a1 - q*(q*c1-b1), which is
   * bounded by d1 in abs size since both the old and the new a1 are positive
   * and bounded by d1. */
  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c = c1;
      q = (c &gt; dd1) ? 1 : (dd1 + (b1 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b1;
    b1 = c + qcb;
    c1 = a1 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b1;
    b1 = qc + qcb;
    c1 = a1 - q*qcb;
      }
      a1 = c;
  
      if (a1 &lt;= L1) { // blacklist this
    if (blp1 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist1[blp1++] = a1;
    }
      }
    }
    if (act2) { // send second form through reduction operator if active
      c = c2;
      q = (c &gt; dd2) ? 1 : (dd2 + (b2 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b2;
    b2 = c + qcb;
    c2 = a2 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b2;
    b2 = qc + qcb;
    c2 = a2 - q*qcb;
      }
      a2 = c;
  
      if (a2 &lt;= L2) { // blacklist this
    if (blp2 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist2[blp2++] = a2;
    }
      }
    }
  
    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;
  
    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)
  
    // examine first form if active
    if (act1 &amp;&amp; a1 == 1) {
      // back to identity
      // drop this discriminant
      act1 = 0;
    }
    if (act1) {
      if (is_square((uint64_t) a1, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j = 0; j &lt; blp1; j++)
        if (a == blacklist1[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q = squfof_ambig(a, b1, dd1, D1);
      if (nm4 == 3 &amp;&amp; q % 3 == 0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  
    // examine second form if active
    if (act2 &amp;&amp; a2 == 1) {
      // back to identity
      // drop this discriminant
      act2 = 0;
    }
    if (act2) {
      if (is_square((uint64_t)a2, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j = 0; j &lt; blp2; j++)
        if (a == blacklist2[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q = squfof_ambig(a, b2, dd2, D2);
      if (nm4 == 1 &amp;&amp; q % 5 == 0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
  
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int chk(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    template&lt;class T&gt;T gcd(T a,T b){
        if(a&lt;0)
            a=-a;
        if(b&lt;0)
            b=-b;
        return b?gcd(b,a%b):a;
    }
    template&lt;class T&gt;T rho(T a,T c){
        T x=double(rand())/RAND_MAX*(a-1),y=x;
        for(int i=1,k=2;;){
            x=(mul(x,x,a)+c)%a;
            T d=gcd(y-x,a);
            if(d!=1&amp;&amp;d!=a)
                return d;
            if(y==x)
                return a;
            if(++i==k)
                y=x,k=2*k;
        }
    }
    template&lt;class T&gt;vector&lt;pair&lt;T,int&gt; &gt;run(T a){
        if(a==1)
            return vector&lt;pair&lt;T,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;T,int&gt; &gt;(1,make_pair(a,1));
        T b=a;
        while((b=rho(b,T(double(rand())/RAND_MAX*(a-1))))==a);
        vector&lt;pair&lt;T,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
  
long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}
  
ll getans(ll n){
    if(1){
        return sq(n);
    }else
            return IntegerFactorization::run(n).back().first;
}
  
int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;getans(a)&lt;&lt;endl;
    }
    return 0;
}</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x) {
  int n = 0;
  if (x == 0) return -1;
  if (x &gt; 0xFFFFFFFFULL) { n += 32; x &gt;&gt;= 32; }
  if (x &gt; 0xFFFF) { n += 16; x &gt;&gt;= 16; }
  if (x &gt; 0xFF) { n += 8;  x &gt;&gt;= 8; }
  if (x &gt; 0xF) { n += 4;  x &gt;&gt;= 4; }
  if (x &gt; 0x7) { n += 2;  x &gt;&gt;= 2; }
  if (x &gt; 0x3) { n += 1;  x &gt;&gt;= 1; }
  if (x &gt; 0x1) { n ++; }
  return n;
}

uint64_t sqrt_u64(const uint64_t x) {
  uint64_t squaredbit;
  uint64_t remainder;
  uint64_t root;
  uint64_t tmp;

  if (x &lt; 1) return 0;

  // Load the binary constant 01 00 00 ... 00, where the number
  // of zero bits to the right of the single one bit
  // is even, and the one bit is as far left as is consistant
  // with that condition.
  squaredbit = ((uint64_t)1) &lt;&lt; (msb_u64(x) &amp; (-2));

  // Form bits of the answer.
  remainder = x;
  root = 0;
  while (squaredbit &gt; 0) {
    tmp = squaredbit | root;
    if (remainder &gt;= tmp) {
      remainder -= tmp;
      root &gt;&gt;= 1;
      root |= squaredbit;
    } else {
      root &gt;&gt;= 1;
    }
    squaredbit &gt;&gt;= 2;
  }
  return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA) {
  *sqrtA = sqrt_u64(A);
  return *sqrtA * *sqrtA == A;
}
 uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b) {
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D) {
  int64_t b, c, q, qc, qcb, a0, b0, b1, c0;

  q = (dd + (B &gt;&gt; 1)) / a;
  b = ((q * a) &lt;&lt; 1) - B;

  c = ((D - b * b) &gt;&gt; 2) / a;

  a0 = a;
  b0 = b; // end of loop detection and safeguard
  b1 = b;

  // reduced cycles are finite
  // this is the reduction step
  for (;;) {
    c0 = c;
    if (c0 &gt; dd) {
      qcb = c0 - b;
      b = c0 + qcb;
      c = a - qcb;
    } else {
      q = (dd + (b &gt;&gt; 1)) / c0;
      if (q == 1) {
    qcb = c0 - b;
    b = c0 + qcb;
    c = a - qcb;
      } else {
    qc = q*c0;
    qcb = qc - b;
    b = qc + qcb;
    c = a - q*qcb;
      }
    }
    a = c0;

    if (b == b1) break;

    /* safeguard against infinite loop: recognize when we've walked the entire
     * cycle in vain. (I don't think this can actually happen -- exercise.) */
    if (b == b0 &amp;&amp; a == a0) {
      return 0;
    }

    b1 = b;
  }
  q = a &amp; 1 ? a : a &gt;&gt; 1;

  return q;
}


/* assume 2,3,5 do not divide n */
uint64_t squfof64(uint64_t n) {
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
  int64_t d1, d2;
  uint64_t nm4; // n (mod 4)
  int cnt = 0;
  int64_t a1, b1, c1, dd1, L1;
  int64_t a2, b2, c2, dd2, L2;
  int64_t a, q, c, qc, qcb;
  int64_t D1, D2;
  static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
  static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
  int blp1 = 0; // black list pointer
  int blp2 = 0;
  int act1 = 1; // is this multiple of N active
  int act2 = 1;
  int j;

  // now we have 5 &lt; n &lt; 2^59
  nm4 = n &amp; 3;
  if (nm4 == 1) { // n = 1 (mod4):  run one iteration on D1 = n, another on D2 = 5n
    D1 = n;
    D2 = 5 * n;
    d2 = (int64_t)sqrt_u64(D2);
    dd2 = (d2 &gt;&gt; 1) + (d2 &amp; 1);
    b2 = (d2 - 1) | 1; // b1, b2 will always stay odd
  } else { // n = 3 (mod4):  run one iteration on D1 = 3n, another on D2 = 4n
    D1 = 3 * n;
    D2 = 4 * n;
    dd2 = (int64_t)sqrt_u64(D2);
    d2 = dd2 &lt;&lt; 1;
    b2 = d2;// &amp; (~1UL); // largest even below d2, will stay even
  }
  d1 = sqrt_u64(D1);
  b1 = (d1 - 1) | 1; // largest odd number not exceeding d1

  c1 = (D1 - b1 * b1) &gt;&gt; 2;
  c2 = (D2 - b2 * b2) &gt;&gt; 2;
  L1 = sqrt_u64(d1);
  L2 = sqrt_u64(d2);

  /* dd1 used to compute floor((d1+b1)/2) as dd1+floor(b1/2), without
   * overflowing the 31bit signed integer size limit. Same for dd2. */
  dd1 = (d1 &gt;&gt; 1) + (d1 &amp; 1);
  a1 = 1;
  a2 = 1;
  while (act1 || act2) {
    if (act1) { // send first form through reduction operator if active
      c = c1;
      q = (c &gt; dd1) ? 1 : (dd1 + (b1 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b1;
    b1 = c + qcb;
    c1 = a1 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b1;
    b1 = qc + qcb;
    c1 = a1 - q*qcb;
      }
      a1 = c;

      if (a1 &lt;= L1) { // blacklist this
    if (blp1 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist1[blp1++] = a1;
    }
      }
    }
    if (act2) { // send second form through reduction operator if active
      c = c2;
      q = (c &gt; dd2) ? 1 : (dd2 + (b2 &gt;&gt; 1)) / c;
      if (q == 1) {
    qcb = c - b2;
    b2 = c + qcb;
    c2 = a2 - qcb;
      } else {
    qc = q*c;
    qcb = qc - b2;
    b2 = qc + qcb;
    c2 = a2 - q*qcb;
      }
      a2 = c;

      if (a2 &lt;= L2) { // blacklist this
    if (blp2 &gt;= SQUFOF_BLACKLIST_SZ) {
      // overflows: shouldn't happen
      printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
      exit(-1);
    } else {
      blacklist2[blp2++] = a2;
    }
      }
    }

    // bump counter, loop if this is an odd iteration (i.e. if the real
    // leading coefficients are negative)
    cnt ++;
    if (cnt &amp; 1)
      continue;

    // second half of main loop entered only when the leading coefficients
    // are positive (i.e., during even-numbered iterations)

    // examine first form if active
    if (act1 &amp;&amp; a1 == 1) {
      // back to identity
      // drop this discriminant
      act1 = 0;
    }
    if (act1) {
      if (is_square((uint64_t) a1, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L1) {
      for (j = 0; j &lt; blp1; j++)
        if (a == blacklist1[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b1); // imprimitive form?
      if (q &gt; 1) { /* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form back along the ambiguous cycle */
      q = squfof_ambig(a, b1, dd1, D1);
      if (nm4 == 3 &amp;&amp; q % 3 == 0) q /= 3;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }

    // examine second form if active
    if (act2 &amp;&amp; a2 == 1) {
      // back to identity
      // drop this discriminant
      act2 = 0;
    }
    if (act2) {
      if (is_square((uint64_t)a2, (uint64_t*)&amp;a)) { // square form
    // check if this is blacklisted
    if (a &lt;= L2) {
      for (j = 0; j &lt; blp2; j++)
        if (a == blacklist2[j]) {
          a = 0;
          break;
        }
    }
    // not blacklisted
    if (a &gt; 0) {
      q = gcd_binary_l2r_u64(a, b2); // imprimitive form?
      /* NB if b2 is even, a is odd, so the gcd is always odd */
      if (q &gt; 1) { /* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
        return q*q;
      }
      /* chase the inverse root form along the ambiguous cycle */
      q = squfof_ambig(a, b2, dd2, D2);
      if (nm4 == 1 &amp;&amp; q % 5 == 0) q /= 5;
      if (q &gt; 1) {
        return q;
      }
    }
      }
    }
  }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return -1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return (long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return (x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x){
    int n=0;
    if(x==0)return-1;
    if(x&gt;0xFFFFFFFFULL){n+=32;x&gt;&gt;=32;}
    if(x&gt;0xFFFF){n+=16;x&gt;&gt;=16;}
    if(x&gt;0xFF){n+=8;x&gt;&gt;=8;}
    if(x&gt;0xF){n+=4;x&gt;&gt;=4;}
    if(x&gt;0x7){n+=2;x&gt;&gt;=2;}
    if(x&gt;0x3){n+=1;x&gt;&gt;=1;}
    if(x&gt;0x1){n++;}
    return n;
}

uint64_t sqrt_u64(const uint64_t x){
    uint64_t squaredbit;
    uint64_t remainder;
    uint64_t root;
    uint64_t tmp;
    if(x&lt;1)return 0;
    squaredbit=((uint64_t)1)&lt;&lt;(msb_u64(x)&amp;(-2));
    remainder=x;
    root=0;
    while(squaredbit&gt;0){
        tmp=squaredbit|root;
        if(remainder&gt;=tmp){
            remainder-= tmp;
            root&gt;&gt;=1;
            root |= squaredbit;
        } else {
            root&gt;&gt;=1;
        }
        squaredbit&gt;&gt;=2;
    }
    return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA){
    *sqrtA=sqrt_u64(A);
    return *sqrtA**sqrtA==A;
}
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b){
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D){
    int64_t b, c, q, qc, qcb, a0, b0, b1, c0;
    q=(dd+(B&gt;&gt;1))/ a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt; 2)/ a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/ c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1 ?a: a&gt;&gt;1;

    return q;
}
uint64_t squfof64(uint64_t n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
    int64_t d1, d2;
    uint64_t nm4;// n(mod 4)
    int cnt=0;
    int64_t a1, b1, c1, dd1, L1;
    int64_t a2, b2, c2, dd2, L2;
    int64_t a, q, c, qc, qcb;
    int64_t D1, D2;
    static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
    static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
    int blp1=0;// black list pointer
    int blp2=0;
    int act1=1;// is this multiple of N active
    int act2=1;
    int j;

    // now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){// n=1(mod4):  run one iteration on D1=n, another on D2=5n
        D1=n;
        D2=5*n;
        d2=(int64_t)sqrt_u64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;// b1, b2 will always stay odd
    } else {// n=3(mod4):  run one iteration on D1=3n, another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(int64_t)sqrt_u64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;// &amp;(~1UL);// largest even below d2, will stay even
    }
    d1=sqrt_u64(D1);
    b1=(d1-1)| 1;// largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt; 2;
    c2=(D2-b2*b2)&gt;&gt; 2;
    L1=sqrt_u64(d1);
    L2=sqrt_u64(d2);

    /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2), without
  *overflowing the 31bit signed integer size limit. Same for dd2. */
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){// send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/ c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;= L1){// blacklist this
                if(blp1&gt;=SQUFOF_BLACKLIST_SZ){
                    // overflows: shouldn't happen
                    printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
                    exit(-1);
                } else {
                    blacklist1[blp1++]=a1;
                }
            }
        }
        if(act2){// send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/ c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;= L2){// blacklist this
                if(blp2&gt;=SQUFOF_BLACKLIST_SZ){
                    // overflows: shouldn't happen
                    printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
                    exit(-1);
                } else {
                    blacklist2[blp2++]=a2;
                }
            }
        }

        // bump counter, loop if this is an odd iteration(i.e. if the real
        // leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

        // second half of main loop entered only when the leading coefficients
        // are positive(i.e., during even-numbered iterations)

        // examine first form if active
        if(act1&amp;&amp;a1==1){
            // back to identity
            // drop this discriminant
            act1=0;
        }
        if(act1){
            if(is_square((uint64_t)a1,(uint64_t*)&amp;a)){// square form
                // check if this is blacklisted
                if(a&lt;= L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
                // not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a, b1);// imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
                        return q*q;
                    }
                    /* chase the inverse root form back along the ambiguous cycle */
                    q=squfof_ambig(a, b1, dd1, D1);
                    if(nm4==3&amp;&amp;q % 3==0)q /= 3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

        // examine second form if active
        if(act2&amp;&amp;a2==1){
            // back to identity
            // drop this discriminant
            act2=0;
        }
        if(act2){
            if(is_square((uint64_t)a2,(uint64_t*)&amp;a)){// square form
                // check if this is blacklisted
                if(a&lt;= L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
                // not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a, b2);// imprimitive form?
                    /* NB if b2 is even, a is odd, so the gcd is always odd */
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
                        return q*q;
                    }
                    /* chase the inverse root form along the ambiguous cycle */
                    q=squfof_ambig(a, b2, dd2, D2);
                    if(nm4==1&amp;&amp;q % 5==0)q /= 5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else if(typeid(T)==typeid(long long))
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
        else
            return x*y%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a,int c=10){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pi[]={2,7,61},pl[]={2,325,9375,28178,450775,9780504,1795265022};
        if(typeid(T)==typeid(int))
            c=3;
        else if(typeid(T)==typeid(long long))
            c=7;
        T u=a-1,t=0,p=1;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            if(typeid(T)==typeid(int))
                p=pi[i]%a;
            else if(typeid(T)==typeid(long long))
                p=pl[i]%a;
            else
                p=(p*29+7)%a;
            if(!p||p==1||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
#define SQUFOF_BLACKLIST_SZ 1&lt;&lt;19
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x){
    int n=0;
    if(x==0)return-1;
    if(x&gt;0xFFFFFFFFULL){n+=32;x&gt;&gt;=32;}
    if(x&gt;0xFFFF){n+=16;x&gt;&gt;=16;}
    if(x&gt;0xFF){n+=8;x&gt;&gt;=8;}
    if(x&gt;0xF){n+=4;x&gt;&gt;=4;}
    if(x&gt;0x7){n+=2;x&gt;&gt;=2;}
    if(x&gt;0x3){n+=1;x&gt;&gt;=1;}
    if(x&gt;0x1){n++;}
    return n;
}

uint64_t sqrt_u64(const uint64_t x){
    uint64_t squaredbit;
    uint64_t remainder;
    uint64_t root;
    uint64_t tmp;
    if(x&lt;1)return 0;
    squaredbit=((uint64_t)1)&lt;&lt;(msb_u64(x)&amp;(-2));
    remainder=x;
    root=0;
    while(squaredbit&gt;0){
        tmp=squaredbit|root;
        if(remainder&gt;=tmp){
            remainder-= tmp;
            root&gt;&gt;=1;
            root |= squaredbit;
        } else {
            root&gt;&gt;=1;
        }
        squaredbit&gt;&gt;=2;
    }
    return root;
}
static inline int is_square(uint64_t A, uint64_t* sqrtA){
    *sqrtA=sqrt_u64(A);
    return *sqrtA**sqrtA==A;
}
uint64_t gcd_binary_l2r_u64(const uint64_t a, const uint64_t b){
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static int64_t squfof_ambig(int64_t a, int64_t B, int64_t dd, int64_t D){
    int64_t b, c, q, qc, qcb, a0, b0, b1, c0;
    q=(dd+(B&gt;&gt;1))/ a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt; 2)/ a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/ c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1 ?a: a&gt;&gt;1;

    return q;
}
uint64_t squfof64(uint64_t n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
    int64_t d1, d2;
    uint64_t nm4;// n(mod 4)
    int cnt=0;
    int64_t a1, b1, c1, dd1, L1;
    int64_t a2, b2, c2, dd2, L2;
    int64_t a, q, c, qc, qcb;
    int64_t D1, D2;
    static int64_t blacklist1[SQUFOF_BLACKLIST_SZ];
    static int64_t blacklist2[SQUFOF_BLACKLIST_SZ];
    int blp1=0;// black list pointer
    int blp2=0;
    int act1=1;// is this multiple of N active
    int act2=1;
    int j;

    // now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){// n=1(mod4):  run one iteration on D1=n, another on D2=5n
        D1=n;
        D2=5*n;
        d2=(int64_t)sqrt_u64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;// b1, b2 will always stay odd
    } else {// n=3(mod4):  run one iteration on D1=3n, another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(int64_t)sqrt_u64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;// &amp;(~1UL);// largest even below d2, will stay even
    }
    d1=sqrt_u64(D1);
    b1=(d1-1)| 1;// largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt; 2;
    c2=(D2-b2*b2)&gt;&gt; 2;
    L1=sqrt_u64(d1);
    L2=sqrt_u64(d2);

    /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2), without
  *overflowing the 31bit signed integer size limit. Same for dd2. */
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){// send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/ c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;= L1){// blacklist this
                if(blp1&gt;=SQUFOF_BLACKLIST_SZ){
                    // overflows: shouldn't happen
                    printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
                    exit(-1);
                } else {
                    blacklist1[blp1++]=a1;
                }
            }
        }
        if(act2){// send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/ c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;= L2){// blacklist this
                if(blp2&gt;=SQUFOF_BLACKLIST_SZ){
                    // overflows: shouldn't happen
                    printf("Black list for second discriminant overflowed.  Increase blacklist.\n");
                    exit(-1);
                } else {
                    blacklist2[blp2++]=a2;
                }
            }
        }

        // bump counter, loop if this is an odd iteration(i.e. if the real
        // leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

        // second half of main loop entered only when the leading coefficients
        // are positive(i.e., during even-numbered iterations)

        // examine first form if active
        if(act1&amp;&amp;a1==1){
            // back to identity
            // drop this discriminant
            act1=0;
        }
        if(act1){
            if(is_square((uint64_t)a1,(uint64_t*)&amp;a)){// square form
                // check if this is blacklisted
                if(a&lt;= L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
                // not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a, b1);// imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n % 3 != 0 ] */
                        return q*q;
                    }
                    /* chase the inverse root form back along the ambiguous cycle */
                    q=squfof_ambig(a, b1, dd1, D1);
                    if(nm4==3&amp;&amp;q % 3==0)q /= 3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

        // examine second form if active
        if(act2&amp;&amp;a2==1){
            // back to identity
            // drop this discriminant
            act2=0;
        }
        if(act2){
            if(is_square((uint64_t)a2,(uint64_t*)&amp;a)){// square form
                // check if this is blacklisted
                if(a&lt;= L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
                // not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a, b2);// imprimitive form?
                    /* NB if b2 is even, a is odd, so the gcd is always odd */
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n % 5 != 0 ] */
                        return q*q;
                    }
                    /* chase the inverse root form along the ambiguous cycle */
                    q=squfof_ambig(a, b2, dd2, D2);
                    if(nm4==1&amp;&amp;q % 5==0)q /= 5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
//    cout&lt;&lt;PrimalityTest::run(3ll);
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef unsigned long long uint64_t;
using namespace std;
int msb_u64(uint64_t x){
    int n=0;
    if(x==0)return-1;
    if(x&gt;0xFFFFFFFFULL){n+=32;x&gt;&gt;=32;}
    if(x&gt;0xFFFF){n+=16;x&gt;&gt;=16;}
    if(x&gt;0xFF){n+=8;x&gt;&gt;=8;}
    if(x&gt;0xF){n+=4;x&gt;&gt;=4;}
    if(x&gt;0x7){n+=2;x&gt;&gt;=2;}
    if(x&gt;0x3){n+=1;x&gt;&gt;=1;}
    if(x&gt;0x1){n++;}
    return n;
}

uint64_t sqrt_u64(const uint64_t x){
    uint64_t squaredbit;
    uint64_t remainder;
    uint64_t root;
    uint64_t tmp;
    if(x&lt;1)return 0;
    squaredbit=((uint64_t)1)&lt;&lt;(msb_u64(x)&amp;(-2));
    remainder=x;
    root=0;
    while(squaredbit&gt;0){
        tmp=squaredbit|root;
        if(remainder&gt;=tmp){
            remainder-=tmp;
            root&gt;&gt;=1;
            root |=squaredbit;
        } else {
            root&gt;&gt;=1;
        }
        squaredbit&gt;&gt;=2;
    }
    return root;
}
static inline int is_square(uint64_t A,uint64_t* sqrtA){
   *sqrtA=sqrt_u64(A);
    return*sqrtA**sqrtA==A;
}
uint64_t gcd_binary_l2r_u64(const uint64_t a,const uint64_t b){
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static int64_t squfof_ambig(int64_t a,int64_t B,int64_t dd,int64_t D){
    int64_t b,c,q,qc,qcb,a0,b0,b1,c0;
    q=(dd+(B&gt;&gt;1))/a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt;2)/a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1?a:a&gt;&gt;1;

    return q;
}
uint64_t squfof64(uint64_t n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
    int64_t d1,d2;
    uint64_t nm4;//n(mod 4)
    int cnt=0;
    int64_t a1,b1,c1,dd1,L1;
    int64_t a2,b2,c2,dd2,L2;
    int64_t a,q,c,qc,qcb;
    int64_t D1,D2;
    static int64_t blacklist1[1&lt;&lt;19];
    static int64_t blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(int64_t)sqrt_u64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    } else {//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(int64_t)sqrt_u64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt_u64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt_u64(d1);
    L2=sqrt_u64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(is_square((uint64_t)a1,(uint64_t*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=squfof_ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(is_square((uint64_t)a2,(uint64_t*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=squfof_ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
int msb_u64(ull x){
    int n=0;
    if(x==0)return-1;
    if(x&gt;0xffffffffull){n+=32;x&gt;&gt;=32;}
    if(x&gt;0xffff){n+=16;x&gt;&gt;=16;}
    if(x&gt;0xff){n+=8;x&gt;&gt;=8;}
    if(x&gt;0xf){n+=4;x&gt;&gt;=4;}
    if(x&gt;0x7){n+=2;x&gt;&gt;=2;}
    if(x&gt;0x3){n+=1;x&gt;&gt;=1;}
    if(x&gt;0x1){n++;}
    return n;
}

ull sqrt_u64(const ull x){
    ull squaredbit;
    ull remainder;
    ull root;
    ull tmp;
    if(x&lt;1)return 0;
    squaredbit=((ull)1)&lt;&lt;(msb_u64(x)&amp;(-2));
    remainder=x;
    root=0;
    while(squaredbit&gt;0){
        tmp=squaredbit|root;
        if(remainder&gt;=tmp){
            remainder-=tmp;
            root&gt;&gt;=1;
            root |=squaredbit;
        } else {
            root&gt;&gt;=1;
        }
        squaredbit&gt;&gt;=2;
    }
    return root;
}
static inline int is_square(ull A,ull* sqrtA){
   *sqrtA=sqrt_u64(A);
    return*sqrtA**sqrtA==A;
}
ull gcd_binary_l2r_u64(const ull a,const ull b){
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static ll squfof_ambig(ll a,ll B,ll dd,ll D){
    ll b,c,q,qc,qcb,a0,b0,b1,c0;
    q=(dd+(B&gt;&gt;1))/a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt;2)/a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1?a:a&gt;&gt;1;

    return q;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt_u64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    } else {//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt_u64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt_u64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt_u64(d1);
    L2=sqrt_u64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(is_square((ull)a1,(ull*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=squfof_ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(is_square((ull)a2,(ull*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=squfof_ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
int msb_u64(ull x){
    int n=0;
    if(x==0)return-1;
    if(x&gt;0xffffffffull){n+=32;x&gt;&gt;=32;}
    if(x&gt;0xffff){n+=16;x&gt;&gt;=16;}
    if(x&gt;0xff){n+=8;x&gt;&gt;=8;}
    if(x&gt;0xf){n+=4;x&gt;&gt;=4;}
    if(x&gt;0x7){n+=2;x&gt;&gt;=2;}
    if(x&gt;0x3){n+=1;x&gt;&gt;=1;}
    if(x&gt;0x1){n++;}
    return n;
}
ull sqrt_u64(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}

ull sqrt_u642(const ull x){
    ull squaredbit;
    ull remainder;
    ull root;
    ull tmp;
    if(x&lt;1)return 0;
    squaredbit=((ull)1)&lt;&lt;(msb_u64(x)&amp;(-2));
    remainder=x;
    root=0;
    while(squaredbit&gt;0){
        tmp=squaredbit|root;
        if(remainder&gt;=tmp){
            remainder-=tmp;
            root&gt;&gt;=1;
            root |=squaredbit;
        } else {
            root&gt;&gt;=1;
        }
        squaredbit&gt;&gt;=2;
    }
    return root;
}
static inline int is_square(ull A,ull* sqrtA){
   *sqrtA=sqrt_u64(A);
    return*sqrtA**sqrtA==A;
}
ull gcd_binary_l2r_u64(const ull a,const ull b){
    return b?gcd_binary_l2r_u64(b,a%b):a;
}

static ll squfof_ambig(ll a,ll B,ll dd,ll D){
    ll b,c,q,qc,qcb,a0,b0,b1,c0;
    q=(dd+(B&gt;&gt;1))/a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt;2)/a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1?a:a&gt;&gt;1;

    return q;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt_u64(n)*sqrt_u64(n)==n)
        return sqrt_u64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt_u64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    } else {//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt_u64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt_u64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt_u64(d1);
    L2=sqrt_u64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(is_square((ull)a1,(ull*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=squfof_ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(is_square((ull)a2,(ull*)&amp;a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd_binary_l2r_u64(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=squfof_ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull sqrt64(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int issqr(const ull&amp;a,ll&amp;b){
   b=sqrt64(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull b){
    return b?gcd(b,a%b):a;
}

static ll squfof_ambig(ll a,ll B,ll dd,ll D){
    ll b,c,q,qc,qcb,a0,b0,b1,c0;
    q=(dd+(B&gt;&gt;1))/a;
    b=((q*a)&lt;&lt; 1)-B;
    c=((D-b*b)&gt;&gt;2)/a;
    a0=a;
    b0=b;
    b1=b;
    for(;;){
        c0=c;
        if(c0&gt;dd){
            qcb=c0-b;
            b=c0+qcb;
            c=a-qcb;
        } else {
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1){
                qcb=c0-b;
                b=c0+qcb;
                c=a-qcb;
            } else {
                qc=q*c0;
                qcb=qc-b;
                b=qc+qcb;
                c=a-q*qcb;
            }
        }
        a=c0;
        if(b==b1)break;
        if(b==b0&amp;&amp;a==a0){
            return 0;
        }

        b1=b;
    }
    q=a&amp;1?a:a&gt;&gt;1;

    return q;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt64(n)*sqrt64(n)==n)
        return sqrt64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    } else {//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt64(d1);
    L2=sqrt64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            } else {
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            } else {
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(issqr((ull)a1,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=squfof_ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(issqr((ull)a2,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=squfof_ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}



int main(){
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull sqrt64(ull a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int issqr(ull a,ll&amp;b){
    b=sqrt64(a);
    return b*b==a;
}
ull gcd(ull a,ull b){
    return b?gcd(b,a%b):a;
}
ll ambig(ll a,ll B,ll dd,ll D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt64(n)*sqrt64(n)==n)
        return sqrt64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    }else{//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt64(d1);
    L2=sqrt64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            }else{
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            }else{
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(issqr((ull)a1,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(issqr((ull)a2,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull sqrt64(ull a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int issqr(ull a,ll&amp;b){
    b=sqrt64(a);
    return b*b==a;
}
ull gcd(ull a,ull b){
    return b?gcd(b,a%b):a;
}
ll ambig(ll a,ll B,ll dd,ll D){
    for(ll q=(dd+(B&gt;&gt;1))/a,b=((q*a)&lt;&lt; 1)-B,c=((D-b*b)&gt;&gt;2)/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt64(n)*sqrt64(n)==n)
        return sqrt64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    }else{//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt64(d1);
    L2=sqrt64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            }else{
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            }else{
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(issqr((ull)a1,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(issqr((ull)a2,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull sqrt64(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int issqr(const ull&amp;a,ll&amp;b){
    b=sqrt64(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll ambig(ll a,ll B,ll dd,ll D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+(b&gt;&gt;1))/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof64(ull n){
    if(n&lt;4||n==5)
        return 0;
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt64(n)*sqrt64(n)==n)
        return sqrt64(n);
    ll d1,d2;
    ull nm4;//n(mod 4)
    int cnt=0;
    ll a1,b1,c1,dd1,L1;
    ll a2,b2,c2,dd2,L2;
    ll a,q,c,qc,qcb;
    ll D1,D2;
    static ll blacklist1[1&lt;&lt;19];
    static ll blacklist2[1&lt;&lt;19];
    int blp1=0;//black list pointer
    int blp2=0;
    int act1=1;//is this multiple of N active
    int act2=1;
    int j;

   //now we have 5&lt;n&lt;2^59
    nm4=n&amp;3;
    if(nm4==1){//n=1(mod4): run one iteration on D1=n,another on D2=5n
        D1=n;
        D2=5*n;
        d2=(ll)sqrt64(D2);
        dd2=(d2&gt;&gt;1)+(d2&amp;1);
        b2=(d2-1)| 1;//b1,b2 will always stay odd
    }else{//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt64(d1);
    L2=sqrt64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    while(act1 || act2){
        if(act1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            }else{
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    blacklist1[blp1++]=a1;

            }
        }
        if(act2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            }else{
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    blacklist2[blp2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        cnt++;
        if(cnt&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(act1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            act1=0;
        }
        if(act1){
            if(issqr((ull)a1,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;blp1;j++)
                        if(a==blacklist1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(act2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            act2=0;
        }
        if(act2){
            if(issqr((ull)a2,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;blp2;j++)
                        if(a==blacklist2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof64(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull sqrt64(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int issqr(const ull&amp;a,ll&amp;b){
    b=sqrt64(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll ambig(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n%2==0)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(sqrt64(n)*sqrt64(n)==n)
        return sqrt64(n);
    ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2;
    ull nm4=n&amp;3;
    static ll bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j;
    if(nm4==1){
        D1=n;
        D2=5*n;
        d2=sqrt64(D2);
        dd2=d2/2+d2%2;
        b2=(d2-1)|1;//b1,b2 will always stay odd
    }else{//n=3(mod4): run one iteration on D1=3n,another on D2=4n
        D1=3*n;
        D2=4*n;
        dd2=(ll)sqrt64(D2);
        d2=dd2 &lt;&lt; 1;
        b2=d2;//&amp;(~1UL);//largest even below d2,will stay even
    }
    d1=sqrt64(D1);
    b1=(d1-1)| 1;//largest odd number not exceeding d1

    c1=(D1-b1*b1)&gt;&gt;2;
    c2=(D2-b2*b2)&gt;&gt;2;
    L1=sqrt64(d1);
    L2=sqrt64(d2);

   /* dd1 used to compute floor((d1+b1)/2)as dd1+floor(b1/2),without
 *overflowing the 31bit signed integer size limit. Same for dd2.*/
    dd1=(d1&gt;&gt;1)+(d1&amp;1);
    a1=1;
    a2=1;
    for(int i=1;ac1||ac2;++i){
        if(ac1){//send first form through reduction operator if active
            c=c1;
            q=(c&gt;dd1)?1:(dd1+(b1&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b1;
                b1=c+qcb;
                c1=a1-qcb;
            }else{
                qc=q*c;
                qcb=qc-b1;
                b1=qc+qcb;
                c1=a1-q*qcb;
            }
            a1=c;

            if(a1&lt;=L1){//blacklist this
                    bl1[p1++]=a1;

            }
        }
        if(ac2){//send second form through reduction operator if active
            c=c2;
            q=(c&gt;dd2)?1:(dd2+(b2&gt;&gt;1))/c;
            if(q==1){
                qcb=c-b2;
                b2=c+qcb;
                c2=a2-qcb;
            }else{
                qc=q*c;
                qcb=qc-b2;
                b2=qc+qcb;
                c2=a2-q*qcb;
            }
            a2=c;

            if(a2&lt;=L2){//blacklist this

                    bl2[p2++]=a2;

            }
        }

       //bump counter,loop if this is an odd iteration(i.e. if the real
       //leading coefficients are negative)
        if(i&amp;1)
            continue;

       //second half of main loop entered only when the leading coefficients
       //are positive(i.e.,during even-numbered iterations)

       //examine first form if active
        if(ac1&amp;&amp;a1==1){
           //back to identity
           //drop this discriminant
            ac1=0;
        }
        if(ac1){
            if(issqr((ull)a1,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L1){
                    for(j=0;j&lt;p1;j++)
                        if(a==bl1[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b1);//imprimitive form?
                    if(q&gt;1){/* q^2 divides D1 hence n [ assuming n%3 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form back along the ambiguous cycle*/
                    q=ambig(a,b1,dd1,D1);
                    if(nm4==3&amp;&amp;q%3==0)q/=3;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }

       //examine second form if active
        if(ac2&amp;&amp;a2==1){
           //back to identity
           //drop this discriminant
            ac2=0;
        }
        if(ac2){
            if(issqr((ull)a2,a)){//square form
               //check if this is blacklisted
                if(a&lt;=L2){
                    for(j=0;j&lt;p2;j++)
                        if(a==bl2[j]){
                            a=0;
                            break;
                        }
                }
               //not blacklisted
                if(a&gt;0){
                    q=gcd(a,b2);//imprimitive form?
                   /* NB if b2 is even,a is odd,so the gcd is always odd*/
                    if(q&gt;1){/* q^2 divides D2 hence n [ assuming n%5 !=0 ]*/
                        return q*q;
                    }
                   /* chase the inverse root form along the ambiguous cycle*/
                    q=ambig(a,b2,dd2,D2);
                    if(nm4==1&amp;&amp;q%5==0)q/=5;
                    if(q&gt;1){
                        return q;
                    }
                }
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
    //test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        if(ac1){
            c=c1;
            q=c&gt;dd1?1:(dd1+b1/2)/c;
            if(q==1)
                qcb=c-b1,b1=c+qcb,c1=a1-qcb;
            else
                qc=q*c,qcb=qc-b1,b1=qc+qcb,c1=a1-q*qcb;
            if((a1=c)&lt;=L1)
                bl1[p1++]=a1;
        }
        if(ac2){
            c=c2;
            q=c&gt;dd2?1:(dd2+b2/2)/c;
            if(q==1)
                qcb=c-b2,b2=c+qcb,c2=a2-qcb;
            else
                qc=q*c,qcb=qc-b2,b2=qc+qcb,c2=a2-q*qcb;
            if((a2=c)&lt;=L2)
                bl2[p2++]=a2;
        }
        if(i&amp;1)
            continue;
        if((ac1=ac1&amp;a1!=1)&amp;&amp;sqr(a1,a)){
            if(a&lt;=L1)
                for(j=0;j&lt;p1;j++)
                    if(a==bl1[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b1))&gt;1)
                    return q*q;
                q=amb(a,b1,dd1,D1);
                if(nm4==3&amp;&amp;(q=amb(a,b1,dd1,D1))%3==0)
                    q/=3;
                if(q&gt;1)
                    return q;
            }
        }
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr((ull)a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
    //test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        if((ac1=ac1&amp;a1!=1)&amp;&amp;sqr(a1,a)){
            if(a&lt;=L1)
                for(j=0;j&lt;p1;j++)
                    if(a==bl1[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b1))&gt;1)
                    return q*q;
                if(nm4==3&amp;&amp;(q=amb(a,b1,dd1,D1))%3==0)
                    q/=3;
                if(q&gt;1)
                    return q;
            }
        }
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr(a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)
                    q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}



int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        if(ac1){
            c=c1;
            q=c&gt;dd1?1:(dd1+b1/2)/c;
            if(q==1)
                qcb=c-b1,b1=c+qcb,c1=a1-qcb;
            else
                qc=q*c,qcb=qc-b1,b1=qc+qcb,c1=a1-q*qcb;
            if((a1=c)&lt;=L1)
                bl1[p1++]=a1;
        }
        if(ac2){
            c=c2;
            q=c&gt;dd2?1:(dd2+b2/2)/c;
            if(q==1)
                qcb=c-b2,b2=c+qcb,c2=a2-qcb;
            else
                qc=q*c,qcb=qc-b2,b2=qc+qcb,c2=a2-q*qcb;
            if((a2=c)&lt;=L2)
                bl2[p2++]=a2;
        }
        if(i&amp;1)
            continue;

        if((ac1=ac1&amp;a1!=1)&amp;&amp;sqr(a1,a)){
            if(a&lt;=L1)
                for(j=0;j&lt;p1;j++)
                    if(a==bl1[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b1))&gt;1)
                    return q*q;
                if(nm4==3&amp;&amp;(q=amb(a,b1,dd1,D1))%3==0)
                    q/=3;
                if(q&gt;1)
                    return q;
            }
        }
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr(a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)
                    q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}



int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        if(ac1){
            c=c1;
            q=c&gt;dd1?1:(dd1+b1/2)/c;
            if(q==1)
                qcb=c-b1,b1=c+qcb,c1=a1-qcb;
            else
                qc=q*c,qcb=qc-b1,b1=qc+qcb,c1=a1-q*qcb;
            if((a1=c)&lt;=L1)
                bl1[p1++]=a1;
        }
        if(ac2){
            c=c2;
            q=c&gt;dd2?1:(dd2+b2/2)/c;
            if(q==1)
                qcb=c-b2,b2=c+qcb,c2=a2-qcb;
            else
                qc=q*c,qcb=qc-b2,b2=qc+qcb,c2=a2-q*qcb;
            if((a2=c)&lt;=L2)
                bl2[p2++]=a2;
        }
        if(i&amp;1)
            continue;
        if((ac1=ac1&amp;a1!=1)&amp;&amp;sqr(a1,a)){
            if(a&lt;=L1)
                for(j=0;j&lt;p1;j++)
                    if(a==bl1[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b1))&gt;1)
                    return q*q;
                q=amb(a,b1,dd1,D1);
                if(nm4==3&amp;&amp;(q=amb(a,b1,dd1,D1))%3==0)
                    q/=3;
                if(q&gt;1)
                    return q;
            }
        }
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr((ull)a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}
 
 
 
long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}
 
void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}
 
int main(){
   // f(),f(),f();
    //for(;;);
    //test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        if((ac1=ac1&amp;a1!=1)&amp;&amp;sqr(a1,a)){
            if(a&lt;=L1)
                for(j=0;j&lt;p1;j++)
                    if(a==bl1[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b1))&gt;1)
                    return q*q;
                q=amb(a,b1,dd1,D1);
                if(nm4==3&amp;&amp;(q=amb(a,b1,dd1,D1))%3==0)
                    q/=3;
                if(q&gt;1)
                    return q;
            }
        }
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr((ull)a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
    //test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        #define m(t)\
        if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
            if(a&lt;=L##t)\
                for(j=0;j&lt;p##t;j++)\
                    if(a==bl##t[j]){\
                        a=0;\
                        break;\
                    }\
            if(a&gt;0){\
                if((q=gcd(a,b##t))&gt;1)\
                    return q*q;\
                q=amb(a,b##t,dd##t,D##t);\
                if(nm4==3&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%3==0)\
                    q/=3;\
                if(q&gt;1)\
                    return q;\
            }\
        }
        m(1)
        #undef m
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr((ull)a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
  //  test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        #define m(t)\
        if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
            if(a&lt;=L##t)\
                for(j=0;j&lt;p##t;j++)\
                    if(a==bl##t[j]){\
                        a=0;\
                        break;\
                    }\
            if(a&gt;0){\
                if((q=gcd(a,b##t))&gt;1)\
                    return q*q;\
                q=amb(a,b##t,dd##t,D##t);\
                if(nm4==3&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%3==0)\
                    q/=3;\
                if(q&gt;1)\
                    return q;\
            }\
        }
        m(1)
        #undef m
        if((ac2=ac2&amp;a2!=1)&amp;&amp;sqr(a2,a)){
            if(a&lt;=L2)
                for(j=0;j&lt;p2;j++)
                    if(a==bl2[j]){
                        a=0;
                        break;
                    }
            if(a&gt;0){
                if((q=gcd(a,b2))&gt;1)
                    return q*q;
                if(nm4==1&amp;&amp;(q=amb(a,b2,dd2,D2))%5==0)q/=5;
                if(q&gt;1)
                    return q;
            }
        }
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
int isp(int n){
    for(int i=2;i*i&lt;=n;++i)
        if(n%i==0)
            return 1;
    return 0;
}
int isp2(long long n){
    for(long long i=2;i*i&lt;=n&amp;&amp;i&lt;=60000;++i)
        if(n%i==0)
            return i;
    return-1;
}
#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
   // test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull squfof(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        #define m(t)\
        if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
            if(a&lt;=L##t)\
                for(j=0;j&lt;p##t;j++)\
                    if(a==bl##t[j]){\
                        a=0;\
                        break;\
                    }\
            if(a&gt;0){\
                if((q=gcd(a,b##t))&gt;1)\
                    return q*q;\
                q=amb(a,b##t,dd##t,D##t);\
                if(nm4==5-2*t&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%(2*t+1)==0)\
                    q/=2*t+1;\
                if(q&gt;1)\
                    return q;\
            }\
        }
        m(1)m(2)
        #undef m
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}

#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace PrimalityTest{
    template&lt;class T&gt;T mul(T x,T y,T z){
        if(typeid(T)==typeid(int))
            return(long long)x*y%z;
        else
            return(x*y-(T)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    template&lt;class T&gt;T pow(T a,T b,T c){
        T r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    template&lt;class T&gt;int run(T a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[][7]={{2,7,61},{2,325,9375,28178,450775,9780504,1795265022}};
        int c=7-4*(typeid(T)==typeid(int));
        T u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;c;++i){
            p=pf[typeid(T)!=typeid(int)][i]%a;
            if(!p||p==a-1)
                continue;
            T x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
}



long long lim=3689348814694258326ll;
typedef long long ll;
ll sq(ll n){
    if(n==1)
        return 0;
    if(PrimalityTest::run(n))
        return n;
    else{
        ll p=squfof(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(PrimalityTest::run(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
//    test();
    int T;cin&gt;&gt;T;
    while(T--){
        long long a;cin&gt;&gt;a;
        if(PrimalityTest::run(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll lim=3689348814694258326ll;
ull srt(const ull&amp;a){
    ull b=sqrt(a);
    b-=b*b&gt;a;
    return b+=(b+1)*(b+1)&lt;=a;
}
int sqr(const ull&amp;a,ll&amp;b){
    b=srt(a);
    return b*b==a;
}
ull gcd(const ull&amp;a,const ull&amp;b){
    return b?gcd(b,a%b):a;
}
ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
    for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
        if(c0&gt;dd)
            qcb=c0-b,b=c0+qcb,c=a-qcb;
        else{
            q=(dd+b/2)/c0;
            if(q==1)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else
                qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
        }
        if(a=c0,b==b1)
            break;
        if(b==b0&amp;&amp;a==a0)
            return 0;
    }
    return a&amp;1?a:a&gt;&gt;1;
}
ull fac(const ull&amp;n){
    if(n&amp;1^1)
        return 2;
    if(n%3==0)
        return 3;
    if(n%5==0)
        return 5;
    if(srt(n)*srt(n)==n)
        return srt(n);
    static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
    int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
    if(nm4==1)
        D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
    else
        D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
    d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
    for(int i=a1=a2=1;ac1||ac2;++i){
        #define m(t)\
        if(ac##t){\
            c=c##t;\
            q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
            if(q==1)\
                qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
            else\
                qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
            if((a##t=c)&lt;=L##t)\
                bl##t[p##t++]=a##t;\
        }
        m(1)m(2)
        if(i&amp;1)
            continue;
        #define m(t)\
        if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
            if(a&lt;=L##t)\
                for(j=0;j&lt;p##t;j++)\
                    if(a==bl##t[j]){\
                        a=0;\
                        break;\
                    }\
            if(a&gt;0){\
                if((q=gcd(a,b##t))&gt;1)\
                    return q*q;\
                q=amb(a,b##t,dd##t,D##t);\
                if(nm4==5-2*t&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%(2*t+1)==0)\
                    q/=2*t+1;\
                if(q&gt;1)\
                    return q;\
            }\
        }
        m(1)m(2)
        #undef m
    }
    for(int i=3;;i+=2)
        if(n%i==0)
            return i;
}
ll mul(ll x,ll y,ll z){
    return(x*y-(ll)(((long double)x*y+0.5)/z)*z+z)%z;
}
ll pow(ll a,ll b,ll c){
    ll r=1;
    for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
    return r;
}
int chk(ll a){
    if(a==2)
        return 1;
    if(a%2==0||a&lt;2)
        return 0;
    static int pf[]={2,325,9375,28178,450775,9780504,1795265022};
    ll u=a-1,t=0,p;
    for(;u%2==0;u/=2,++t);
    for(int i=0;i&lt;7;++i){
        p=pf[i]%a;
        if(!p||p==a-1)
            continue;
        ll x=pow(p,u,a);
        if(x==1)
            continue;
        for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
            x=mul(x,x,a);
            if(x==1)
                return 0;
        }
        if(x==a-1)
            continue;
        return 0;
    }
    return 1;
}





ll sq(ll n){
    if(n==1)
        return 0;
    if(chk(n))
        return n;
    else{
        ll p=fac(n);
        while(n%p==0)
            n/=p;
        return max(sq(p),sq(n));
    }
}

void test(){
    //lim=ll(1666612313);
    //lim*=lim;
    //lim+=100;
    for(ll i=lim;;--i){
        if(chk(i))
            continue;
        ll j=sq(i);
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;i%j&lt;&lt;endl;
        if(i%j)
            for(;;);
    }
}

int main(){
   // f(),f(),f();
    //for(;;);
//    test();
    int ll;cin&gt;&gt;ll;
    while(ll--){
        long long a;cin&gt;&gt;a;
        if(chk(a)){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;sq(a)&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    typedef long long ll;
    typedef unsigned long long ull;
    ll lim=3689348814694258326ll;
    ull srt(const ull&amp;a){
        ull b=sqrt(a);
        b-=b*b&gt;a;
        return b+=(b+1)*(b+1)&lt;=a;
    }
    int sqr(const ull&amp;a,ll&amp;b){
        b=srt(a);
        return b*b==a;
    }
    ull gcd(const ull&amp;a,const ull&amp;b){
        return b?gcd(b,a%b):a;
    }
    ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
        for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
            if(c0&gt;dd)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else{
                q=(dd+b/2)/c0;
                if(q==1)
                    qcb=c0-b,b=c0+qcb,c=a-qcb;
                else
                    qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
            }
            if(a=c0,b==b1)
                break;
            if(b==b0&amp;&amp;a==a0)
                return 0;
        }
        return a&amp;1?a:a&gt;&gt;1;
    }
    ull fac(const ull&amp;n){
        if(n&amp;1^1)
            return 2;
        if(n%3==0)
            return 3;
        if(n%5==0)
            return 5;
        if(srt(n)*srt(n)==n)
            return srt(n);
        static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
        int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
        if(nm4==1)
            D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
        else
            D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
        d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
        for(int i=a1=a2=1;ac1||ac2;++i){
            #define m(t)\
            if(ac##t){\
                c=c##t;\
                q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
                if(q==1)\
                    qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
                else\
                    qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
                if((a##t=c)&lt;=L##t)\
                    bl##t[p##t++]=a##t;\
            }
            m(1)m(2)
            if(i&amp;1)
                continue;
            #define m(t)\
            if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
                if(a&lt;=L##t)\
                    for(j=0;j&lt;p##t;j++)\
                        if(a==bl##t[j]){\
                            a=0;\
                            break;\
                        }\
                if(a&gt;0){\
                    if((q=gcd(a,b##t))&gt;1)\
                        return q*q;\
                    q=amb(a,b##t,dd##t,D##t);\
                    if(nm4==5-2*t&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%(2*t+1)==0)\
                        q/=2*t+1;\
                    if(q&gt;1)\
                        return q;\
                }\
            }
            m(1)m(2)
            #undef m
        }
        for(int i=3;;i+=2)
            if(n%i==0)
                return i;
    }
    ll mul(ll x,ll y,ll z){
        return(x*y-(ll)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    ll pow(ll a,ll b,ll c){
        ll r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    int chk(ll a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[]={2,325,9375,28178,450775,9780504,1795265022};
        ll u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;7;++i){
            p=pf[i]%a;
            if(!p||p==a-1)
                continue;
            ll x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    vector&lt;pair&lt;ll,int&gt; &gt;run(ll a){
        if(a==1)
            return vector&lt;pair&lt;ll,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;ll,int&gt; &gt;(1,make_pair(a,1));
        ll b=fac(a);
        vector&lt;pair&lt;ll,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int t;cin&gt;&gt;t;
    while(t--){
        long long a;cin&gt;&gt;a;
        vector&lt;pair&lt;long long,int&gt; &gt;v=IntegerFactorization::run(a);
        if(v.size()==1&amp;&amp;v[0].second==1){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;v.back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    typedef long long ll;
    typedef unsigned long long ull;
    ll lim=3689348814694258326ll;
    ull srt(const ull&amp;a){
        ull b=sqrt(a);
        b-=b*b&gt;a;
        return b+=(b+1)*(b+1)&lt;=a;
    }
    int sqr(const ull&amp;a,ll&amp;b){
        b=srt(a);
        return b*b==a;
    }
    ull gcd(const ull&amp;a,const ull&amp;b){
        return b?gcd(b,a%b):a;
    }
    ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
        for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
            if(c0&gt;dd)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else{
                q=(dd+b/2)/c0;
                if(q==1)
                    qcb=c0-b,b=c0+qcb,c=a-qcb;
                else
                    qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
            }
            if(a=c0,b==b1)
                break;
            if(b==b0&amp;&amp;a==a0)
                return 0;
        }
        return a&amp;1?a:a&gt;&gt;1;
    }
    ull fac(const ull&amp;n){
        if(n&amp;1^1)
            return 2;
        if(n%3==0)
            return 3;
        if(n%5==0)
            return 5;
        if(srt(n)*srt(n)==n)
            return srt(n);
        static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
        int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
        if(nm4==1)
            D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
        else
            D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
        d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
        for(int i=a1=a2=1;ac1||ac2;++i){
            #define m(t)\
            if(ac##t){\
                c=c##t;\
                q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
                if(q==1)\
                    qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
                else\
                    qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
                if((a##t=c)&lt;=L##t)\
                    bl##t[p##t++]=a##t;\
            }
            m(1)m(2)
            if(i&amp;1)
                continue;
            #define m(t)\
            if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
                if(a&lt;=L##t)\
                    for(j=0;j&lt;p##t;j++)\
                        if(a==bl##t[j]){\
                            a=0;\
                            break;\
                        }\
                if(a&gt;0){\
                    if((q=gcd(a,b##t))&gt;1)\
                        return q*q;\
                    q=amb(a,b##t,dd##t,D##t);\
                    if(nm4==5-2*t&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%(2*t+1)==0)\
                        q/=2*t+1;\
                    if(q&gt;1)\
                        return q;\
                }\
            }
            m(1)m(2)
            #undef m
        }
        for(int i=3;;i+=2)
            if(n%i==0)
                return i;
    }
    ll mul(const ll&amp;x,const ll&amp;y,const ll&amp;z){
        return(x*y-(ll)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    ll pow(ll a,ll b,const ll&amp;c){
        ll r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    int chk(const ll&amp;a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[]={2,325,9375,28178,450775,9780504,1795265022};
        ll u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;7;++i){
            p=pf[i]%a;
            if(!p||p==a-1)
                continue;
            ll x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    vector&lt;pair&lt;ll,int&gt; &gt;run(const ll&amp;a){
        if(a==1)
            return vector&lt;pair&lt;ll,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;ll,int&gt; &gt;(1,make_pair(a,1));
        ll b=fac(a);
        vector&lt;pair&lt;ll,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int t;cin&gt;&gt;t;
    while(t--){
        long long a;cin&gt;&gt;a;
        vector&lt;pair&lt;long long,int&gt; &gt;v=IntegerFactorization::run(a);
        if(v.size()==1&amp;&amp;v[0].second==1){
            cout&lt;&lt;"Prime\n";
        }else
            cout&lt;&lt;v.back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3667</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
namespace IntegerFactorization{
    typedef long long ll;
    typedef unsigned long long ull;
    ll lim=3689348814694258326ll;
    ull srt(const ull&amp;a){
        ull b=sqrt(a);
        b-=b*b&gt;a;
        return b+=(b+1)*(b+1)&lt;=a;
    }
    int sqr(const ull&amp;a,ll&amp;b){
        b=srt(a);
        return b*b==a;
    }
    ull gcd(const ull&amp;a,const ull&amp;b){
        return b?gcd(b,a%b):a;
    }
    ll amb(ll a,const ll&amp;B,const ll&amp;dd,const ll&amp;D){
        for(ll q=(dd+B/2)/a,b=q*a*2-B,c=(D-b*b)/4/a,qc,qcb,a0=a,b0=a,b1=b,c0=c;;b1=b,c0=c){
            if(c0&gt;dd)
                qcb=c0-b,b=c0+qcb,c=a-qcb;
            else{
                q=(dd+b/2)/c0;
                if(q==1)
                    qcb=c0-b,b=c0+qcb,c=a-qcb;
                else
                    qc=q*c0,qcb=qc-b,b=qc+qcb,c=a-q*qcb;
            }
            if(a=c0,b==b1)
                break;
            if(b==b0&amp;&amp;a==a0)
                return 0;
        }
        return a&amp;1?a:a&gt;&gt;1;
    }
    ull fac(const ull&amp;n){
        if(n&amp;1^1)
            return 2;
        if(n%3==0)
            return 3;
        if(n%5==0)
            return 5;
        if(srt(n)*srt(n)==n)
            return srt(n);
        static ll d1,d2,a1,b1,c1,dd1,L1,a2,b2,c2,dd2,L2,a,q,c,qc,qcb,D1,D2,bl1[1&lt;&lt;19],bl2[1&lt;&lt;19];
        int p1=0,p2=0,ac1=1,ac2=1,j,nm4=n&amp;3;
        if(nm4==1)
            D1=n,D2=5*n,d2=srt(D2),dd2=d2/2+d2%2,b2=(d2-1)|1;
        else
            D1=3*n,D2=4*n,dd2=srt(D2),d2=dd2*2,b2=d2;
        d1=srt(D1),b1=(d1-1)|1,c1=(D1-b1*b1)/4,c2=(D2-b2*b2)/4,L1=srt(d1),L2=srt(d2),dd1=d1/2+d1%2;
        for(int i=a1=a2=1;ac1||ac2;++i){
            #define m(t)\
            if(ac##t){\
                c=c##t;\
                q=c&gt;dd##t?1:(dd##t+b##t/2)/c;\
                if(q==1)\
                    qcb=c-b##t,b##t=c+qcb,c##t=a##t-qcb;\
                else\
                    qc=q*c,qcb=qc-b##t,b##t=qc+qcb,c##t=a##t-q*qcb;\
                if((a##t=c)&lt;=L##t)\
                    bl##t[p##t++]=a##t;\
            }
            m(1)m(2)
            if(i&amp;1)
                continue;
            #define m(t)\
            if((ac##t=ac##t&amp;a##t!=1)&amp;&amp;sqr(a##t,a)){\
                if(a&lt;=L##t)\
                    for(j=0;j&lt;p##t;j++)\
                        if(a==bl##t[j]){\
                            a=0;\
                            break;\
                        }\
                if(a&gt;0){\
                    if((q=gcd(a,b##t))&gt;1)\
                        return q*q;\
                    q=amb(a,b##t,dd##t,D##t);\
                    if(nm4==5-2*t&amp;&amp;(q=amb(a,b##t,dd##t,D##t))%(2*t+1)==0)\
                        q/=2*t+1;\
                    if(q&gt;1)\
                        return q;\
                }\
            }
            m(1)m(2)
            #undef m
        }
        for(int i=3;;i+=2)
            if(n%i==0)
                return i;
    }
    ll mul(const ll&amp;x,const ll&amp;y,const ll&amp;z){
        return(x*y-(ll)(((long double)x*y+0.5)/z)*z+z)%z;
    }
    ll pow(ll a,ll b,const ll&amp;c){
        ll r=1;
        for(;b;b&amp;1?r=mul(r,a,c):0,b&gt;&gt;=1,a=mul(a,a,c));
        return r;
    }
    int chk(const ll&amp;a){
        if(a==2)
            return 1;
        if(a%2==0||a&lt;2)
            return 0;
        static int pf[]={2,325,9375,28178,450775,9780504,1795265022};
        ll u=a-1,t=0,p;
        for(;u%2==0;u/=2,++t);
        for(int i=0;i&lt;7;++i){
            p=pf[i]%a;
            if(!p||p==a-1)
                continue;
            ll x=pow(p,u,a);
            if(x==1)
                continue;
            for(int j=0;x!=a-1&amp;&amp;j&lt;t;++j){
                x=mul(x,x,a);
                if(x==1)
                    return 0;
            }
            if(x==a-1)
                continue;
            return 0;
        }
        return 1;
    }
    vector&lt;pair&lt;ll,int&gt; &gt;run(const ll&amp;a){
        if(a==1)
            return vector&lt;pair&lt;ll,int&gt; &gt;();
        if(chk(a))
            return vector&lt;pair&lt;ll,int&gt; &gt;(1,make_pair(a,1));
        ll b=fac(a);
        vector&lt;pair&lt;ll,int&gt; &gt;u=run(b),v=run(a/b),r;
        for(int pu=0,pv=0;pu&lt;u.size()||pv&lt;v.size();){
            if(pu==u.size())
                r.push_back(v[pv++]);
            else if(pv==v.size())
                r.push_back(u[pu++]);
            else if(u[pu].first==v[pv].first)
                r.push_back(make_pair(u[pu].first,(u[pu].second+v[pv].second))),++pu,++pv;
            else if(u[pu].first&gt;v[pv].first)
                r.push_back(v[pv++]);
            else
                r.push_back(u[pu++]);}
        return r;
    }
}
int main(){
    int t;cin&gt;&gt;t;
    while(t--){
        long long a,b=1;cin&gt;&gt;a;
        if(IntegerFactorization::chk(a)){
            cout&lt;&lt;"Prime\n";
            continue;
        }
        for(long long j=a-1;j&gt;1&amp;&amp;j&gt;a-10000;--j)
            if(a%j==0){
                b=j;
                break;
            }
        a/=b;
        vector&lt;pair&lt;long long,int&gt; &gt;v=IntegerFactorization::run(a),w=IntegerFactorization::run(b);
        if(b!=1)
            cout&lt;&lt;max(v.back().first,w.back().first)&lt;&lt;endl;
        else
            cout&lt;&lt;v.back().first&lt;&lt;endl;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
using namespace std;
const int N=300010,M=26;
struct PT{
    int n,m,nxt[N+3][M],fail[N+3],cnt[N+3],hei[N+3],len[N+3],str[N+1],strl,lst,nds;
    PT(int _n,int _m):
        n(_n),m(_m),strl(0),lst(1),nds(0){
        newnode(-2);
        fill(nxt[0],nxt[0]+M,2);
        newnode(-1);
        fail[1]=0;
        newnode(0);
        fail[2]=1;
        str[0]=-1;
    }
    int newnode(int _l){
        fill(nxt[nds],nxt[nds]+M,-1);
        cnt[nds]=0;
        hei[nds]=0;
        len[nds]=_l;
        return nds++;
    }
    int getfail(int x){
        while(x&amp;&amp;str[strl-len[x]-1]!=str[strl])
            x=fail[x];
        return x;
    }
    void add(int c){
        str[++strl]=c;
        int p=getfail(lst);
        if(nxt[p][c]==-1){
            int np=newnode(len[p]+2);
            fail[np]=nxt[getfail(fail[p])][c];
            nxt[p][c]=np;
            hei[np]=hei[fail[np]]+1;
        }
        ++cnt[lst=nxt[p][c]];
    }
    void count(){
        for(int i=nds-1;i&gt;=1;--i)
            cnt[fail[i]]+=cnt[i];
    }
};

int main(){
    static char s[300010];
    scanf("%s",s+1);
    int l=strlen(s+1);
    PT*pt=new PT(l,26);
    for(int i=1;i&lt;=l;++i)
        pt-&gt;add(s[i]-'a');
    pt-&gt;count();
    long long ans=0;
    for(int i=3;i&lt;=pt-&gt;nds;++i){
        ans=max(ans,((long long)pt-&gt;cnt[i])*pt-&gt;len[i]);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem3832</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,ind[500010],oud[500010];
struct edge{
    int u,v,w;
};
#include&lt;iostream&gt;
vector&lt;edge*&gt;to[500010];
vector&lt;edge*&gt;rto[500010];
int dp[500010],rdp[500010];
vector&lt;edge*&gt;eall;
void add(int u,int v){
    edge*tmp=new edge;
    tmp-&gt;u=u;
    tmp-&gt;v=v;
    to[u].push_back(tmp);
    rto[v].push_back(tmp);
    eall.push_back(tmp);
}
int ans1,ans2=~0u&gt;&gt;1;
int main(){
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        scanf("%d%d",&amp;u,&amp;v);
        add(u,v);
        ++ind[v];
        ++oud[u];
    }
    //n+1 S     n+2 T
    int S=n+1,T=n+2;
    for(int i=1;i&lt;=n;++i){
        if(1){
            ++ind[i];
            ++oud[S];
           add(S,i);
        }
        if(1){
            ++oud[i];
            ++ind[T];
            add(i,T);
        }
    }
    vector&lt;int&gt;tps;
    queue&lt;int&gt;qu;
    qu.push(S);
    while(!qu.empty()){
        int u=qu.front();
        qu.pop();
        for(int i=0;i&lt;to[u].size();++i){
            int v=to[u][i]-&gt;v;
            --ind[v];
            if(ind[v]==0)
                qu.push(v);
        }
        tps.push_back(u);
    }
    int INF=~0u&gt;&gt;1;
    for(int i=n+1;i&gt;=0;--i){
        int u=tps[i];
        if(u==T){
            dp[u]=0;
        }else{
            dp[u]=-INF;
            for(int i=0;i&lt;to[u].size();++i){
                int v=to[u][i]-&gt;v;
                dp[u]=max(dp[u],dp[v]+1);
            }
        }
    }
    for(int i=0;i&lt;=n+1;++i){
        int u=tps[i];
        if(u==S){
            rdp[u]=0;
        }else{
            rdp[u]=-INF;
            for(int i=0;i&lt;rto[u].size();++i){
                int v=rto[u][i]-&gt;u;
                rdp[u]=max(rdp[u],rdp[v]+1);
            }
        }
    }
   // cout&lt;&lt;dp[2]&lt;&lt;endl;
   // cout&lt;&lt;rdp[2]&lt;&lt;endl;
    for(int i=0;i&lt;eall.size();++i){
        int u=eall[i]-&gt;u,v=eall[i]-&gt;v;
        eall[i]-&gt;w=dp[v]+rdp[u]+1;
      // cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;eall[i]-&gt;w&lt;&lt;endl;
    }
    multiset&lt;int&gt;cut;
    for(int i=0;i&lt;to[S].size();++i){
        cut.insert(to[S][i]-&gt;w);
    }
    for(int i=1;i&lt;=n;++i){
        int u=tps[i];
        for(int i=0;i&lt;rto[u].size();++i){
            cut.erase(cut.find(rto[u][i]-&gt;w));
        }
        if(cut.size()!=0&amp;&amp;*cut.rbegin()!=-INF&amp;&amp;*cut.rbegin()-2&lt;ans2){
            ans2=*cut.rbegin()-2;
            ans1=u;
        }
        for(int i=0;i&lt;to[u].size();++i)
            cut.insert(to[u][i]-&gt;w);
    }
    printf("%d %d\n",ans1,ans2);
    return 0;
}
</pre><pre></pre><h2>Problem3911</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=b;++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define all(a) a.begin(),a.end()
#define sqr(a) ((a)*(a))
#define pub push_back
#define mkp make_pair
#define scf scanf
#define ptf printf
#define inf (~0u&gt;&gt;1)
#define sta static
#define ocf 0
#ifdef ONLINE_JUDGE
#define ocf 1
#endif
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef string str;
typedef vector&lt;int&gt; vei;
typedef vector&lt;string&gt; ves;
typedef map&lt;int,int&gt; mii;
typedef map&lt;str,int&gt; msi;
typedef set&lt;int&gt; sti;
typedef set&lt;str&gt; sts;
typedef pair&lt;int,int&gt; pii;
typedef vector&lt;pii&gt; vii;

#ifndef DELAUNAY_TRIANGULATION
#define DELAUNAY_TRIANGULATION
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct DelaunayTriangulation{
        typedef double T;const static T E;
        struct poi{
            T x,y;poi(T _x=0,T _y=0):x(_x),y(_y){}
            poi operator-(poi b){return poi(x-b.x,y-b.y);}
            int operator&lt;(poi b)const{if(fabs(x-b.x)&lt;E)return y&lt;b.y;return x&lt;b.x;}};
        int n;vector&lt;pair&lt;poi,int&gt; &gt;pts;vector&lt;vector&lt;int&gt; &gt;egs;
        T det(poi a,poi b){return a.x*b.y-a.y*b.x;}
        T dot(poi a,poi b){return a.x*b.x+a.y*b.y;}
        int dir(poi a,poi b,poi c){T r=det(c-a,b-a);if(r&lt;-E)return -1;return r&gt;E?1:0;}
        int inc(poi a,poi b,poi c,poi d){
            a=a-d;b=b-d;c=c-d;
            T az=a.x*a.x+a.y*a.y,bz=b.x*b.x+b.y*b.y,cz=c.x*c.x+c.y*c.y;
            return a.x*b.y*cz+b.x*c.y*az+c.x*a.y*bz-a.x*bz*c.y-b.x*a.y*cz-c.x*b.y*az&gt;E;}
        int crs(poi a,poi b,poi c,poi d){return dir(a,b,c)*dir(a,b,d)==-1&amp;&amp;dir(c,d,a)*dir(c,d,b)==-1;}
        DelaunayTriangulation():n(0),pts(1){}
        void add(T x,T y){poi a;a.x=x;a.y=y;pts.push_back(make_pair(a,++n));}
        poi&amp;pot(int a){return pts[a].first;}
        void con(int a,int b){
            egs[a].push_back(b);egs[b].push_back(a);}
        void dco(int a,int b){
            egs[a].erase(find(egs[a].begin(),egs[a].end(),b));
            egs[b].erase(find(egs[b].begin(),egs[b].end(),a));}
        void dnc(int l,int r){
            if(r==l)return;if(r==l+1){con(l,r);return;}
            if(r==l+2){
                if(dir(pot(l),pot(l+1),pot(r)))con(l,l+1),con(l+1,r),con(l,r);
                else{
                    if(dot(pot(l+1)-pot(l),pot(r)-pot(l))&lt;0)con(l,l+1),con(l,r);
                    else if(dot(pot(l)-pot(l+1),pot(r)-pot(l+1))&lt;0)con(l,l+1),con(l+1,r);
                    else con(l,r),con(l+1,r);}
                return;}
            int m=(l+r)/2,pl=l,pr=r;dnc(l,m);dnc(m+1,r);
            for(int f=0;;f=0){
                for(int i=0;i&lt;egs[pl].size();++i){
                    int a=egs[pl][i],d=dir(pot(pl),pot(pr),pot(a));
                    if(d&gt;0||(d==0&amp;&amp;dot(pot(pl)-pot(a),pot(pr)-pot(a))&lt;0)){
                        pl=a;f=1;break;}}
                for(int i=0;i&lt;egs[pr].size();++i){
                    int a=egs[pr][i],d=dir(pot(pl),pot(pr),pot(a));
                    if(d&gt;0||(d==0&amp;&amp;dot(pot(pl)-pot(a),pot(pr)-pot(a))&lt;0)){
                        pr=a;f=1;break;}}
                if(!f)break;}
            con(pl,pr);for(int pn=-1,wh=0;;pn=-1,wh=0){
                for(int i=0;i&lt;egs[pl].size();++i){
                    int a=egs[pl][i],d=dir(pot(pl),pot(pr),pot(a));
                    if(d&lt;0&amp;&amp;(pn==-1||inc(pot(pl),pot(pr),pot(pn),pot(a))))pn=a;}
                for(int i=0;i&lt;egs[pr].size();++i){
                    int a=egs[pr][i],d=dir(pot(pl),pot(pr),pot(a));
                    if(d&lt;0&amp;&amp;(pn==-1||inc(pot(pl),pot(pr),pot(pn),pot(a))))pn=a,wh=1;}
                if(pn==-1)break;vector&lt;int&gt;ne;
                if(!wh){
                    for(int i=0;i&lt;egs[pl].size();++i){
                        int a=egs[pl][i];
                        if(!crs(pot(pn),pot(pr),pot(pl),pot(a)))ne.push_back(a);
                        else egs[a].erase(find(egs[a].begin(),egs[a].end(),pl));}
                    egs[pl]=ne;con(pr,pn);pl=pn;
                }else{
                    for(int i=0;i&lt;egs[pr].size();++i){
                        int a=egs[pr][i];
                        if(!crs(pot(pn),pot(pl),pot(pr),pot(a)))ne.push_back(a);
                        else egs[a].erase(find(egs[a].begin(),egs[a].end(),pr));}
                    egs[pr]=ne;con(pl,pn);pr=pn;}}}
        vector&lt;vector&lt;int&gt; &gt;run(){
            egs.resize(n+1);sort(pts.begin()+1,pts.end());dnc(1,n);
            vector&lt;vector&lt;int&gt; &gt;res(n+1);
            for(int u=1;u&lt;=n;++u)for(int i=0;i&lt;egs[u].size();++i){
                int v=egs[u][i];res[pts[u].second].push_back(pts[v].second);}
            return res;}};
    const double DelaunayTriangulation::E=1e-8;}
#endif

#ifndef LINK_CUT_TREES
#define LINK_CUT_TREES
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct LinkCutTrees{
        struct node{
            node():ch({0,0}),pr(0),rev(0){}
            node*ch[2],*pr;T ifo;int rev;}*ptrs;
        int direct(node*x){
            if(!x-&gt;pr)return 2;
            if(x==x-&gt;pr-&gt;ch[0])return 0;
            if(x==x-&gt;pr-&gt;ch[1])return 1;
            return 2;}
        void down(node*x){
            if(x-&gt;rev){
                x-&gt;ifo.reverse();swap(x-&gt;ch[0],x-&gt;ch[1]);
                for(int i=0;i&lt;2;++i)if(x-&gt;ch[i])x-&gt;ch[i]-&gt;rev^=1;
                x-&gt;rev=0;}
            x-&gt;ifo.down(x-&gt;ch[0]?&amp;x-&gt;ch[0]-&gt;ifo:0,x-&gt;ch[1]?&amp;x-&gt;ch[1]-&gt;ifo:0);}
        void up(node*x){
            for(int i=0;i&lt;2;++i)if(x-&gt;ch[i])down(x-&gt;ch[i]);
            x-&gt;ifo.up(x-&gt;ch[0]?&amp;x-&gt;ch[0]-&gt;ifo:0,x-&gt;ch[1]?&amp;x-&gt;ch[1]-&gt;ifo:0);}
        void setchild(node*x,node*y,int d){x-&gt;ch[d]=y;if(y)y-&gt;pr=x;up(x);}
        void rotate(node*x){
            node*y=x-&gt;pr,*z=y-&gt;pr;int d1=direct(x),d2=direct(y);
            setchild(y,x-&gt;ch[!d1],d1);setchild(x,y,!d1);
            if(d2&lt;2)setchild(z,x,d2);else x-&gt;pr=z;}
        void release(node*x){if(direct(x)&lt;2)release(x-&gt;pr);down(x);}
        void splay(node*x){
            for(release(x);direct(x)&lt;2;){
                node*y=x-&gt;pr;
                if(direct(y)==2)rotate(x);
                else if(direct(x)==direct(y))rotate(y),rotate(x);
                else rotate(x),rotate(x);}}
        node*access(node*x){
            node*y=0;for(;x;){splay(x);setchild(x,y,1);y=x;x=x-&gt;pr;}return y;}
        void evert(node*x){access(x);splay(x);x-&gt;rev=1;}
        LinkCutTrees(int n):ptrs(new node[n]-1){}
        void set(int x,T v){ptrs[x].ifo=v;}
        int linked(int a,int b){
            access((ptrs+a));node*z=access((ptrs+b));return z==access((ptrs+a));}
        void link(int a,int b){evert((ptrs+b));(ptrs+b)-&gt;pr=(ptrs+a);}
        void cut(int a,int b){
            access((ptrs+b));node*z=access((ptrs+a));
            if(z==(ptrs+a))splay((ptrs+b)),(ptrs+b)-&gt;pr=0;
            else access((ptrs+b)),splay((ptrs+a)),(ptrs+a)-&gt;pr=0;}
        int root(int a){
            access((ptrs+a));splay((ptrs+a));
            node*r=(ptrs+a);while(r-&gt;ch[1])r=r-&gt;ch[1];
            return r-ptrs;}
        void evert(int a){evert((ptrs+a));}
        int lca(int a,int b){access((ptrs+a));return access((ptrs+b))-ptrs;}
        T query(int a){splay((ptrs+a));T p=(ptrs+a)-&gt;ifo;p.up(0,0);return p;}
        T query(int a,int b){
            if((ptrs+a)==(ptrs+b))return query((ptrs+a));
            access((ptrs+a));node*c=access((ptrs+b));
            T p=c.ifo;if(c==(ptrs+b)){
                splay((ptrs+a));T q=(ptrs+a)-&gt;ifo;
                q.reverse();p.up(&amp;q,0);return p;
            }else if(c==(ptrs+a))p.up(0,&amp;(ptrs+a)-&gt;ch[1]-&gt;ifo);
            else{
                splay((ptrs+a));T q=(ptrs+a)-&gt;ifo;
                q.reverse();p.up(&amp;q,&amp;c-&gt;ch[1]-&gt;ifo);}
            return p;}
        T equery(int a){return query(a);}
        T equery(int a,int b){
            access((ptrs+a));node*c=access((ptrs+b));
            if(c==(ptrs+b)){
                splay((ptrs+a));T q=(ptrs+a)-&gt;ifo;
                q.reverse();return q;
            }else if(c==(ptrs+a))return (ptrs+a)-&gt;ch[1]-&gt;ifo;
            else{
                splay((ptrs+a));node*t=c-&gt;ch[1];
                while(t-&gt;ch[0])t=t-&gt;ch[0];splay(t);
                if(t-&gt;ch[1])down(t-&gt;ch[1]);
                T p=t-&gt;ifo,q=(ptrs+a)-&gt;ifo;q.reverse();
                p.up(&amp;q,t-&gt;ch[1]?&amp;t-&gt;ch[1]-&gt;ifo:0);return p;}}
        template&lt;class F&gt;void modify(int a,F f){
            splay((ptrs+a));f(&amp;(ptrs+a)-&gt;ifo);up((ptrs+a));}
        template&lt;class F&gt;void modify(int a,int b,F f){
            if((ptrs+a)==(ptrs+b)){
                splay((ptrs+a));f(0,&amp;(ptrs+a)-&gt;ifo,0);up((ptrs+a));return ;}
            access((ptrs+a));node*c=access((ptrs+b));
            if(c==(ptrs+b))splay((ptrs+a)),f(&amp;(ptrs+a)-&gt;ifo,&amp;(ptrs+b)-&gt;ifo,0);
            else if(c==a)f(0,&amp;(ptrs+a)-&gt;ifo,&amp;(ptrs+a)-&gt;ch[1]-&gt;ifo);
            else splay(a),f(&amp;(ptrs+a)-&gt;ifo,&amp;c-&gt;ifo,&amp;c-&gt;ch[1]-&gt;ifo);
            up(c);}
        template&lt;class F&gt;void emodify(int a,F f){modify(a,f);}
        template&lt;class F&gt;void emodify(int a,int b,F f){
            access((ptrs+a));node*c=access((ptrs+b));
            if(c==(ptrs+b))splay((ptrs+a)),f(&amp;(ptrs+a)-&gt;ifo,0);
            else if(c==a)f(0,&amp;(ptrs+a)-&gt;ch[1]-&gt;ifo);
            else splay(a),f(&amp;(ptrs+a)-&gt;ifo,&amp;c-&gt;ch[1]-&gt;ifo);
            up(c);}};}
#endif

#ifndef MINIMUM_SPANNING_TREE
#define MINIMUM_SPANNING_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    template&lt;class T,class C=less&lt;T&gt; &gt;struct MinimumSpanningTree {
        struct edge{
            T w;int u,v;
            int operator&lt;(const edge&amp;b)const{return C()(w,b.w);}};
        int n;vector&lt;edge&gt;egs;vector&lt;int&gt;pr;
        MinimumSpanningTree(int _n):n(_n),pr(n+1){}
        void add(int u,int v,T w){edge e;e.u=u;e.v=v;e.w=w;egs.push_back(e);}
        int fd(int x){return x==pr[x]?x:pr[x]=fd(pr[x]);}
        void lk(int x,int y){pr[fd(x)]=y;}
        pair&lt;T,vector&lt;edge&gt; &gt;run(){
            vector&lt;edge&gt;ret;T sum=0;
            sort(egs.begin(),egs.end());
            for(int i=1;i&lt;=n;++i)pr[i]=i;
            for(int i=0;i&lt;egs.size();++i){
                int u=egs[i].u,v=egs[i].v;T w=egs[i].w;
                if(fd(u)!=fd(v))lk(u,v),ret.push_back(egs[i]),sum+=w;}
            return make_pair(sum,ret);}};}
#endif
double x[100010],y[100010];
double dis(int u,int v){
    return sqrt(sqr(x[u]-x[v])+sqr(y[u]-y[v]));
}
struct info{
    double w,mxw;
    void reverse(){}
    void up(info*l,info*r){
        mxw=w;
        if(l)mxw=max(mxw,l-&gt;mxw);
        if(r)mxw=max(mxw,r-&gt;mxw);
    }
    void down(info*l,info*r){

    }
};
vector&lt;int&gt;to[100010];
vector&lt;double&gt;wei[100010];
int prt[100010];
void dfs(LinkCutTrees&lt;info&gt;&amp;lct,int u,int p){
    prt[u]=p;
    if(p==0){
        info ifo;
        ifo.w=0;
        ifo.mxw=0;
        lct.set(u,ifo);
    }
    for(int i=0;i&lt;to[u].size();++i){
        int v=to[u][i];double w=wei[u][i];
        if(v==p)continue;
        info ifo;
        ifo.w=w;
        ifo.mxw=w;
        lct.set(v,ifo);
        dfs(lct,v,u);

    }
}

int main(){
    int n;scf("%d",&amp;n);
    DelaunayTriangulation dt;
    lop(i,1,n){
        scf("%lf%lf",x+i,y+i);
        dt.add(x[i],y[i]);
    }
    vector&lt;vector&lt;int&gt; &gt;egs=dt.run();
    MinimumSpanningTree&lt;double&gt; mst(n);
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;egs[i].size();++j){
            int u=i,v=egs[i][j];
            double w=dis(u,v);
            mst.add(u,v,w);
        }
    }
    vector&lt;MinimumSpanningTree&lt;double&gt;::edge&gt;mm=mst.run().second;
    for(int i=0;i&lt;mm.size();++i){
        int u=mm[i].u,v=mm[i].v;double w=mm[i].w;
        to[u].push_back(v);
        wei[u].push_back(w);  to[v].push_back(u);
        wei[v].push_back(w);
    }

    LinkCutTrees&lt;info&gt; lct(n);
    dfs(lct,1,0);
    for(int i=2;i&lt;=n;++i)
        lct.link(prt[i],i);
    int m;scanf("%d",&amp;m);
    while(m--){
        int u,v;scf("%d%d",&amp;u,&amp;v);
        double ans=lct.equery(u,v).mxw;
        if(u==v)ans=0;
        ptf("%.6lf\n",ans);
    }
    return 0;
}
</pre><pre></pre><h2>Problem3998</h2><pre>#include&lt;iostream&gt;

#include&lt;cstdio&gt;
typedef long long ll;
ll dp1[500010*2],dp2[500010*2],dp3[500010*2] ;
#include&lt;algorithm&gt;
using namespace std;
const int N=500000,M=26;
struct SA{
    int pr[2*N+2],tr[2*N+2][M],ln[2*N+2],cnt[2*N+2],m,nw;
    SA(int _m):
        m(_m),nw(1){
        fill(tr[1],tr[1]+m,0);
        pr[1]=0;
        ln[1]=0;
        cnt[1]=0;
    }
    int add(int lst,int c){
        if(tr[lst][c]){
            int p=lst,q=tr[lst][c];
            if(ln[q]==ln[p]+1)
                return q;
            else{
                int np=++nw;
                cnt[np]=1;
                fill(tr[np],tr[np]+m,0);
                ln[np]=ln[p]+1;pr[np]=pr[q];
                copy(tr[q],tr[q]+m,tr[np]);
                pr[q]=np;
                for(;p&amp;&amp;tr[p][c]==q;p=pr[p])
                    tr[p][c]=np;
                return np;
            }
        }else{
            int p=lst,np=++nw;
            cnt[np]=1;
            fill(tr[np],tr[np]+m,0);
            ln[np]=ln[p]+1;
            for(;p&amp;&amp;!tr[p][c];p=pr[p])
                tr[p][c]=np;
            if(!p)
                pr[np]=1;
            else{
                int q=tr[p][c];
                if(ln[p]+1==ln[q])
                    pr[np]=q;
                else{
                    int nq=++nw;
                    cnt[nq]=0;
                    fill(tr[nq],tr[nq]+m,0);
                    ln[nq]=ln[p]+1;
                    pr[nq]=pr[q];
                    copy(tr[q],tr[q]+m,tr[nq]);
                    pr[q]=pr[np]=nq;
                    for(;p&amp;&amp;tr[p][c]==q;p=pr[p])
                        tr[p][c]=nq;
                }
            }
            return np;
        }
    }
    void count(){
        static int t[2*N+2],c[2*N+1];
        fill(c,c+nw+1,0);
        for(int i=1;i&lt;=nw;++i)
            ++c[ln[i]];
        for(int i=1;i&lt;=nw;++i)
            c[i]+=c[i-1];
        for(int i=1;i&lt;=nw;++i)
            t[c[ln[i]]--]=i;
        for(int i=nw;i&gt;=1;--i)
            cnt[pr[t[i]]]+=cnt[t[i]];
    }
};




SA*sa;


int vis[500010*2];

typedef long long ll;


void dodp(int x){
    if(vis[x])return;

  //  dp2[x]=sa-&gt;cnt[x];
    vis[x]=1;
    for(int i=0;i&lt;26;++i)
        if(sa-&gt;tr[x][i]){
            int u=sa-&gt;tr[x][i];
            dodp(u);
            dp1[x]+=dp1[u]+1;
            dp2[x]+=dp2[u]+sa-&gt;cnt[u];
            //dp3[x]+=dp3[u];
        }
}
void try1(int x,int k){
    for(int i=0;i&lt;26;++i)
        if(sa-&gt;tr[x][i]){
               int u=sa-&gt;tr[x][i];
            if(k-(dp1[u]+1)&gt;0)
                k-=(dp1[u]+1);
            else{
                putchar('a'+i);
                if(k!=1)
                try1(u,k-1);
                return;
            }
        }
}
void try2(int x,int k){
    for(int i=0;i&lt;26;++i)
        if(sa-&gt;tr[x][i]){
               int u=sa-&gt;tr[x][i];
            if(k-(dp2[u]+sa-&gt;cnt[u])&gt;0){
                int t1=dp2[u];
                int t2=sa-&gt;cnt[u];
                k-=dp2[u]+sa-&gt;cnt[u];
           } else{
                putchar('a'+i);
                if(k&gt;sa-&gt;cnt[u])
                try2(u,k-sa-&gt;cnt[u]);
                return;
            }
        }
}
#include&lt;string&gt;
void dfs(int u,string s){
    cout&lt;&lt;u&lt;&lt;" "&lt;&lt;sa-&gt;cnt[u]&lt;&lt;endl;
cout&lt;&lt;u&lt;&lt;" "&lt;&lt;sa-&gt;pr[u]&lt;&lt;endl;
  //  cout&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;26;++i)
        if(sa-&gt;tr[u][i]){// cout&lt;&lt;u&lt;&lt;" "&lt;&lt;sa-&gt;tr[u][i]&lt;&lt;" "&lt;&lt;char('a'+i)&lt;&lt;endl;
            dfs(sa-&gt;tr[u][i],s+string(1,'a'+i));

        }
}

int main(){
    static char s[500010];
    scanf("%s",s+1);
    sa=new SA(26);
    int lst=1;
    for(char*p=s+1;*p;++p){
        lst=sa-&gt;add(lst,*p-'a');
    }
    sa-&gt;count();
    int t,k;
    scanf("%d%d",&amp;t,&amp;k);
    dodp(1);
  //  for(int i=1;i&lt;=sa-&gt;nw;++i)
     //   cout&lt;&lt;dp2[i]&lt;&lt;endl;
    //for(int i=1;i&lt;=sa-&gt;nw;++i)
     //   --dp2[i];
    if(t==0){
        if(dp1[1]&lt;k)
            printf("-1\n");
        else{
            try1(1,k);
            printf("\n");
        }
    }else{
        if(dp2[1]&lt;k)
            printf("-1\n");
        else{
            try2(1,k);
            printf("\n");
        }
    }
  //  for(int i=1;i&lt;=sa-&gt;nw;++i)
       // cout&lt;&lt;dp2[i]&lt;&lt;endl;
 //  dfs(1,"");
    return 0;
}
</pre><pre></pre><h2>Problem3998</h2><pre>#include&lt;cstdio&gt; 
#include&lt;cstring&gt; 
#define N 1000010 
typedef long long ll; 
char s[N];int n,i,j,k,T,K; 
namespace Suffixarray{ 
int S[N],SA[N],rank[N],height[N],sum,pre; 
inline bool leq(int a1,int a2,int b1,int b2){return a1&lt;b1||a1==b1&amp;&amp;a2&lt;=b2;} 
inline bool leq(int a1,int a2,int a3,int b1,int b2,int b3){return a1&lt;b1||a1==b1&amp;&amp;leq(a2,a3,b2,b3);} 
inline void radixPass(int*a,int*b,int*r,int n,int K){ 
  int*c=new int[K+1]; 
  int i,sum,t; 
  for(i=0;i&lt;=K;i++)c[i]=0; 
  for(i=0;i&lt;n;i++)c[r[a[i]]]++; 
  for(i=sum=0;i&lt;=K;i++)t=c[i],c[i]=sum,sum+=t; 
  for(i=0;i&lt;n;i++)b[c[r[a[i]]]++]=a[i]; 
  delete[]c; 
} 
void suffixArray(int*T,int*SA,int n,int K){ 
  int n0=(n+2)/3,n1=(n+1)/3,n2=n/3,n02=n0+n2; 
  int*R=new int[n02+3];R[n02]=R[n02+1]=R[n02+2]=0; 
  int*SA12=new int[n02+3];SA12[n02]=SA12[n02+1]=SA12[n02+2]=0; 
  int*R0=new int[n0]; 
  int*SA0=new int[n0]; 
  int i,j,name=0,c0=-1,c1=-1,c2=-1,p=0,t=n0-n1,k=0; 
  for(i=j=0;i&lt;n+n0-n1;i++)if(i%3)R[j++]=i; 
  radixPass(R,SA12,T+2,n02,K),radixPass(SA12,R,T+1,n02,K),radixPass(R,SA12,T,n02,K); 
  for(i=0;i&lt;n02;i++){ 
    if(T[SA12[i]]!=c0||T[SA12[i]+1]!=c1||T[SA12[i]+2]!=c2)name++,c0=T[SA12[i]],c1=T[SA12[i]+1],c2=T[SA12[i]+2]; 
    if(SA12[i]%3==1)R[SA12[i]/3]=name;else R[SA12[i]/3+n0]=name; 
  } 
  if(name&lt;n02)for(suffixArray(R,SA12,n02,name),i=0;i&lt;n02;i++)R[SA12[i]]=i+1;else for(i=0;i&lt;n02;i++)SA12[R[i]-1]=i; 
  for(i=j=0;i&lt;n02;i++)if(SA12[i]&lt;n0)R0[j++]=3*SA12[i]; 
  for(radixPass(R0,SA0,T,n0,K);k&lt;n;k++){ 
    #define GetI() (SA12[t]&lt;n0?SA12[t]*3+1:(SA12[t]-n0)*3+2) 
    i=GetI(),j=SA0[p]; 
    if(SA12[t]&lt;n0?leq(T[i],R[SA12[t]+n0],T[j],R[j/3]):leq(T[i],T[i+1],R[SA12[t]-n0+1],T[j],T[j+1],R[j/3+n0])){ 
      SA[k]=i; 
      if(++t==n02)for(k++;p&lt;n0;p++,k++)SA[k]=SA0[p]; 
    }else{ 
      SA[k]=j; 
      if(++p==n0)for(k++;t&lt;n02;t++,k++)SA[k]=GetI(); 
    } 
  } 
  delete[]R;delete[]SA12;delete[]SA0;delete[]R0; 
} 
void work(){ 
  for(i=0;i&lt;n;i++)S[i]=s[i]-'a'+1; 
  suffixArray(S,SA,n,26); 
  for(i=0;i&lt;n;i++)rank[SA[i]]=i; 
  for(k=i=0;i&lt;n;i++)if(rank[i]==n-1)k=0; 
  else{ 
    if(k)k--; 
    for(j=SA[rank[i]+1];S[i+k]==S[j+k];k++); 
    height[rank[i]]=k; 
  } 
  for(i=0;i&lt;n;pre=sum,i++){ 
    sum=pre+n-SA[i]; 
    if(i)sum-=height[i-1]; 
    if(sum&gt;=K){ 
      j=K-pre; 
      if(i)j+=height[i-1]; 
      for(k=0;k&lt;j;k++)putchar(s[SA[i]+k]); 
      return; 
    } 
  } 
  puts("-1"); 
} 
} 
namespace Suffixtree{ 
const int inf=1&lt;&lt;25,S=28; 
int text[N],root,last,pos,need,remain,acnode,ace,aclen; 
int i,j,k,x,y,q[N],tot,g[N];ll f[N]; 
inline int min(int a,int b){return a&lt;b?a:b;} 
struct node{int st,en,lk,son[S];inline int len(){return min(en,pos)-st;}}tree[N]; 
inline int new_node(int st,int en=inf){return tree[++last].st=st,tree[last].en=en,last;} 
inline int acedge(){return text[ace];} 
inline void addedge(int node){ 
  if(need)tree[need].lk=node; 
  need=node; 
} 
inline bool down(int node){ 
  if(aclen&gt;=tree[node].len())return ace+=tree[node].len(),aclen-=tree[node].len(),acnode=node,1; 
  return 0; 
} 
inline void init(){ 
  need=last=remain=ace=aclen=0; 
  root=acnode=new_node(pos=-1,-1); 
} 
inline void extend(int c){ 
  text[++pos]=c;need=0;remain++; 
  while(remain){ 
    if(!aclen)ace=pos; 
    if(!tree[acnode].son[acedge()])tree[acnode].son[acedge()]=new_node(pos),addedge(acnode); 
    else{ 
      int nxt=tree[acnode].son[acedge()]; 
      if(down(nxt))continue; 
      if(text[tree[nxt].st+aclen]==c){aclen++;addedge(acnode);break;} 
      int split=new_node(tree[nxt].st,tree[nxt].st+aclen); 
      tree[acnode].son[acedge()]=split; 
      tree[split].son[c]=new_node(pos); 
      tree[nxt].st+=aclen; 
      tree[split].son[text[tree[nxt].st]]=nxt; 
      addedge(split); 
    } 
    remain--; 
    if(acnode==root&amp;&amp;aclen)aclen--,ace=pos-remain+1; 
    else acnode=tree[acnode].lk?tree[acnode].lk:root; 
  } 
} 
void dfs(int x){ 
  if(tree[x].en==inf)f[x]=g[x]=1; 
  for(int i=0;i&lt;S;i++)if(tree[x].son[i]){ 
    int y=tree[x].son[i]; 
    dfs(y),f[x]+=f[y]+(ll)tree[y].len()*g[y],g[x]+=g[y]; 
  } 
} 
void work(){ 
  init(); 
  for(i=0;i&lt;n;i++)extend(s[i]-'a'+1);extend(27); 
  dfs(x=root); 
  while(1){ 
    if(x!=root&amp;&amp;(ll)tree[x].len()*g[x]&gt;=K){ 
      for(j=1;j&lt;tot;j++)for(k=tree[q[j]].st;k&lt;tree[q[j]].en;k++)putchar(text[k]+'a'-1); 
      for(K=(K-1)/g[x]+1,j=0;j&lt;K;j++)putchar(text[tree[y].st+j]+'a'-1); 
      return; 
    } 
    for(K-=tree[x].len()*g[x],i=0;i&lt;S;i++)if(tree[x].son[i]){ 
      y=tree[x].son[i]; 
      if(f[y]+(ll)(tree[y].len()-1)*g[y]&gt;=K){q[++tot]=x=y;break;}else K-=f[y]+(ll)(tree[y].len()-1)*g[y]; 
    } 
  } 
} 
} 
int main(){ 
  gets(s),scanf("%d%d",&amp;T,&amp;K),n=std::strlen(s); 
  if(K&gt;(ll)n*(n+1)/2)return puts("-1"),0; 
  if(!T)Suffixarray::work();else Suffixtree::work(); 
  return 0; 
}</pre><pre></pre><h2>Problem4106</h2><pre>#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;cmath&gt;
#include&lt;complex&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;ctime&gt;
#include&lt;deque&gt;
#include&lt;fstream&gt;
#include&lt;functional&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;list&gt;
#include&lt;map&gt;
#include&lt;numeric&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;sstream&gt;
#include&lt;stack&gt;
#include&lt;string&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#define sf scanf
#define si(a)scanf("%d",&amp;a)
#define pf printf
#define pi(a)printf("%d",a)
#define fr freopen
#define ps for(;;)
#define pb push_back
#define mp make_pair
#define lp(i,a,b)for(int i=a;i&lt;=int(b);++i)
#define rp(i,a,b)for(int i=int(a);i&gt;=b;--i)
#define vp(i,a)for(int i=0;i&lt;int(a.size());++i)
#define wp(i,a)for(int i=int(a.size())-1;i&gt;=0;--i)
#define mc int T;scanf("%d",&amp;T);for(int I=1;I&lt;=T;++I)
using namespace std;
typedef long long ll;
typedef long double ld;
typedef vector&lt;int&gt;vi;
typedef pair&lt;int,int&gt;pii;
int main(){
    int p,a,b,c,d,n;
    while(sf("%d%d%d%d%d%d",&amp;p,&amp;a,&amp;b,&amp;c,&amp;d,&amp;n)!=EOF){
        static double mxx[1000010],mii[1000010];
        lp(k,1,n)
                mxx[k]=mii[k]=p * (sin(a * k + b) + cos(c * k + d) + 2);
        lp(i,2,n)mxx[i]=max(mxx[i],mxx[i-1]);
        rp(i,n-1,1)mii[i]=min(mii[i],mii[i+1]);
        double ans=0;
        lp(i,2,n)ans=max(ans,mxx[i-1]-mii[i]);
        pf("%.6lf\n",ans);
    }
    return 0;
}
</pre><pre></pre><h2>Problem4108</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;

#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
template&lt;class FLOW=int,class COST=int&gt;struct MCMF{
    struct edge{
            edge(int _v,FLOW _c,COST _w):
                v(_v),c(_c),w(_w){}
            int v;
            FLOW c;
            COST w;
    };
    int n,src,snk;
    vector&lt;vector&lt;int&gt; &gt;bg;
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;vis;
    vector&lt;COST&gt;dis;
    FLOW all,flow;
    COST cost;
    MCMF(int _n,int _src,int _snk,FLOW _all):
        n(_n),src(_src-1),snk(_snk-1),bg(_n),vis(n),dis(n),all(_all),flow(0),cost(0){}
    void add(int u,int v,FLOW c,COST w){
        bg[u-1].push_back(eg.size());
        eg.push_back(edge(v-1,c,w));
        bg[v-1].push_back(eg.size());
        eg.push_back(edge(u-1,0,-w));
    }
    int spfa(){
        vector&lt;int&gt;in(n,0);
        queue&lt;int&gt;qu;
        fill(vis.begin(),vis.end(),0);
        dis[src]=0;
        vis[src]=in[src]=1;
        qu.push(src);
        while(!qu.empty()){
            int u=qu.front();
            qu.pop();
            in[u]=0;
            for(int i=0;i&lt;bg[u].size();++i){
                edge&amp;e=eg[bg[u][i]];
                if(e.c!=0&amp;&amp;(!vis[e.v]||dis[u]+e.w&lt;dis[e.v])){
                    dis[e.v]=dis[u]+e.w;
                    vis[e.v]=1;
                    if(!in[e.v]){
                        in[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return vis[snk]&amp;&amp;dis[snk]&lt;0;
    }
    FLOW dfs(int u,FLOW f){
        if(u==snk)
            return f;
        FLOW g=f;
        vis[u]=1;
        for(int i=0;i&lt;bg[u].size();++i){
            edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
            if(e.c!=0&amp;&amp;dis[e.v]==dis[u]+e.w&amp;&amp;!vis[e.v]){
                FLOW t=dfs(e.v,min(g,e.c));
                g-=t;
                e.c-=t;
                ev.c+=t;
                cost+=t*e.w;
                if(g==0)
                    return f;
            }
        }
        return f-g;
    }
    void run(){
        while(all!=0&amp;&amp;spfa()){
            FLOW t;
            do{
                fill(vis.begin(),vis.end(),0);
                flow+=(t=dfs(src,all));
                all-=t;
            }while(t!=0);
        }
    }
};
int main(){
    static int dis[110][110];
    int n,k;
   while(scanf("%d%d",&amp;n,&amp;k)!=EOF){
    for(int i=1;i&lt;=n;++i)
        for(int j=i+1;j&lt;=n+1;++j)
            scanf("%d",&amp;dis[i][j]);
    int src=2*n+2,snk=2*n+3;
    static int head[110],tail[110];
    for(int i=2;i&lt;=n+1;++i)
        head[i]=2*i-2,tail[i]=2*i-1;
    MCMF&lt;int,long long&gt;mcmf(2*n+3,src,snk,~0u&gt;&gt;1);
    mcmf.add(src,1,k,0);
    for(int i=2;i&lt;=n+1;++i){
        mcmf.add(head[i],tail[i],1,(long long)(-1e12));
        mcmf.add(tail[i],snk,1,0);
        mcmf.add(1,head[i],1,dis[1][i]);
        for(int j=i+1;j&lt;=n+1;++j)
            mcmf.add(tail[i],head[j],1,dis[i][j]);
    }
    mcmf.run();
    //cout&lt;&lt;mcmf.flow&lt;&lt;endl;
    //cout&lt;&lt;mcmf.cost&lt;&lt;endl;
    int ans=int(mcmf.cost+(long long)(1e12)*n);
    printf("%d\n",ans);}
    return 0;
}
</pre><pre></pre><h2>Problem4108</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;

#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
template&lt;class FLOW=int,class COST=int&gt;struct MCMF{
    struct edge{
        edge(int _v,FLOW _c,COST _w):
            v(_v),c(_c),w(_w){}
        int v;
        FLOW c;
        COST w;
    };
    int n,src,snk;
    vector&lt;vector&lt;int&gt; &gt;bg;
    vector&lt;edge&gt;eg;
    vector&lt;int&gt;vis;
    vector&lt;COST&gt;dis;
    FLOW all,flow;
    COST cost;
    MCMF(int _n,int _src,int _snk,FLOW _all):
        n(_n),src(_src-1),snk(_snk-1),bg(_n),vis(n),dis(n),all(_all),flow(0),cost(0){}
    void add(int u,int v,FLOW c,COST w){
        bg[u-1].push_back(eg.size());
        eg.push_back(edge(v-1,c,w));
        bg[v-1].push_back(eg.size());
        eg.push_back(edge(u-1,0,-w));
    }
    int spfa(){
        vector&lt;int&gt;in(n,0);
        queue&lt;int&gt;qu;
        fill(vis.begin(),vis.end(),0);
        dis[src]=0;
        vis[src]=in[src]=1;
        qu.push(src);
        while(!qu.empty()){
            int u=qu.front();
            qu.pop();
            in[u]=0;
            for(int i=0;i&lt;bg[u].size();++i){
                edge&amp;e=eg[bg[u][i]];
                if(e.c&gt;0&amp;&amp;(!vis[e.v]||dis[u]+e.w&lt;dis[e.v])){
                    dis[e.v]=dis[u]+e.w;
                    vis[e.v]=1;
                    if(!in[e.v]){
                        in[e.v]=1;
                        qu.push(e.v);
                    }
                }
            }
        }
        return vis[snk]&amp;&amp;dis[snk]&lt;0;
    }
    FLOW dfs(int u,FLOW f){
        if(u==snk)
            return f;
        FLOW g=f;
        vis[u]=1;
        for(int i=0;i&lt;bg[u].size();++i){
            edge&amp;e=eg[bg[u][i]],&amp;ev=eg[bg[u][i]^1];
            if(e.c&gt;0&amp;&amp;dis[e.v]==dis[u]+e.w&amp;&amp;!vis[e.v]){
                FLOW t=dfs(e.v,min(g,e.c));
                g-=t;
                e.c-=t;
                ev.c+=t;
                cost+=t*e.w;
                if(g&lt;=0)
                    return f;
            }
        }
        return f-g;
    }
    void run(){
        while(all&gt;0&amp;&amp;spfa()){
            FLOW t;
            do{
                fill(vis.begin(),vis.end(),0);
                flow+=(t=dfs(src,all));
                all-=t;
            }while(t&gt;0);
        }
    }
};
int main(){
    static int dis[110][110];
    int n,k;
    while(scanf("%d%d",&amp;n,&amp;k)!=EOF){
        for(int i=1;i&lt;=n;++i)
            for(int j=i+1;j&lt;=n+1;++j)
                scanf("%d",&amp;dis[i][j]);
        int src=2*n+2,snk=2*n+3;
        static int head[110],tail[110];
        for(int i=2;i&lt;=n+1;++i)
            head[i]=2*i-2,tail[i]=2*i-1;
        MCMF&lt;int,long long&gt;mcmf(2*n+3,src,snk,~0u&gt;&gt;1);
        mcmf.add(src,1,k,0);
        for(int i=2;i&lt;=n+1;++i){
            mcmf.add(head[i],tail[i],1,(long long)(-1e12));
            mcmf.add(tail[i],snk,1,0);
            mcmf.add(1,head[i],1,dis[1][i]);
            for(int j=i+1;j&lt;=n+1;++j)
                mcmf.add(tail[i],head[j],1,dis[i][j]);
        }
        mcmf.run();
        //cout&lt;&lt;mcmf.flow&lt;&lt;endl;
        //cout&lt;&lt;mcmf.cost&lt;&lt;endl;
        int ans=int(mcmf.cost+(long long)(1e12)*n);
        printf("%d\n",ans);}
    return 0;
}
</pre><pre></pre><h2>Problem4109</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
double pi=acos(-1.0);
int n,s;
double x[10010],y[10010],z[10010],r[10010];
double sum(double zi){
    double ret=(1e10)*zi;
    for(int i=1;i&lt;=n;++i){
        if(z[i]-r[i]&gt;=zi)
            continue;
       else if(z[i]+r[i]&lt;=zi){
            ret-=4/3.0*pi*r[i]*r[i]*r[i];
        }else{
            ret-=2/3.0*pi*r[i]*r[i]*r[i]-pi*r[i]*r[i]*(z[i]-zi)+pi/3*(z[i]-zi)*(z[i]-zi)*(z[i]-zi);
        }
    }
    return ret;
}

int main(){
    scanf("%d%d",&amp;n,&amp;s);
    for(int i=1;i&lt;=n;++i)
        scanf("%lf%lf%lf%lf",r+i,x+i,y+i,z+i);
    double all=sum(1e5);
    double per=all/s;
    double st=0;
    for(int i=1;i&lt;=s;++i){
        double lft=st;
        double rht=1e5;
        double tmp=sum(st);
        while(rht-lft&gt;1e-10){
            double mid=(lft+rht)/2;
            if(sum(mid)-tmp&gt;per)
                rht=mid;
            else
                lft=mid;
        }
        printf("%.9lf\n",(lft-st)/1e3);
        st=lft;
    }
    return 0;
}
</pre><pre></pre><h2>Problem4117</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
int n;
double p[10];
typedef long long ll;
ll comb[110][110];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=4;++i)
        cin&gt;&gt;p[i];
    comb[0][0]=1;
    for(int i=1;i&lt;=100;++i)
        for(int j=0;j&lt;=i;++j){
            if(j==0||j==i)
                comb[i][j]=1;
            else
                comb[i][j]=comb[i-1][j]+comb[i-1][j-1];
        }
    vector&lt;pair&lt;double,ll &gt; &gt;vec;
    for(int n1=0;n1&lt;=n;++n1)
        for(int n2=0;n2&lt;=n;++n2)
            for(int n3=0;n3&lt;=n;++n3)
                for(int n4=0;n4&lt;=n;++n4){

                    if(n1+n2+n3+n4!=n)
                        continue;
                    ll cnt=comb[n][n1]*comb[n-n1][n2]*comb[n-n1-n2][n3];
                    double pro=1;
                    for(int i=1;i&lt;=n1;++i)
                        pro*=p[1];
                    for(int i=1;i&lt;=n2;++i)
                        pro*=p[2];
                    for(int i=1;i&lt;=n3;++i)
                        pro*=p[3];
                    for(int i=1;i&lt;=n4;++i)
                        pro*=p[4];
                    vec.push_back(make_pair(pro,cnt));
                }
    double ans=0;
    int del=0;
    /*while(true){
        ++del;
        double mi;
        int miindex=-1;
        for(int i=0;i&lt;vec.size();++i)
            if(miindex==-1||vec[i].first&lt;mi){
                miindex=i;
                mi=vec[i].first;
            }
        if(vec[miindex].second==1){
            if(vec.size()==1)
                break;
            double smi;
            int smiindex=-1;
            for(int i=0;i&lt;vec.size();++i)
                if(i!=miindex&amp;&amp;(smiindex==-1||vec[i].first&lt;smi)){
                    smiindex=i;
                    smi=vec[i].first;
                }
            --vec[miindex].second;
            --vec[smiindex].second;
            ans+=vec[miindex].first+vec[smiindex].first;
            vec.push_back(make_pair(vec[miindex].first+vec[smiindex].first,1));
        }else{
            ll tcnt=vec[miindex].second/2;
            ans+=vec[miindex].first*tcnt*2;
            vec[miindex].second-=tcnt*2;
            vec.push_back(make_pair(2*vec[miindex].first,tcnt));
        }
        while(true){
            int src=-1;
            for(int i=0;i&lt;vec.size();++i)
                if(vec[i].second==0)
                    src=i;
            if(src==-1)
                break;
            vec.erase(vec.begin()+src);
        }
    }*/
    typedef pair&lt;double,ll&gt; ND;
    priority_queue&lt;pair&lt;double,ll&gt;,vector&lt;pair&lt;double,ll&gt; &gt;,greater&lt; pair&lt;double,ll&gt; &gt; &gt;qu;
    for(int i=0;i&lt;vec.size();++i)
        qu.push(vec[i]);
    while(true){
        ++del;
        ND nd=qu.top();
        qu.pop();
        if(nd.second==1){
            if(qu.empty())
                break;
            ND nd2=qu.top();
            qu.pop();
            ans+=nd.first+nd2.first;
            --nd.second;
            --nd2.second;
            if(nd.second!=0)
                qu.push(nd);
            if(nd2.second!=0)
                qu.push(nd2);
            qu.push(make_pair(nd.first+nd2.first,1));
        }else{
            ll tcnt=nd.second/2;
            ans+=nd.first*tcnt*2;
            nd.second-=tcnt*2;
            if(nd.second!=0)
                qu.push(nd);
            qu.push(make_pair(2*nd.first,tcnt));
        }
    }
    printf("%.6lf\n",ans);
    //cout&lt;&lt;del&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem4143</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
struct hui{
    int d,a,b,id;
}hs[500010],h[21][500010];
int s[21];
struct node{
    node(int u,int v){
        id=u,a=v;
    }

    int id,a;
};
bool operator&lt;(node a,node b){
    return a.a&lt;b.a;
}

int main(){
    int n,m;
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i){
        int a,b,d;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;d);
        hs[i].d=d;
        hs[i].a=a;
        hs[i].b=b;
        hs[i].id=i;
        ++s[d];
        h[d][s[d]]=hs[i];
    }
    for(int i=1;i&lt;=m;++i){
        set&lt;node&gt;st;
        for(int j=1;j&lt;=s[i];++j)
            st.insert(node(h[i][j].id,h[i][j].a));
        int ans1=-1,ans2=-1;
        for(int j=1;j&lt;=s[i];++j){
            node tmp(0,h[i][j].b);
            set&lt;node&gt;::iterator it=st.upper_bound(tmp);
            if(it!=st.end()){
                ans1=h[i][j].id;
                ans2=it-&gt;id;
                break;
            }
        }
        if(ans1==-1)
            printf("NIE\n");
        else
            printf("TAK %d %d\n",ans1,ans2);
    }
    return 0;
}
</pre><pre></pre><h2>Problem4144</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;

int n,s,m,q;
vector&lt;int&gt;to[200010],we[200010];
vector&lt;int&gt;pet;
struct query{
    int id,x,y,b;
};
vector&lt;query&gt;qs;
bool operator&lt;(query a,query b){
    return a.b&lt;b.b;
}

int ans[200010];
int dis[200010];
struct edge{
    int u,v,w;
};
bool operator&lt;(edge a,edge b){
    return a.w&lt;b.w;
}

const int N=200000;
struct UFS{
    int p[N+1],n;
    UFS(int _n):
        n(_n){
        for(int i=1;i&lt;=n;++i)
            p[i]=i;
    }
    int find(int x){
        return p[x]==x?x:p[x]=find(p[x]);
    }
    int link(int x,int y){
        p[find(x)]=y;
    }
};
vector&lt;edge&gt;e1,e2;
int main(){
    scanf("%d%d%d",&amp;n,&amp;s,&amp;m);
    for(int i=1;i&lt;=s;++i){
        int c;scanf("%d",&amp;c);
        pet.push_back(c);
    }
    for(int i=1;i&lt;=m;++i){
        int u,v,d;
        scanf("%d%d%d",&amp;u,&amp;v,&amp;d);
        to[u].push_back(v);
        we[u].push_back(d);
        swap(u,v);
        to[u].push_back(v);
        we[u].push_back(d);
        edge tmp;
        tmp.u=u;
        tmp.v=v;
        tmp.w=d;
        e1.push_back(tmp);
    }
    scanf("%d",&amp;q);
    for(int i=1;i&lt;=q;++i){
        int x,y,b;
        query tmp;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;b);
        tmp.x=x;
        tmp.y=y;
        tmp.b=b;
        tmp.id=i;
        qs.push_back(tmp);
    }
    for(int i=1;i&lt;=n;++i)
        dis[i]=~0u&gt;&gt;1;

    queue&lt;int&gt;qu;
    static int in[200010];
    for(int i=0;i&lt;pet.size();++i){
        dis[pet[i]]=0;
        in[pet[i]]=1;
        qu.push(pet[i]);
    }
    while(!qu.empty()){
        int u=qu.front();
        qu.pop();
        in[u]=0;
        for(int i=0;i&lt;to[u].size();++i){
            int v=to[u][i],w=we[u][i];
            if(dis[u]+w&lt;dis[v]){
                dis[v]=dis[u]+w;
                if(!in[v]){
                    in[v]=1;
                    qu.push(v);
                }
            }
        }
    }
    for(int i=0;i&lt;e1.size();++i){
        int u=e1[i].u,v=e1[i].v,w=e1[i].w;
        if(dis[u]!=~0u&gt;&gt;1&amp;&amp;dis[v]!=~0u&gt;&gt;1){
            w+=dis[u]+dis[v];
            edge tmp=e1[i];
            tmp.w+=dis[u]+dis[v];
            e2.push_back(tmp);
        }
    }
    sort(e2.begin(),e2.end());
    sort(qs.begin(),qs.end());
    int ptr=0;
    UFS*ufs=new UFS(n);
    for(int i=0;i&lt;qs.size();++i){
        int b=qs[i].b;
        while(ptr&lt;e2.size()&amp;&amp;e2[ptr].w&lt;=b){
            int u1=e2[ptr].u;
            int v1=e2[ptr].v;
            if(ufs-&gt;find(u1)!=ufs-&gt;find(v1))
                ufs-&gt;link(u1,v1);
            ++ptr;
        }
        int u=qs[i].x,v=qs[i].y;
        if(ufs-&gt;find(u)==ufs-&gt;find(v))
            ans[qs[i].id]=1;
        else
            ans[qs[i].id]=0;
    }
    for(int i=1;i&lt;=q;++i)
        printf("%s",ans[i]?"TAK\n":"NIE\n");
    return 0;
}
</pre><pre></pre><h2>Problem4145</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;

int n,m,d[110],c[110][21];

int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;++i){
        cin&gt;&gt;d[i];
        for(int j=1;j&lt;=m;++j){
            cin&gt;&gt;c[i][j];
        }
    }
    static int dp[110][70010];
    for(int i=1;i&lt;=n;++i){
        if(i==1){

                for(int s=0;s&lt;(1&lt;&lt;m);++s){
                    if(s==0)
                        dp[i][s]=0;
                    else{
                        dp[i][s]=d[i];
                        for(int j=1;j&lt;=m;++j){
                            if((s&gt;&gt;(j-1))&amp;1){
                                dp[i][s]+=c[i][j];
                            }
                        }
                    }
                }
        }
        else{
             for(int s=0;s&lt;(1&lt;&lt;m);++s){
                 dp[i][s]=dp[i-1][s]+d[i];
             }
             for(int j=1;j&lt;=m;++j){
                  for(int s=0;s&lt;(1&lt;&lt;m);++s){
                      if(((s&gt;&gt;(j-1))&amp;1)==0)
                          dp[i][s + (1 &lt;&lt;( j - 1))] = min(dp[i][s + (1 &lt;&lt;( j - 1))], dp[i][s] + c[i][j]);
                  }
             }
             for(int s=0;s&lt;(1&lt;&lt;m);++s)
                 dp[i][s]=min(dp[i][s],dp[i-1][s]);
        }
    }
    printf("%d\n",dp[n][(1&lt;&lt;m)-1]);
    return 0;
}
</pre><pre></pre><h2>Problem4146</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;

int n,a[2000010];
int cnt[2000010];
int ans[2000010];
int mxa;
int main(){
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;++i)
        scanf("%d",a+i),mxa=max(mxa,a[i]),++cnt[a[i]];
    for(int i=1;i&lt;=mxa;++i){
        for(int j=i;j&lt;=mxa;j+=i){
            ans[j]+=cnt[i];
        }
    }
    typedef long long ll;
    ll ans1=0;
    for(int i=1;i&lt;=n;++i)
        ans1+=ans[a[i]]-1;
    cout&lt;&lt;ans1&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem4147</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,p,q;
bool Calculate(int n,int p,int q)
{
    return n%p&lt;q &amp;&amp; n%p%(p-q)==0;
}
int main()
{
    int T;
    for(cin&gt;&gt;T;T;T--)
    {
        scanf("%d%d%d",&amp;p,&amp;q,&amp;n);
        int gcd=__gcd(p,q);
        if(n%gcd)
        {
            puts("R");
            continue;
        }
        p/=gcd;q/=gcd;n/=gcd;
        if(p==q)
            puts("E");
        else if(p&gt;q)
        {
            if(n&lt;p) puts("P");
            else puts(Calculate(n,p,q)?"E":"P");
        }
        else
        {
            if(n&lt;p)
            {
                if(n+p&lt;q) puts("E");
                else puts(Calculate(n+p,q,p)?"P":"E");
            }
            else puts("E");
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem4147</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;

typedef long long ll;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
ll egcd(ll a,ll b,ll&amp;x,ll&amp;y){
    if(!b){
        x=1;
        y=0;
        return a;
    }else{
        ll d=egcd(b,a%b,y,x);
        y-=a/b*x;
        return d;
    }
}

bool calc(int n,int p,int q){
    return n%p&lt;q&amp;&amp;n%p%(p-q)==0;
}



int main(){
    int t;cin&gt;&gt;t;
    while(t--){
        int p,q,n;
        scanf("%d%d%d",&amp;p,&amp;q,&amp;n);
        int d=gcd(p,q);
        if(n%d){
            puts("R");
            continue;
        }
        p/=d;
        q/=d;
        n/=d;
        if(p==q)puts("E");
        else if(p&gt;q){
            if(n&lt;p)puts("P");
            else puts(calc(n,p,q)?"E":"P");
        }
        else{
            if(n&lt;p){
                if(n+p&lt;q)puts("E");
                else puts(calc(n+p,q,p)?"P":"E");
            }
                else puts("E");

        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem4148</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,m,f;
char a[1010][1010];
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;f);
	for(int i=1;i&lt;n;++i)
		a[i][1]='P';
	a[n][1]='G';
	if(m==2){
		for(int i=n;i&gt;1;--i)
			a[i][2]='L';
		a[1][2]='D';
	}else{
		for(int i=1;i&lt;=n;++i){
			if(i==1)a[i][2]='D';
			else if(i==n)a[i][2]='G';
			else if(i%2==0)a[i][2]='G';
			else a[i][2]='L';
			if(i==1)a[i][m]='D';
			else if(i==n)a[i][m]='L';
			else if(i%2==0)a[i][m]='L';
			else a[i][m]='D';
			for(int j=3;j&lt;m;++j){
				if(i%2==1)
					a[i][j]='D';
				else
					a[i][j]='G';
			}
		}
		
	}
/*	for(int j=m;j&gt;=1;--j){
		for(int i=1;i&lt;=n;++i){
			putchar(a[i][j]);
		}
		putchar('\n');

	}
*/
	for(int i=1;i&lt;=f;++i){
		int x,y;
		scanf("%d%d",&amp;x,&amp;y);
		if(x%2==1){
		
		a[x+2][y+3]='L';
		a[x][y+2]='P';
		a[x+1][y+2]='P';
		a[x+1][y-1]='L';
		}else if(y!=3){
			a[x+2][y-2]='L';
			a[x][y-1]='P';
			a[x+1][y-1]='P';
			a[x+1][y+2]='L';
		}else{
			a[x][1]='G';
        	a[x][2]='P';
        	a[x+1][2]='D';
        	a[x+1][y+2]='L';
		}
	}
	printf("TAK\n");
	int x=1,y=1;
	for(int i=1;i&lt;=n*m-4*f;++i){
		putchar(a[x][y]);
		if(a[x][y]=='L')
			--x;
		else if(a[x][y]=='P')
			++x;
		else if(a[x][y]=='G')
			++y;
		else
			--y;
	}
	putchar('\n');
	return 0;
}</pre><pre></pre><h2>Problem4150</h2><pre>#include &lt;iostream&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
struct info{
    bool left_can_shoot_when_right_die;
    int left_shoot_time_when_right_die;
    int people_alive_when_right_die;

    bool left_can_shoot_when_right_live;
    int left_shoot_time_when_right_live;
    int people_alive_when_right_live;

    int l,r,right_shoot_time;
    int slowest_shooter;
    int slowest_shooter_time;
    inline void update(const info&amp;a,const info&amp;b){
        if(b.left_can_shoot_when_right_die){
            if(b.left_shoot_time_when_right_die&gt;a.right_shoot_time){
                left_can_shoot_when_right_die=a.left_can_shoot_when_right_live;
                left_shoot_time_when_right_die=a.left_shoot_time_when_right_live;
                people_alive_when_right_die=b.people_alive_when_right_die+a.people_alive_when_right_live-1;
            }else{
                left_can_shoot_when_right_die=a.left_can_shoot_when_right_die;
                left_shoot_time_when_right_die=a.left_shoot_time_when_right_die;
                people_alive_when_right_die=b.people_alive_when_right_die+a.people_alive_when_right_die;
            }
        }else{
                left_can_shoot_when_right_die=a.left_can_shoot_when_right_live;
                left_shoot_time_when_right_die=a.left_shoot_time_when_right_live;
                people_alive_when_right_die=b.people_alive_when_right_die+a.people_alive_when_right_live;
        }


        if(b.left_can_shoot_when_right_live){
            if(b.left_shoot_time_when_right_live&gt;a.right_shoot_time){
                left_can_shoot_when_right_live=a.left_can_shoot_when_right_live;
                left_shoot_time_when_right_live=a.left_shoot_time_when_right_live;
                people_alive_when_right_live=b.people_alive_when_right_live+a.people_alive_when_right_live-1;
            }else{
                left_can_shoot_when_right_live=a.left_can_shoot_when_right_die;
                left_shoot_time_when_right_live=a.left_shoot_time_when_right_die;
                people_alive_when_right_live=b.people_alive_when_right_live+a.people_alive_when_right_die;
            }
        }else{
                left_can_shoot_when_right_live=a.left_can_shoot_when_right_live;
                left_shoot_time_when_right_live=a.left_shoot_time_when_right_live;
                people_alive_when_right_live=b.people_alive_when_right_live+a.people_alive_when_right_live;
        }
        if(a.slowest_shooter_time&gt;=b.slowest_shooter_time){
            slowest_shooter_time=a.slowest_shooter_time;
            slowest_shooter=a.slowest_shooter;
        }else{
            slowest_shooter_time=b.slowest_shooter_time;
            slowest_shooter=b.slowest_shooter;
        }
        l=a.l;
        r=b.r;
        right_shoot_time=b.right_shoot_time;
    }
};
    void printinfo(info ifo){
        return;
        cout&lt;&lt;"---------------------------------\n";
        cout&lt;&lt;ifo.l&lt;&lt;" "&lt;&lt;ifo.r&lt;&lt;endl;
        cout&lt;&lt;"lshoot time"&lt;&lt;ifo.right_shoot_time&lt;&lt;endl;
         cout&lt;&lt;"ifo.left_can_shoot_when_right_die"&lt;&lt;ifo.left_can_shoot_when_right_die&lt;&lt;endl;
   cout&lt;&lt;" ifo. left_shoot_time_when_right_die"&lt;&lt;ifo. left_shoot_time_when_right_die&lt;&lt;endl;
    cout&lt;&lt;" ifo. people_alive_when_right_di" &lt;&lt;ifo. people_alive_when_right_die&lt;&lt;endl;

    cout&lt;&lt;  " ifo.  left_can_shoot_when_right_live"&lt;&lt;ifo.  left_can_shoot_when_right_live&lt;&lt;endl;
    cout&lt;&lt;  "ifo. left_shoot_time_when_right_live " &lt;&lt; ifo. left_shoot_time_when_right_live&lt;&lt;endl;
    cout&lt;&lt;  " ifo.  people_alive_when_right_live" &lt;&lt;ifo.  people_alive_when_right_live&lt;&lt;endl;
    cout&lt;&lt;"---------------------------------\n\n";
    }
struct segmenttree{
    int *a,n;
    struct node{
        node*lc,*rc;
        info ifo;
    }*root;
    void buildtree(node*x,int l,int r){
        x-&gt;ifo.l=l;
        x-&gt;ifo.r=r;
        x-&gt;ifo.right_shoot_time=a[r];
        if(l==r){
            x-&gt;ifo.left_can_shoot_when_right_die=false;
            x-&gt;ifo.left_shoot_time_when_right_die=-1;
            x-&gt;ifo.people_alive_when_right_die=0;
            x-&gt;ifo.left_can_shoot_when_right_live=true;
            x-&gt;ifo.left_shoot_time_when_right_live=a[r];
            x-&gt;ifo.people_alive_when_right_live=1;
            x-&gt;ifo.slowest_shooter=l;
            x-&gt;ifo.slowest_shooter_time=a[r];
        }else{
            x-&gt;lc=new node;
            x-&gt;rc=new node;
            int m=(l+r)/2;
            buildtree(x-&gt;lc,l,m);
            buildtree(x-&gt;rc,m+1,r);
            x-&gt;ifo.update(x-&gt;lc-&gt;ifo,x-&gt;rc-&gt;ifo);
        }
    }
    void change(node*x,int p,int v){
        if(x-&gt;ifo.l==x-&gt;ifo.r){
            x-&gt;ifo.left_shoot_time_when_right_live=v;
            x-&gt;ifo.slowest_shooter_time=v;
            x-&gt;ifo.right_shoot_time=v;
        }else{
            int m=(x-&gt;ifo.l+x-&gt;ifo.r)/2;
            if(p&lt;=m){
                change(x-&gt;lc,p,v);
            }else
                change(x-&gt;rc,p,v);
            x-&gt;ifo.update(x-&gt;lc-&gt;ifo,x-&gt;rc-&gt;ifo);
           // x-&gt;ifo.right_shoot_time=x-&gt;rc-&gt;ifo.right_shoot_time;
        }
    }
    void query(node*x,vector&lt;info*&gt;&amp;ifs,int l,int r){
        if(l==x-&gt;ifo.l&amp;&amp;r==x-&gt;ifo.r){
            ifs.push_back(&amp;x-&gt;ifo);
        }else{
            int m=(x-&gt;ifo.l+x-&gt;ifo.r)/2;
            if(r&lt;=m){
                query(x-&gt;lc,ifs,l,r);
            }else if(l&gt;m){
                query(x-&gt;rc,ifs,l,r);
            }else{
                query(x-&gt;lc,ifs,l,m);
                query(x-&gt;rc,ifs,m+1,r);
            }
        }
    }

    void build(){

       //for(int i=1;i&lt;=n;++i)
      //     cout&lt;&lt;a[i]&lt;&lt;" ";
    //   cout&lt;&lt;endl;
        root=new node;
        buildtree(root,1,n);
    }
    int curans;
    int calc(){
        //cout&lt;&lt;"hehe";
        int t=root-&gt;ifo.slowest_shooter;
        int l=t,r=t+n/2-1;
   //    cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
        vector&lt;info*&gt;ifs;
        query(root,ifs,l,r);
        for(int i=0;i&lt;ifs.size();++i)
            printinfo(*ifs[i]);
        info tmp=*ifs[0];
        for(int i=1;i&lt;ifs.size();++i){
            info tmo2;
            tmo2.update(tmp,*ifs[i]);
            tmp=tmo2;
            printinfo(tmp);
        }
        if(tmp.left_can_shoot_when_right_live)
            return curans=(tmp.people_alive_when_right_live-1);
        else
            return curans=(tmp.people_alive_when_right_live);
    }
};
segmenttree trees[200010];int treecnt;
int treepos[200010];
int intreepos[200010];
int ans;
void modify(int p,int v){
    segmenttree&amp;tr=trees[treepos[p]];
    int u=intreepos[p];
    ans-=tr.curans;
    tr.change(tr.root,u,v);
    tr.change(tr.root,u+tr.n/2,v);
    ans+=tr.calc();
}

int main()
{
    int n;static int p[200010],u[200010];
    static int vis[200010];
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;++i){
            int t;scanf("%d",&amp;t);
        p[t]=i;
    }
    for(int i=1;i&lt;=n;++i)
        scanf("%d",u+i);
    for(int i=1;i&lt;=n;++i){
        if(vis[i])continue;
        int cirlen=0;
        static int num[200010];
        num[i]=++cirlen;
        static int vec[200010];
        int vlen=0;
        vec[++vlen]=i;
        vis[i]=1;
        for(int j=p[i];j!=i;j=p[j]){
            num[j]=++cirlen;
            vec[++vlen]=j;
            vis[j]=1;
        }
        ++treecnt;
        segmenttree&amp;tr=trees[treecnt];
        tr.n=2*cirlen;
        tr.a=new int[2*cirlen+10];
        for(int j=1;j&lt;=vlen;++j){
            tr.a[j]=u[vec[j]];
            tr.a[j+vlen]=u[vec[j]];
            treepos[vec[j]]=treecnt;
            intreepos[vec[j]]=j;
        }
        tr.build();
    }
    for(int i=1;i&lt;=treecnt;++i)
        ans+=trees[i].calc();
    printf("%d\n",ans);
    int q;scanf("%d",&amp;q);
    for(int i=1;i&lt;=q;++i){
        int k,v;
        scanf("%d%d",&amp;k,&amp;v);
        modify(k,v);
        printf("%d\n",ans);
    }
    return 0;
}
/*
4
2 3 4 1
8 2 3 4
*/
</pre><pre></pre><h2>Problem4151</h2><pre>#include &lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
int t,n,m;
vector&lt;int&gt;to[300010];
int a[300010],b[300010],d[300010];
int dep[300010],prt[300010];
int getlca(int x,int y){
    static int vis[300010];
    for(int i=1;i&lt;=n;++i)
        vis[i]=0;
    for(int i=x;i!=0;i=prt[i])
        vis[i]=1;
    for(int i=y;;i=prt[i])
        if(vis[i]==1)
            return i;
}
void dfs1(int u,int p){
    prt[u]=p;
    dep[u]=dep[p]+1;
    for(int i=0;i&lt;to[u].size();++i){
        int v=to[u][i];
        if(v!=p)
            dfs1(v,u);
    }
}
int main()
{
    dep[0]=-1;
    scanf("%d",&amp;t);
    for(int I=1;I&lt;=t;++I){
        scanf("%d%d",&amp;n,&amp;m);
        for(int i=1;i&lt;=n;++i)
            to[i].clear();
        for(int i=1;i&lt;=n-1;++i){
            int x,y;
            scanf("%d%d",&amp;x,&amp;y);
            to[x].push_back(y);
            to[y].push_back(x);
        }
        for(int i=1;i&lt;=m;++i)
            scanf("%d%d%d",&amp;a[i],&amp;b[i],&amp;d[i]);
        dfs1(1,0);
        int maxhehe=-1,maxheheid=-1;
        for(int i=1;i&lt;=m;++i){
            int dd=dep[a[i]]+dep[b[i]]-d[i];
            if(dd&lt;0)dd=0;
            if(dd&gt;maxhehe){
                maxhehe=dd;
                maxheheid=i;
            }
        }
        int ca=a[maxheheid];
        int cb=b[maxheheid];
      //  cout&lt;&lt;ca&lt;&lt;" "&lt;&lt;cb&lt;&lt;endl;
        int lca=getlca(ca,cb);
      //  cout&lt;&lt;lca&lt;&lt;endl;
        int cd=d[maxheheid];
        int already=-dep[lca]+dep[ca]-dep[lca]+dep[cb];
       // cout&lt;&lt;already&lt;&lt;endl;
        while(lca!=1&amp;&amp;already+2&lt;=cd){
            lca=prt[lca];
            already+=2;
        }
   //     cout&lt;&lt;lca&lt;&lt;endl;
        dfs1(lca,0);
        int fail=0;
        for(int i=1;i&lt;=m;++i){
            if(dep[a[i]]+dep[b[i]]&gt;d[i])
                fail=1;
        }
        if(fail)
            printf("NIE\n");
        else
            printf("TAK %d\n",lca);
    }
    return 0;
}
</pre><pre></pre><h2>Problem4152</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
#include&lt;limits&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
using namespace std;
const int N=200000;
template&lt;class COST&gt;struct D{
    int n,src;
    COST di[N],mx;
    vector&lt;int&gt;to[N];
    vector&lt;COST&gt;we[N];
    D(int _n,int _src):
        n(_n),src(_src-1),mx(numeric_limits&lt;COST&gt;::max()){}
    void add(int u,int v,COST w){
        to[u-1].push_back(v-1);
        we[u-1].push_back(w);
    }
    COST segw[N*4];
    int segu[N*4];
    void buildseg(int x,int l,int r){
        segw[x]=mx;
        if(l!=r){
            int m=(l+r)/2;
            buildseg(x*2,l,m);
            buildseg(x*2+1,m+1,r);
        }
    }
    void changeseg(int x,int l,int r,int u,COST w){
        if(l==r){
            segu[x]=u;
            segw[x]=w;
        }else{
             int m=(l+r)/2;
             if(u&lt;=m)
                 changeseg(x*2,l,m,u,w);
             else
                 changeseg(x*2+1,m+1,r,u,w);
             int t=(segw[x*2]&gt;segw[x*2+1]);
             segw[x]=segw[x*2+t];
             segu[x]=segu[x*2+t];
        }
    }
    void run(){
        fill(di,di+n,mx);
        di[src]=0;
        buildseg(1,0,n-1);
        changeseg(1,0,n-1,src,0);
        while(segw[1]!=mx){
            int u=segu[1];
            changeseg(1,0,n-1,u,mx);
            for(int i=0;i&lt;to[u].size();++i){
                int v=to[u][i];
                COST w=we[u][i];
                if(di[u]+w&lt;di[v]){
                    di[v]=di[u]+w;
                    changeseg(1,0,n-1,v,di[v]);
                }
            }
        }
    }
};
struct data{
    int u;
    long long x,y;
}da[200010];
int n;
bool cmpx(data a,data b){
    return a.x&lt;b.x;
}
bool cmpy(data a,data b){
    return a.y&lt;b.y;
}
int dis(data a,data b){
    int t1=a.x-b.x;
    if(t1&lt;0)t1=-t1;
    int t2=a.y-b.y;
    if(t2&lt;0)t2=-t2;
    return min(t1,t2);
}

int main(){
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;++i){
        int a,b;
        scanf("%d%d",&amp;a,&amp;b);
        da[i].u=i;
        da[i].x=a;
        da[i].y=b;
    }
    D&lt;long long&gt;* dij=new D&lt;long long&gt; (n,1);
    sort(da+1,da+n+1,cmpx);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij-&gt;add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij-&gt;add(u,v,w);
        }
    }
    sort(da+1,da+n+1,cmpy);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij-&gt;add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij-&gt;add(u,v,w);
        }
    }
    dij-&gt;run();
    cout&lt;&lt;dij-&gt;di[n-1]&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem4152</h2><pre>#ifndef DIJKSTRAS_ALGORITHM
#define DIJKSTRAS_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;limits&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct DijkstrasAlgorithm{
        int n,m;vector&lt;vector&lt;int&gt; &gt;to;vector&lt;vector&lt;T&gt; &gt;we;
        T inf;vector&lt;pair&lt;T,int&gt; &gt;sg;vector&lt;T&gt;di;
        DijkstrasAlgorithm(int _n):n(_n),m(1&lt;&lt;(int)ceil(log2(n)+1e-8)),
            to(n+1),we(n+1),inf(numeric_limits&lt;T&gt;::max()),sg(2*m,make_pair(inf,0)),di(n+1,inf){}
        void set(int u,T d){di[u]=d;}
        void add(int u,int v,T w){to[u].push_back(v);we[u].push_back(w);}
        int upd(T&amp;a,T b,T c){if(b!=inf&amp;&amp;c!=inf&amp;&amp;b+c&lt;a){a=b+c;return 1;}return 0;}
        void mod(int u,T d){for(sg[u+m-1]=make_pair(d,u),u=(u+m-1)&gt;&gt;1;u;u&gt;&gt;=1)sg[u]=min(sg[u&lt;&lt;1],sg[u&lt;&lt;1^1]);}
        vector&lt;T&gt;run(){
            for(int i=1;i&lt;=n;++i)sg[i+m-1]=make_pair(di[i],i);
            for(int i=m-1;i&gt;=1;--i)sg[i]=min(sg[i&lt;&lt;1],sg[i&lt;&lt;1^1]);
            for(int u=sg[1].second;sg[1].first!=inf?(mod(u,inf),1):0;u=sg[1].second)
                for(int i=0;i&lt;to[u].size();++i){int v=to[u][i];T w=we[u][i];if(upd(di[v],di[u],w))mod(v,di[v]);}
            return di;}};}
#endif
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
#include&lt;limits&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
using namespace std;
const int N=200000;
template&lt;class COST&gt;struct D{
    int n,src;
    COST di[N],mx;
    vector&lt;int&gt;to[N];
    vector&lt;COST&gt;we[N];
    D(int _n,int _src):
        n(_n),src(_src-1),mx(numeric_limits&lt;COST&gt;::max()){}
    void add(int u,int v,COST w){
        to[u-1].push_back(v-1);
        we[u-1].push_back(w);
    }
    COST segw[N*4];
    int segu[N*4];
    void buildseg(int x,int l,int r){
        segw[x]=mx;
        if(l!=r){
            int m=(l+r)/2;
            buildseg(x*2,l,m);
            buildseg(x*2+1,m+1,r);
        }
    }
    void changeseg(int x,int l,int r,int u,COST w){
        if(l==r){
            segu[x]=u;
            segw[x]=w;
        }else{
             int m=(l+r)/2;
             if(u&lt;=m)
                 changeseg(x*2,l,m,u,w);
             else
                 changeseg(x*2+1,m+1,r,u,w);
             int t=(segw[x*2]&gt;segw[x*2+1]);
             segw[x]=segw[x*2+t];
             segu[x]=segu[x*2+t];
        }
    }
    void run(){
        fill(di,di+n,mx);
        di[src]=0;
        buildseg(1,0,n-1);
        changeseg(1,0,n-1,src,0);
        while(segw[1]!=mx){
            int u=segu[1];
            changeseg(1,0,n-1,u,mx);
            for(int i=0;i&lt;to[u].size();++i){
                int v=to[u][i];
                COST w=we[u][i];
                if(di[u]+w&lt;di[v]){
                    di[v]=di[u]+w;
                    changeseg(1,0,n-1,v,di[v]);
                }
            }
        }
    }
};
struct data{
    int u;
    long long x,y;
}da[200010];
int n;
bool cmpx(data a,data b){
    return a.x&lt;b.x;
}
bool cmpy(data a,data b){
    return a.y&lt;b.y;
}
int dis(data a,data b){
    int t1=a.x-b.x;
    if(t1&lt;0)t1=-t1;
    int t2=a.y-b.y;
    if(t2&lt;0)t2=-t2;
    return min(t1,t2);
}

int main(){
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;++i){
        int a,b;
        scanf("%d%d",&amp;a,&amp;b);
        da[i].u=i;
        da[i].x=a;
        da[i].y=b;
    }
    //D&lt;long long&gt;* dij=new D&lt;long long&gt; (n,1);
    CTL::DijkstrasAlgorithm&lt;long long&gt;dij(n);
    dij.set(1,0);
    sort(da+1,da+n+1,cmpx);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij.add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij.add(u,v,w);
        }
    }
    sort(da+1,da+n+1,cmpy);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij.add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij.add(u,v,w);
        }
    }

    cout&lt;&lt;dij.run()[n]&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem4152</h2><pre>#ifndef DIJKSTRAS_ALGORITHM
#define DIJKSTRAS_ALGORITHM
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;limits&gt;
#include&lt;utility&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct DijkstrasAlgorithm{
        int n,m;vector&lt;vector&lt;int&gt; &gt;to;vector&lt;vector&lt;T&gt; &gt;we;
        T inf;vector&lt;pair&lt;T,int&gt; &gt;sg;vector&lt;T&gt;di;
        DijkstrasAlgorithm(int _n):n(_n),m(1&lt;&lt;(int)ceil(log2(n)+1e-8)),
            to(n+1),we(n+1),inf(numeric_limits&lt;T&gt;::max()),sg(2*m,make_pair(inf,0)),di(n+1,inf){}
        void set(int u,T d){di[u]=d;}
        void add(int u,int v,T w){to[u].push_back(v);we[u].push_back(w);}
        int upd(T&amp;a,T b,T c){if(b!=inf&amp;&amp;c!=inf&amp;&amp;b+c&lt;a){a=b+c;return 1;}return 0;}
        void mod(int u,T d){for(sg[u+m-1]=make_pair(d,u),u=(u+m-1)&gt;&gt;1;u;u&gt;&gt;=1)sg[u]=min(sg[u&lt;&lt;1],sg[u&lt;&lt;1^1]);}
        vector&lt;T&gt;run(){
            for(int i=1;i&lt;=n;++i)sg[i+m-1]=make_pair(di[i],i);
            for(int i=m-1;i&gt;=1;--i)sg[i]=min(sg[i&lt;&lt;1],sg[i&lt;&lt;1^1]);
            for(int u=sg[1].second;sg[1].first!=inf?(mod(u,inf),1):0;u=sg[1].second)
                for(int i=0;i&lt;to[u].size();++i){int v=to[u][i];T w=we[u][i];if(upd(di[v],di[u],w))mod(v,di[v]);}
            return di;}};}
#endif
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;


#include&lt;algorithm&gt;
#include&lt;limits&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
using namespace std;
const int N=200000;
template&lt;class COST&gt;struct D{
    int n,src;
    COST di[N],mx;
    vector&lt;int&gt;to[N];
    vector&lt;COST&gt;we[N];
    D(int _n,int _src):
        n(_n),src(_src-1),mx(numeric_limits&lt;COST&gt;::max()){}
    void add(int u,int v,COST w){
        to[u-1].push_back(v-1);
        we[u-1].push_back(w);
    }
    COST segw[N*4];
    int segu[N*4];
    void buildseg(int x,int l,int r){
        segw[x]=mx;
        if(l!=r){
            int m=(l+r)/2;
            buildseg(x*2,l,m);
            buildseg(x*2+1,m+1,r);
        }
    }
    void changeseg(int x,int l,int r,int u,COST w){
        if(l==r){
            segu[x]=u;
            segw[x]=w;
        }else{
             int m=(l+r)/2;
             if(u&lt;=m)
                 changeseg(x*2,l,m,u,w);
             else
                 changeseg(x*2+1,m+1,r,u,w);
             int t=(segw[x*2]&gt;segw[x*2+1]);
             segw[x]=segw[x*2+t];
             segu[x]=segu[x*2+t];
        }
    }
    void run(){
        fill(di,di+n,mx);
        di[src]=0;
        buildseg(1,0,n-1);
        changeseg(1,0,n-1,src,0);
        while(segw[1]!=mx){
            int u=segu[1];
            changeseg(1,0,n-1,u,mx);
            for(int i=0;i&lt;to[u].size();++i){
                int v=to[u][i];
                COST w=we[u][i];
                if(di[u]+w&lt;di[v]){
                    di[v]=di[u]+w;
                    changeseg(1,0,n-1,v,di[v]);
                }
            }
        }
    }
};
struct data{
    int u;
    long long x,y;
}da[200010];
int n;
bool cmpx(data a,data b){
    return a.x&lt;b.x;
}
bool cmpy(data a,data b){
    return a.y&lt;b.y;
}
int dis(data a,data b){
    int t1=a.x-b.x;
    if(t1&lt;0)t1=-t1;
    int t2=a.y-b.y;
    if(t2&lt;0)t2=-t2;
    return min(t1,t2);
}
#ifndef FAST_READER_WRITER
#define FAST_READER_WRITER
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    struct FastReader{
        FILE*f;char*p,*e;vector&lt;char&gt;v;
        FastReader(FILE*_f):f(_f){red();}
        FastReader(string _f):f(fopen(_f.c_str(),"r")){red();}
        ~FastReader(){fclose(f);}
        void red(){
            for(int i=0,t;;++i){
                v.resize(v.size()+(1&lt;&lt;i));
                if((t=fread(&amp;v[0]+v.size()-(1&lt;&lt;i),1,1&lt;&lt;i,f))!=(1&lt;&lt;i)){
                    p=&amp;v[0],e=p+v.size()-(1&lt;&lt;i)+t;break;}}}
        void ign(){while(p!=e&amp;&amp;isspace(*p))++p;}
        int isc(){return p!=e&amp;&amp;!isspace(*p);}
        int isd(){return p!=e&amp;&amp;isdigit(*p);}
        FastReader&amp;operator&gt;&gt;(char&amp;a){ign(),a=*p++;return*this;}
        FastReader&amp;operator&gt;&gt;(char*a){for(ign();isc()?1:(*a=0);)*a++=*p++;return*this;}
        FastReader&amp;operator&gt;&gt;(int&amp;a){
            int n=1;if(ign(),a=0,*p=='-')n=-1,++p;
            for(;isd()?1:(a*=n,0);)a=a*10+*p++-'0';
            return*this;}
        FastReader&amp;operator&gt;&gt;(long long&amp;a){
            int n=1;if(ign(),a=0,*p=='-')n=-1,++p;
            for(;isd()?1:(a*=n,0);)a=a*10+*p++-'0';
            return*this;}
        char get(){return*p++;}};
    struct FastWriter{
        FILE*f;vector&lt;char&gt;p;
        FastWriter(FILE*_f):f(_f){}
        FastWriter(string _f):f(fopen(_f.c_str(),"w")){}
        ~FastWriter(){(p.size()?fwrite(&amp;p[0],1,p.size(),f):0),fclose(f);}
        FastWriter&amp;operator&lt;&lt;(char a){p.push_back(a);return*this;}
        FastWriter&amp;operator&lt;&lt;(const char*a){while(*a)p.push_back(*a++);return*this;}
        FastWriter&amp;operator&lt;&lt;(int a){
            if(a&lt;0)p.push_back('-'),a=-a;
            static char t[10];char*q=t;
            do{int b=a/10;*q++=a-b*10+'0',a=b;}while(a);
            while(q&gt;t)p.push_back(*--q);
            return*this;}
        FastWriter&amp;operator&lt;&lt;(long long a){
            if(a&lt;0)p.push_back('-'),a=-a;
            static char t[19];char*q=t;
            do{long long b=a/10;*q++=a-b*10+'0',a=b;}while(a);
            while(q&gt;t)p.push_back(*--q);
            return*this;}
    };
}
#endif
int main(){
    CTL::FastReader rd(stdin);
    rd&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        int a,b;
        rd&gt;&gt;a&gt;&gt;b;
        da[i].u=i;
        da[i].x=a;
        da[i].y=b;
    }
    //D&lt;long long&gt;* dij=new D&lt;long long&gt; (n,1);
    CTL::DijkstrasAlgorithm&lt;long long&gt;dij(n);
    dij.set(1,0);
    sort(da+1,da+n+1,cmpx);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij.add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij.add(u,v,w);
        }
    }
    sort(da+1,da+n+1,cmpy);
    for(int i=1;i&lt;=n;++i){
        if(i!=1){
            int u=da[i].u,v=da[i-1].u;
            int w=dis(da[i],da[i-1]);
            dij.add(u,v,w);
        }
        if(i!=n){
            int u=da[i].u,v=da[i+1].u;
            int w=dis(da[i],da[i+1]);
            dij.add(u,v,w);
        }
    }

    cout&lt;&lt;dij.run()[n]&lt;&lt;endl;
    return 0;
}
</pre><pre></pre><h2>Problem4153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long ll;
ll M=1e9+7;
void move(ll&amp;ans,map&lt;pair&lt;int,int&gt;,int &gt;&amp;mp,int x,int y){
    ll t=mp[make_pair(x,y)];
    t=t*(t-1)/2;
    ans-=t;
    --mp[make_pair(x,y)];
    t=mp[make_pair(x,y)];
    t=t*(t-1)/2;
    ans+=t;
}
void add(ll&amp;ans,map&lt;pair&lt;int,int&gt;,int &gt;&amp;mp,int x,int y){
    ll t=mp[make_pair(x,y)];
    t=t*(t-1)/2;
    ans-=t;
    ++mp[make_pair(x,y)];
    t=mp[make_pair(x,y)];
    t=t*(t-1)/2;
    ans+=t;
}
#define BIG 1000010
int main(){
    int T;scanf("%d",&amp;T);
    for(int I=1;I&lt;=T;++I){
        int n,q;
        ll allans=0;
        scanf("%d%d",&amp;n,&amp;q);
        static int belman[BIG],belwo[BIG];
        for(int i=1;i&lt;=n;++i)
            belman[i]=belwo[i]=i;
        static vector&lt;int&gt;lstman[BIG],lstwo[BIG];
        for(int i=1;i&lt;=n;++i)
            lstman[i].clear(),lstman[i].push_back(i),lstwo[i]=lstman[i];
        map&lt;pair&lt;int,int&gt;,int &gt;mp;
        ll ans=0;
        for(int i=1;i&lt;=n;++i)
            mp[make_pair(i,i)]=1;
        for(int i=1;i&lt;=q;++i){
            int t,a,b;
            scanf("%d%d%d",&amp;t,&amp;a,&amp;b);
            if(t==1){
                if(belman[a]==belman[b])goto ok;
                if(lstman[belman[a]].size()&gt;lstman[belman[b]].size()){
                    swap(a,b);
                }
                int originmancolor=belman[a];
                int tobemancolor=belman[b];
                for(int j=0;j&lt;lstman[originmancolor].size();++j){
                    int couple=lstman[originmancolor][j];
                    int x=originmancolor,y=belwo[couple];
                    move(ans,mp,x,y);
                    add(ans,mp,tobemancolor,y);
                    belman[couple]=belman[b];
                    lstman[tobemancolor].push_back(couple);
                }
                lstman[originmancolor].clear();
            }else{
                if(belwo[a]==belwo[b])goto ok;
                if(lstwo[belwo[a]].size()&gt;lstwo[belwo[b]].size()){
                    swap(a,b);
                }
                int originwocolor=belwo[a];
                int tobewocolor=belwo[b];
                for(int j=0;j&lt;lstwo[originwocolor].size();++j){
                    int couple=lstwo[originwocolor][j];
                    int x=belman[couple],y=originwocolor;
                    move(ans,mp,x,y);
                    add(ans,mp,x,tobewocolor);
                    belwo[couple]=belwo[b];
                    lstwo[tobewocolor].push_back(couple);
                }
                lstwo[originwocolor].clear();
            }
            ok:
            allans+=ans*i%M;
            allans%=M;
        }
        printf("%d\n",int(allans));
    }
    return 0;
}
</pre><pre></pre><h2>Problem4154</h2><pre>#ifndef K_DIMENSIONAL_TREE
#define K_DIMENSIONAL_TREE
#include&lt;bits/stdc++.h&gt;
namespace CTL{
    using namespace std;
    struct KDimensionalTree{
        struct node{
            node(int x0,int x1,int d):color(1),cover(0),dir(d){
                ch[0]=ch[1]=0;x[0]=mi[0]=mx[0]=x0;x[1]=mi[1]=mx[1]=x1;}
            node*ch[2];int x[2],mi[2],mx[2],color,cover,dir;}*root;
        KDimensionalTree(pair&lt;int,int&gt;*a,int n){root=build(a,1,n,0);}
        static int direct;static int cmp(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){
            if(direct)return make_pair(a.second,a.first)&lt;make_pair(b.second,b.first);
            return a&lt;b;}
        node*build(pair&lt;int,int&gt;*a,int l,int r,int d){
            int m=(r+l)/2;direct=d;nth_element(a+l,a+m,a+r+1,cmp);
            node*p=new node((a+m)-&gt;first,(a+m)-&gt;second,d);
            if(l!=m)p-&gt;ch[0]=build(a,l,m-1,!d);if(r!=m)p-&gt;ch[1]=build(a,m+1,r,!d);
            for(int i=0;i&lt;2;++i)for(int j=0;j&lt;2;++j)if(p-&gt;ch[j])
                p-&gt;mi[i]=min(p-&gt;mi[i],p-&gt;ch[j]-&gt;mi[i]),
                p-&gt;mx[i]=max(p-&gt;mx[i],p-&gt;ch[j]-&gt;mx[i]);
            return p;}
        void down(node*a){
            if(a-&gt;cover){
                for(int i=0;i&lt;2;++i)if(a-&gt;ch[i])a-&gt;ch[i]-&gt;cover=a-&gt;cover;
                a-&gt;color=a-&gt;cover;a-&gt;cover=0;}}
        void modify(node*a,int mi0,int mx0,int mi1,int mx1,int c){
            if(mi0&gt;a-&gt;mx[0]||mx0&lt;a-&gt;mi[0]||mi1&gt;a-&gt;mx[1]||mx1&lt;a-&gt;mi[1])return;
            if(mi0&lt;=a-&gt;mi[0]&amp;&amp;mx0&gt;=a-&gt;mx[0]&amp;&amp;mi1&lt;=a-&gt;mi[1]&amp;&amp;mx1&gt;=a-&gt;mx[1]){
                a-&gt;cover=c;return;}
            down(a);if(mi0&lt;=a-&gt;x[0]&amp;&amp;mx0&gt;=a-&gt;x[0]&amp;&amp;mi1&lt;=a-&gt;x[1]&amp;&amp;mx1&gt;=a-&gt;x[1])a-&gt;color=c;
            for(int i=0;i&lt;2;++i)if(a-&gt;ch[i])modify(a-&gt;ch[i],mi0,mx0,mi1,mx1,c);}
        void modify(int mi0,int mx0,int mi1,int mx1,int c){modify(root,mi0,mx0,mi1,mx1,c);}
        int query(node*a,int x0,int x1){
            down(a);if(x0==a-&gt;x[0]&amp;&amp;x1==a-&gt;x[1])return a-&gt;color;
            direct=a-&gt;dir;if(cmp(make_pair(x0,x1),make_pair(a-&gt;x[0],a-&gt;x[1])))
                return query(a-&gt;ch[0],x0,x1);
            else return query(a-&gt;ch[1],x0,x1);}
        int query(int x0,int x1){return query(root,x0,x1);}};
    int KDimensionalTree::direct=0;}
#endif

#include&lt;bits/stdc++.h&gt;
#define lop(i,a,b) for(int i=a;i&lt;=int(b);++i)
#define rlp(i,a,b) for(int i=a;i&gt;=b;--i)
#define vlp(i,a) for(int i=0;i&lt;a.size();++i)
#define all(a) a.begin(),a.end()
#define sqr(a) ((a)*(a))
#define pub push_back
#define pob pop_back
#define mkp make_pair
#define scf scanf
#define ptf printf
#define inf (~0u&gt;&gt;1)
namespace CTL{}
using namespace CTL;
using namespace std;
typedef long long lli;
typedef unsigned long long ull;
typedef string str;
typedef vector&lt;int&gt; vei;
typedef vector&lt;string&gt; ves;
typedef map&lt;int,int&gt; mii;
typedef map&lt;str,int&gt; msi;
typedef set&lt;int&gt; sti;
typedef set&lt;str&gt; sts;
typedef pair&lt;int,int&gt; pii;
typedef vector&lt;pii&gt; vii;
vector&lt;int&gt;to[100010];
int nw;
int bg[100010],ed[100010],dep[100010];
void dfs(int u,int d){
    dep[u]=d;
    bg[u]=++nw;
    lop(i,0,to[u].size()-1){
        dfs(to[u][i],d+1);
    }
    ed[u]=nw;
}
pii pts[100010];
int main(){
    int T;scanf("%d",&amp;T);
    while(T--){
        int n,c,q;
        cin&gt;&gt;n&gt;&gt;c&gt;&gt;q;
        for(int i=1;i&lt;=n;++i)
            to[i].clear();
        for(int i=2;i&lt;=n;++i){
            int f;scanf("%d",&amp;f);
            to[f].push_back(i);
        }
        nw=0;
        dfs(1,1);
        lop(i,1,n)pts[i].first=dep[i],pts[i].second=bg[i];
        KDimensionalTree kdtree(pts,n);
        lli P=1e9+7,A=0;
        lop(i,1,q){
            int a,l;scf("%d%d%d",&amp;a,&amp;l,&amp;c);
            int ans;
            if(c==0)
                ans=kdtree.query(dep[a],bg[a]);
            else
                kdtree.modify(dep[a],dep[a]+l,bg[a],ed[a],c),ans=0;
            A=(A+lli(i)*ans)%P;
        }
        cout&lt;&lt;A&lt;&lt;endl;
    }
    return 0;
}
/*
1
4 3 2
1 2 2
2 1 3
2 0 0
*/
</pre><pre></pre><h2>Problem4155</h2><pre>#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
template&lt;class FLOW = int&gt;struct MF{
	struct edge{
	public:
		int v;
		FLOW c,l;
		edge(int _v,FLOW _c):
			v(_v),c(_c),l(_c){
		}
	};
	vector&lt;edge&gt;edges;
	vector&lt;vector&lt;int&gt; &gt;start;
	vector&lt;int&gt;height,gap,cur,from;
	int n,source,sink;
	void label(){
		height[sink] = 0;
		queue&lt;int&gt;qu;
		qu.push(sink);
		while(!qu.empty()){
			int u = qu.front();
			qu.pop();
			for(int i = 0;i&lt;start[u].size();++i){
				edge&amp;e = edges[start[u][i]],&amp;ev = edges[start[u][i]^1];
				if(ev.c&gt;0&amp;&amp;height[e.v]==n){
					height[e.v] = height[u]+1;
					qu.push(e.v);
				}
			}
		}
		for(int i = 0;i&lt;n;++i)
			++gap[height[i]];
	}
	FLOW augment(){
		FLOW f = 0;
		for(int u = sink;u!=source;u = edges[from[u]^1].v)
			if(f&lt;=0||f&gt;edges[from[u]].c)
			f = edges[from[u]].c;
		for(int u = sink;u!=source;u = edges[from[u]^1].v){
			edges[from[u]].c -= f;
			edges[from[u]^1].c += f;
		}
		return f;
	}
	MF(int _n,int _source,int _sink):
		start(_n),height(_n,_n),gap(_n+1),n(_n),
		cur(_n),from(_n),source(_source-1),sink(_sink-1){
	}
	void add(int u,int v,FLOW c){
		start[u-1].push_back(edges.size());
		edges.push_back(edge(v-1,c));
		start[v-1].push_back(edges.size());
		edges.push_back(edge(u-1,0));
	}
	FLOW run(){
		label();
		FLOW r = 0;
		int u = source;
		while(height[source]!=n){
			if(u==sink){
				r += augment();
				u = source;
			}
			bool flag = false;
			for(int i = cur[u];i&lt;start[u].size();++i){
				edge&amp;e = edges[start[u][i]];
				if(e.c&gt;0&amp;&amp;height[u]==height[e.v]+1){
					flag = true;
					from[e.v] = start[u][i];
					u = e.v;
					break;
				}
			}
			if(!flag){
				int mh = n-1;
				for(int i = 0;i&lt;start[u].size();++i){
					edge&amp;e = edges[start[u][i]];
					if(e.c&gt;0&amp;&amp;mh&gt;height[e.v])
						mh = height[e.v];
				}
				if(!--gap[height[u]])
					break;
				++gap[height[u] = mh+1];
				cur[u] = 0;
				if(u!=source)
					u = edges[from[u]^1].v;
			}
		}
		return r;
	}
};
#include&lt;iostream&gt;
#include&lt;bitset&gt;
int main(){
	int t;cin&gt;&gt;t;
	while(t--){
		int n,m;
		static int d[1010];
		cin&gt;&gt;n&gt;&gt;m;
		MF&lt;&gt; mf(n,1,2);
		fill(d+1,d+n+1,0);
		for(int i = 1;i&lt;=m;++i){
			int u,v;
			cin&gt;&gt;u&gt;&gt;v;
			mf.add(u,v,1);
			mf.add(v,u,1);
			++d[u];
			++d[v];
		}
		cout&lt;&lt;m-mf.run()&lt;&lt;" ";
		vector&lt;bitset&lt;40000&gt; &gt;f(n+1);
		f[2][d[1]] = 1;
		for(int i = 3;i&lt;=n;++i)
			f[i] = ((f[i-1]&lt;&lt;d[i])|f[i-1]);
		int ans = ~0u&gt;&gt;1;
		for(int i = 0;i&lt;40000;++i)
			if(f[n][i]){
				int t1 = i;
				int t2 = 2*m-i;
				if(t1&lt;t2)swap(t1,t2);
				ans = min(ans,(t1-t2)/2);
			}
		cout&lt;&lt;ans&lt;&lt;endl;


	}
	return 0;
}</pre><pre></pre><h2>Problem4157</h2><pre>#include&lt;cstdio&gt;
#include&lt;string&gt;

#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;

class FastStream{
private:
    std::FILE*infile,*outfile;
    std::vector&lt;char&gt;inbuffer,outbuffer;
    char*inpointer,*inend;
    inline void read_file(){
        for(int i=0;;++i){
            inbuffer.resize(inbuffer.size()+(1&lt;&lt;i));
            int t=std::fread(&amp;inbuffer[0]+inbuffer.size()-(1&lt;&lt;i),1,(1&lt;&lt;i),infile);
            if(t!=(1&lt;&lt;i)){
                inpointer=&amp;inbuffer[0];
                inend=inpointer+inbuffer.size()-(1&lt;&lt;i)+t;
                break;
            }
        }
    }
    inline void ignore(){
        while(inpointer!=inend&amp;&amp;std::isspace(*inpointer))
            ++inpointer;
    }
public:
    inline FastStream(std::FILE*_infile,std::FILE*_outfile):
            infile(_infile),outfile(_outfile){
        read_file();
    }
    inline FastStream(std::string _infile,std::string _outfile):
            infile(std::fopen(_infile.c_str(),"r")),outfile(std::fopen(_outfile.c_str(),"w")){
        read_file();
    }
    inline~FastStream(){
        fclose(infile);
        if(!outbuffer.empty())
            std::fwrite(&amp;outbuffer[0],1,outbuffer.size(),outfile);
        fclose(outfile);
    }
    inline FastStream&amp;operator&gt;&gt;(char&amp;a){
        ignore();
        a=*inpointer++;
        return*this;
    }
    inline FastStream&amp;operator&gt;&gt;(char*a){
        ignore();
        while(inpointer!=inend&amp;&amp;!std::isspace(*inpointer))
            *a++=*inpointer++;
        *a=0;
        return*this;
    }
    inline FastStream&amp;operator&gt;&gt;(std::string&amp;a){
        ignore();
        while(inpointer!=inend&amp;&amp;!std::isspace(*inpointer))
            a.push_back(*inpointer++);
        return*this;
    }
    inline FastStream&amp;operator&gt;&gt;(int&amp;a){
        ignore();
        bool f=false;
        if(*inpointer=='-'){
            f=true;
            ++inpointer;
        }
        a=0;
        while(inpointer!=inend&amp;&amp;std::isdigit(*inpointer))
            a=a*10+*inpointer++-'0';
        if(f)
            a=-a;
        return*this;
    }
    inline FastStream&amp;operator&gt;&gt;(long long&amp;a){
        ignore();
        bool f=false;
        if(*inpointer=='-'){
            f=true;
            ++inpointer;
        }
        a=0;
        while(inpointer!=inend&amp;&amp;std::isdigit(*inpointer))
            a=a*10+*inpointer++-'0';
        if(f)
            a=-a;
        return*this;
    }
    template&lt;class VAL&gt;inline void ReadVector(std::vector&lt;VAL&gt;&amp;a,int n=0){
        if(n==0)
            *this&gt;&gt;n;
        for(int i=0;i&lt;n;++i){
            VAL t;
            *this&gt;&gt;t;
            a.push_back(t);
        }
    }
    inline FastStream&amp;operator&lt;&lt;(char a){
        outbuffer.push_back(a);
        return*this;
    }
    inline FastStream&amp;operator&lt;&lt;(const char*a){
        while(*a)
            outbuffer.push_back(*a++);
        return*this;
    }
    inline FastStream&amp;operator&lt;&lt;(const std::string&amp;a){
        for(int i=0;i&lt;a.size();++i)
            outbuffer.push_back(a[i]);
        return*this;
    }
    inline FastStream&amp;operator&lt;&lt;(int a){
        if(a&lt;0){
            outbuffer.push_back('-');
            a=-a;
        }
        static char t[10];
        char*p=t;
        do{
            int b=a/10;
            *p++=a-b*10+'0';
            a=b;
        }while(a);
        while(p&gt;t)
            outbuffer.push_back(*--p);
        return*this;
    }
    inline FastStream&amp;operator&lt;&lt;(unsigned a){
        static char t[10];
        char*p=t;
        do{
            int b=a/10;
            *p++=a-b*10+'0';
            a=b;
        }while(a);
        while(p&gt;t)
            outbuffer.push_back(*--p);
        return*this;
    }
    inline FastStream&amp;operator&lt;&lt;(long long a){
        if(a&lt;0){
            outbuffer.push_back('-');
            a=-a;
        }
        static char t[19];
        char*p=t;
        do{
            long long b=a/10;
            *p++=a-b*10+'0';
            a=b;
        }while(a);
        while(p&gt;t)
            outbuffer.push_back(*--p);
        return*this;
    }
    template&lt;class VAL&gt;inline void WriteVector(const std::vector&lt;VAL&gt;&amp;a,const std::string&amp;b){
        for(int i=0;i&lt;a.size();++i){
            if(i!=0)
                *this&lt;&lt;b;
            *this&lt;&lt;a[i];
        }
    }
};

#include&lt;stack&gt;
const int N=200000;
struct DT{
    int n,r,pr[N+1],ch[N+1][2],rev[N+1],prt[N+1];
    int mi[N+1],yuan[N+1];
    vector&lt;int&gt;to[N+1],tto[N+1];
    int direct(int x){
        if(!pr[x])
            return 2;
        if(x==ch[pr[x]][0])
            return 0;
        if(x==ch[pr[x]][1])
            return 1;
        return 2;
    }
    void down(int x){
        if(rev[x]){
            swap(ch[x][0],ch[x][1]);
            rev[ch[x][0]]^=1;
            rev[ch[x][1]]^=1;
            rev[x]=0;
        }
    }
    void update(int x){
        down(ch[x][0]);
        down(ch[x][1]);
        mi[x]=yuan[x];
        if(ch[x][0])
            mi[x]=min(mi[x],mi[ch[x][0]]);
        if(ch[x][1])
            mi[x]=min(mi[x],mi[ch[x][1]]);
    }
    void setchd(int x,int y,int d){
        ch[x][d]=y;
        pr[y]=x;
        update(x);
    }
    void rotate(int x){
        int y=pr[x],z=pr[y];
        int d1=direct(x),d2=direct(y);
        setchd(y,ch[x][!d1],d1);
        setchd(x,y,!d1);
        if(d2&lt;2)
            setchd(z,x,d2);
        else
            pr[x]=z;
    }
    void release(int x){
        stack&lt;int&gt;stk;
        for(stk.push(x);direct(x)&lt;2;stk.push(pr[x]),x=pr[x]);
        for(;!stk.empty();down(stk.top()),stk.pop());
    }
    void splay(int x){
        release(x);
        while(direct(x)&lt;2){
            int y=pr[x];
            if(direct(y)==2)
                rotate(x);
            else if(direct(x)==direct(y))
                rotate(y),rotate(x);
            else
                rotate(x),rotate(x);
        }
    }
    int access(int x){
        int y=0;
        while(x){
            splay(x);
            setchd(x,y,1);
            y=x;
            x=pr[x];
        }
        return y;
    }
    void evert(int x){
        access(x);
        splay(x);
        rev[x]=1;
    }
    void cut(int x,int y){
        access(y);
        access(x);
        splay(y);
        pr[y]=0;
    }
    void link(int x,int y){
        splay(y);
        pr[y]=x;
    }
    int lca(int x,int y){
        access(x);
        return access(y);
    }
    int query(int x){
        access(x);
        splay(x);
        return mi[x];
    }
    DT(int _n,int _r):
            n(_n),r(_r){
        for(int i=1;i&lt;=n;++i)
            pr[i]=ch[i][0]=ch[i][1]=rev[i]=0;
    }
    void add(int u,int v){
        to[u].push_back(v);
    }
    void build(){
        queue&lt;int&gt;qu;
        static int inq[N+1];
        fill(inq+1,inq+n+1,0);
        fill(prt+1,prt+n+1,0);
        prt[r]=r;
        while(true){
            bool f=false;
            for(int i=1;i&lt;=n;++i)
                if(prt[i]){
                    inq[i]=1;
                    qu.push(i);
                }
            while(!qu.empty()){
                int u=qu.front();
                qu.pop();
                inq[u]=0;
                for(int i=0;i&lt;to[u].size();++i){
                    int v=to[u][i];
                    if(!prt[v]){
                        link(u,v);
                        prt[v]=u;
                        inq[v]=1;
                        qu.push(v);
                        f=true;
                    }else{
                        int w=lca(prt[v],u);
                        if(w!=prt[v]){
                            cut(prt[v],v);
                            link(w,v);
                            prt[v]=w;
                            if(!inq[v]){
                                inq[v]=1;
                                qu.push(v);
                            }
                            f=true;
                        }
                    }
                }
            }
            if(!f)
                break;
        }
        for(int i=1;i&lt;=n;++i)
            if(i!=r&amp;&amp;prt[i])
                tto[prt[i]].push_back(i);
    }
}*dt;
int main(){
    int n,m,r;
    //FastStream fs("plague.in","plague.out");
    FastStream fs(stdin,stdout);
    fs&gt;&gt;n&gt;&gt;m&gt;&gt;r;
    dt=new DT(n,r);
    for(int i=1;i&lt;=m;++i){
        int u,v;
        fs&gt;&gt;u&gt;&gt;v;
        dt-&gt;add(u,v);
    }
    for(int i=1;i&lt;=n;++i){
        fs&gt;&gt;dt-&gt;yuan[i];
        dt-&gt;mi[i]=dt-&gt;yuan[i];
    }
    dt-&gt;build();
    int q;fs&gt;&gt;q;
    for(int i=1;i&lt;=q;++i){
        int t,w;fs&gt;&gt;t&gt;&gt;w;
        int tmp=-1;
        static int vec[200010];
        vec[0]=0;
        for(int j=1;j&lt;=t;++j){
            int num;
            fs&gt;&gt;num;
            if(dt-&gt;prt[num]==0)
                continue;
            vec[++vec[0]]=num;
            if(tmp==-1)
                tmp=num;
            else
                tmp=dt-&gt;lca(tmp,num);
        }
        if(vec[0]==0)
            fs&lt;&lt;0&lt;&lt;"\n";
        else {
            for (int j = 1; j &lt;= vec[0]; ++j)
                if (tmp == vec[j])
                    tmp = dt-&gt;prt[vec[j]];
            int ty = dt-&gt;query(tmp);
            if (ty &gt; w)
                fs &lt;&lt; "1\n";
            else
                fs &lt;&lt; ty &lt;&lt; "\n";
        }

    }
    return 0;
}
</pre><pre></pre><h2>Problem4161</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define rep(i,s,t) for (int i=(s);i&lt;=(t);i++)
#define per(i,s,t) for (int i=(s);i&gt;=(t);i--)
#define REP(i,n) rep(i,0,(n)-1)
#define PER(i,n) per(i,(n)-1,0)
typedef long long LL;

const int K=2222,MODN=1000000007;
int n,k,a[K],f[K*2];

int tmp[K*2];
inline void mult(int C[K],int A[K],int B[K]) {
  memset(tmp,0,sizeof(tmp[0])*k*2);
  REP(i,k) if (A[i]) REP(j,k) if (B[j]) tmp[i+j]=(tmp[i+j]+LL(A[i])*B[j])%MODN;
  per(i,2*k-2,k) if (tmp[i]) {
    REP(j,k) tmp[i-j-1]=(tmp[i-j-1]+LL(tmp[i])*a[j])%MODN;
    tmp[i]=0;
  }
  memcpy(C,tmp,sizeof(tmp[0])*k);
}

int cur[K],ret[K];
void pw(int n) {
  cur[1]=1; ret[0]=1;
  for (;n;n&gt;&gt;=1) {
    if (n&amp;1) mult(ret,ret,cur);
    mult(cur,cur,cur);
  }
}

int main() {
  scanf("%d%d",&amp;n,&amp;k);
  REP(i,k) scanf("%d",a+i);
  REP(i,k) scanf("%d",f+i);
  if (n&lt;k) { printf("%d\n",f[n]); return 0; }
  n-=k-1;

  pw(n);
  rep(i,k,2*k-1) REP(j,k) f[i]=(f[i]+LL(f[i-j-1])*a[j])%MODN;
  int fn=0;
  REP(i,k) fn=(fn+LL(f[i+k-1])*ret[i])%MODN;
  printf("%d\n",(fn+MODN)%MODN);

  return 0;
}</pre><pre></pre><h2>Problem4161</h2><pre>#ifndef LINEAR_HOMOGENEOUS_RECURRENCE_RELATIONS_WITH_CONSTANT_COEFFICIENTS
#define LINEAR_HOMOGENEOUS_RECURRENCE_RELATIONS_WITH_CONSTANT_COEFFICIENTS
#include&lt;vector&gt;
namespace CTL{
    using namespace std;
    template&lt;class T&gt;struct LinearHomogeneousRecurrenceRelationsWithConstantCoefficients{
        static vector&lt;T&gt;cal(int n,int k,vector&lt;T&gt;&amp;c,T p){
            vector&lt;T&gt;r(2*k);
            if(n&lt;k){
                r[n]=1;
                return r;
            }
            vector&lt;T&gt;u=cal(n/2,k,c,p);
            for(int i=0;i&lt;k;++i)
                for(int j=0;j&lt;k;++j)
                    r[i+j]=(r[i+j]+u[i]*u[j])%p;
            if(n&amp;1)r.insert(r.begin(),0);
            for(int i=2*k-1;i&gt;=k;--i)
                for(int j=1;j&lt;=k;++j)
                    r[i-j]=(r[i-j]+c[j-1]*r[i])%p;
            return r;
        }
        static T run(vector&lt;T&gt;a,vector&lt;T&gt;c,int n,T p){
            if(n&lt;a.size())
                return a[n];
            int k=a.size();
            vector&lt;T&gt;b=cal(n-k+1,k,c,p);
            a.resize(2*k-1);
            for(int i=k;i&lt;=2*k-2;++i){
                for(int j=0;j&lt;k;++j)
                    a[i]=(a[i]+a[i-j-1]*c[j])%p;
            }
            T r=0;
            for(int j=0;j&lt;k;++j)
                r=(r+b[j]*a[k-1+j])%p;
            return r;
        }

    };
}
#endif
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long ll;ll p=1000000007;
int main(){
    int n,k;
    vector&lt;ll&gt;c,a;
    scanf("%d%d",&amp;n,&amp;k);
    for(int i=1;i&lt;=k;++i){
        int t;scanf("%d",&amp;t);
        c.push_back((t%p+p)%p);
    }
    for(int i=1;i&lt;=k;++i){
        int t;scanf("%d",&amp;t);
        a.push_back((t%p+p)%p);
    }
   int res= CTL::LinearHomogeneousRecurrenceRelationsWithConstantCoefficients&lt;ll&gt;::run(a,c,n,p);
    printf("%d\n",res);
    return 0;
}
</pre><pre>﻿








</pre><br><a href="http://www.lydsy.com/JudgeOnline/"></a><span class="red">HOME</span><a href="javascript:history.go(-1)"></a><span class="red">Back</span><hr><center>
	
</center><div class="footer">
			&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		
			
		
	</div><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=ko">한국어</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=cn">中文</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=fa">فارسی</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=en">English</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=th">ไทย</a><br><div>版权所有 ©2008-2012 大视野在线测评 |  | 
</div><a href="http://www.miitbeian.gov.cn/">湘ICP备13009380号</a><script src="./Export All AC Source_files/stat.php" language="JavaScript"></script><script src="./Export All AC Source_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=2982771" target="_blank" title="站长统计">站长统计</a><div>Based on opensource project .</div><a href="http://hustoj.googlecode.com/">hustoj</a></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></body></html>